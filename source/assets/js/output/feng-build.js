// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_DEFINES} may be defined before loading
 * base.js.  If a key is defined in {@code CLOSURE_DEFINES}, {@code goog.define}
 * will use the value instead of the default value.  This allows flags to be
 * overwritten without compilation (this is normally accomplished with the
 * compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && opt_object !== undefined) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retreived from
 * CLOSURE_DEFINES if the object is defined and has the property specified,
 * and otherwise used the defined defaultValue. When compiled, the default
 * can be overridden using compiler command-line options.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(
        goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Provided objects must not be null or undefined.
 * Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice. This is intended
    // to teach new developers that 'goog.provide' is effectively a variable
    // declaration. And when JSCompiler transforms goog.provide into a real
    // variable declaration, the compiled JS should work the same as the raw
    // JS--even when the raw JS uses goog.provide incorrectly.
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                opt_message ? ': ' + opt_message : '.');
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return !goog.implicitNamespaces_[name] &&
        goog.isDefAndNotNull(goog.getObjectByName(name));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {Object}
   * @private
   */
  goog.implicitNamespaces_ = {};
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function(relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// http://code.google.com/closure/library/docs/depswriter.html
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 */
goog.require = function(name) {

  // If the object already exists we do not need do do anything.
  // TODO(arv): If we start to support require based on file name this has to
  //            change.
  // TODO(arv): If we allow goog.foo.* this has to change.
  // TODO(arv): If we implement dynamic load after page load we should probably
  //            not remove this code for the compiled output.
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }


      throw Error(errorMessage);

  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * Object used to keep track of urls that have already been added. This record
   * allows the prevention of circular dependencies.
   * @type {Object}
   * @private
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {Object}
   */
  goog.dependencies_ = {
    pathToNames: {}, // 1 to many
    nameToPath: {}, // 1 to 1
    requires: {}, // 1 to many
    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},
    written: {} // Used to keep track of script files we have written.
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @private
   */
  goog.importScript_ = function(src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script source.
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page.
      if (doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      doc.write(
          '<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };


  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    // The scripts we need to write this time.
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}



//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  return val !== undefined;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is alreay assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {Object} obj The object to check.
 * @return {boolean} Whether there an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked as
 * follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // Other code here.
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 2);
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * contsructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.DEBUG) {
    if (!caller) {
      throw Error('arguments.caller not defined.  goog.base() expects not ' +
                  'to be running in strict mode. See ' +
                  'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    }
  }

  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(
      prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(
      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if {@code str1} and {@code str2} are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = function(str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function(str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';

  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length &&
         // Replace up to the last split part. We are inserting in the
         // positions between split parts.
         splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }

  return returnString + splitParts.join('%s'); // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} True if{@code str} is null, undefined, empty, or
 *     whitespace only.
 */
goog.string.isEmptySafe = function(str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a space.
 */
goog.string.isSpace = function(ch) {
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
         ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(
      /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function(str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

  var count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {

      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII-betical string
  // comparison to stablize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escape double quote '"' characters in addition to '&', '<', and '>' so that a
 * string can be included in an HTML tag attribute value within double quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;')
          .replace(goog.string.ltRe_, '&lt;')
          .replace(goog.string.gtRe_, '&gt;')
          .replace(goog.string.quotRe_, '&quot;')
          .replace(goog.string.singleQuoteRe_, '&#39;');

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.allRe_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.singleQuoteRe_, '&#39;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.amperRe_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.ltRe_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.gtRe_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.quotRe_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.singleQuoteRe_ = /'/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @type {RegExp}
 * @private
 */
goog.string.allRe_ = /[&<>"']/;


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one. We use the []
    // notation so that the JSCompiler will not complain about these objects and
    // fields in the case where we have no DOM.
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes a HTML string using the provided document.
 *
 * @param {string} str The string to unescape.
 * @param {!Document} document A document to use in escaping the string.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  if (goog.string.contains(str, '&')) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @param {Document=} opt_document An optional document to use for creating
 *     elements. If this is not specified then the default window.document
 *     will be used.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  var div;
  if (opt_document) {
    div = opt_document.createElement('div');
  } else {
    div = document.createElement('div');
  }
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          var n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function(str, chars,
    opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private
 * @type {Object}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B', // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private
 * @type {Object}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function(s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
          ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) { // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Takes a string and creates a map (Object) in which the keys are the
 * characters in the string. The value for the key is set to true. You can
 * then use goog.object.map or goog.array.map to change the values.
 * @param {string} s The string to build the map from.
 * @return {Object} The map of characters used.
 */
// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
//            we want a dependency on goog.array in goog.string?
goog.string.toMap = function(s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};


/**
 * Checks whether a string contains a given substring.
 * @param {string} s The string to test.
 * @param {string} ss The substring to test for.
 * @return {boolean} True if {@code s} contains {@code ss}.
 */
goog.string.contains = function(s, ss) {
  return s.indexOf(ss) != -1;
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = function(string, length) {
  return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function(obj) {
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * Maximum value of #goog.string.hashCode, exclusive. 2^32.
 * @type {number}
 * @private
 */
goog.string.HASHCODE_MAX_ = 0x100000000;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    // Normalize to 4 byte range, 0 ... 2^32.
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Infinity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function(str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function(str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ?
      goog.string.regExpEscape(opt_delimiters) : '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (goog.isString(value)) {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ?
        parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array.<string>} The string, split.
 */

goog.string.splitLimit = function(str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];

  // Only continue doing this while we haven't hit the limit and we have
  // parts left.
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }

  // If there are remaining parts, append them to the end.
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }

  return returnVal;
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 * Some user agents (I'm thinking of you, Gears WorkerPool) do not expose a
 * navigator object off the global scope.  In that case we return null.
 *
 * @return {?string} The userAgent string or null if there is none.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.global['navigator'] ? goog.global['navigator'].userAgent : null;
};


/**
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'];
};


/**
 * Initializer for goog.userAgent.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.init_ = function() {
  /**
   * Whether the user agent string denotes Opera.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedOpera_ = false;

  /**
   * Whether the user agent string denotes Internet Explorer. This includes
   * other browsers using Trident as its rendering engine. For example AOL
   * and Netscape 8
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIe_ = false;

  /**
   * Whether the user agent string denotes WebKit. WebKit is the rendering
   * engine that Safari, Android and others use.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWebkit_ = false;

  /**
   * Whether the user agent string denotes a mobile device.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMobile_ = false;

  /**
   * Whether the user agent string denotes Gecko. Gecko is the rendering
   * engine used by Mozilla, Mozilla Firefox, Camino and many more.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedGecko_ = false;

  var ua;
  if (!goog.userAgent.BROWSER_KNOWN_ &&
      (ua = goog.userAgent.getUserAgentString())) {
    var navigator = goog.userAgent.getNavigator();
    goog.userAgent.detectedOpera_ = goog.string.startsWith(ua, 'Opera');
    goog.userAgent.detectedIe_ = !goog.userAgent.detectedOpera_ &&
        (goog.string.contains(ua, 'MSIE') ||
         goog.string.contains(ua, 'Trident'));
    goog.userAgent.detectedWebkit_ = !goog.userAgent.detectedOpera_ &&
        goog.string.contains(ua, 'WebKit');
    // WebKit also gives navigator.product string equal to 'Gecko'.
    goog.userAgent.detectedMobile_ = goog.userAgent.detectedWebkit_ &&
        goog.string.contains(ua, 'Mobile');
    goog.userAgent.detectedGecko_ = !goog.userAgent.detectedOpera_ &&
        !goog.userAgent.detectedWebkit_ && !goog.userAgent.detectedIe_ &&
        navigator.product == 'Gecko';
  }
};


if (!goog.userAgent.BROWSER_KNOWN_) {
  goog.userAgent.init_();
}


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA : goog.userAgent.detectedOpera_;


/**
 * Whether the user agent is Internet Explorer. This includes other browsers
 * using Trident as its rendering engine. For example AOL and Netscape 8
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE : goog.userAgent.detectedIe_;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Mozilla Firefox, Camino and many more.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.userAgent.detectedGecko_;


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.userAgent.detectedWebkit_;


/**
 * Whether the user agent is running on a mobile device.
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.detectedMobile_;


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11 ||
    goog.userAgent.ASSUME_ANDROID ||
    goog.userAgent.ASSUME_IPHONE ||
    goog.userAgent.ASSUME_IPAD;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function() {
  /**
   * Whether the user agent is running on a Macintosh operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMac_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Mac');

  /**
   * Whether the user agent is running on a Windows operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWindows_ = goog.string.contains(
      goog.userAgent.PLATFORM, 'Win');

  /**
   * Whether the user agent is running on a Linux operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Linux');

  /**
   * Whether the user agent is running on a X11 windowing system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
      goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
          'X11');

  // Need user agent string for Android/IOS detection
  var ua = goog.userAgent.getUserAgentString();

  /**
   * Whether the user agent is running on Android.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedAndroid_ = !!ua &&
      goog.string.contains(ua, 'Android');

  /**
   * Whether the user agent is running on an iPhone.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPhone_ = !!ua && goog.string.contains(ua, 'iPhone');

  /**
   * Whether the user agent is running on an iPad.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPad_ = !!ua && goog.string.contains(ua, 'iPad');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
  goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID : goog.userAgent.detectedAndroid_;


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE : goog.userAgent.detectedIPhone_;


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD : goog.userAgent.detectedIPad_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '', re;

  if (goog.userAgent.OPERA && goog.global['opera']) {
    var operaVersion = goog.global['opera'].version;
    version = typeof operaVersion == 'function' ? operaVersion() : operaVersion;
  } else {
    if (goog.userAgent.GECKO) {
      re = /rv\:([^\);]+)(\)|;)/;
    } else if (goog.userAgent.IE) {
      re = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/;
    } else if (goog.userAgent.WEBKIT) {
      // WebKit/125.4
      re = /WebKit\/(\S+)/;
    }
    if (re) {
      var arr = re.exec(goog.userAgent.getUserAgentString());
      version = arr ? arr[1] : '';
    }
  }
  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }
  return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(user): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.userAgent.isVersionOrHigherCache_[version] ||
      (goog.userAgent.isVersionOrHigherCache_[version] =
          goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
  return goog.userAgent.IE && goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
  var doc = goog.global['document'];
  if (!doc || !goog.userAgent.IE) {
    return undefined;
  }
  var mode = goog.userAgent.getDocumentMode_();
  return mode || (doc['compatMode'] == 'CSS1Compat' ?
      parseInt(goog.userAgent.VERSION, 10) : 5);
})();
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */

goog.provide('goog.debug.Error');



/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function(opt_msg) {

  // Attempt to ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    var stack = new Error().stack;
    if (stack) {
      this.stack = stack;
    }
  }

  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array.<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  // Remove the messagePattern afterwards to avoid permenantly modifying the
  // passed in array.
  messageArgs.shift();

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array.<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array.<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  throw new goog.asserts.AssertionError('' + message, args || []);
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {*} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
        [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertElement = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) ||
      value.nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_('Expected Element but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {!T}
 * @template T
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null,
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */
goog.asserts.assertObjectPrototypeIsIntact = function() {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple utilities for dealing with URI strings.
 *
 * This is intended to be a lightweight alternative to constructing goog.Uri
 * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
 * of how much of its functionality you use, this is designed to be a set of
 * mostly-independent utilities so that the compiler includes only what is
 * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
 * 1.5k post-gzip.  To ensure the savings remain, future developers should
 * avoid adding new functionality to existing functions, but instead create
 * new ones and factor out shared code.
 *
 * Many of these utilities have limited functionality, tailored to common
 * cases.  The query parameter utilities assume that the parameter keys are
 * already encoded, since most keys are compile-time alphanumeric strings.  The
 * query parameter mutation utilities also do not tolerate fragment identifiers.
 *
 * By design, these functions can be slower than goog.Uri equivalents.
 * Repeated calls to some of functions may be quadratic in behavior for IE,
 * although the effect is somewhat limited given the 2kb limit.
 *
 * One advantage of the limited functionality here is that this approach is
 * less sensitive to differences in URI encodings than goog.Uri, since these
 * functions modify the strings in place, rather than decoding and
 * re-encoding.
 *
 * Uses features of RFC 3986 for parsing/formatting URIs:
 *   http://www.ietf.org/rfc/rfc3986.txt
 *
 * @author gboyer@google.com (Garrett Boyer) - The "lightened" design.
 * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.
 */

goog.provide('goog.uri.utils');
goog.provide('goog.uri.utils.ComponentIndex');
goog.provide('goog.uri.utils.QueryArray');
goog.provide('goog.uri.utils.QueryValue');
goog.provide('goog.uri.utils.StandardQueryParam');

goog.require('goog.asserts');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Character codes inlined to avoid object allocations due to charCode.
 * @enum {number}
 * @private
 */
goog.uri.utils.CharCode_ = {
  AMPERSAND: 38,
  EQUAL: 61,
  HASH: 35,
  QUESTION: 63
};


/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|number|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
goog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo,
    opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
  var out = '';

  if (opt_scheme) {
    out += opt_scheme + ':';
  }

  if (opt_domain) {
    out += '//';

    if (opt_userInfo) {
      out += opt_userInfo + '@';
    }

    out += opt_domain;

    if (opt_port) {
      out += ':' + opt_port;
    }
  }

  if (opt_path) {
    out += opt_path;
  }

  if (opt_queryData) {
    out += '?' + opt_queryData;
  }

  if (opt_fragment) {
    out += '#' + opt_fragment;
  }

  return out;
};


/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @private
 */
goog.uri.utils.splitRe_ = new RegExp(
    '^' +
    '(?:' +
        '([^:/?#.]+)' +                  // scheme - ignore special characters
                                         // used by other URL parts such as :,
                                         // ?, /, #, and .
    ':)?' +
    '(?://' +
        '(?:([^/?#]*)@)?' +              // userInfo
        '([^/#?]*?)' +                   // domain
        '(?::([0-9]+))?' +               // port
        '(?=[/#?]|$)' +                  // authority-terminating character
    ')?' +
    '([^?#]+)?' +                        // path
    '(?:\\?([^#]*))?' +                  // query
    '(?:#(.*))?' +                       // fragment
    '$');


/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
goog.uri.utils.ComponentIndex = {
  SCHEME: 1,
  USER_INFO: 2,
  DOMAIN: 3,
  PORT: 4,
  PATH: 5,
  QUERY_DATA: 6,
  FRAGMENT: 7
};


/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
goog.uri.utils.split = function(uri) {
  goog.uri.utils.phishingProtection_();

  // See @return comment -- never null.
  return /** @type {!Array.<string|undefined>} */ (
      uri.match(goog.uri.utils.splitRe_));
};


/**
 * Safari has a nasty bug where if you have an http URL with a username, e.g.,
 * http://evil.com%2F@google.com/
 * Safari will report that window.location.href is
 * http://evil.com/google.com/
 * so that anyone who tries to parse the domain of that URL will get
 * the wrong domain. We've seen exploits where people use this to trick
 * Safari into loading resources from evil domains.
 *
 * To work around this, we run a little "Safari phishing check", and throw
 * an exception if we see this happening.
 *
 * There is no convenient place to put this check. We apply it to
 * anyone doing URI parsing on Webkit. We're not happy about this, but
 * it fixes the problem.
 *
 * This should be removed once Safari fixes their bug.
 *
 * Exploit reported by Masato Kinugawa.
 *
 * @type {boolean}
 * @private
 */
goog.uri.utils.needsPhishingProtection_ = goog.userAgent.WEBKIT;


/**
 * Check to see if the user is being phished.
 * @private
 */
goog.uri.utils.phishingProtection_ = function() {
  if (goog.uri.utils.needsPhishingProtection_) {
    // Turn protection off, so that we don't recurse.
    goog.uri.utils.needsPhishingProtection_ = false;

    // Use quoted access, just in case the user isn't using location externs.
    var location = goog.global['location'];
    if (location) {
      var href = location['href'];
      if (href) {
        var domain = goog.uri.utils.getDomain(href);
        if (domain && domain != location['hostname']) {
          // Phishing attack
          goog.uri.utils.needsPhishingProtection_ = true;
          throw Error();
        }
      }
    }
  }
};


/**
 * @param {?string} uri A possibly null string.
 * @return {?string} The string URI-decoded, or null if uri is null.
 * @private
 */
goog.uri.utils.decodeIfPossible_ = function(uri) {
  return uri && decodeURIComponent(uri);
};


/**
 * Gets a URI component by index.
 *
 * It is preferred to use the getPathEncoded() variety of functions ahead,
 * since they are more readable.
 *
 * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
 * @param {string} uri The URI to examine.
 * @return {?string} The still-encoded component, or null if the component
 *     is not present.
 * @private
 */
goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
  // Convert undefined, null, and empty string into null.
  return goog.uri.utils.split(uri)[componentIndex] || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The protocol or scheme, or null if none.  Does not
 *     include trailing colons or slashes.
 */
goog.uri.utils.getScheme = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.SCHEME, uri);
};


/**
 * Gets the effective scheme for the URL.  If the URL is relative then the
 * scheme is derived from the page's location.
 * @param {string} uri The URI to examine.
 * @return {string} The protocol or scheme, always lower case.
 */
goog.uri.utils.getEffectiveScheme = function(uri) {
  var scheme = goog.uri.utils.getScheme(uri);
  if (!scheme && self.location) {
    var protocol = self.location.protocol;
    scheme = protocol.substr(0, protocol.length - 1);
  }
  // NOTE: When called from a web worker in Firefox 3.5, location maybe null.
  // All other browsers with web workers support self.location from the worker.
  return scheme ? scheme.toLowerCase() : '';
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The user name still encoded, or null if none.
 */
goog.uri.utils.getUserInfoEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.USER_INFO, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded user info, or null if none.
 */
goog.uri.utils.getUserInfo = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getUserInfoEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The domain name still encoded, or null if none.
 */
goog.uri.utils.getDomainEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.DOMAIN, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded domain, or null if none.
 */
goog.uri.utils.getDomain = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?number} The port number, or null if none.
 */
goog.uri.utils.getPort = function(uri) {
  // Coerce to a number.  If the result of getComponentByIndex_ is null or
  // non-numeric, the number coersion yields NaN.  This will then return
  // null for all non-numeric cases (though also zero, which isn't a relevant
  // port number).
  return Number(goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PORT, uri)) || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The path still encoded, or null if none. Includes the
 *     leading slash, if any.
 */
goog.uri.utils.getPathEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PATH, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded path, or null if none.  Includes the leading
 *     slash, if any.
 */
goog.uri.utils.getPath = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The query data still encoded, or null if none.  Does not
 *     include the question mark itself.
 */
goog.uri.utils.getQueryData = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The fragment identifier, or null if none.  Does not
 *     include the hash mark itself.
 */
goog.uri.utils.getFragmentEncoded = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);
};


/**
 * @param {string} uri The URI to examine.
 * @param {?string} fragment The encoded fragment identifier, or null if none.
 *     Does not include the hash mark itself.
 * @return {string} The URI with the fragment set.
 */
goog.uri.utils.setFragmentEncoded = function(uri, fragment) {
  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded fragment identifier, or null if none.  Does
 *     not include the hash mark.
 */
goog.uri.utils.getFragment = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getFragmentEncoded(uri));
};


/**
 * Extracts everything up to the port of the URI.
 * @param {string} uri The URI string.
 * @return {string} Everything up to and including the port.
 */
goog.uri.utils.getHost = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      pieces[goog.uri.utils.ComponentIndex.SCHEME],
      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
      pieces[goog.uri.utils.ComponentIndex.PORT]);
};


/**
 * Extracts the path of the URL and everything after.
 * @param {string} uri The URI string.
 * @return {string} The URI, starting at the path and including the query
 *     parameters and fragment identifier.
 */
goog.uri.utils.getPathAndAfter = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(null, null, null, null,
      pieces[goog.uri.utils.ComponentIndex.PATH],
      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Gets the URI with the fragment identifier removed.
 * @param {string} uri The URI to examine.
 * @return {string} Everything preceding the hash mark.
 */
goog.uri.utils.removeFragment = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);
};


/**
 * Ensures that two URI's have the exact same domain, scheme, and port.
 *
 * Unlike the version in goog.Uri, this checks protocol, and therefore is
 * suitable for checking against the browser's same-origin policy.
 *
 * @param {string} uri1 The first URI.
 * @param {string} uri2 The second URI.
 * @return {boolean} Whether they have the same domain and port.
 */
goog.uri.utils.haveSameDomain = function(uri1, uri2) {
  var pieces1 = goog.uri.utils.split(uri1);
  var pieces2 = goog.uri.utils.split(uri2);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
             pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};


/**
 * Asserts that there are no fragment or query identifiers, only in uncompiled
 * mode.
 * @param {string} uri The URI to examine.
 * @private
 */
goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
  // NOTE: would use goog.asserts here, but jscompiler doesn't know that
  // indexOf has no side effects.
  if (goog.DEBUG && (uri.indexOf('#') >= 0 || uri.indexOf('?') >= 0)) {
    throw Error('goog.uri.utils: Fragment or query identifiers are not ' +
        'supported: [' + uri + ']');
  }
};


/**
 * Supported query parameter values by the parameter serializing utilities.
 *
 * If a value is null or undefined, the key-value pair is skipped, as an easy
 * way to omit parameters conditionally.  Non-array parameters are converted
 * to a string and URI encoded.  Array values are expanded into multiple
 * &key=value pairs, with each element stringized and URI-encoded.
 *
 * @typedef {*}
 */
goog.uri.utils.QueryValue;


/**
 * An array representing a set of query parameters with alternating keys
 * and values.
 *
 * Keys are assumed to be URI encoded already and live at even indices.  See
 * goog.uri.utils.QueryValue for details on how parameter values are encoded.
 *
 * Example:
 * <pre>
 * var data = [
 *   // Simple param: ?name=BobBarker
 *   'name', 'BobBarker',
 *   // Conditional param -- may be omitted entirely.
 *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,
 *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null
 *   'house', ['LosAngeles', 'NewYork', null]
 * ];
 * </pre>
 *
 * @typedef {!Array.<string|goog.uri.utils.QueryValue>}
 */
goog.uri.utils.QueryArray;


/**
 * Appends a URI and query data in a string buffer with special preconditions.
 *
 * Internal implementation utility, performing very few object allocations.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer.  The first element
 *     must be the base URI, and may have a fragment identifier.  If the array
 *     contains more than one element, the second element must be an ampersand,
 *     and may be overwritten, depending on the base URI.  Undefined elements
 *     are treated as empty-string.
 * @return {string} The concatenated URI and query data.
 * @private
 */
goog.uri.utils.appendQueryData_ = function(buffer) {
  if (buffer[1]) {
    // At least one query parameter was added.  We need to check the
    // punctuation mark, which is currently an ampersand, and also make sure
    // there aren't any interfering fragment identifiers.
    var baseUri = /** @type {string} */ (buffer[0]);
    var hashIndex = baseUri.indexOf('#');
    if (hashIndex >= 0) {
      // Move the fragment off the base part of the URI into the end.
      buffer.push(baseUri.substr(hashIndex));
      buffer[0] = baseUri = baseUri.substr(0, hashIndex);
    }
    var questionIndex = baseUri.indexOf('?');
    if (questionIndex < 0) {
      // No question mark, so we need a question mark instead of an ampersand.
      buffer[1] = '?';
    } else if (questionIndex == baseUri.length - 1) {
      // Question mark is the very last character of the existing URI, so don't
      // append an additional delimiter.
      buffer[1] = undefined;
    }
  }

  return buffer.join('');
};


/**
 * Appends key=value pairs to an array, supporting multi-valued objects.
 * @param {string} key The key prefix.
 * @param {goog.uri.utils.QueryValue} value The value to serialize.
 * @param {!Array.<string>} pairs The array to which the 'key=value' strings
 *     should be appended.
 * @private
 */
goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
  if (goog.isArray(value)) {
    // Convince the compiler it's an array.
    goog.asserts.assertArray(value);
    for (var j = 0; j < value.length; j++) {
      // Convert to string explicitly, to short circuit the null and array
      // logic in this function -- this ensures that null and undefined get
      // written as literal 'null' and 'undefined', and arrays don't get
      // expanded out but instead encoded in the default way.
      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);
    }
  } else if (value != null) {
    // Skip a top-level null or undefined entirely.
    pairs.push('&', key,
        // Check for empty string. Zero gets encoded into the url as literal
        // strings.  For empty string, skip the equal sign, to be consistent
        // with UriBuilder.java.
        value === '' ? '' : '=',
        goog.string.urlEncode(value));
  }
};


/**
 * Builds a buffer of query data from a sequence of alternating keys and values.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {goog.uri.utils.QueryArray|Arguments} keysAndValues An array with
 *     alternating keys and values -- see the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBuffer_ = function(
    buffer, keysAndValues, opt_startIndex) {
  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0),
      0) % 2 == 0, 'goog.uri.utils: Key/value lists must be even in length.');

  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {
    goog.uri.utils.appendKeyValuePairs_(
        keysAndValues[i], keysAndValues[i + 1], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a sequence of alternating keys and values.
 * Currently generates "&key&" for empty args.
 *
 * @param {goog.uri.utils.QueryArray} keysAndValues Alternating keys and
 *     values.  See the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
  var buffer = goog.uri.utils.buildQueryDataBuffer_(
      [], keysAndValues, opt_startIndex);
  buffer[0] = ''; // Remove the leading ampersand.
  return buffer.join('');
};


/**
 * Builds a buffer of query data from a map.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {Object.<goog.uri.utils.QueryValue>} map An object where keys are
 *     URI-encoded parameter keys, and the values conform to the contract
 *     specified in the goog.uri.utils.QueryValue typedef.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBufferFromMap_ = function(buffer, map) {
  for (var key in map) {
    goog.uri.utils.appendKeyValuePairs_(key, map[key], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a map.
 * Currently generates "&key&" for empty args.
 *
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryDataFromMap = function(map) {
  var buffer = goog.uri.utils.buildQueryDataBufferFromMap_([], map);
  buffer[0] = '';
  return buffer.join('');
};


/**
 * Appends URI parameters to an existing URI.
 *
 * The variable arguments may contain alternating keys and values.  Keys are
 * assumed to be already URI encoded.  The values should not be URI-encoded,
 * and will instead be encoded by this function.
 * <pre>
 * appendParams('http://www.foo.com?existing=true',
 *     'key1', 'value1',
 *     'key2', 'value?willBeEncoded',
 *     'key3', ['valueA', 'valueB', 'valueC'],
 *     'key4', null);
 * result: 'http://www.foo.com?existing=true&' +
 *     'key1=value1&' +
 *     'key2=value%3FwillBeEncoded&' +
 *     'key3=valueA&key3=valueB&key3=valueC'
 * </pre>
 *
 * A single call to this function will not exhibit quadratic behavior in IE,
 * whereas multiple repeated calls may, although the effect is limited by
 * fact that URL's generally can't exceed 2kb.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {...(goog.uri.utils.QueryArray|string|goog.uri.utils.QueryValue)} var_args
 *     An array or argument list conforming to goog.uri.utils.QueryArray.
 * @return {string} The URI with all query parameters added.
 */
goog.uri.utils.appendParams = function(uri, var_args) {
  return goog.uri.utils.appendQueryData_(
      arguments.length == 2 ?
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments[1], 0) :
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments, 1));
};


/**
 * Appends query parameters from a map.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The new parameters.
 */
goog.uri.utils.appendParamsFromMap = function(uri, map) {
  return goog.uri.utils.appendQueryData_(
      goog.uri.utils.buildQueryDataBufferFromMap_([uri], map));
};


/**
 * Appends a single URI parameter.
 *
 * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
 * way string append works, though it should be limited given the 2kb limit.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} key The key, which must already be URI encoded.
 * @param {*=} opt_value The value, which will be stringized and encoded
 *     (assumed not already to be encoded).  If omitted, undefined, or null, the
 *     key will be added as a valueless parameter.
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.appendParam = function(uri, key, opt_value) {
  var paramArr = [uri, '&', key];
  if (goog.isDefAndNotNull(opt_value)) {
    paramArr.push('=', goog.string.urlEncode(opt_value));
  }
  return goog.uri.utils.appendQueryData_(paramArr);
};


/**
 * Finds the next instance of a query parameter with the specified name.
 *
 * Does not instantiate any objects.
 *
 * @param {string} uri The URI to search.  May contain a fragment identifier
 *     if opt_hashIndex is specified.
 * @param {number} startIndex The index to begin searching for the key at.  A
 *     match may be found even if this is one character after the ampersand.
 * @param {string} keyEncoded The URI-encoded key.
 * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
 *     mark is present, it should be its index, otherwise it should be the
 *     length of the string.
 * @return {number} The position of the first character in the key's name,
 *     immediately after either a question mark or a dot.
 * @private
 */
goog.uri.utils.findParam_ = function(
    uri, startIndex, keyEncoded, hashOrEndIndex) {
  var index = startIndex;
  var keyLength = keyEncoded.length;

  // Search for the key itself and post-filter for surronuding punctuation,
  // rather than expensively building a regexp.
  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&
      index < hashOrEndIndex) {
    var precedingChar = uri.charCodeAt(index - 1);
    // Ensure that the preceding character is '&' or '?'.
    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
      // Ensure the following character is '&', '=', '#', or NaN
      // (end of string).
      var followingChar = uri.charCodeAt(index + keyLength);
      if (!followingChar ||
          followingChar == goog.uri.utils.CharCode_.EQUAL ||
          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
          followingChar == goog.uri.utils.CharCode_.HASH) {
        return index;
      }
    }
    index += keyLength + 1;
  }

  return -1;
};


/**
 * Regular expression for finding a hash mark or end of string.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.hashOrEndRe_ = /#|$/;


/**
 * Determines if the URI contains a specific key.
 *
 * Performs no object instantiations.
 *
 * @param {string} uri The URI to process.  May contain a fragment
 *     identifier.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {boolean} Whether the key is present.
 */
goog.uri.utils.hasParam = function(uri, keyEncoded) {
  return goog.uri.utils.findParam_(uri, 0, keyEncoded,
      uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;
};


/**
 * Gets the first value of a query parameter.
 * @param {string} uri The URI to process.  May contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {?string} The first value of the parameter (URI-decoded), or null
 *     if the parameter is not found.
 */
goog.uri.utils.getParamValue = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var foundIndex = goog.uri.utils.findParam_(
      uri, 0, keyEncoded, hashOrEndIndex);

  if (foundIndex < 0) {
    return null;
  } else {
    var endPosition = uri.indexOf('&', foundIndex);
    if (endPosition < 0 || endPosition > hashOrEndIndex) {
      endPosition = hashOrEndIndex;
    }
    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > endPosition.
    return goog.string.urlDecode(
        uri.substr(foundIndex, endPosition - foundIndex));
  }
};


/**
 * Gets all values of a query parameter.
 * @param {string} uri The URI to process.  May contain a framgnet.
 * @param {string} keyEncoded The URI-encoded key.  Case-snsitive.
 * @return {!Array.<string>} All URI-decoded values with the given key.
 *     If the key is not found, this will have length 0, but never be null.
 */
goog.uri.utils.getParamValues = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var result = [];

  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Find where this parameter ends, either the '&' or the end of the
    // query parameters.
    position = uri.indexOf('&', foundIndex);
    if (position < 0 || position > hashOrEndIndex) {
      position = hashOrEndIndex;
    }

    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > position.
    result.push(goog.string.urlDecode(uri.substr(
        foundIndex, position - foundIndex)));
  }

  return result;
};


/**
 * Regexp to find trailing question marks and ampersands.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;


/**
 * Removes all instances of a query parameter.
 * @param {string} uri The URI to process.  Must not contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.
 * @return {string} The URI with all instances of the parameter removed.
 */
goog.uri.utils.removeParam = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var buffer = [];

  // Look for a query parameter.
  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Get the portion of the query string up to, but not including, the ?
    // or & starting the parameter.
    buffer.push(uri.substring(position, foundIndex));
    // Progress to immediately after the '&'.  If not found, go to the end.
    // Avoid including the hash mark.
    position = Math.min((uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex,
        hashOrEndIndex);
  }

  // Append everything that is remaining.
  buffer.push(uri.substr(position));

  // Join the buffer, and remove trailing punctuation that remains.
  return buffer.join('').replace(
      goog.uri.utils.trailingQueryPunctuationRe_, '$1');
};


/**
 * Replaces all existing definitions of a parameter with a single definition.
 *
 * Repeated calls to this can exhibit quadratic behavior due to the need to
 * find existing instances and reconstruct the string, though it should be
 * limited given the 2kb limit.  Consider using appendParams to append multiple
 * parameters in bulk.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} keyEncoded The key, which must already be URI encoded.
 * @param {*} value The value, which will be stringized and encoded (assumed
 *     not already to be encoded).
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.setParam = function(uri, keyEncoded, value) {
  return goog.uri.utils.appendParam(
      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
};


/**
 * Generates a URI path using a given URI and a path with checks to
 * prevent consecutive "//". The baseUri passed in must not contain
 * query or fragment identifiers. The path to append may not contain query or
 * fragment identifiers.
 *
 * @param {string} baseUri URI to use as the base.
 * @param {string} path Path to append.
 * @return {string} Updated URI.
 */
goog.uri.utils.appendPath = function(baseUri, path) {
  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);

  // Remove any trailing '/'
  if (goog.string.endsWith(baseUri, '/')) {
    baseUri = baseUri.substr(0, baseUri.length - 1);
  }
  // Remove any leading '/'
  if (goog.string.startsWith(path, '/')) {
    path = path.substr(1);
  }
  return goog.string.buildString(baseUri, '/', path);
};


/**
 * Replaces the path.
 * @param {string} uri URI to use as the base.
 * @param {string} path New path.
 * @return {string} Updated URI.
 */
goog.uri.utils.setPath = function(uri, path) {
  // Add any missing '/'.
  if (!goog.string.startsWith(path, '/')) {
    path = '/' + path;
  }
  var parts = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      parts[goog.uri.utils.ComponentIndex.SCHEME],
      parts[goog.uri.utils.ComponentIndex.USER_INFO],
      parts[goog.uri.utils.ComponentIndex.DOMAIN],
      parts[goog.uri.utils.ComponentIndex.PORT],
      path,
      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],
      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Standard supported query parameters.
 * @enum {string}
 */
goog.uri.utils.StandardQueryParam = {

  /** Unused parameter for unique-ifying. */
  RANDOM: 'zx'
};


/**
 * Sets the zx parameter of a URI to a random value.
 * @param {string} uri Any URI.
 * @return {string} That URI with the "zx" parameter added or replaced to
 *     contain a random string.
 */
goog.uri.utils.makeUnique = function(uri) {
  return goog.uri.utils.setParam(uri,
      goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):?} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @template T,K,V
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to call
 *     for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):R} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
goog.object.some = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return false;
    }
  }
  return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function(obj) {
  for (var key in obj) {
    return key;
  }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object.<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
goog.object.getAnyValue = function(obj) {
  for (var key in obj) {
    return obj[key];
  }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object from which to get the values.
 * @return {!Array.<V>} The values in the object/map/hash.
 * @template K,V
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array.<number|string>)} var_args A number of keys
 *     (as strings, or numbers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function(obj, var_args) {
  var isArrayLike = goog.isArrayLike(var_args);
  var keys = isArrayLike ? var_args : arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    obj = obj[keys[i]];
    if (!goog.isDef(obj)) {
      break;
    }
  }

  return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function(obj, key) {
  return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The
 *      function to call for every element. Takes 3 arguments (the value,
 *     the key and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findKey = function(obj, f, opt_this) {
  for (var key in obj) {
    if (f.call(opt_this, obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The function
 *     to call for every element. Takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findValue = function(obj, f, opt_this) {
  var key = goog.object.findKey(obj, f, opt_this);
  return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @template K,V
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object.<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setIfUndefined = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object.<K,V>} obj Object to clone.
 * @return {!Object.<K,V>} Clone of the input object.
 * @template K,V
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.object.unsafeClone(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function(obj) {
  var transposed = {};
  for (var key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {b: 2, c: 3});
 * o; // {a: 0, b: 2, c: 3}
 *
 * @param {Object} target The object to modify. Existing properties will be
 *     overwritten if they are also present in one of the objects in
 *     {@code var_args}.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }

  var rv = {};
  for (var i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
};


/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 *
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 *
 * @param {!Object.<K,V>} obj An object.
 * @return {!Object.<K,V>} An immutable view of that object, or the
 *     original object if this browser does not support immutables.
 * @template K,V
 */
goog.object.createImmutableView = function(obj) {
  var result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
};


/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
goog.object.isImmutableView = function(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for creating functions. Loosely inspired by the
 * java classes: http://goo.gl/GM0Hmu and http://goo.gl/6k7nI8.
 *
 * @author nicksantos@google.com (Nick Santos)
 */


goog.provide('goog.functions');


/**
 * Creates a function that always returns the same value.
 * @param {T} retValue The value to return.
 * @return {function():T} The new function.
 * @template T
 */
goog.functions.constant = function(retValue) {
  return function() {
    return retValue;
  };
};


/**
 * Always returns false.
 * @type {function(...): boolean}
 */
goog.functions.FALSE = goog.functions.constant(false);


/**
 * Always returns true.
 * @type {function(...): boolean}
 */
goog.functions.TRUE = goog.functions.constant(true);


/**
 * Always returns NULL.
 * @type {function(...): null}
 */
goog.functions.NULL = goog.functions.constant(null);


/**
 * A simple function that returns the first argument of whatever is passed
 * into it.
 * @param {T=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {T} The first argument passed in, or undefined if nothing was passed.
 * @template T
 */
goog.functions.identity = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * Creates a function that always throws an error with the given message.
 * @param {string} message The error message.
 * @return {!Function} The error-throwing function.
 */
goog.functions.error = function(message) {
  return function() {
    throw Error(message);
  };
};


/**
 * Creates a function that throws the given object.
 * @param {*} err An object to be thrown.
 * @return {!Function} The error-throwing function.
 */
goog.functions.fail = function(err) {
  return function() {
    throw err;
  }
};


/**
 * Given a function, create a function that keeps opt_numArgs arguments and
 * silently discards all additional arguments.
 * @param {Function} f The original function.
 * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
 * @return {!Function} A version of f that only keeps the first opt_numArgs
 *     arguments.
 */
goog.functions.lock = function(f, opt_numArgs) {
  opt_numArgs = opt_numArgs || 0;
  return function() {
    return f.apply(this, Array.prototype.slice.call(arguments, 0, opt_numArgs));
  };
};


/**
 * Creates a function that returns its nth argument.
 * @param {number} n The position of the return argument.
 * @return {!Function} A new function.
 */
goog.functions.nth = function(n) {
  return function() {
    return arguments[n];
  };
};


/**
 * Given a function, create a new function that swallows its return value
 * and replaces it with a new one.
 * @param {Function} f A function.
 * @param {T} retValue A new return value.
 * @return {function(...[?]):T} A new function.
 * @template T
 */
goog.functions.withReturnValue = function(f, retValue) {
  return goog.functions.sequence(f, goog.functions.constant(retValue));
};


/**
 * Creates the composition of the functions passed in.
 * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
 * @param {function(...[?]):T} fn The final function.
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):T} The composition of all inputs.
 * @template T
 */
goog.functions.compose = function(fn, var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    if (length) {
      result = functions[length - 1].apply(this, arguments);
    }

    for (var i = length - 2; i >= 0; i--) {
      result = functions[i].call(this, result);
    }
    return result;
  };
};


/**
 * Creates a function that calls the functions passed in in sequence, and
 * returns the value of the last function. For example,
 * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
 * @param {...Function} var_args A list of functions.
 * @return {!Function} A function that calls all inputs in sequence.
 */
goog.functions.sequence = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }
    return result;
  };
};


/**
 * Creates a function that returns true if each of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns false.
 * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ANDs its component
 *      functions.
 */
goog.functions.and = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (!functions[i].apply(this, arguments)) {
        return false;
      }
    }
    return true;
  };
};


/**
 * Creates a function that returns true if any of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns true.
 * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ORs its component
 *    functions.
 */
goog.functions.or = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (functions[i].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  };
};


/**
 * Creates a function that returns the Boolean opposite of a provided function.
 * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
 * @param {!Function} f The original function.
 * @return {function(...[?]):boolean} A function that delegates to f and returns
 * opposite.
 */
goog.functions.not = function(f) {
  return function() {
    return !f.apply(this, arguments);
  };
};


/**
 * Generic factory function to construct an object given the constructor
 * and the arguments. Intended to be bound to create object factories.
 *
 * Callers should cast the result to the appropriate type for proper type
 * checking by the compiler.
 * @param {!Function} constructor The constructor for the Object.
 * @param {...*} var_args The arguments to be passed to the constructor.
 * @return {!Object} A new instance of the class given in {@code constructor}.
 */
goog.functions.create = function(constructor, var_args) {
  /**
 * @constructor
 * @final
 */
  var temp = function() {};
  temp.prototype = constructor.prototype;

  // obj will have constructor's prototype in its chain and
  // 'obj instanceof constructor' will be true.
  var obj = new temp();

  // obj is initialized by constructor.
  // arguments is only array-like so lacks shift(), but can be used with
  // the Array prototype function.
  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
  return obj;
};


/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.define('goog.functions.CACHE_RETURN_VALUE', true);


/**
 * Gives a wrapper function that caches the return value of a parameterless
 * function when first called.
 *
 * When called for the first time, the given function is called and its
 * return value is cached (thus this is only appropriate for idempotent
 * functions).  Subsequent calls will return the cached return value. This
 * allows the evaluation of expensive functions to be delayed until first used.
 *
 * To cache the return values of functions with parameters, see goog.memoize.
 *
 * @param {!function():T} fn A function to lazily evaluate.
 * @return {!function():T} A wrapped version the function.
 * @template T
 */
goog.functions.cacheReturnValue = function(fn) {
  var called = false;
  var value;

  return function() {
    if (!goog.functions.CACHE_RETURN_VALUE) {
      return fn();
    }

    if (!called) {
      value = fn();
      called = true;
    }

    return value;
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., {@code Array#filter}) and remove the
 * unused pure JS implementation.
 */
goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * @param {Array.<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.indexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!Array.<T>|!goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.lastIndexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (goog.isString(arr)) {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.forEach) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array.<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.filter) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
 *     for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return something. The result will be
 *     inserted into a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array.<RESULT>} a new array with the results from f.
 * @template THIS, VALUE, RESULT
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                  goog.array.ARRAY_PROTOTYPE_.map) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.reduce) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEach(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.reduceRight) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEachRight(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                   goog.array.ARRAY_PROTOTYPE_.some) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                    goog.array.ARRAY_PROTOTYPE_.every) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!(Array.<T>|goog.array.ArrayLike)} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
goog.array.count = function(arr, f, opt_obj) {
  var count = 0;
  goog.array.forEach(arr, function(element, index, arr) {
    if (f.call(opt_obj, element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = 0; i < l; i++) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function(arr, f, opt_obj) {
  var i = goog.array.findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {Object=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array.<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function(arr, obj) {
  if (!goog.array.contains(arr, obj)) {
    arr.push(obj);
  }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array.<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function(arr, obj, opt_obj2) {
  var i;
  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    goog.array.insertAt(arr, obj, i);
  }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  goog.asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  if (i >= 0) {
    goog.array.removeAt(arr, i);
    return true;
  }
  return false;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {Array.<T>|goog.array.ArrayLike} object  The object to convert to an
 *     array.
 * @return {!Array.<T>} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 * @template T
 */
goog.array.toArray = function(object) {
  var length = object.length;

  // If length is not a number the following it false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    var rv = new Array(length);
    for (var i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
};


/**
 * Does a shallow copy of an array.
 * @param {Array.<T>|goog.array.ArrayLike} arr  Array or array-like object to
 *     clone.
 * @return {!Array.<T>} Clone of the input array.
 * @template T
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array.<VALUE>} arr1  The array to modify.
 * @param {...(Array.<VALUE>|VALUE)} var_args The elements or arrays of elements
 *     to add to arr1.
 * @template VALUE
 */
goog.array.extend = function(arr1, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var arr2 = arguments[i];
    // If we have an Array or an Arguments object we can just call push
    // directly.
    var isArrayLike;
    if (goog.isArray(arr2) ||
        // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
        // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
        // detect Arguments by checking for array like and presence of "callee".
        (isArrayLike = goog.isArrayLike(arr2)) &&
            // The getter for callee throws an exception in strict mode
            // according to section 10.6 in ES5 so check for presence instead.
            Object.prototype.hasOwnProperty.call(arr2, 'callee')) {
      arr1.push.apply(arr1, arr2);
    } else if (isArrayLike) {
      // Otherwise loop over arr2 to prevent copying the object.
      var len1 = arr1.length;
      var len2 = arr2.length;
      for (var j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array.<T>} the removed elements.
 * @template T
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  goog.asserts.assert(arr.length != null);

  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array.<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function(arr, start, opt_end) {
  goog.asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
  var returnArray = opt_rv || arr;
  var defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(current) ? 'o' + goog.getUid(current) :
        (typeof current).charAt(0) + current;
  };
  var hashFn = opt_hashFn || defaultHashFn;

  var seen = {}, cursorInsert = 0, cursorRead = 0;
  while (cursorRead < arr.length) {
    var current = arr[cursorRead++];
    var key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {TARGET} target The sought value.
 * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template TARGET, VALUE
 */
goog.array.binarySearch = function(arr, target, opt_compareFn) {
  return goog.array.binarySearch_(arr,
      opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
      target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(this:THIS, VALUE, number, ?): number} evaluator
 *     Evaluator function that receives 3 arguments (the element, the index and
 *     the array). Should return a negative number, zero, or a positive number
 *     depending on whether the desired index is before, at, or after the
 *     element passed to it.
 * @param {THIS=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 * @template THIS, VALUE
 */
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
  return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
      undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(TARGET, VALUE): number|
 *         function(this:THIS, VALUE, number, ?): number} compareFn Either an
 *     evaluator or a comparison function, as defined by binarySearch
 *     and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {TARGET=} opt_target If the function is a comparison function, then
 *     this is the target to binary search for.
 * @param {THIS=} opt_selfObj If the function is an evaluator, this is an
  *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template THIS, VALUE, TARGET
 * @private
 */
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
    opt_selfObj) {
  var left = 0;  // inclusive
  var right = arr.length;  // exclusive
  var found;
  while (left < right) {
    var middle = (left + right) >> 1;
    var compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      compareResult = compareFn(opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // ~left is a shorthand for -left - 1.
  return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  arr.sort(opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function(arr, opt_compareFn) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = {index: i, value: arr[i]};
  }
  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  };
  goog.array.sort(arr, stableCompareFn);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = arr[i].value;
  }
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array.<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  goog.array.sort(arr, function(a, b) {
    return compare(a[key], b[key]);
  });
};


/**
 * Tells if the array is sorted.
 * @param {!Array.<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  for (var i = 1; i < arr.length; i++) {
    var compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};


/**
 * 3-way array compare function.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} arr1 The first array to
 *     compare.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} arr2 The second array to
 *     compare.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is to be ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template VALUE
 */
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  var l = Math.min(arr1.length, arr2.length);
  for (var i = 0; i < l; i++) {
    var result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 * @template VALUE
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array.<VALUE>|goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to insert.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template VALUE
 */
goog.array.binaryInsert = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    goog.array.insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
};


/**
 * Removes a value from a sorted array.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to remove.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was removed.
 * @template VALUE
 */
goog.array.binaryRemove = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array.<T>} array The array.
 * @param {function(this:S, T,number,Array.<T>):?} sorter Function to call for
 *     every element.  This takes 3 arguments (the element, the index and the
 *     array) and must return a valid object key (a string, number, etc), or
 *     undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
goog.array.bucket = function(array, sorter, opt_obj) {
  var buckets = {};

  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    var key = sorter.call(opt_obj, value, i, array);
    if (goog.isDef(key)) {
      // Push the value to the right bucket, creating it if necessary.
      var bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
};


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object.<T>} The new object.
 * @template T,S
 */
goog.array.toObject = function(arr, keyFunc, opt_obj) {
  var ret = {};
  goog.array.forEach(arr, function(element, index) {
    ret[keyFunc.call(opt_obj, element, index, arr)] = element;
  });
  return ret;
};


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array.<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
goog.array.range = function(startOrEnd, opt_end, opt_step) {
  var array = [];
  var start = 0;
  var end = startOrEnd;
  var step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (var i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (var i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {VALUE} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array.<VALUE>} An array with the repeated value.
 * @template VALUE
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array} An array containing the flattened values.
 */
goog.array.flatten = function(var_args) {
  var result = [];
  for (var i = 0; i < arguments.length; i++) {
    var element = arguments[i];
    if (goog.isArray(element)) {
      result.push.apply(result, goog.array.flatten.apply(null, element));
    } else {
      result.push(element);
    }
  }
  return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array.<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array.<T>} The array.
 * @template T
 */
goog.array.rotate = function(array, n) {
  goog.asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
};


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!(Array|Arguments|{length:number})} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     {@code arr.length - 1}.
 * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
 */
goog.array.moveItem = function(arr, fromIndex, toIndex) {
  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
 */
goog.array.zip = function(var_args) {
  if (!arguments.length) {
    return [];
  }
  var result = [];
  for (var i = 0; true; i++) {
    var value = [];
    for (var j = 0; j < arguments.length; j++) {
      var arr = arguments[j];
      // If i is larger than the array length, this is the shortest array.
      if (i >= arr.length) {
        return result;
      }
      value.push(arr[i]);
    }
    result.push(value);
  }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function(arr, opt_randFn) {
  var randFn = opt_randFn || Math.random;

  for (var i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    var j = Math.floor(randFn() * (i + 1));

    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Additional mathematical functions.
 */

goog.provide('goog.math');

goog.require('goog.array');
goog.require('goog.asserts');


/**
 * Returns a random integer greater than or equal to 0 and less than {@code a}.
 * @param {number} a  The upper bound for the random integer (exclusive).
 * @return {number} A random integer N such that 0 <= N < a.
 */
goog.math.randomInt = function(a) {
  return Math.floor(Math.random() * a);
};


/**
 * Returns a random number greater than or equal to {@code a} and less than
 * {@code b}.
 * @param {number} a  The lower bound for the random number (inclusive).
 * @param {number} b  The upper bound for the random number (exclusive).
 * @return {number} A random number N such that a <= N < b.
 */
goog.math.uniformRandom = function(a, b) {
  return a + Math.random() * (b - a);
};


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
goog.math.clamp = function(value, min, max) {
  return Math.min(Math.max(value, min), max);
};


/**
 * The % operator in JavaScript returns the remainder of a / b, but differs from
 * some other languages in that the result will have the same sign as the
 * dividend. For example, -1 % 8 == -1, whereas in some other languages
 * (such as Python) the result would be 7. This function emulates the more
 * correct modulo behavior, which is useful for certain applications such as
 * calculating an offset index in a circular list.
 *
 * @param {number} a The dividend.
 * @param {number} b The divisor.
 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
 *     or b < x <= 0, depending on the sign of b).
 */
goog.math.modulo = function(a, b) {
  var r = a % b;
  // If r and b differ in sign, add b to wrap the result to the correct sign.
  return (r * b < 0) ? r + b : r;
};


/**
 * Performs linear interpolation between values a and b. Returns the value
 * between a and b proportional to x (when x is between 0 and 1. When x is
 * outside this range, the return value is a linear extrapolation).
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number} x The proportion between a and b.
 * @return {number} The interpolated value between a and b.
 */
goog.math.lerp = function(a, b, x) {
  return a + x * (b - a);
};


/**
 * Tests whether the two values are equal to each other, within a certain
 * tolerance to adjust for floating point errors.
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number=} opt_tolerance Optional tolerance range. Defaults
 *     to 0.000001. If specified, should be greater than 0.
 * @return {boolean} Whether {@code a} and {@code b} are nearly equal.
 */
goog.math.nearlyEquals = function(a, b, opt_tolerance) {
  return Math.abs(a - b) <= (opt_tolerance || 0.000001);
};


/**
 * Standardizes an angle to be in range [0-360). Negative angles become
 * positive, and values greater than 360 are returned modulo 360.
 * @param {number} angle Angle in degrees.
 * @return {number} Standardized angle.
 */
goog.math.standardAngle = function(angle) {
  return goog.math.modulo(angle, 360);
};


/**
 * Converts degrees to radians.
 * @param {number} angleDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
goog.math.toRadians = function(angleDegrees) {
  return angleDegrees * Math.PI / 180;
};


/**
 * Converts radians to degrees.
 * @param {number} angleRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
goog.math.toDegrees = function(angleRadians) {
  return angleRadians * 180 / Math.PI;
};


/**
 * For a given angle and radius, finds the X portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The x-distance for the angle and radius.
 */
goog.math.angleDx = function(degrees, radius) {
  return radius * Math.cos(goog.math.toRadians(degrees));
};


/**
 * For a given angle and radius, finds the Y portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The y-distance for the angle and radius.
 */
goog.math.angleDy = function(degrees, radius) {
  return radius * Math.sin(goog.math.toRadians(degrees));
};


/**
 * Computes the angle between two points (x1,y1) and (x2,y2).
 * Angle zero points in the +X direction, 90 degrees points in the +Y
 * direction (down) and from there we grow clockwise towards 360 degrees.
 * @param {number} x1 x of first point.
 * @param {number} y1 y of first point.
 * @param {number} x2 x of second point.
 * @param {number} y2 y of second point.
 * @return {number} Standardized angle in degrees of the vector from
 *     x1,y1 to x2,y2.
 */
goog.math.angle = function(x1, y1, x2, y2) {
  return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1,
                                                                x2 - x1)));
};


/**
 * Computes the difference between startAngle and endAngle (angles in degrees).
 * @param {number} startAngle  Start angle in degrees.
 * @param {number} endAngle  End angle in degrees.
 * @return {number} The number of degrees that when added to
 *     startAngle will result in endAngle. Positive numbers mean that the
 *     direction is clockwise. Negative numbers indicate a counter-clockwise
 *     direction.
 *     The shortest route (clockwise vs counter-clockwise) between the angles
 *     is used.
 *     When the difference is 180 degrees, the function returns 180 (not -180)
 *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
 *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
 */
goog.math.angleDifference = function(startAngle, endAngle) {
  var d = goog.math.standardAngle(endAngle) -
          goog.math.standardAngle(startAngle);
  if (d > 180) {
    d = d - 360;
  } else if (d <= -180) {
    d = 360 + d;
  }
  return d;
};


/**
 * Returns the sign of a number as per the "sign" or "signum" function.
 * @param {number} x The number to take the sign of.
 * @return {number} -1 when negative, 1 when positive, 0 when 0.
 */
goog.math.sign = function(x) {
  return x == 0 ? 0 : (x < 0 ? -1 : 1);
};


/**
 * JavaScript implementation of Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the longest possible array that is subarray of both of given arrays.
 *
 * @param {Array.<Object>} array1 First array of objects.
 * @param {Array.<Object>} array2 Second array of objects.
 * @param {Function=} opt_compareFn Function that acts as a custom comparator
 *     for the array ojects. Function should return true if objects are equal,
 *     otherwise false.
 * @param {Function=} opt_collectorFn Function used to decide what to return
 *     as a result subsequence. It accepts 2 arguments: index of common element
 *     in the first array and index in the second. The default function returns
 *     element from the first array.
 * @return {Array.<Object>} A list of objects that are common to both arrays
 *     such that there is no common subsequence with size greater than the
 *     length of the list.
 */
goog.math.longestCommonSubsequence = function(
    array1, array2, opt_compareFn, opt_collectorFn) {

  var compare = opt_compareFn || function(a, b) {
    return a == b;
  };

  var collect = opt_collectorFn || function(i1, i2) {
    return array1[i1];
  };

  var length1 = array1.length;
  var length2 = array2.length;

  var arr = [];
  for (var i = 0; i < length1 + 1; i++) {
    arr[i] = [];
    arr[i][0] = 0;
  }

  for (var j = 0; j < length2 + 1; j++) {
    arr[0][j] = 0;
  }

  for (i = 1; i <= length1; i++) {
    for (j = 1; j <= length2; j++) {
      if (compare(array1[i - 1], array2[j - 1])) {
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
      }
    }
  }

  // Backtracking
  var result = [];
  var i = length1, j = length2;
  while (i > 0 && j > 0) {
    if (compare(array1[i - 1], array2[j - 1])) {
      result.unshift(collect(i - 1, j - 1));
      i--;
      j--;
    } else {
      if (arr[i - 1][j] > arr[i][j - 1]) {
        i--;
      } else {
        j--;
      }
    }
  }

  return result;
};


/**
 * Returns the sum of the arguments.
 * @param {...number} var_args Numbers to add.
 * @return {number} The sum of the arguments (0 if no arguments were provided,
 *     {@code NaN} if any of the arguments is not a valid number).
 */
goog.math.sum = function(var_args) {
  return /** @type {number} */ (goog.array.reduce(arguments,
      function(sum, value) {
        return sum + value;
      }, 0));
};


/**
 * Returns the arithmetic mean of the arguments.
 * @param {...number} var_args Numbers to average.
 * @return {number} The average of the arguments ({@code NaN} if no arguments
 *     were provided or any of the arguments is not a valid number).
 */
goog.math.average = function(var_args) {
  return goog.math.sum.apply(null, arguments) / arguments.length;
};


/**
 * Returns the unbiased sample variance of the arguments. For a definition,
 * see e.g. http://en.wikipedia.org/wiki/Variance
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The unbiased sample variance of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.sampleVariance = function(var_args) {
  var sampleSize = arguments.length;
  if (sampleSize < 2) {
    return 0;
  }

  var mean = goog.math.average.apply(null, arguments);
  var variance = goog.math.sum.apply(null, goog.array.map(arguments,
      function(val) {
        return Math.pow(val - mean, 2);
      })) / (sampleSize - 1);

  return variance;
};


/**
 * Returns the sample standard deviation of the arguments.  For a definition of
 * sample standard deviation, see e.g.
 * http://en.wikipedia.org/wiki/Standard_deviation
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The sample standard deviation of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.standardDeviation = function(var_args) {
  return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));
};


/**
 * Returns whether the supplied number represents an integer, i.e. that is has
 * no fractional component.  No range-checking is performed on the number.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is an integer.
 */
goog.math.isInt = function(num) {
  return isFinite(num) && num % 1 == 0;
};


/**
 * Returns whether the supplied number is finite and not NaN.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is a finite number.
 */
goog.math.isFiniteNumber = function(num) {
  return isFinite(num) && !isNaN(num);
};


/**
 * A tweaked variant of {@code Math.floor} which tolerates if the passed number
 * is infinitesimally smaller than the closest integer. It often happens with
 * the results of floating point calculations because of the finite precision
 * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
 * Math.LN10) == 2}, not 3 as one would expect.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The largest integer less than or equal to {@code num}.
 */
goog.math.safeFloor = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.floor(num + (opt_epsilon || 2e-15));
};


/**
 * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for
 * details.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The smallest integer greater than or equal to {@code num}.
 */
goog.math.safeCeil = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.ceil(num - (opt_epsilon || 2e-15));
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Python style iteration utilities.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterable');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.functions');
goog.require('goog.math');


// TODO(nnaze): Add more functions from Python's itertools.
// http://docs.python.org/library/itertools.html


/**
 * @typedef {goog.iter.Iterator|{length:number}|{__iterator__}}
 */
goog.iter.Iterable;


// For script engines that already support iterators.
if ('StopIteration' in goog.global) {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   */
  goog.iter.StopIteration = goog.global['StopIteration'];
} else {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   * @suppress {duplicate}
   */
  goog.iter.StopIteration = Error('StopIteration');
}



/**
 * Class/interface for iterators.  An iterator needs to implement a {@code next}
 * method and it needs to throw a {@code goog.iter.StopIteration} when the
 * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 * @template VALUE
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter#StopIteration} when the iteration passes the end.
 * @return {VALUE} Any object or value.
 */
goog.iter.Iterator.prototype.next = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the {@code Iterator} object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (false).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator.<VALUE>} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable  If the
 *     object is an iterator it will be returned as is.  If the object has an
 *     {@code __iterator__} method that will be called to get the value
 *     iterator.  If the object is an array-like object we create an iterator
 *     for that.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator that knows how to iterate
 *     over the values in {@code iterable}.
 * @template VALUE
 */
goog.iter.toIterator = function(iterable) {
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return iterable.__iterator__(false);
  }
  if (goog.isArrayLike(iterable)) {
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.next = function() {
      while (true) {
        if (i >= iterable.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in iterable)) {
          i++;
          continue;
        }
        return iterable[i++];
      }
    };
    return newIter;
  }


  // TODO(arv): Should we fall back on goog.structs.getValues()?
  throw Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable  The iterator
 *     to iterate over. If the iterable is an object {@code toIterator} will be
 *     called on it.
 * @param {function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>)|
 *         function(this:THIS,number,undefined,goog.iter.Iterator.<VALUE>)} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and the return value is
 *     irrelevant.  The reason for passing undefined as the second argument is
 *     so that the same function can be used in {@see goog.array#forEach} as
 *     well as others.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     {@code f}.
 * @template THIS, VALUE
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  if (goog.isArrayLike(iterable)) {
    /** @preserveTry */
    try {
      // NOTES: this passes the index number to the second parameter
      // of the callback contrary to the documentation above.
      goog.array.forEach(/** @type {goog.array.ArrayLike} */(iterable), f,
                         opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);
    /** @preserveTry */
    try {
      while (true) {
        f.call(opt_obj, iterable.next(), undefined, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every element. This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a boolean.
 *     If the return value is true the element will be included  in the returned
 *     iterator.  If it is false the element is not included.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator in which only elements
 *     that passed the test are present.
 * @template THIS, VALUE
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (f.call(opt_obj, val, undefined, iterator)) {
        return val;
      }
    }
  };
  return newIter;
};


/**
 * Creates a new iterator that returns the values in a range.  This function
 * can take 1, 2 or 3 arguments:
 * <pre>
 * range(5) same as range(0, 5, 1)
 * range(2, 5) same as range(2, 5, 1)
 * </pre>
 *
 * @param {number} startOrStop  The stop value if only one argument is provided.
 *     The start value if 2 or more arguments are provided.  If only one
 *     argument is used the start value is 0.
 * @param {number=} opt_stop  The stop value.  If left out then the first
 *     argument is used as the stop value.
 * @param {number=} opt_step  The number to increment with between each call to
 *     next.  This can be negative.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the values
 *     in the range.
 */
goog.iter.range = function(startOrStop, opt_stop, opt_step) {
  var start = 0;
  var stop = startOrStop;
  var step = opt_step || 1;
  if (arguments.length > 1) {
    start = startOrStop;
    stop = opt_stop;
  }
  if (step == 0) {
    throw Error('Range step argument must not be zero');
  }

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    if (step > 0 && start >= stop || step < 0 && start <= stop) {
      throw goog.iter.StopIteration;
    }
    var rv = start;
    start += step;
    return rv;
  };
  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 * @template VALUE
 */
goog.iter.join = function(iterable, deliminator) {
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterator to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator.<VALUE>):RESULT} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a new value.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<RESULT>} A new iterator that returns the
 *     results of applying the function to each element in the original
 *     iterator.
 * @template THIS, VALUE, RESULT
 */
goog.iter.map = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      return f.call(opt_obj, val, undefined, iterator);
    }
  };
  return newIter;
};


/**
 * Passes every element of an iterator into a function and accumulates the
 * result.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {function(this:THIS,VALUE,VALUE):VALUE} f The function to call for
 *     every element. This function takes 2 arguments (the function's previous
 *     result or the initial value, and the value of the current element).
 *     function(previousValue, currentElement) : newValue.
 * @param {VALUE} val The initial value to pass into the function on the first
 *     call.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     f.
 * @return {VALUE} Result of evaluating f repeatedly across the values of
 *     the iterator.
 * @template THIS, VALUE
 */
goog.iter.reduce = function(iterable, f, val, opt_obj) {
  var rval = val;
  goog.iter.forEach(iterable, function(val) {
    rval = f.call(opt_obj, rval, val);
  });
  return rval;
};


/**
 * Goes through the values in the iterator. Calls f for each of these, and if
 * any of them returns true, this returns true (without checking the rest). If
 * all return false this will return false.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if any value passes the test.
 * @template THIS, VALUE
 */
goog.iter.some = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return true;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return false;
};


/**
 * Goes through the values in the iterator. Calls f for each of these and if any
 * of them returns false this returns false (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if every value passes the test.
 * @template THIS, VALUE
 */
goog.iter.every = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (!f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return true;
};


/**
 * Takes zero or more iterables and returns one iterator that will iterate over
 * them in the order chained.
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<VALUE>} Returns a new iterator that will
 *     iterate over all the given iterables' contents.
 * @template VALUE
 */
goog.iter.chain = function(var_args) {
  var iterator = goog.iter.toIterator(arguments);
  var iter = new goog.iter.Iterator();
  var current = null;

  iter.next = function() {
    while (true) {
      if (current == null) {
        var it = iterator.next();
        current = goog.iter.toIterator(it);
      }
      try {
        return current.next();
      } catch (ex) {
        if (ex !== goog.iter.StopIteration) {
          throw ex;
        }
        current = null;
      }
    }
  };

  return iter;
};


/**
 * Takes a single iterable containing zero or more iterables and returns one
 * iterator that will iterate over each one in the order given.
 * @see http://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable
 * @param {goog.iter.Iterable} iterable The iterable of iterables to chain.
 * @return {!goog.iter.Iterator.<VALUE>} Returns a new iterator that will
 *     iterate over all the contents of the iterables contained within
 *     {@code iterable}.
 * @template VALUE
 */
goog.iter.chainFromIterable = function(iterable) {
  return goog.iter.chain.apply(undefined, iterable);
};


/**
 * Builds a new iterator that iterates over the original, but skips elements as
 * long as a supplied function returns true.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that drops elements from
 *     the original iterator as long as {@code f} is true.
 * @template THIS, VALUE
 */
goog.iter.dropWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var dropping = true;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (dropping && f.call(opt_obj, val, undefined, iterator)) {
        continue;
      } else {
        dropping = false;
      }
      return val;
    }
  };
  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but only as long as a
 * supplied function returns true.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj This is used as the 'this' object in f when called.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that keeps elements in
 *     the original iterator as long as the function is true.
 * @template THIS, VALUE
 */
goog.iter.takeWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var taking = true;
  newIter.next = function() {
    while (true) {
      if (taking) {
        var val = iterator.next();
        if (f.call(opt_obj, val, undefined, iterator)) {
          return val;
        } else {
          taking = false;
        }
      } else {
        throw goog.iter.StopIteration;
      }
    }
  };
  return newIter;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to convert to an array.
 * @return {!Array.<VALUE>} An array of the elements the iterator iterates over.
 * @template VALUE
 */
goog.iter.toArray = function(iterable) {
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray(/** @type {!goog.array.ArrayLike} */(iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    array.push(val);
  });
  return array;
};


/**
 * Iterates over two iterables and returns true if they contain the same
 * sequence of elements and have the same length.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable1 The first
 *     iterable object.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable2 The second
 *     iterable object.
 * @return {boolean} true if the iterables contain the same sequence of elements
 *     and have the same length.
 * @template VALUE
 */
goog.iter.equals = function(iterable1, iterable2) {
  var fillValue = {};
  var pairs = goog.iter.zipLongest(fillValue, iterable1, iterable2);
  return goog.iter.every(pairs, function(pair) {
    return pair[0] == pair[1];
  });
};


/**
 * Advances the iterator to the next position, returning the given default value
 * instead of throwing an exception if the iterator has no more entries.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterable
 *     object.
 * @param {VALUE} defaultValue The value to return if the iterator is empty.
 * @return {VALUE} The next item in the iteration, or defaultValue if the
 *     iterator was empty.
 * @template VALUE
 */
goog.iter.nextOrValue = function(iterable, defaultValue) {
  try {
    return goog.iter.toIterator(iterable).next();
  } catch (e) {
    if (e != goog.iter.StopIteration) {
      throw e;
    }
    return defaultValue;
  }
};


/**
 * Cartesian product of zero or more sets.  Gives an iterator that gives every
 * combination of one element chosen from each set.  For example,
 * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
 * @see http://docs.python.org/library/itertools.html#itertools.product
 * @param {...!goog.array.ArrayLike.<VALUE>} var_args Zero or more sets, as
 *     arrays.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} An iterator that gives each
 *     n-tuple (as an array).
 * @template VALUE
 */
goog.iter.product = function(var_args) {
  var someArrayEmpty = goog.array.some(arguments, function(arr) {
    return !arr.length;
  });

  // An empty set in a cartesian product gives an empty set.
  if (someArrayEmpty || !arguments.length) {
    return new goog.iter.Iterator();
  }

  var iter = new goog.iter.Iterator();
  var arrays = arguments;

  // The first indices are [0, 0, ...]
  var indicies = goog.array.repeat(0, arrays.length);

  iter.next = function() {

    if (indicies) {
      var retVal = goog.array.map(indicies, function(valueIndex, arrayIndex) {
        return arrays[arrayIndex][valueIndex];
      });

      // Generate the next-largest indices for the next call.
      // Increase the rightmost index. If it goes over, increase the next
      // rightmost (like carry-over addition).
      for (var i = indicies.length - 1; i >= 0; i--) {
        // Assertion prevents compiler warning below.
        goog.asserts.assert(indicies);
        if (indicies[i] < arrays[i].length - 1) {
          indicies[i]++;
          break;
        }

        // We're at the last indices (the last element of every array), so
        // the iteration is over on the next call.
        if (i == 0) {
          indicies = null;
          break;
        }
        // Reset the index in this column and loop back to increment the
        // next one.
        indicies[i] = 0;
      }
      return retVal;
    }

    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Create an iterator to cycle over the iterable's elements indefinitely.
 * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
 * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable object.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator that iterates indefinitely
 *     over the values in {@code iterable}.
 * @template VALUE
 */
goog.iter.cycle = function(iterable) {
  var baseIterator = goog.iter.toIterator(iterable);

  // We maintain a cache to store the iterable elements as we iterate
  // over them. The cache is used to return elements once we have
  // iterated over the iterable once.
  var cache = [];
  var cacheIndex = 0;

  var iter = new goog.iter.Iterator();

  // This flag is set after the iterable is iterated over once
  var useCache = false;

  iter.next = function() {
    var returnElement = null;

    // Pull elements off the original iterator if not using cache
    if (!useCache) {
      try {
        // Return the element from the iterable
        returnElement = baseIterator.next();
        cache.push(returnElement);
        return returnElement;
      } catch (e) {
        // If an exception other than StopIteration is thrown
        // or if there are no elements to iterate over (the iterable was empty)
        // throw an exception
        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
          throw e;
        }
        // set useCache to true after we know that a 'StopIteration' exception
        // was thrown and the cache is not empty (to handle the 'empty iterable'
        // use case)
        useCache = true;
      }
    }

    returnElement = cache[cacheIndex];
    cacheIndex = (cacheIndex + 1) % cache.length;

    return returnElement;
  };

  return iter;
};


/**
 * Creates an iterator that counts indefinitely from a starting value.
 * @see http://docs.python.org/2/library/itertools.html#itertools.count
 * @param {number=} opt_start The starting value. Default is 0.
 * @param {number=} opt_step The number to increment with between each call to
 *     next. Negative and floating point numbers are allowed. Default is 1.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the values
 *     in the series.
 */
goog.iter.count = function(opt_start, opt_step) {
  var counter = opt_start || 0;
  var step = goog.isDef(opt_step) ? opt_step : 1;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    var returnValue = counter;
    counter += step;
    return returnValue;
  };

  return iter;
};


/**
 * Creates an iterator that returns the same object or value repeatedly.
 * @param {VALUE} value Any object or value to repeat.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that returns the
 *     repeated value.
 * @template VALUE
 */
goog.iter.repeat = function(value) {
  var iter = new goog.iter.Iterator();

  iter.next = goog.functions.constant(value);

  return iter;
};


/**
 * Creates an iterator that returns running totals from the numbers in
 * {@code iterable}. For example, the array {@code [1, 2, 3, 4, 5]} yields
 * {@code 1 -> 3 -> 6 -> 10 -> 15}.
 * @see http://docs.python.org/3.2/library/itertools.html#itertools.accumulate
 * @param {!goog.iter.Iterable.<number>} iterable The iterable of numbers to
 *     accumulate.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the
 *     numbers in the series.
 */
goog.iter.accumulate = function(iterable) {
  var iterator = goog.iter.toIterator(iterable);
  var total = 0;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    total += iterator.next();
    return total;
  };

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Once the shortest iterable is
 * exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zip = function(var_args) {
  var args = arguments;
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);
    iter.next = function() {
      var arr = goog.array.map(iterators, function(it) {
        return it.next();
      });
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Shorter iterables will be extended
 * with {@code fillValue}. Once the longest iterable is exhausted, subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip_longest
 * @param {VALUE} fillValue The object or value used to fill shorter iterables.
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zipLongest = function(fillValue, var_args) {
  var args = goog.array.slice(arguments, 1);
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);

    iter.next = function() {
      var iteratorsHaveValues = false;  // false when all iterators are empty.
      var arr = goog.array.map(iterators, function(it) {
        var returnValue;
        try {
          returnValue = it.next();
          // Iterator had a value, so we've not exhausted the iterators.
          // Set flag accordingly.
          iteratorsHaveValues = true;
        } catch (ex) {
          if (ex !== goog.iter.StopIteration) {
            throw ex;
          }
          returnValue = fillValue;
        }
        return returnValue;
      });

      if (!iteratorsHaveValues) {
        throw goog.iter.StopIteration;
      }
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that filters {@code iterable} based on a series of
 * {@code selectors}. On each call to {@code next()}, one item is taken from
 * both the {@code iterable} and {@code selectors} iterators. If the item from
 * {@code selectors} evaluates to true, the item from {@code iterable} is given.
 * Otherwise, it is skipped. Once either {@code iterable} or {@code selectors}
 * is exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.compress
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to filter.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} selectors An
 *     iterable of items to be evaluated in a boolean context to determine if
 *     the corresponding element in {@code iterable} should be included in the
 *     result.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that returns the
 *     filtered values.
 * @template VALUE
 */
goog.iter.compress = function(iterable, selectors) {
  var selectorIterator = goog.iter.toIterator(selectors);

  return goog.iter.filter(iterable, function() {
    return !!selectorIterator.next();
  });
};



/**
 * Implements the {@code goog.iter.groupBy} iterator.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(...[VALUE]): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the {@code iterable}. Default
 *     is the identity function.
 * @constructor
 * @extends {goog.iter.Iterator.<!Array>}
 * @template KEY, VALUE
 * @private
 */
goog.iter.GroupByIterator_ = function(iterable, opt_keyFunc) {

  /**
   * The iterable to group, coerced to an iterator.
   * @type {!goog.iter.Iterator}
   */
  this.iterator = goog.iter.toIterator(iterable);

  /**
   * A function for determining the key value for each element in the iterable.
   * If no function is provided, the identity function is used and returns the
   * element unchanged.
   * @type {function(...[VALUE]): KEY}
   */
  this.keyFunc = opt_keyFunc || goog.functions.identity;

  /**
   * The target key for determining the start of a group.
   * @type {KEY}
   */
  this.targetKey;

  /**
   * The current key visited during iteration.
   * @type {KEY}
   */
  this.currentKey;

  /**
   * The current value being added to the group.
   * @type {VALUE}
   */
  this.currentValue;
};
goog.inherits(goog.iter.GroupByIterator_, goog.iter.Iterator);


/** @override */
goog.iter.GroupByIterator_.prototype.next = function() {
  while (this.currentKey == this.targetKey) {
    this.currentValue = this.iterator.next();  // Exits on StopIteration
    this.currentKey = this.keyFunc(this.currentValue);
  }
  this.targetKey = this.currentKey;
  return [this.currentKey, this.groupItems_(this.targetKey)];
};


/**
 * Performs the grouping of objects using the given key.
 * @param {KEY} targetKey  The target key object for the group.
 * @return {!Array.<VALUE>} An array of grouped objects.
 * @private
 */
goog.iter.GroupByIterator_.prototype.groupItems_ = function(targetKey) {
  var arr = [];
  while (this.currentKey == targetKey) {
    arr.push(this.currentValue);
    try {
      this.currentValue = this.iterator.next();
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
      break;
    }
    this.currentKey = this.keyFunc(this.currentValue);
  }
  return arr;
};


/**
 * Creates an iterator that returns arrays containing elements from the
 * {@code iterable} grouped by a key value. For iterables with repeated
 * elements (i.e. sorted according to a particular key function), this function
 * has a {@code uniq}-like effect. For example, grouping the array:
 * {@code [A, B, B, C, C, A]} produces
 * {@code [A, [A]], [B, [B, B]], [C, [C, C]], [A, [A]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.groupby
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(...[VALUE]): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the {@code iterable}. Default
 *     is the identity function.
 * @return {!goog.iter.Iterator.<!Array>} A new iterator that returns arrays of
 *     consecutive key and groups.
 * @template KEY, VALUE
 */
goog.iter.groupBy = function(iterable, opt_keyFunc) {
  return new goog.iter.GroupByIterator_(iterable, opt_keyFunc);
};


/**
 * Returns an array of iterators each of which can iterate over the values in
 * {@code iterable} without advancing the others.
 * @see http://docs.python.org/2/library/itertools.html#itertools.tee
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to tee.
 * @param {number=} opt_num  The number of iterators to create. Default is 2.
 * @return {!Array.<goog.iter.Iterator.<VALUE>>} An array of iterators.
 * @template VALUE
 */
goog.iter.tee = function(iterable, opt_num) {
  var iterator = goog.iter.toIterator(iterable);
  var num = goog.isNumber(opt_num) ? opt_num : 2;
  var buffers = goog.array.map(goog.array.range(num), function() {
    return [];
  });

  var addNextIteratorValueToBuffers = function() {
    var val = iterator.next();
    goog.array.forEach(buffers, function(buffer) {
      buffer.push(val);
    });
  };

  var createIterator = function(buffer) {
    // Each tee'd iterator has an associated buffer (initially empty). When a
    // tee'd iterator's buffer is empty, it calls
    // addNextIteratorValueToBuffers(), adding the next value to all tee'd
    // iterators' buffers, and then returns that value. This allows each
    // iterator to be advanced independently.
    var iter = new goog.iter.Iterator();

    iter.next = function() {
      if (goog.array.isEmpty(buffer)) {
        addNextIteratorValueToBuffers();
      }
      goog.asserts.assert(!goog.array.isEmpty(buffer));
      return buffer.shift();
    };

    return iter;
  };

  return goog.array.map(buffers, createIterator);
};


/**
 * Creates an iterator that returns arrays containing a count and an element
 * obtained from the given {@code iterable}.
 * @see http://docs.python.org/2/library/functions.html#enumerate
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to enumerate.
 * @param {number=} opt_start  Optional starting value. Default is 0.
 * @return {!goog.iter.Iterator.<!Array>} A new iterator containing count/item
 *     pairs.
 * @template VALUE
 */
goog.iter.enumerate = function(iterable, opt_start) {
  return goog.iter.zip(goog.iter.count(opt_start), iterable);
};


/**
 * Creates an iterator that returns the first {@code limitSize} elements from an
 * iterable. If this number is greater than the number of elements in the
 * iterable, all the elements are returned.
 * @see http://goo.gl/V0sihp Inspired by the limit iterator in Guava.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to limit.
 * @param {number} limitSize  The maximum number of elements to return.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator containing
 *     {@code limitSize} elements.
 * @template VALUE
 */
goog.iter.limit = function(iterable, limitSize) {
  goog.asserts.assert(goog.math.isInt(limitSize) && limitSize >= 0);

  var iterator = goog.iter.toIterator(iterable);

  var iter = new goog.iter.Iterator();
  var remaining = limitSize;

  iter.next = function() {
    if (remaining-- > 0) {
      return iterator.next();
    }
    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Creates an iterator that is advanced {@code count} steps ahead. Consumed
 * values are silently discarded. If {@code count} is greater than the number
 * of elements in {@code iterable}, an empty iterator is returned. Subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to consume.
 * @param {number} count  The number of elements to consume from the iterator.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator advanced zero or more steps
 *     ahead.
 * @template VALUE
 */
goog.iter.consume = function(iterable, count) {
  goog.asserts.assert(goog.math.isInt(count) && count >= 0);

  var iterator = goog.iter.toIterator(iterable);

  while (count-- > 0) {
    goog.iter.nextOrValue(iterator, null);
  }

  return iterator;
};


/**
 * Creates an iterator that returns a range of elements from an iterable.
 * Similar to {@see goog.array#slice} but does not support negative indexes.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to slice.
 * @param {number} start  The index of the first element to return.
 * @param {number=} opt_end  The index after the last element to return. If
 *     defined, must be greater than or equal to {@code start}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator containing a slice of
 *     the original.
 * @template VALUE
 */
goog.iter.slice = function(iterable, start, opt_end) {
  goog.asserts.assert(goog.math.isInt(start) && start >= 0);

  var iterator = goog.iter.consume(iterable, start);

  if (goog.isNumber(opt_end)) {
    goog.asserts.assert(
        goog.math.isInt(/** @type {number} */ (opt_end)) && opt_end >= start);
    iterator = goog.iter.limit(iterator, opt_end - start /* limitSize */);
  }

  return iterator;
};


/**
 * Checks an array for duplicate elements.
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to check for
 *     duplicates.
 * @return {boolean} True, if the array contains duplicates, false otherwise.
 * @private
 * @template VALUE
 */
// TODO(user): Consider moving this into goog.array as a public function.
goog.iter.hasDuplicates_ = function(arr) {
  var deduped = [];
  goog.array.removeDuplicates(arr, deduped);
  return arr.length != deduped.length;
};


/**
 * Creates an iterator that returns permutations of elements in
 * {@code iterable}.
 *
 * Permutations are obtained by taking the Cartesian product of
 * {@code opt_length} iterables and filtering out those with repeated
 * elements. For example, the permutations of {@code [1,2,3]} are
 * {@code [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.permutations
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate permutations.
 * @param {number=} opt_length Length of each permutation. If omitted, defaults
 *     to the length of {@code iterable}.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing the
 *     permutations of {@code iterable}.
 * @template VALUE
 */
goog.iter.permutations = function(iterable, opt_length) {
  var elements = goog.iter.toArray(iterable);
  var length = goog.isNumber(opt_length) ? opt_length : elements.length;

  var sets = goog.array.repeat(elements, length);
  var product = goog.iter.product.apply(undefined, sets);

  return goog.iter.filter(product, function(arr) {
    return !goog.iter.hasDuplicates_(arr);
  });
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}.
 *
 * Combinations are obtained by taking the {@see goog.iter#permutations} of
 * {@code iterable} and filtering those whose elements appear in the order they
 * are encountered in {@code iterable}. For example, the 3-length combinations
 * of {@code [0,1,2,3]} are {@code [[0,1,2], [0,1,3], [0,2,3], [1,2,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate combinations.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing
 *     combinations from the {@code iterable}.
 * @template VALUE
 */
goog.iter.combinations = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.iter.range(elements.length);
  var indexIterator = goog.iter.permutations(indexes, length);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}, with repeated elements possible.
 *
 * Combinations are obtained by taking the Cartesian product of {@code length}
 * iterables and filtering those whose elements appear in the order they are
 * encountered in {@code iterable}. For example, the 2-length combinations of
 * {@code [1,2,3]} are {@code [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations_with_replacement
 * @see http://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to combine.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing
 *     combinations from the {@code iterable}.
 * @template VALUE
 */
goog.iter.combinationsWithReplacement = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.array.range(elements.length);
  var sets = goog.array.repeat(indexes, length);
  var indexIterator = goog.iter.product.apply(undefined, sets);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Hash Map.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author jonp@google.com (Jon Perlow) Optimized for IE6
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes. This
 * is best suited for complex key types. For simple keys such as numbers and
 * strings, and where special names like __proto__ are not a concern, consider
 * using the lighter-weight utilities in goog.object.
 */


goog.provide('goog.structs.Map');

goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.object');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 * @template K, V
 */
goog.structs.Map = function(opt_map, var_args) {

  /**
   * Underlying JS object used to implement the map.
   * @private {!Object}
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @private {!Array.<string>}
   */
  this.keys_ = [];

  /**
   * The number of key value pairs in the map.
   * @private {number}
   */
  this.count_ = 0;

  /**
   * Version used to detect changes while iterating.
   * @private {number}
   */
  this.version_ = 0;

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {Object} */ (opt_map));
  }
};


/**
 * @return {number} The number of key-value pairs in the map.
 */
goog.structs.Map.prototype.getCount = function() {
  return this.count_;
};


/**
 * Returns the values of the map.
 * @return {!Array.<V>} The values in the map.
 */
goog.structs.Map.prototype.getValues = function() {
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array.<string>} Array of string values.
 */
goog.structs.Map.prototype.getKeys = function() {
  this.cleanupKeysArray_();
  return /** @type {!Array.<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {V} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(V, V): boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  if (this === otherMap) {
    return true;
  }

  if (this.count_ != otherMap.getCount()) {
    return false;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return false;
    }
  }

  return true;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 */
goog.structs.Map.prototype.isEmpty = function() {
  return this.count_ == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  this.map_ = {};
  this.keys_.length = 0;
  this.count_ = 0;
  this.version_ = 0;
};


/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.remove = function(key) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.count_--;
    this.version_++;

    // clean up the keys array if the threshhold is hit
    if (this.keys_.length > 2 * this.count_) {
      this.cleanupKeysArray_();
    }

    return true;
  }
  return false;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  if (this.count_ != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.count_ != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return {@code undefined}.
 * @param {*} key The key to get the value for.
 * @param {DEFAULT=} opt_val The value to return if no item is found for the
 *     given key, defaults to undefined.
 * @return {V|DEFAULT} The value for the given key.
 * @template DEFAULT
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {V} value The value to add.
 * @return {*} Some subclasses return a value.
 */
goog.structs.Map.prototype.set = function(key, value) {
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.count_++;
    this.keys_.push(key);
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {Object} map  Object containing the data to add.
 */
goog.structs.Map.prototype.addAll = function(map) {
  var keys, values;
  if (map instanceof goog.structs.Map) {
    keys = map.getKeys();
    values = map.getValues();
  } else {
    keys = goog.object.getKeys(map);
    values = goog.object.getValues(map);
  }
  // we could use goog.array.forEach here but I don't want to introduce that
  // dependency just for this.
  for (var i = 0; i < keys.length; i++) {
    this.set(keys[i], values[i]);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 */
goog.structs.Map.prototype.clone = function() {
  return new goog.structs.Map(this);
};


/**
 * Returns a new map in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * It acts very similarly to {goog.object.transpose(Object)}.
 *
 * @return {!goog.structs.Map} The transposed map.
 */
goog.structs.Map.prototype.transpose = function() {
  var transposed = new goog.structs.Map();
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    var value = this.map_[key];
    transposed.set(value, key);
  }

  return transposed;
};


/**
 * @return {!Object} Object representation of the map.
 */
goog.structs.Map.prototype.toObject = function() {
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the keys in the map.  Removal of keys
 * while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the keys in the map.
 */
goog.structs.Map.prototype.getKeyIterator = function() {
  return this.__iterator__(true);
};


/**
 * Returns an iterator that iterates over the values in the map.  Removal of
 * keys while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the values in the map.
 */
goog.structs.Map.prototype.getValueIterator = function() {
  return this.__iterator__(false);
};


/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var keys = this.keys_;
  var map = this.map_;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      if (version != selfObj.version_) {
        throw Error('The map has changed since the iterator was created');
      }
      if (i >= keys.length) {
        throw goog.iter.StopIteration;
      }
      var key = keys[i++];
      return opt_keys ? key : map[key];
    }
  };
  return newIter;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 */


goog.provide('goog.structs');

goog.require('goog.array');
goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  if (typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  if (typeof col.getValues == 'function') {
    return col.getValues();
  }
  if (goog.isString(col)) {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  if (typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (typeof col.getValues == 'function') {
    return undefined;
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  if (typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.contains(/** @type {Array} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  if (typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmpty because here we treat the string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.isEmpty(/** @type {Array} */ (col));
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 */
goog.structs.clear = function(col) {
  // NOTE(arv): This should not contain strings because strings are immutable
  if (typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear(/** @type {goog.array.ArrayLike} */ (col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):?} f The function to call for every value.
 *     This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @template T,S
 */
goog.structs.forEach = function(col, f, opt_obj) {
  if (typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || goog.isString(col)) {
    goog.array.forEach(/** @type {Array} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(opt_obj, values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is false the value is not included.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 * @template T,S
 */
goog.structs.filter = function(col, f, opt_obj) {
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.filter(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use goog.array.filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], undefined, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):V} f The function to call for every value.
 *     This function takes 3 arguments (the value, the key or undefined if the
 *     collection has no notion of keys, and the collection) and should return
 *     something. The result will be used as the value in the new collection.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object.<V>|!Array.<V>} A new collection with the new values.  If
 *     col is a key-less collection an array is returned.  If col has keys and
 *     values a plain old JS object is returned.
 * @template T,S,V
 */
goog.structs.map = function(col, f, opt_obj) {
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.map(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col);
    }
  } else {
    // We should not use goog.array.map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(opt_obj, values[i], undefined, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns false this returns false.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or undefined
 *     if the collection has no notion of keys, and the collection) and should
 *     return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if any value passes the test.
 * @template T,S
 */
goog.structs.some = function(col, f, opt_obj) {
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.some(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(opt_obj, values[i], keys && keys[i], col)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns false this returns false at this point
 *  and does not continue to check the remaining values.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or
 *     undefined if the collection has no notion of keys, and the collection)
 *     and should return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if all key-value pairs pass the test.
 * @template T,S
 */
goog.structs.every = function(col, f, opt_obj) {
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.every(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(opt_obj, values[i], keys && keys[i], col)) {
      return false;
    }
  }
  return true;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class for parsing and formatting URIs.
 *
 * Use goog.Uri(string) to parse a URI string.  Use goog.Uri.create(...) to
 * create a new instance of the goog.Uri object from Uri parts.
 *
 * e.g: <code>var myUri = new goog.Uri(window.location);</code>
 *
 * Implements RFC 3986 for parsing/formatting URIs.
 * http://www.ietf.org/rfc/rfc3986.txt
 *
 * Some changes have been made to the interface (more like .NETs), though the
 * internal representation is now of un-encoded parts, this will change the
 * behavior slightly.
 *
 */

goog.provide('goog.Uri');
goog.provide('goog.Uri.QueryData');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.uri.utils.ComponentIndex');
goog.require('goog.uri.utils.StandardQueryParam');



/**
 * This class contains setters and getters for the parts of the URI.
 * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part
 * -- so<code>goog.Uri.parse('/foo%20bar').getPath()</code> will return the
 * decoded path, <code>/foo bar</code>.
 *
 * The constructor accepts an optional unparsed, raw URI string.  The parser
 * is relaxed, so special characters that aren't escaped but don't cause
 * ambiguities will not cause parse failures.
 *
 * All setters return <code>this</code> and so may be chained, a la
 * <code>goog.Uri.parse('/foo').setFragment('part').toString()</code>.
 *
 * @param {*=} opt_uri Optional string URI to parse
 *        (use goog.Uri.create() to create a URI from parts), or if
 *        a goog.Uri is passed, a clone is created.
 * @param {boolean=} opt_ignoreCase If true, #getParameterValue will ignore
 * the case of the parameter name.
 *
 * @constructor
 */
goog.Uri = function(opt_uri, opt_ignoreCase) {
  // Parse in the uri string
  var m;
  if (opt_uri instanceof goog.Uri) {
    this.ignoreCase_ = goog.isDef(opt_ignoreCase) ?
        opt_ignoreCase : opt_uri.getIgnoreCase();
    this.setScheme(opt_uri.getScheme());
    this.setUserInfo(opt_uri.getUserInfo());
    this.setDomain(opt_uri.getDomain());
    this.setPort(opt_uri.getPort());
    this.setPath(opt_uri.getPath());
    this.setQueryData(opt_uri.getQueryData().clone());
    this.setFragment(opt_uri.getFragment());
  } else if (opt_uri && (m = goog.uri.utils.split(String(opt_uri)))) {
    this.ignoreCase_ = !!opt_ignoreCase;

    // Set the parts -- decoding as we do so.
    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,
    // whereas in other browsers they will be undefined.
    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);
    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);
    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);
    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);
    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);
    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);
    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);

  } else {
    this.ignoreCase_ = !!opt_ignoreCase;
    this.queryData_ = new goog.Uri.QueryData(null, null, this.ignoreCase_);
  }
};


/**
 * If true, we preserve the type of query parameters set programmatically.
 *
 * This means that if you set a parameter to a boolean, and then call
 * getParameterValue, you will get a boolean back.
 *
 * If false, we will coerce parameters to strings, just as they would
 * appear in real URIs.
 *
 * TODO(nicksantos): Remove this once people have time to fix all tests.
 *
 * @type {boolean}
 */
goog.Uri.preserveParameterTypesCompatibilityFlag = false;


/**
 * Parameter name added to stop caching.
 * @type {string}
 */
goog.Uri.RANDOM_PARAM = goog.uri.utils.StandardQueryParam.RANDOM;


/**
 * Scheme such as "http".
 * @type {string}
 * @private
 */
goog.Uri.prototype.scheme_ = '';


/**
 * User credentials in the form "username:password".
 * @type {string}
 * @private
 */
goog.Uri.prototype.userInfo_ = '';


/**
 * Domain part, e.g. "www.google.com".
 * @type {string}
 * @private
 */
goog.Uri.prototype.domain_ = '';


/**
 * Port, e.g. 8080.
 * @type {?number}
 * @private
 */
goog.Uri.prototype.port_ = null;


/**
 * Path, e.g. "/tests/img.png".
 * @type {string}
 * @private
 */
goog.Uri.prototype.path_ = '';


/**
 * Object representing query data.
 * @type {!goog.Uri.QueryData}
 * @private
 */
goog.Uri.prototype.queryData_;


/**
 * The fragment without the #.
 * @type {string}
 * @private
 */
goog.Uri.prototype.fragment_ = '';


/**
 * Whether or not this Uri should be treated as Read Only.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.isReadOnly_ = false;


/**
 * Whether or not to ignore case when comparing query params.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.ignoreCase_ = false;


/**
 * @return {string} The string form of the url.
 * @override
 */
goog.Uri.prototype.toString = function() {
  var out = [];

  var scheme = this.getScheme();
  if (scheme) {
    out.push(goog.Uri.encodeSpecialChars_(
        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_), ':');
  }

  var domain = this.getDomain();
  if (domain) {
    out.push('//');

    var userInfo = this.getUserInfo();
    if (userInfo) {
      out.push(goog.Uri.encodeSpecialChars_(
          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_), '@');
    }

    out.push(goog.string.urlEncode(domain));

    var port = this.getPort();
    if (port != null) {
      out.push(':', String(port));
    }
  }

  var path = this.getPath();
  if (path) {
    if (this.hasDomain() && path.charAt(0) != '/') {
      out.push('/');
    }
    out.push(goog.Uri.encodeSpecialChars_(
        path,
        path.charAt(0) == '/' ?
            goog.Uri.reDisallowedInAbsolutePath_ :
            goog.Uri.reDisallowedInRelativePath_));
  }

  var query = this.getEncodedQuery();
  if (query) {
    out.push('?', query);
  }

  var fragment = this.getFragment();
  if (fragment) {
    out.push('#', goog.Uri.encodeSpecialChars_(
        fragment, goog.Uri.reDisallowedInFragment_));
  }
  return out.join('');
};


/**
 * Resolves the given relative URI (a goog.Uri object), using the URI
 * represented by this instance as the base URI.
 *
 * There are several kinds of relative URIs:<br>
 * 1. foo - replaces the last part of the path, the whole query and fragment<br>
 * 2. /foo - replaces the the path, the query and fragment<br>
 * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>
 * 4. ?foo - replace the query and fragment<br>
 * 5. #foo - replace the fragment only
 *
 * Additionally, if relative URI has a non-empty path, all ".." and "."
 * segments will be resolved, as described in RFC 3986.
 *
 * @param {goog.Uri} relativeUri The relative URI to resolve.
 * @return {!goog.Uri} The resolved URI.
 */
goog.Uri.prototype.resolve = function(relativeUri) {

  var absoluteUri = this.clone();

  // we satisfy these conditions by looking for the first part of relativeUri
  // that is not blank and applying defaults to the rest

  var overridden = relativeUri.hasScheme();

  if (overridden) {
    absoluteUri.setScheme(relativeUri.getScheme());
  } else {
    overridden = relativeUri.hasUserInfo();
  }

  if (overridden) {
    absoluteUri.setUserInfo(relativeUri.getUserInfo());
  } else {
    overridden = relativeUri.hasDomain();
  }

  if (overridden) {
    absoluteUri.setDomain(relativeUri.getDomain());
  } else {
    overridden = relativeUri.hasPort();
  }

  var path = relativeUri.getPath();
  if (overridden) {
    absoluteUri.setPort(relativeUri.getPort());
  } else {
    overridden = relativeUri.hasPath();
    if (overridden) {
      // resolve path properly
      if (path.charAt(0) != '/') {
        // path is relative
        if (this.hasDomain() && !this.hasPath()) {
          // RFC 3986, section 5.2.3, case 1
          path = '/' + path;
        } else {
          // RFC 3986, section 5.2.3, case 2
          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');
          if (lastSlashIndex != -1) {
            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;
          }
        }
      }
      path = goog.Uri.removeDotSegments(path);
    }
  }

  if (overridden) {
    absoluteUri.setPath(path);
  } else {
    overridden = relativeUri.hasQuery();
  }

  if (overridden) {
    absoluteUri.setQueryData(relativeUri.getDecodedQuery());
  } else {
    overridden = relativeUri.hasFragment();
  }

  if (overridden) {
    absoluteUri.setFragment(relativeUri.getFragment());
  }

  return absoluteUri;
};


/**
 * Clones the URI instance.
 * @return {!goog.Uri} New instance of the URI objcet.
 */
goog.Uri.prototype.clone = function() {
  return new goog.Uri(this);
};


/**
 * @return {string} The encoded scheme/protocol for the URI.
 */
goog.Uri.prototype.getScheme = function() {
  return this.scheme_;
};


/**
 * Sets the scheme/protocol.
 * @param {string} newScheme New scheme value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setScheme = function(newScheme, opt_decode) {
  this.enforceReadOnly();
  this.scheme_ = opt_decode ? goog.Uri.decodeOrEmpty_(newScheme) : newScheme;

  // remove an : at the end of the scheme so somebody can pass in
  // window.location.protocol
  if (this.scheme_) {
    this.scheme_ = this.scheme_.replace(/:$/, '');
  }
  return this;
};


/**
 * @return {boolean} Whether the scheme has been set.
 */
goog.Uri.prototype.hasScheme = function() {
  return !!this.scheme_;
};


/**
 * @return {string} The decoded user info.
 */
goog.Uri.prototype.getUserInfo = function() {
  return this.userInfo_;
};


/**
 * Sets the userInfo.
 * @param {string} newUserInfo New userInfo value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setUserInfo = function(newUserInfo, opt_decode) {
  this.enforceReadOnly();
  this.userInfo_ = opt_decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :
                   newUserInfo;
  return this;
};


/**
 * @return {boolean} Whether the user info has been set.
 */
goog.Uri.prototype.hasUserInfo = function() {
  return !!this.userInfo_;
};


/**
 * @return {string} The decoded domain.
 */
goog.Uri.prototype.getDomain = function() {
  return this.domain_;
};


/**
 * Sets the domain.
 * @param {string} newDomain New domain value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setDomain = function(newDomain, opt_decode) {
  this.enforceReadOnly();
  this.domain_ = opt_decode ? goog.Uri.decodeOrEmpty_(newDomain) : newDomain;
  return this;
};


/**
 * @return {boolean} Whether the domain has been set.
 */
goog.Uri.prototype.hasDomain = function() {
  return !!this.domain_;
};


/**
 * @return {?number} The port number.
 */
goog.Uri.prototype.getPort = function() {
  return this.port_;
};


/**
 * Sets the port number.
 * @param {*} newPort Port number. Will be explicitly casted to a number.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPort = function(newPort) {
  this.enforceReadOnly();

  if (newPort) {
    newPort = Number(newPort);
    if (isNaN(newPort) || newPort < 0) {
      throw Error('Bad port number ' + newPort);
    }
    this.port_ = newPort;
  } else {
    this.port_ = null;
  }

  return this;
};


/**
 * @return {boolean} Whether the port has been set.
 */
goog.Uri.prototype.hasPort = function() {
  return this.port_ != null;
};


/**
  * @return {string} The decoded path.
 */
goog.Uri.prototype.getPath = function() {
  return this.path_;
};


/**
 * Sets the path.
 * @param {string} newPath New path value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPath = function(newPath, opt_decode) {
  this.enforceReadOnly();
  this.path_ = opt_decode ? goog.Uri.decodeOrEmpty_(newPath) : newPath;
  return this;
};


/**
 * @return {boolean} Whether the path has been set.
 */
goog.Uri.prototype.hasPath = function() {
  return !!this.path_;
};


/**
 * @return {boolean} Whether the query string has been set.
 */
goog.Uri.prototype.hasQuery = function() {
  return this.queryData_.toString() !== '';
};


/**
 * Sets the query data.
 * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 *     Applies only if queryData is a string.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQueryData = function(queryData, opt_decode) {
  this.enforceReadOnly();

  if (queryData instanceof goog.Uri.QueryData) {
    this.queryData_ = queryData;
    this.queryData_.setIgnoreCase(this.ignoreCase_);
  } else {
    if (!opt_decode) {
      // QueryData accepts encoded query string, so encode it if
      // opt_decode flag is not true.
      queryData = goog.Uri.encodeSpecialChars_(queryData,
                                               goog.Uri.reDisallowedInQuery_);
    }
    this.queryData_ = new goog.Uri.QueryData(queryData, null, this.ignoreCase_);
  }

  return this;
};


/**
 * Sets the URI query.
 * @param {string} newQuery New query value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQuery = function(newQuery, opt_decode) {
  return this.setQueryData(newQuery, opt_decode);
};


/**
 * @return {string} The encoded URI query, not including the ?.
 */
goog.Uri.prototype.getEncodedQuery = function() {
  return this.queryData_.toString();
};


/**
 * @return {string} The decoded URI query, not including the ?.
 */
goog.Uri.prototype.getDecodedQuery = function() {
  return this.queryData_.toDecodedString();
};


/**
 * Returns the query data.
 * @return {goog.Uri.QueryData} QueryData object.
 */
goog.Uri.prototype.getQueryData = function() {
  return this.queryData_;
};


/**
 * @return {string} The encoded URI query, not including the ?.
 *
 * Warning: This method, unlike other getter methods, returns encoded
 * value, instead of decoded one.
 */
goog.Uri.prototype.getQuery = function() {
  return this.getEncodedQuery();
};


/**
 * Sets the value of the named query parameters, clearing previous values for
 * that key.
 *
 * @param {string} key The parameter to set.
 * @param {*} value The new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValue = function(key, value) {
  this.enforceReadOnly();
  this.queryData_.set(key, value);
  return this;
};


/**
 * Sets the values of the named query parameters, clearing previous values for
 * that key.  Not new values will currently be moved to the end of the query
 * string.
 *
 * So, <code>goog.Uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
 * </code> yields <tt>foo?a=b&e=f&c=new</tt>.</p>
 *
 * @param {string} key The parameter to set.
 * @param {*} values The new values. If values is a single
 *     string then it will be treated as the sole value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValues = function(key, values) {
  this.enforceReadOnly();

  if (!goog.isArray(values)) {
    values = [String(values)];
  }

  // TODO(nicksantos): This cast shouldn't be necessary.
  this.queryData_.setValues(key, /** @type {Array} */ (values));

  return this;
};


/**
 * Returns the value<b>s</b> for a given cgi parameter as a list of decoded
 * query parameter values.
 * @param {string} name The parameter to get values for.
 * @return {Array} The values for a given cgi parameter as a list of
 *     decoded query parameter values.
 */
goog.Uri.prototype.getParameterValues = function(name) {
  return this.queryData_.getValues(name);
};


/**
 * Returns the first value for a given cgi parameter or undefined if the given
 * parameter name does not appear in the query string.
 * @param {string} paramName Unescaped parameter name.
 * @return {string|undefined} The first value for a given cgi parameter or
 *     undefined if the given parameter name does not appear in the query
 *     string.
 */
goog.Uri.prototype.getParameterValue = function(paramName) {
  // NOTE(nicksantos): This type-cast is a lie when
  // preserveParameterTypesCompatibilityFlag is set to true.
  // But this should only be set to true in tests.
  return /** @type {string|undefined} */ (this.queryData_.get(paramName));
};


/**
 * @return {string} The URI fragment, not including the #.
 */
goog.Uri.prototype.getFragment = function() {
  return this.fragment_;
};


/**
 * Sets the URI fragment.
 * @param {string} newFragment New fragment value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setFragment = function(newFragment, opt_decode) {
  this.enforceReadOnly();
  this.fragment_ = opt_decode ? goog.Uri.decodeOrEmpty_(newFragment) :
                   newFragment;
  return this;
};


/**
 * @return {boolean} Whether the URI has a fragment set.
 */
goog.Uri.prototype.hasFragment = function() {
  return !!this.fragment_;
};


/**
 * Returns true if this has the same domain as that of uri2.
 * @param {goog.Uri} uri2 The URI object to compare to.
 * @return {boolean} true if same domain; false otherwise.
 */
goog.Uri.prototype.hasSameDomainAs = function(uri2) {
  return ((!this.hasDomain() && !uri2.hasDomain()) ||
          this.getDomain() == uri2.getDomain()) &&
      ((!this.hasPort() && !uri2.hasPort()) ||
          this.getPort() == uri2.getPort());
};


/**
 * Adds a random parameter to the Uri.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.makeUnique = function() {
  this.enforceReadOnly();
  this.setParameterValue(goog.Uri.RANDOM_PARAM, goog.string.getRandomString());

  return this;
};


/**
 * Removes the named query parameter.
 *
 * @param {string} key The parameter to remove.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.removeParameter = function(key) {
  this.enforceReadOnly();
  this.queryData_.remove(key);
  return this;
};


/**
 * Sets whether Uri is read only. If this goog.Uri is read-only,
 * enforceReadOnly_ will be called at the start of any function that may modify
 * this Uri.
 * @param {boolean} isReadOnly whether this goog.Uri should be read only.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setReadOnly = function(isReadOnly) {
  this.isReadOnly_ = isReadOnly;
  return this;
};


/**
 * @return {boolean} Whether the URI is read only.
 */
goog.Uri.prototype.isReadOnly = function() {
  return this.isReadOnly_;
};


/**
 * Checks if this Uri has been marked as read only, and if so, throws an error.
 * This should be called whenever any modifying function is called.
 */
goog.Uri.prototype.enforceReadOnly = function() {
  if (this.isReadOnly_) {
    throw Error('Tried to modify a read-only Uri');
  }
};


/**
 * Sets whether to ignore case.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setIgnoreCase = function(ignoreCase) {
  this.ignoreCase_ = ignoreCase;
  if (this.queryData_) {
    this.queryData_.setIgnoreCase(ignoreCase);
  }
  return this;
};


/**
 * @return {boolean} Whether to ignore case.
 */
goog.Uri.prototype.getIgnoreCase = function() {
  return this.ignoreCase_;
};


//==============================================================================
// Static members
//==============================================================================


/**
 * Creates a uri from the string form.  Basically an alias of new goog.Uri().
 * If a Uri object is passed to parse then it will return a clone of the object.
 *
 * @param {*} uri Raw URI string or instance of Uri
 *     object.
 * @param {boolean=} opt_ignoreCase Whether to ignore the case of parameter
 * names in #getParameterValue.
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.parse = function(uri, opt_ignoreCase) {
  return uri instanceof goog.Uri ?
         uri.clone() : new goog.Uri(uri, opt_ignoreCase);
};


/**
 * Creates a new goog.Uri object from unencoded parts.
 *
 * @param {?string=} opt_scheme Scheme/protocol or full URI to parse.
 * @param {?string=} opt_userInfo username:password.
 * @param {?string=} opt_domain www.google.com.
 * @param {?number=} opt_port 9830.
 * @param {?string=} opt_path /some/path/to/a/file.html.
 * @param {string|goog.Uri.QueryData=} opt_query a=1&b=2.
 * @param {?string=} opt_fragment The fragment without the #.
 * @param {boolean=} opt_ignoreCase Whether to ignore parameter name case in
 *     #getParameterValue.
 *
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.create = function(opt_scheme, opt_userInfo, opt_domain, opt_port,
                           opt_path, opt_query, opt_fragment, opt_ignoreCase) {

  var uri = new goog.Uri(null, opt_ignoreCase);

  // Only set the parts if they are defined and not empty strings.
  opt_scheme && uri.setScheme(opt_scheme);
  opt_userInfo && uri.setUserInfo(opt_userInfo);
  opt_domain && uri.setDomain(opt_domain);
  opt_port && uri.setPort(opt_port);
  opt_path && uri.setPath(opt_path);
  opt_query && uri.setQueryData(opt_query);
  opt_fragment && uri.setFragment(opt_fragment);

  return uri;
};


/**
 * Resolves a relative Uri against a base Uri, accepting both strings and
 * Uri objects.
 *
 * @param {*} base Base Uri.
 * @param {*} rel Relative Uri.
 * @return {!goog.Uri} Resolved uri.
 */
goog.Uri.resolve = function(base, rel) {
  if (!(base instanceof goog.Uri)) {
    base = goog.Uri.parse(base);
  }

  if (!(rel instanceof goog.Uri)) {
    rel = goog.Uri.parse(rel);
  }

  return base.resolve(rel);
};


/**
 * Removes dot segments in given path component, as described in
 * RFC 3986, section 5.2.4.
 *
 * @param {string} path A non-empty path component.
 * @return {string} Path component with removed dot segments.
 */
goog.Uri.removeDotSegments = function(path) {
  if (path == '..' || path == '.') {
    return '';

  } else if (!goog.string.contains(path, './') &&
             !goog.string.contains(path, '/.')) {
    // This optimization detects uris which do not contain dot-segments,
    // and as a consequence do not require any processing.
    return path;

  } else {
    var leadingSlash = goog.string.startsWith(path, '/');
    var segments = path.split('/');
    var out = [];

    for (var pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else if (segment == '..') {
        if (out.length > 1 || out.length == 1 && out[0] != '') {
          out.pop();
        }
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else {
        out.push(segment);
        leadingSlash = true;
      }
    }

    return out.join('/');
  }
};


/**
 * Decodes a value or returns the empty string if it isn't defined or empty.
 * @param {string|undefined} val Value to decode.
 * @return {string} Decoded value.
 * @private
 */
goog.Uri.decodeOrEmpty_ = function(val) {
  // Don't use UrlDecode() here because val is not a query parameter.
  return val ? decodeURIComponent(val) : '';
};


/**
 * If unescapedPart is non null, then escapes any characters in it that aren't
 * valid characters in a url and also escapes any special characters that
 * appear in extra.
 *
 * @param {*} unescapedPart The string to encode.
 * @param {RegExp} extra A character set of characters in [\01-\177].
 * @return {?string} null iff unescapedPart == null.
 * @private
 */
goog.Uri.encodeSpecialChars_ = function(unescapedPart, extra) {
  if (goog.isString(unescapedPart)) {
    return encodeURI(unescapedPart).replace(extra, goog.Uri.encodeChar_);
  }
  return null;
};


/**
 * Converts a character in [\01-\177] to its unicode character equivalent.
 * @param {string} ch One character string.
 * @return {string} Encoded string.
 * @private
 */
goog.Uri.encodeChar_ = function(ch) {
  var n = ch.charCodeAt(0);
  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);
};


/**
 * Regular expression for characters that are disallowed in the scheme or
 * userInfo part of the URI.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\/\?@]/g;


/**
 * Regular expression for characters that are disallowed in a relative path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInRelativePath_ = /[\#\?:]/g;


/**
 * Regular expression for characters that are disallowed in an absolute path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInAbsolutePath_ = /[\#\?]/g;


/**
 * Regular expression for characters that are disallowed in the query.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInQuery_ = /[\#\?@]/g;


/**
 * Regular expression for characters that are disallowed in the fragment.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInFragment_ = /#/g;


/**
 * Checks whether two URIs have the same domain.
 * @param {string} uri1String First URI string.
 * @param {string} uri2String Second URI string.
 * @return {boolean} true if the two URIs have the same domain; false otherwise.
 */
goog.Uri.haveSameDomain = function(uri1String, uri2String) {
  // Differs from goog.uri.utils.haveSameDomain, since this ignores scheme.
  // TODO(gboyer): Have this just call goog.uri.util.haveSameDomain.
  var pieces1 = goog.uri.utils.split(uri1String);
  var pieces2 = goog.uri.utils.split(uri2String);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};



/**
 * Class used to represent URI query parameters.  It is essentially a hash of
 * name-value pairs, though a name can be present more than once.
 *
 * Has the same interface as the collections in goog.structs.
 *
 * @param {?string=} opt_query Optional encoded query string to parse into
 *     the object.
 * @param {goog.Uri=} opt_uri Optional uri object that should have its
 *     cache invalidated when this object updates. Deprecated -- this
 *     is no longer required.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @constructor
 * @final
 */
goog.Uri.QueryData = function(opt_query, opt_uri, opt_ignoreCase) {
  /**
   * Encoded query string, or null if it requires computing from the key map.
   * @type {?string}
   * @private
   */
  this.encodedQuery_ = opt_query || null;

  /**
   * If true, ignore the case of the parameter name in #get.
   * @type {boolean}
   * @private
   */
  this.ignoreCase_ = !!opt_ignoreCase;
};


/**
 * If the underlying key map is not yet initialized, it parses the
 * query string and fills the map with parsed data.
 * @private
 */
goog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {
  if (!this.keyMap_) {
    this.keyMap_ = new goog.structs.Map();
    this.count_ = 0;

    if (this.encodedQuery_) {
      var pairs = this.encodedQuery_.split('&');
      for (var i = 0; i < pairs.length; i++) {
        var indexOfEquals = pairs[i].indexOf('=');
        var name = null;
        var value = null;
        if (indexOfEquals >= 0) {
          name = pairs[i].substring(0, indexOfEquals);
          value = pairs[i].substring(indexOfEquals + 1);
        } else {
          name = pairs[i];
        }
        name = goog.string.urlDecode(name);
        name = this.getKeyName_(name);
        this.add(name, value ? goog.string.urlDecode(value) : '');
      }
    }
  }
};


/**
 * Creates a new query data instance from a map of names and values.
 *
 * @param {!goog.structs.Map|!Object} map Map of string parameter
 *     names to parameter value. If parameter value is an array, it is
 *     treated as if the key maps to each individual value in the
 *     array.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromMap = function(map, opt_uri, opt_ignoreCase) {
  var keys = goog.structs.getKeys(map);
  if (typeof keys == 'undefined') {
    throw Error('Keys are undefined');
  }

  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  var values = goog.structs.getValues(map);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = values[i];
    if (!goog.isArray(value)) {
      queryData.add(key, value);
    } else {
      queryData.setValues(key, value);
    }
  }
  return queryData;
};


/**
 * Creates a new query data instance from parallel arrays of parameter names
 * and values. Allows for duplicate parameter names. Throws an error if the
 * lengths of the arrays differ.
 *
 * @param {Array.<string>} keys Parameter names.
 * @param {Array} values Parameter values.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromKeysValues = function(
    keys, values, opt_uri, opt_ignoreCase) {
  if (keys.length != values.length) {
    throw Error('Mismatched lengths for keys/values');
  }
  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  for (var i = 0; i < keys.length; i++) {
    queryData.add(keys[i], values[i]);
  }
  return queryData;
};


/**
 * The map containing name/value or name/array-of-values pairs.
 * May be null if it requires parsing from the query string.
 *
 * We need to use a Map because we cannot guarantee that the key names will
 * not be problematic for IE.
 *
 * @type {goog.structs.Map}
 * @private
 */
goog.Uri.QueryData.prototype.keyMap_ = null;


/**
 * The number of params, or null if it requires computing.
 * @type {?number}
 * @private
 */
goog.Uri.QueryData.prototype.count_ = null;


/**
 * @return {?number} The number of parameters.
 */
goog.Uri.QueryData.prototype.getCount = function() {
  this.ensureKeyMapInitialized_();
  return this.count_;
};


/**
 * Adds a key value pair.
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.add = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  key = this.getKeyName_(key);
  var values = this.keyMap_.get(key);
  if (!values) {
    this.keyMap_.set(key, (values = []));
  }
  values.push(value);
  this.count_++;
  return this;
};


/**
 * Removes all the params with the given key.
 * @param {string} key Name.
 * @return {boolean} Whether any parameter was removed.
 */
goog.Uri.QueryData.prototype.remove = function(key) {
  this.ensureKeyMapInitialized_();

  key = this.getKeyName_(key);
  if (this.keyMap_.containsKey(key)) {
    this.invalidateCache_();

    // Decrement parameter count.
    this.count_ -= this.keyMap_.get(key).length;
    return this.keyMap_.remove(key);
  }
  return false;
};


/**
 * Clears the parameters.
 */
goog.Uri.QueryData.prototype.clear = function() {
  this.invalidateCache_();
  this.keyMap_ = null;
  this.count_ = 0;
};


/**
 * @return {boolean} Whether we have any parameters.
 */
goog.Uri.QueryData.prototype.isEmpty = function() {
  this.ensureKeyMapInitialized_();
  return this.count_ == 0;
};


/**
 * Whether there is a parameter with the given name
 * @param {string} key The parameter name to check for.
 * @return {boolean} Whether there is a parameter with the given name.
 */
goog.Uri.QueryData.prototype.containsKey = function(key) {
  this.ensureKeyMapInitialized_();
  key = this.getKeyName_(key);
  return this.keyMap_.containsKey(key);
};


/**
 * Whether there is a parameter with the given value.
 * @param {*} value The value to check for.
 * @return {boolean} Whether there is a parameter with the given value.
 */
goog.Uri.QueryData.prototype.containsValue = function(value) {
  // NOTE(arv): This solution goes through all the params even if it was the
  // first param. We can get around this by not reusing code or by switching to
  // iterators.
  var vals = this.getValues();
  return goog.array.contains(vals, value);
};


/**
 * Returns all the keys of the parameters. If a key is used multiple times
 * it will be included multiple times in the returned array
 * @return {!Array.<string>} All the keys of the parameters.
 */
goog.Uri.QueryData.prototype.getKeys = function() {
  this.ensureKeyMapInitialized_();
  // We need to get the values to know how many keys to add.
  var vals = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
  var keys = this.keyMap_.getKeys();
  var rv = [];
  for (var i = 0; i < keys.length; i++) {
    var val = vals[i];
    for (var j = 0; j < val.length; j++) {
      rv.push(keys[i]);
    }
  }
  return rv;
};


/**
 * Returns all the values of the parameters with the given name. If the query
 * data has no such key this will return an empty array. If no key is given
 * all values wil be returned.
 * @param {string=} opt_key The name of the parameter to get the values for.
 * @return {!Array} All the values of the parameters with the given name.
 */
goog.Uri.QueryData.prototype.getValues = function(opt_key) {
  this.ensureKeyMapInitialized_();
  var rv = [];
  if (goog.isString(opt_key)) {
    if (this.containsKey(opt_key)) {
      rv = goog.array.concat(rv, this.keyMap_.get(this.getKeyName_(opt_key)));
    }
  } else {
    // Return all values.
    var values = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
    for (var i = 0; i < values.length; i++) {
      rv = goog.array.concat(rv, values[i]);
    }
  }
  return rv;
};


/**
 * Sets a key value pair and removes all other keys with the same value.
 *
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.set = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  // TODO(user): This could be better written as
  // this.remove(key), this.add(key, value), but that would reorder
  // the key (since the key is first removed and then added at the
  // end) and we would have to fix unit tests that depend on key
  // ordering.
  key = this.getKeyName_(key);
  if (this.containsKey(key)) {
    this.count_ -= this.keyMap_.get(key).length;
  }
  this.keyMap_.set(key, [value]);
  this.count_++;
  return this;
};


/**
 * Returns the first value associated with the key. If the query data has no
 * such key this will return undefined or the optional default.
 * @param {string} key The name of the parameter to get the value for.
 * @param {*=} opt_default The default value to return if the query data
 *     has no such key.
 * @return {*} The first string value associated with the key, or opt_default
 *     if there's no value.
 */
goog.Uri.QueryData.prototype.get = function(key, opt_default) {
  var values = key ? this.getValues(key) : [];
  if (goog.Uri.preserveParameterTypesCompatibilityFlag) {
    return values.length > 0 ? values[0] : opt_default;
  } else {
    return values.length > 0 ? String(values[0]) : opt_default;
  }
};


/**
 * Sets the values for a key. If the key already exists, this will
 * override all of the existing values that correspond to the key.
 * @param {string} key The key to set values for.
 * @param {Array} values The values to set.
 */
goog.Uri.QueryData.prototype.setValues = function(key, values) {
  this.remove(key);

  if (values.length > 0) {
    this.invalidateCache_();
    this.keyMap_.set(this.getKeyName_(key), goog.array.clone(values));
    this.count_ += values.length;
  }
};


/**
 * @return {string} Encoded query string.
 * @override
 */
goog.Uri.QueryData.prototype.toString = function() {
  if (this.encodedQuery_) {
    return this.encodedQuery_;
  }

  if (!this.keyMap_) {
    return '';
  }

  var sb = [];

  // In the past, we use this.getKeys() and this.getVals(), but that
  // generates a lot of allocations as compared to simply iterating
  // over the keys.
  var keys = this.keyMap_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var encodedKey = goog.string.urlEncode(key);
    var val = this.getValues(key);
    for (var j = 0; j < val.length; j++) {
      var param = encodedKey;
      // Ensure that null and undefined are encoded into the url as
      // literal strings.
      if (val[j] !== '') {
        param += '=' + goog.string.urlEncode(val[j]);
      }
      sb.push(param);
    }
  }

  return this.encodedQuery_ = sb.join('&');
};


/**
 * @return {string} Decoded query string.
 */
goog.Uri.QueryData.prototype.toDecodedString = function() {
  return goog.Uri.decodeOrEmpty_(this.toString());
};


/**
 * Invalidate the cache.
 * @private
 */
goog.Uri.QueryData.prototype.invalidateCache_ = function() {
  this.encodedQuery_ = null;
};


/**
 * Removes all keys that are not in the provided list. (Modifies this object.)
 * @param {Array.<string>} keys The desired keys.
 * @return {!goog.Uri.QueryData} a reference to this object.
 */
goog.Uri.QueryData.prototype.filterKeys = function(keys) {
  this.ensureKeyMapInitialized_();
  goog.structs.forEach(this.keyMap_,
      /** @this {goog.Uri.QueryData} */
      function(value, key, map) {
        if (!goog.array.contains(keys, key)) {
          this.remove(key);
        }
      }, this);
  return this;
};


/**
 * Clone the query data instance.
 * @return {!goog.Uri.QueryData} New instance of the QueryData object.
 */
goog.Uri.QueryData.prototype.clone = function() {
  var rv = new goog.Uri.QueryData();
  rv.encodedQuery_ = this.encodedQuery_;
  if (this.keyMap_) {
    rv.keyMap_ = this.keyMap_.clone();
    rv.count_ = this.count_;
  }
  return rv;
};


/**
 * Helper function to get the key name from a JavaScript object. Converts
 * the object to a string, and to lower case if necessary.
 * @private
 * @param {*} arg The object to get a key name from.
 * @return {string} valid key name which can be looked up in #keyMap_.
 */
goog.Uri.QueryData.prototype.getKeyName_ = function(arg) {
  var keyName = String(arg);
  if (this.ignoreCase_) {
    keyName = keyName.toLowerCase();
  }
  return keyName;
};


/**
 * Ignore case in parameter names.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 */
goog.Uri.QueryData.prototype.setIgnoreCase = function(ignoreCase) {
  var resetKeys = ignoreCase && !this.ignoreCase_;
  if (resetKeys) {
    this.ensureKeyMapInitialized_();
    this.invalidateCache_();
    goog.structs.forEach(this.keyMap_,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          var lowerCase = key.toLowerCase();
          if (key != lowerCase) {
            this.remove(key);
            this.setValues(lowerCase, value);
          }
        }, this);
  }
  this.ignoreCase_ = ignoreCase;
};


/**
 * Extends a query data object with another query data or map like object. This
 * operates 'in-place', it does not create a new QueryData object.
 *
 * @param {...(goog.Uri.QueryData|goog.structs.Map|Object)} var_args The object
 *     from which key value pairs will be copied.
 */
goog.Uri.QueryData.prototype.extend = function(var_args) {
  for (var i = 0; i < arguments.length; i++) {
    var data = arguments[i];
    goog.structs.forEach(data,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          this.add(key, value);
        }, this);
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility for fast string concatenation.
 */

goog.provide('goog.string.StringBuffer');



/**
 * Utility class to facilitate string concatenation.
 *
 * @param {*=} opt_a1 Optional first initial item to append.
 * @param {...*} var_args Other initial items to
 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
 * @constructor
 */
goog.string.StringBuffer = function(opt_a1, var_args) {
  if (opt_a1 != null) {
    this.append.apply(this, arguments);
  }
};


/**
 * Internal buffer for the string to be concatenated.
 * @type {string}
 * @private
 */
goog.string.StringBuffer.prototype.buffer_ = '';


/**
 * Sets the contents of the string buffer object, replacing what's currently
 * there.
 *
 * @param {*} s String to set.
 */
goog.string.StringBuffer.prototype.set = function(s) {
  this.buffer_ = '' + s;
};


/**
 * Appends one or more items to the buffer.
 *
 * Calling this with null, undefined, or empty arguments is an error.
 *
 * @param {*} a1 Required first string.
 * @param {*=} opt_a2 Optional second string.
 * @param {...*} var_args Other items to append,
 *     e.g., sb.append('foo', 'bar', 'baz').
 * @return {goog.string.StringBuffer} This same StringBuffer object.
 * @suppress {duplicate}
 */
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
  // Use a1 directly to avoid arguments instantiation for single-arg case.
  this.buffer_ += a1;
  if (opt_a2 != null) { // second argument is undefined (null == undefined)
    for (var i = 1; i < arguments.length; i++) {
      this.buffer_ += arguments[i];
    }
  }
  return this;
};


/**
 * Clears the internal buffer.
 */
goog.string.StringBuffer.prototype.clear = function() {
  this.buffer_ = '';
};


/**
 * @return {number} the length of the current contents of the buffer.
 */
goog.string.StringBuffer.prototype.getLength = function() {
  return this.buffer_.length;
};


/**
 * @return {string} The concatenated string.
 * @override
 */
goog.string.StringBuffer.prototype.toString = function() {
  return this.buffer_;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility functions for supporting Bidi issues.
 */


/**
 * Namespace for bidi supporting functions.
 */
goog.provide('goog.i18n.bidi');
goog.provide('goog.i18n.bidi.Dir');
goog.provide('goog.i18n.bidi.DirectionalString');
goog.provide('goog.i18n.bidi.Format');


/**
 * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
 * to say that the current locale is a RTL locale.  This should only be used
 * if you want to override the default behavior for deciding whether the
 * current locale is RTL or not.
 *
 * {@see goog.i18n.bidi.IS_RTL}
 */
goog.define('goog.i18n.bidi.FORCE_RTL', false);


/**
 * Constant that defines whether or not the current locale is a RTL locale.
 * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
 * to check that {@link goog.LOCALE} is one of a few major RTL locales.
 *
 * <p>This is designed to be a maximally efficient compile-time constant. For
 * example, for the default goog.LOCALE, compiling
 * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
 * is this design consideration that limits the implementation to only
 * supporting a few major RTL locales, as opposed to the broader repertoire of
 * something like goog.i18n.bidi.isRtlLanguage.
 *
 * <p>Since this constant refers to the directionality of the locale, it is up
 * to the caller to determine if this constant should also be used for the
 * direction of the UI.
 *
 * {@see goog.LOCALE}
 *
 * @type {boolean}
 *
 * TODO(user): write a test that checks that this is a compile-time constant.
 */
goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL ||
    (goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||
     goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||
     goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||
     goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||
     goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||
     goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&
    (goog.LOCALE.length == 2 ||
     goog.LOCALE.substring(2, 3) == '-' ||
     goog.LOCALE.substring(2, 3) == '_');


/**
 * Unicode formatting characters and directionality string constants.
 * @enum {string}
 */
goog.i18n.bidi.Format = {
  /** Unicode "Left-To-Right Embedding" (LRE) character. */
  LRE: '\u202A',
  /** Unicode "Right-To-Left Embedding" (RLE) character. */
  RLE: '\u202B',
  /** Unicode "Pop Directional Formatting" (PDF) character. */
  PDF: '\u202C',
  /** Unicode "Left-To-Right Mark" (LRM) character. */
  LRM: '\u200E',
  /** Unicode "Right-To-Left Mark" (RLM) character. */
  RLM: '\u200F'
};


/**
 * Directionality enum.
 * @enum {number}
 */
goog.i18n.bidi.Dir = {
  /**
   * Left-to-right.
   */
  LTR: 1,

  /**
   * Right-to-left.
   */
  RTL: -1,

  /**
   * Neither left-to-right nor right-to-left.
   */
  NEUTRAL: 0,

  /**
   * A historical misnomer for NEUTRAL.
   * @deprecated For "neutral", use NEUTRAL; for "unknown", use null.
   */
  UNKNOWN: 0
};


/**
 * 'right' string constant.
 * @type {string}
 */
goog.i18n.bidi.RIGHT = 'right';


/**
 * 'left' string constant.
 * @type {string}
 */
goog.i18n.bidi.LEFT = 'left';


/**
 * 'left' if locale is RTL, 'right' if not.
 * @type {string}
 */
goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT :
    goog.i18n.bidi.RIGHT;


/**
 * 'right' if locale is RTL, 'left' if not.
 * @type {string}
 */
goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT :
    goog.i18n.bidi.LEFT;


/**
 * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
 * constant. Useful for interaction with different standards of directionality
 * representation.
 *
 * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
 *     in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
 *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
 *     order to preserve legacy behavior.
 * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
 *     given directionality. If given null, returns null (i.e. unknown).
 */
goog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {
  if (typeof givenDir == 'number') {
    // This includes the non-null goog.i18n.bidi.Dir case.
    return givenDir > 0 ? goog.i18n.bidi.Dir.LTR :
        givenDir < 0 ? goog.i18n.bidi.Dir.RTL :
        opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
  } else if (givenDir == null) {
    return null;
  } else {
    // Must be typeof givenDir == 'boolean'.
    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }
};


/**
 * A practical pattern to identify strong LTR characters. This pattern is not
 * theoretically correct according to the Unicode standard. It is simplified for
 * performance and small code size.
 * @type {string}
 * @private
 */
goog.i18n.bidi.ltrChars_ =
    'A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF' +
    '\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';


/**
 * A practical pattern to identify strong RTL character. This pattern is not
 * theoretically correct according to the Unicode standard. It is simplified
 * for performance and small code size.
 * @type {string}
 * @private
 */
goog.i18n.bidi.rtlChars_ = '\u0591-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC';


/**
 * Simplified regular expression for an HTML tag (opening or closing) or an HTML
 * escape. We might want to skip over such expressions when estimating the text
 * directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;


/**
 * Returns the input text with spaces instead of HTML tags or HTML escapes, if
 * opt_isStripNeeded is true. Else returns the input as is.
 * Useful for text directionality estimation.
 * Note: the function should not be used in other contexts; it is not 100%
 * correct, but rather a good-enough implementation for directionality
 * estimation purposes.
 * @param {string} str The given string.
 * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
 *     Default: false (to retain consistency with calling functions).
 * @return {string} The given string cleaned of HTML tags / escapes.
 * @private
 */
goog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {
  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') :
      str;
};


/**
 * Regular expression to check for RTL characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Regular expression to check for LTR characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains RTL characters.
 */
goog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(
      str, opt_isHtml));
};


/**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the string contains RTL characters.
 * @deprecated Use hasAnyRtl.
 */
goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;


/**
 * Test whether the given string has any LTR characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains LTR characters.
 */
goog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(
      str, opt_isHtml));
};


/**
 * Regular expression pattern to check if the first character in the string
 * is LTR.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Regular expression pattern to check if the first character in the string
 * is RTL.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Check if the first character in the string is RTL or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an RTL char.
 */
goog.i18n.bidi.isRtlChar = function(str) {
  return goog.i18n.bidi.rtlRe_.test(str);
};


/**
 * Check if the first character in the string is LTR or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an LTR char.
 */
goog.i18n.bidi.isLtrChar = function(str) {
  return goog.i18n.bidi.ltrRe_.test(str);
};


/**
 * Check if the first character in the string is neutral or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is a neutral char.
 */
goog.i18n.bidi.isNeutralChar = function(str) {
  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
};


/**
 * Regular expressions to check if a piece of text is of LTR directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrDirCheckRe_ = new RegExp(
    '^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Regular expressions to check if a piece of text is of RTL directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlDirCheckRe_ = new RegExp(
    '^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 */
goog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(
      str, opt_isHtml));
};


/**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithRtl.
 */
goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;


/**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 */
goog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(
      str, opt_isHtml));
};


/**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithLtr.
 */
goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;


/**
 * Regular expression to check if a string looks like something that must
 * always be LTR even in RTL text, e.g. a URL. When estimating the
 * directionality of text containing these, we treat these as weakly LTR,
 * like numbers.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;


/**
 * Check whether the input string either contains no strongly directional
 * characters or looks like a url.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether neutral directionality is detected.
 */
goog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {
  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
  return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||
      !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
};


/**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is LTR.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(
    '[' + goog.i18n.bidi.ltrChars_ + '][^' + goog.i18n.bidi.rtlChars_ + ']*$');


/**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is RTL.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(
    '[' + goog.i18n.bidi.rtlChars_ + '][^' + goog.i18n.bidi.ltrChars_ + ']*$');


/**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 */
goog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrExitDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 * @deprecated Use endsWithLtr.
 */
goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;


/**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 */
goog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlExitDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 * @deprecated Use endsWithRtl.
 */
goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;


/**
 * A regular expression for matching right-to-left language codes.
 * See {@link #isRtlLanguage} for the design.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlLocalesRe_ = new RegExp(
    '^(ar|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))' +
    '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)',
    'i');


/**
 * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
 * - a language code explicitly specifying one of the right-to-left scripts,
 *   e.g. "az-Arab", or<p>
 * - a language code specifying one of the languages normally written in a
 *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
 *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
 * The list of right-to-left scripts appears in the 100-199 range in
 * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
 * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
 * Tifinagh, which also have significant modern usage. The rest (Syriac,
 * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
 * and are not recognized to save on code size.
 * The languages usually written in a right-to-left script are taken as those
 * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
 * http://www.iana.org/assignments/language-subtag-registry,
 * as well as Sindhi (sd) and Uyghur (ug).
 * Other subtags of the language code, e.g. regions like EG (Egypt), are
 * ignored.
 * @param {string} lang BCP 47 (a.k.a III) language code.
 * @return {boolean} Whether the language code is an RTL language.
 */
goog.i18n.bidi.isRtlLanguage = function(lang) {
  return goog.i18n.bidi.rtlLocalesRe_.test(lang);
};


/**
 * Regular expression for bracket guard replacement in html.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.bracketGuardHtmlRe_ =
    /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&lt;.*?(&gt;)+)/g;


/**
 * Regular expression for bracket guard replacement in text.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.bracketGuardTextRe_ =
    /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;


/**
 * Apply bracket guard using html span tag. This is to address the problem of
 * messy bracket display frequently happens in RTL layout.
 * @param {string} s The string that need to be processed.
 * @param {boolean=} opt_isRtlContext specifies default direction (usually
 *     direction of the UI).
 * @return {string} The processed string, with all bracket guarded.
 */
goog.i18n.bidi.guardBracketInHtml = function(s, opt_isRtlContext) {
  var useRtl = opt_isRtlContext === undefined ?
      goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
  if (useRtl) {
    return s.replace(goog.i18n.bidi.bracketGuardHtmlRe_,
        '<span dir=rtl>$&</span>');
  }
  return s.replace(goog.i18n.bidi.bracketGuardHtmlRe_,
      '<span dir=ltr>$&</span>');
};


/**
 * Apply bracket guard using LRM and RLM. This is to address the problem of
 * messy bracket display frequently happens in RTL layout.
 * This version works for both plain text and html. But it does not work as
 * good as guardBracketInHtml in some cases.
 * @param {string} s The string that need to be processed.
 * @param {boolean=} opt_isRtlContext specifies default direction (usually
 *     direction of the UI).
 * @return {string} The processed string, with all bracket guarded.
 */
goog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {
  var useRtl = opt_isRtlContext === undefined ?
      goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
  var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
};


/**
 * Enforce the html snippet in RTL directionality regardless overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet start with with tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */
goog.i18n.bidi.enforceRtlInHtml = function(html) {
  if (html.charAt(0) == '<') {
    return html.replace(/<\w+/, '$& dir=rtl');
  }
  // '\n' is important for FF so that it won't incorrectly merge span groups
  return '\n<span dir=rtl>' + html + '</span>';
};


/**
 * Enforce RTL on both end of the given text piece using unicode BiDi formatting
 * characters RLE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */
goog.i18n.bidi.enforceRtlInText = function(text) {
  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
};


/**
 * Enforce the html snippet in RTL directionality regardless overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet start with with tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */
goog.i18n.bidi.enforceLtrInHtml = function(html) {
  if (html.charAt(0) == '<') {
    return html.replace(/<\w+/, '$& dir=ltr');
  }
  // '\n' is important for FF so that it won't incorrectly merge span groups
  return '\n<span dir=ltr>' + html + '</span>';
};


/**
 * Enforce LTR on both end of the given text piece using unicode BiDi formatting
 * characters LRE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */
goog.i18n.bidi.enforceLtrInText = function(text) {
  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
};


/**
 * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.dimensionsRe_ =
    /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;


/**
 * Regular expression for left.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.leftRe_ = /left/gi;


/**
 * Regular expression for right.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rightRe_ = /right/gi;


/**
 * Placeholder regular expression for swapping.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.tempRe_ = /%%%%/g;


/**
 * Swap location parameters and 'left'/'right' in CSS specification. The
 * processed string will be suited for RTL layout. Though this function can
 * cover most cases, there are always exceptions. It is suggested to put
 * those exceptions in separate group of CSS string.
 * @param {string} cssStr CSS spefication string.
 * @return {string} Processed CSS specification string.
 */
goog.i18n.bidi.mirrorCSS = function(cssStr) {
  return cssStr.
      // reverse dimensions
      replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2').
      replace(goog.i18n.bidi.leftRe_, '%%%%').          // swap left and right
      replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).
      replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
};


/**
 * Regular expression for hebrew double quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;


/**
 * Regular expression for hebrew single quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;


/**
 * Replace the double and single quote directly after a Hebrew character with
 * GERESH and GERSHAYIM. In such case, most likely that's user intention.
 * @param {string} str String that need to be processed.
 * @return {string} Processed string with double/single quote replaced.
 */
goog.i18n.bidi.normalizeHebrewQuote = function(str) {
  return str.
      replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05f4').
      replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05f3');
};


/**
 * Regular expression to split a string into "words" for directionality
 * estimation based on relative word counts.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.wordSeparatorRe_ = /\s+/;


/**
 * Regular expression to check if a string contains any numerals. Used to
 * differentiate between completely neutral strings and those containing
 * numbers, which are weakly LTR.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.hasNumeralsRe_ = /\d/;


/**
 * This constant controls threshold of RTL directionality.
 * @type {number}
 * @private
 */
goog.i18n.bidi.rtlDetectionThreshold_ = 0.40;


/**
 * Estimates the directionality of a string based on relative word counts.
 * If the number of RTL words is above a certain percentage of the total number
 * of strongly directional words, returns RTL.
 * Otherwise, if any words are strongly or weakly LTR, returns LTR.
 * Otherwise, returns UNKNOWN, which is used to mean "neutral".
 * Numbers are counted as weakly LTR.
 * @param {string} str The string to be checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
 */
goog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {
  var rtlCount = 0;
  var totalCount = 0;
  var hasWeaklyLtr = false;
  var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).
      split(goog.i18n.bidi.wordSeparatorRe_);
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (goog.i18n.bidi.startsWithRtl(token)) {
      rtlCount++;
      totalCount++;
    } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
      hasWeaklyLtr = true;
    } else if (goog.i18n.bidi.hasAnyLtr(token)) {
      totalCount++;
    } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
      hasWeaklyLtr = true;
    }
  }

  return totalCount == 0 ?
      (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :
      (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?
          goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR);
};


/**
 * Check the directionality of a piece of text, return true if the piece of
 * text should be laid out in RTL direction.
 * @param {string} str The piece of text that need to be detected.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether this piece of text should be laid out in RTL.
 */
goog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {
  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==
      goog.i18n.bidi.Dir.RTL;
};


/**
 * Sets text input element's directionality and text alignment based on a
 * given directionality. Does nothing if the given directionality is unknown or
 * neutral.
 * @param {Element} element Input field element to set directionality to.
 * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
 *     given in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 */
goog.i18n.bidi.setElementDirAndAlign = function(element, dir) {
  if (element) {
    dir = goog.i18n.bidi.toDir(dir);
    if (dir) {
      element.style.textAlign =
          dir == goog.i18n.bidi.Dir.RTL ? 'right' : 'left';
      element.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
    }
  }
};



/**
 * Strings that have an (optional) known direction.
 *
 * Implementations of this interface are string-like objects that carry an
 * attached direction, if known.
 * @interface
 */
goog.i18n.bidi.DirectionalString = function() {};


/**
 * Interface marker of the DirectionalString interface.
 *
 * This property can be used to determine at runtime whether or not an object
 * implements this interface.  All implementations of this interface set this
 * property to {@code true}.
 * @type {boolean}
 */
goog.i18n.bidi.DirectionalString.prototype.
    implementsGoogI18nBidiDirectionalString;


/**
 * Retrieves this object's known direction (if any).
 * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
 */
goog.i18n.bidi.DirectionalString.prototype.getDirection;
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Soy data primitives.
 *
 * The goal is to encompass data types used by Soy, especially to mark content
 * as known to be "safe".
 *
 * @author gboyer@google.com (Garrett Boyer)
 */

goog.provide('goog.soy.data');
goog.provide('goog.soy.data.SanitizedContent');
goog.provide('goog.soy.data.SanitizedContentKind');

goog.require('goog.i18n.bidi.Dir');


/**
 * A type of textual content.
 *
 * This is an enum of type Object so that these values are unforgeable.
 *
 * @enum {!Object}
 */
goog.soy.data.SanitizedContentKind = {

  /**
   * A snippet of HTML that does not start or end inside a tag, comment, entity,
   * or DOCTYPE; and that does not contain any executable code
   * (JS, {@code <object>}s, etc.) from a different trust domain.
   */
  HTML: goog.DEBUG ? {sanitizedContentKindHtml: true} : {},

  /**
   * Executable Javascript code or expression, safe for insertion in a
   * script-tag or event handler context, known to be free of any
   * attacker-controlled scripts. This can either be side-effect-free
   * Javascript (such as JSON) or Javascript that entirely under Google's
   * control.
   */
  JS: goog.DEBUG ? {sanitizedContentJsStrChars: true} : {},

  /**
   * A sequence of code units that can appear between quotes (either kind) in a
   * JS program without causing a parse error, and without causing any side
   * effects.
   * <p>
   * The content should not contain unescaped quotes, newlines, or anything else
   * that would cause parsing to fail or to cause a JS parser to finish the
   * string its parsing inside the content.
   * <p>
   * The content must also not end inside an escape sequence ; no partial octal
   * escape sequences or odd number of '{@code \}'s at the end.
   */
  JS_STR_CHARS: goog.DEBUG ? {sanitizedContentJsStrChars: true} : {},

  /** A properly encoded portion of a URI. */
  URI: goog.DEBUG ? {sanitizedContentUri: true} : {},

  /**
   * Repeated attribute names and values. For example,
   * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
   */
  ATTRIBUTES: goog.DEBUG ? {sanitizedContentHtmlAttribute: true} : {},

  // TODO: Consider separating rules, declarations, and values into
  // separate types, but for simplicity, we'll treat explicitly blessed
  // SanitizedContent as allowed in all of these contexts.
  /**
   * A CSS3 declaration, property, value or group of semicolon separated
   * declarations.
   */
  CSS: goog.DEBUG ? {sanitizedContentCss: true} : {},

  /**
   * Unsanitized plain-text content.
   *
   * This is effectively the "null" entry of this enum, and is sometimes used
   * to explicitly mark content that should never be used unescaped. Since any
   * string is safe to use as text, being of ContentKind.TEXT makes no
   * guarantees about its safety in any other context such as HTML.
   */
  TEXT: goog.DEBUG ? {sanitizedContentKindText: true} : {}
};



/**
 * A string-like object that carries a content-type and a content direction.
 *
 * IMPORTANT! Do not create these directly, nor instantiate the subclasses.
 * Instead, use a trusted, centrally reviewed library as endorsed by your team
 * to generate these objects. Otherwise, you risk accidentally creating
 * SanitizedContent that is attacker-controlled and gets evaluated unescaped in
 * templates.
 *
 * @constructor
 */
goog.soy.data.SanitizedContent = function() {
  throw Error('Do not instantiate directly');
};


/**
 * The context in which this content is safe from XSS attacks.
 * @type {goog.soy.data.SanitizedContentKind}
 */
goog.soy.data.SanitizedContent.prototype.contentKind;


/**
 * The content's direction; null if unknown and thus to be estimated when
 * necessary.
 * @type {?goog.i18n.bidi.Dir}
 */
goog.soy.data.SanitizedContent.prototype.contentDir = null;


/**
 * The already-safe content.
 * @type {string}
 */
goog.soy.data.SanitizedContent.prototype.content;


/** @override */
goog.soy.data.SanitizedContent.prototype.toString = function() {
  return this.content;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the goog.dom.TagName enum.  This enumerates
 * all HTML tag names specified in either the the W3C HTML 4.01 index of
 * elements or the HTML5 draft specification.
 *
 * References:
 * http://www.w3.org/TR/html401/index/elements.html
 * http://dev.w3.org/html5/spec/section-index.html
 *
 */
goog.provide('goog.dom.TagName');


/**
 * Enum of all html tag names specified by the W3C HTML4.01 and HTML5
 * specifications.
 * @enum {string}
 */
goog.dom.TagName = {
  A: 'A',
  ABBR: 'ABBR',
  ACRONYM: 'ACRONYM',
  ADDRESS: 'ADDRESS',
  APPLET: 'APPLET',
  AREA: 'AREA',
  ARTICLE: 'ARTICLE',
  ASIDE: 'ASIDE',
  AUDIO: 'AUDIO',
  B: 'B',
  BASE: 'BASE',
  BASEFONT: 'BASEFONT',
  BDI: 'BDI',
  BDO: 'BDO',
  BIG: 'BIG',
  BLOCKQUOTE: 'BLOCKQUOTE',
  BODY: 'BODY',
  BR: 'BR',
  BUTTON: 'BUTTON',
  CANVAS: 'CANVAS',
  CAPTION: 'CAPTION',
  CENTER: 'CENTER',
  CITE: 'CITE',
  CODE: 'CODE',
  COL: 'COL',
  COLGROUP: 'COLGROUP',
  COMMAND: 'COMMAND',
  DATA: 'DATA',
  DATALIST: 'DATALIST',
  DD: 'DD',
  DEL: 'DEL',
  DETAILS: 'DETAILS',
  DFN: 'DFN',
  DIALOG: 'DIALOG',
  DIR: 'DIR',
  DIV: 'DIV',
  DL: 'DL',
  DT: 'DT',
  EM: 'EM',
  EMBED: 'EMBED',
  FIELDSET: 'FIELDSET',
  FIGCAPTION: 'FIGCAPTION',
  FIGURE: 'FIGURE',
  FONT: 'FONT',
  FOOTER: 'FOOTER',
  FORM: 'FORM',
  FRAME: 'FRAME',
  FRAMESET: 'FRAMESET',
  H1: 'H1',
  H2: 'H2',
  H3: 'H3',
  H4: 'H4',
  H5: 'H5',
  H6: 'H6',
  HEAD: 'HEAD',
  HEADER: 'HEADER',
  HGROUP: 'HGROUP',
  HR: 'HR',
  HTML: 'HTML',
  I: 'I',
  IFRAME: 'IFRAME',
  IMG: 'IMG',
  INPUT: 'INPUT',
  INS: 'INS',
  ISINDEX: 'ISINDEX',
  KBD: 'KBD',
  KEYGEN: 'KEYGEN',
  LABEL: 'LABEL',
  LEGEND: 'LEGEND',
  LI: 'LI',
  LINK: 'LINK',
  MAP: 'MAP',
  MARK: 'MARK',
  MATH: 'MATH',
  MENU: 'MENU',
  META: 'META',
  METER: 'METER',
  NAV: 'NAV',
  NOFRAMES: 'NOFRAMES',
  NOSCRIPT: 'NOSCRIPT',
  OBJECT: 'OBJECT',
  OL: 'OL',
  OPTGROUP: 'OPTGROUP',
  OPTION: 'OPTION',
  OUTPUT: 'OUTPUT',
  P: 'P',
  PARAM: 'PARAM',
  PRE: 'PRE',
  PROGRESS: 'PROGRESS',
  Q: 'Q',
  RP: 'RP',
  RT: 'RT',
  RUBY: 'RUBY',
  S: 'S',
  SAMP: 'SAMP',
  SCRIPT: 'SCRIPT',
  SECTION: 'SECTION',
  SELECT: 'SELECT',
  SMALL: 'SMALL',
  SOURCE: 'SOURCE',
  SPAN: 'SPAN',
  STRIKE: 'STRIKE',
  STRONG: 'STRONG',
  STYLE: 'STYLE',
  SUB: 'SUB',
  SUMMARY: 'SUMMARY',
  SUP: 'SUP',
  SVG: 'SVG',
  TABLE: 'TABLE',
  TBODY: 'TBODY',
  TD: 'TD',
  TEXTAREA: 'TEXTAREA',
  TFOOT: 'TFOOT',
  TH: 'TH',
  THEAD: 'THEAD',
  TIME: 'TIME',
  TITLE: 'TITLE',
  TR: 'TR',
  TRACK: 'TRACK',
  TT: 'TT',
  U: 'U',
  UL: 'UL',
  VAR: 'VAR',
  VIDEO: 'VIDEO',
  WBR: 'WBR'
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for adding, removing and setting classes.  Prefer
 * {@link goog.dom.classlist} over these utilities since goog.dom.classlist
 * conforms closer to the semantics of Element.classList, is faster (uses
 * native methods rather than parsing strings on every call) and compiles
 * to smaller code as a result.
 *
 * Note: these utilities are meant to operate on HTMLElements and
 * will not work on elements with differing interfaces (such as SVGElements).
 *
 */


goog.provide('goog.dom.classes');

goog.require('goog.array');


/**
 * Sets the entire class name of an element.
 * @param {Node} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classes.set = function(element, className) {
  element.className = className;
};


/**
 * Gets an array of class names on an element
 * @param {Node} element DOM node to get class of.
 * @return {!Array} Class names on {@code element}. Some browsers add extra
 *     properties to the array. Do not depend on any of these!
 */
goog.dom.classes.get = function(element) {
  var className = element.className;
  // Some types of elements don't have a className in IE (e.g. iframes).
  // Furthermore, in Firefox, className is not a string when the element is
  // an SVG element.
  return goog.isString(className) && className.match(/\S+/g) || [];
};


/**
 * Adds a class or classes to an element. Does not add multiples of class names.
 * @param {Node} element DOM node to add class to.
 * @param {...string} var_args Class names to add.
 * @return {boolean} Whether class was added (or all classes were added).
 */
goog.dom.classes.add = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var expectedCount = classes.length + args.length;
  goog.dom.classes.add_(classes, args);
  goog.dom.classes.set(element, classes.join(' '));
  return classes.length == expectedCount;
};


/**
 * Removes a class or classes from an element.
 * @param {Node} element DOM node to remove class from.
 * @param {...string} var_args Class name(s) to remove.
 * @return {boolean} Whether all classes in {@code var_args} were found and
 *     removed.
 */
goog.dom.classes.remove = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var newClasses = goog.dom.classes.getDifference_(classes, args);
  goog.dom.classes.set(element, newClasses.join(' '));
  return newClasses.length == classes.length - args.length;
};


/**
 * Helper method for {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.addRemove}. Adds one or more classes to the supplied
 * classes array.
 * @param {Array.<string>} classes All class names for the element, will be
 *     updated to have the classes supplied in {@code args} added.
 * @param {Array.<string>} args Class names to add.
 * @private
 */
goog.dom.classes.add_ = function(classes, args) {
  for (var i = 0; i < args.length; i++) {
    if (!goog.array.contains(classes, args[i])) {
      classes.push(args[i]);
    }
  }
};


/**
 * Helper method for {@link goog.dom.classes.remove} and
 * {@link goog.dom.classes.addRemove}. Calculates the difference of two arrays.
 * @param {!Array.<string>} arr1 First array.
 * @param {!Array.<string>} arr2 Second array.
 * @return {!Array.<string>} The first array without the elements of the second
 *     array.
 * @private
 */
goog.dom.classes.getDifference_ = function(arr1, arr2) {
  return goog.array.filter(arr1, function(item) {
    return !goog.array.contains(arr2, item);
  });
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.
 * @param {Node} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classes.swap = function(element, fromClass, toClass) {
  var classes = goog.dom.classes.get(element);

  var removed = false;
  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == fromClass) {
      goog.array.splice(classes, i--, 1);
      removed = true;
    }
  }

  if (removed) {
    classes.push(toClass);
    goog.dom.classes.set(element, classes.join(' '));
  }

  return removed;
};


/**
 * Adds zero or more classes to an element and removes zero or more as a single
 * operation. Unlike calling {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.remove} separately, this is more efficient as it only
 * parses the class property once.
 *
 * If a class is in both the remove and add lists, it will be added. Thus,
 * you can use this instead of {@link goog.dom.classes.swap} when you have
 * more than two class names that you want to swap.
 *
 * @param {Node} element DOM node to swap classes on.
 * @param {?(string|Array.<string>)} classesToRemove Class or classes to
 *     remove, if null no classes are removed.
 * @param {?(string|Array.<string>)} classesToAdd Class or classes to add, if
 *     null no classes are added.
 */
goog.dom.classes.addRemove = function(element, classesToRemove, classesToAdd) {
  var classes = goog.dom.classes.get(element);
  if (goog.isString(classesToRemove)) {
    goog.array.remove(classes, classesToRemove);
  } else if (goog.isArray(classesToRemove)) {
    classes = goog.dom.classes.getDifference_(classes, classesToRemove);
  }

  if (goog.isString(classesToAdd) &&
      !goog.array.contains(classes, classesToAdd)) {
    classes.push(classesToAdd);
  } else if (goog.isArray(classesToAdd)) {
    goog.dom.classes.add_(classes, classesToAdd);
  }

  goog.dom.classes.set(element, classes.join(' '));
};


/**
 * Returns true if an element has a class.
 * @param {Node} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classes.has = function(element, className) {
  return goog.array.contains(goog.dom.classes.get(element), className);
};


/**
 * Adds or removes a class depending on the enabled argument.
 * @param {Node} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classes.enable = function(element, className, enabled) {
  if (enabled) {
    goog.dom.classes.add(element, className);
  } else {
    goog.dom.classes.remove(element, className);
  }
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.
 * @param {Node} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classes.toggle = function(element, className) {
  var add = !goog.dom.classes.has(element, className);
  goog.dom.classes.enable(element, className, add);
  return add;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 */
goog.math.Size = function(width, height) {
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size.
   * @return {string} In the form (50 x 73).
   * @override
   */
  goog.math.Size.prototype.toString = function() {
    return '(' + this.width + ' x ' + this.height + ')';
  };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function() {
  return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function() {
  return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function() {
  return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function() {
  return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function() {
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function(target) {
  return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function() {
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function() {
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
 * given, then {@code sx} is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.width *= sx;
  this.height *= sy;
  return this;
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function(target) {
  var s = this.aspectRatio() > target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the dom package.
 *
 */


goog.provide('goog.dom.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.dom.BrowserFeature = {
  /**
   * Whether attributes 'name' and 'type' can be added to an element after it's
   * created. False in Internet Explorer prior to version 9.
   */
  CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether we can use element.children to access an element's Element
   * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
   * nodes in the collection.)
   */
  CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
      goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),

  /**
   * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
   * include text nodes in script and style tags. Not document-mode-dependent.
   */
  CAN_USE_INNER_TEXT: (
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),

  /**
   * MSIE, Opera, and Safari>=4 support element.parentElement to access an
   * element's parent if it is an Element.
   */
  CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA ||
      goog.userAgent.WEBKIT,

  /**
   * Whether NoScope elements need a scoped element written before them in
   * innerHTML.
   * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
   */
  INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */


goog.provide('goog.math.Coordinate');

goog.require('goog.math');



/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @constructor
 */
goog.math.Coordinate = function(opt_x, opt_y) {
  /**
   * X-value
   * @type {number}
   */
  this.x = goog.isDef(opt_x) ? opt_x : 0;

  /**
   * Y-value
   * @type {number}
   */
  this.y = goog.isDef(opt_y) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function() {
  return new goog.math.Coordinate(this.x, this.y);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the coordinate.
   * @return {string} In the form (50, 73).
   * @override
   */
  goog.math.Coordinate.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
  };
}


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.x == b.x && a.y == b.y;
};


/**
 * Returns the distance between two coordinates.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.distance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
};


/**
 * Returns the magnitude of a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The distance between the origin and {@code a}.
 */
goog.math.Coordinate.magnitude = function(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
};


/**
 * Returns the angle from the origin to a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The angle, in degrees, clockwise from the positive X
 *     axis to {@code a}.
 */
goog.math.Coordinate.azimuth = function(a) {
  return goog.math.angle(0, 0, a.x, a.y);
};


/**
 * Returns the squared distance between two coordinates. Squared distances can
 * be used for comparisons when the actual value is not required.
 *
 * Performance note: eliminating the square root is an optimization often used
 * in lower-level languages, but the speed difference is not nearly as
 * pronounced in JavaScript (only a few percent.)
 *
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The squared distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.squaredDistance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx * dx + dy * dy;
};


/**
 * Returns the difference between two coordinates as a new
 * goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the difference
 *     between {@code a} and {@code b}.
 */
goog.math.Coordinate.difference = function(a, b) {
  return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
};


/**
 * Returns the sum of two coordinates as a new goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
 *     coordinates.
 */
goog.math.Coordinate.sum = function(a, b) {
  return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
};


/**
 * Rounds the x and y fields to the next larger integer values.
 * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
 */
goog.math.Coordinate.prototype.ceil = function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the next smaller integer values.
 * @return {!goog.math.Coordinate} This coordinate with floored fields.
 */
goog.math.Coordinate.prototype.floor = function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the nearest integer values.
 * @return {!goog.math.Coordinate} This coordinate with rounded fields.
 */
goog.math.Coordinate.prototype.round = function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the x and y values are translated by the coordinate's x and y.
 * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}
 * respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate x by or the
 *     the coordinate to translate this coordinate by.
 * @param {number=} opt_ty The value to translate y by.
 * @return {!goog.math.Coordinate} This coordinate after translating.
 */
goog.math.Coordinate.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.x += tx.x;
    this.y += tx.y;
  } else {
    this.x += tx;
    if (goog.isNumber(opt_ty)) {
      this.y += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y values are
 * scaled by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy}
 * is not given, then {@code sx} is used for both x and y.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Coordinate} This coordinate after scaling.
 */
goog.math.Coordinate.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.x *= sx;
  this.y *= sy;
  return this;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 */


// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.functions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function(opt_element) {
  return opt_element ?
      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
      (goog.dom.defaultDomHelper_ ||
          (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {goog.dom.DomHelper}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function() {
  return document;
};


/**
 * Gets an element from the current document by element id.
 *
 * If an Element is passed in, it is returned.
 *
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function(element) {
  return goog.dom.getElementHelper_(document, element);
};


/**
 * Gets an element by id from the given document (if present).
 * If an element is given, it is returned.
 * @param {!Document} doc
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The resulting element.
 * @private
 */
goog.dom.getElementHelper_ = function(doc, element) {
  return goog.isString(element) ?
      doc.getElementById(element) :
      element;
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(document, id);
};


/**
 * Helper function for getRequiredElementHelper functions, both static and
 * on DomHelper.  Asserts the element with the given id exists.
 * @param {!Document} doc
 * @param {string} id
 * @return {!Element} The element with the given ID, if it exists.
 * @private
 */
goog.dom.getRequiredElementHelper_ = function(doc, id) {
  // To prevent users passing in Elements as is permitted in getElement().
  goog.asserts.assertString(id);
  var element = goog.dom.getElementHelper_(doc, id);
  element = goog.asserts.assertElement(element,
      'No element found with id: ' + id);
  return element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  {@code goog.dom.query} offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions, but at increased cost in code size. If all you
 * need is particular tags belonging to a single class, this function
 * is fast and sleek.
 *
 * Note that tag names are case sensitive in the SVG namespace, and this
 * function converts opt_tag to uppercase for comparisons. For queries in the
 * SVG namespace you should use querySelector or querySelectorAll instead.
 * https://bugzilla.mozilla.org/show_bug.cgi?id=963870
 * https://bugs.webkit.org/show_bug.cgi?id=83438
 *
 * @see {goog.dom.query}
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class,
                                                opt_el);
};


/**
 * Returns a static, array-like list of the elements with the provided
 * className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.getElementsByClass = function(className, opt_el) {
  var parent = opt_el || document;
  if (goog.dom.canUseQuerySelector_(parent)) {
    return parent.querySelectorAll('.' + className);
  }
  return goog.dom.getElementsByTagNameAndClass_(
      document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function(className, opt_el) {
  var parent = opt_el || document;
  var retVal = null;
  if (goog.dom.canUseQuerySelector_(parent)) {
    retVal = parent.querySelector('.' + className);
  } else {
    retVal = goog.dom.getElementsByTagNameAndClass_(
        document, '*', className, opt_el)[0];
  }
  return retVal || null;
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {!Element|!Document=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.getRequiredElementByClass = function(className, opt_root) {
  var retValue = goog.dom.getElementByClass(className, opt_root);
  return goog.asserts.assert(retValue,
      'No element found with className: ' + className);
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API.
 * @param {!(Element|Document)} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function(parent) {
  return !!(parent.querySelectorAll && parent.querySelector);
};


/**
 * Helper for {@code getElementsByTagNameAndClass}.
 * @param {!Document} doc The document to get the elements in.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class,
                                                  opt_el) {
  var parent = opt_el || doc;
  var tagName = (opt_tag && opt_tag != '*') ? opt_tag.toUpperCase() : '';

  if (goog.dom.canUseQuerySelector_(parent) &&
      (tagName || opt_class)) {
    var query = tagName + (opt_class ? '.' + opt_class : '');
    return parent.querySelectorAll(query);
  }

  // Use the native getElementsByClassName if available, under the assumption
  // that even when the tag name is specified, there will be fewer elements to
  // filter through when going by class than by tag name
  if (opt_class && parent.getElementsByClassName) {
    var els = parent.getElementsByClassName(opt_class);

    if (tagName) {
      var arrayLike = {};
      var len = 0;

      // Filter for specific tags if requested.
      for (var i = 0, el; el = els[i]; i++) {
        if (tagName == el.nodeName) {
          arrayLike[len++] = el;
        }
      }
      arrayLike.length = len;

      return arrayLike;
    } else {
      return els;
    }
  }

  var els = parent.getElementsByTagName(tagName || '*');

  if (opt_class) {
    var arrayLike = {};
    var len = 0;
    for (var i = 0, el; el = els[i]; i++) {
      var className = el.className;
      // Check if className has a split function since SVG className does not.
      if (typeof className.split == 'function' &&
          goog.array.contains(className.split(/\s+/), opt_class)) {
        arrayLike[len++] = el;
      }
    }
    arrayLike.length = len;
    return arrayLike;
  } else {
    return els;
  }
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.setProperties = function(element, properties) {
  goog.object.forEach(properties, function(val, key) {
    if (key == 'style') {
      element.style.cssText = val;
    } else if (key == 'class') {
      element.className = val;
    } else if (key == 'for') {
      element.htmlFor = val;
    } else if (key in goog.dom.DIRECT_ATTRIBUTE_MAP_) {
      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
    } else if (goog.string.startsWith(key, 'aria-') ||
        goog.string.startsWith(key, 'data-')) {
      element.setAttribute(key, val);
    } else {
      element[key] = val;
    }
  });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @type {Object}
 * @private
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
  'cellpadding': 'cellPadding',
  'cellspacing': 'cellSpacing',
  'colspan': 'colSpan',
  'frameborder': 'frameBorder',
  'height': 'height',
  'maxlength': 'maxLength',
  'role': 'role',
  'rowspan': 'rowSpan',
  'type': 'type',
  'usemap': 'useMap',
  'valign': 'vAlign',
  'width': 'width'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument
  return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for {@code getViewportSize}.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function(win) {
  var doc = win.document;
  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
  return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the current document.
 */
goog.dom.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(window);
};


/**
 * Calculates the height of the document of the given window.
 *
 * Function code copied from the opensocial gadget api:
 *   gadgets.window.adjustHeight(opt_height)
 *
 * @private
 * @param {Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeight_ = function(win) {
  // NOTE(eae): This method will return the window size rather than the document
  // size in webkit quirks mode.
  var doc = win.document;
  var height = 0;

  if (doc) {
    // Calculating inner content height is hard and different between
    // browsers rendering in Strict vs. Quirks mode.  We use a combination of
    // three properties within document.body and document.documentElement:
    // - scrollHeight
    // - offsetHeight
    // - clientHeight
    // These values differ significantly between browsers and rendering modes.
    // But there are patterns.  It just takes a lot of time and persistence
    // to figure out.

    // Get the height of the viewport
    var vh = goog.dom.getViewportSize_(win).height;
    var body = doc.body;
    var docEl = doc.documentElement;
    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
      // In Strict mode:
      // The inner content height is contained in either:
      //    document.documentElement.scrollHeight
      //    document.documentElement.offsetHeight
      // Based on studying the values output by different browsers,
      // use the value that's NOT equal to the viewport height found above.
      height = docEl.scrollHeight != vh ?
          docEl.scrollHeight : docEl.offsetHeight;
    } else {
      // In Quirks mode:
      // documentElement.clientHeight is equal to documentElement.offsetHeight
      // except in IE.  In most browsers, document.documentElement can be used
      // to calculate the inner content height.
      // However, in other browsers (e.g. IE), document.body must be used
      // instead.  How do we know which one to use?
      // If document.documentElement.clientHeight does NOT equal
      // document.documentElement.offsetHeight, then use document.body.
      var sh = docEl.scrollHeight;
      var oh = docEl.offsetHeight;
      if (docEl.clientHeight != oh) {
        sh = body.scrollHeight;
        oh = body.offsetHeight;
      }

      // Detect whether the inner content height is bigger or smaller
      // than the bounding box (viewport).  If bigger, take the larger
      // value.  If smaller, take the smaller value.
      if (sh > vh) {
        // Content is larger
        height = sh > oh ? sh : oh;
      } else {
        // Content is smaller
        height = sh < oh ? sh : oh;
      }
    }
  }

  return height;
};


/**
 * Gets the page scroll distance as a coordinate object.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
 */
goog.dom.getPageScroll = function(opt_window) {
  var win = opt_window || goog.global || window;
  return goog.dom.getDomHelper(win.document).getDocumentScroll();
};


/**
 * Gets the document scroll distance as a coordinate object.
 *
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 */
goog.dom.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(document);
};


/**
 * Helper for {@code getDocumentScroll}.
 *
 * @param {!Document} doc The document to get the scroll for.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @private
 */
goog.dom.getDocumentScroll_ = function(doc) {
  var el = goog.dom.getDocumentScrollElement_(doc);
  var win = goog.dom.getWindow_(doc);
  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
      win.pageYOffset != el.scrollTop) {
    // The keyboard on IE10 touch devices shifts the page using the pageYOffset
    // without modifying scrollTop. For this case, we want the body scroll
    // offsets.
    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
  }
  return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft,
      win.pageYOffset || el.scrollTop);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(document);
};


/**
 * Helper for {@code getDocumentScrollElement}.
 * @param {!Document} doc The document to get the scroll element for.
 * @return {Element} Scrolling element.
 * @private
 */
goog.dom.getDocumentScrollElement_ = function(doc) {
  // WebKit needs body.scrollLeft in both quirks mode and strict mode. We also
  // default to the documentElement if the document does not have a body (e.g.
  // a SVG document).
  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {
    return doc.documentElement;
  }
  return doc.body || doc.documentElement;
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.getWindow = function(opt_doc) {
  // TODO(arv): This should not take an argument.
  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for {@code getWindow}.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function(doc) {
  return doc.parentWindow || doc.defaultView;
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * @param {string} tagName Tag to create.
 * @param {(Object|Array.<string>|string)=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or NodeList,i
 *     its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
  return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for {@code createDom}.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     {@code goog.dom.createDom} for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function(doc, args) {
  var tagName = args[0];
  var attributes = args[1];

  // Internet Explorer is dumb: http://msdn.microsoft.com/workshop/author/
  //                            dhtml/reference/properties/name_2.asp
  // Also does not allow setting of 'type' attribute on 'input' or 'button'.
  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
      (attributes.name || attributes.type)) {
    var tagNameArr = ['<', tagName];
    if (attributes.name) {
      tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name),
                      '"');
    }
    if (attributes.type) {
      tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type),
                      '"');

      // Clone attributes map to remove 'type' without mutating the input.
      var clone = {};
      goog.object.extend(clone, attributes);

      // JSCompiler can't see how goog.object.extend added this property,
      // because it was essentially added by reflection.
      // So it needs to be quoted.
      delete clone['type'];

      attributes = clone;
    }
    tagNameArr.push('>');
    tagName = tagNameArr.join('');
  }

  var element = doc.createElement(tagName);

  if (attributes) {
    if (goog.isString(attributes)) {
      element.className = attributes;
    } else if (goog.isArray(attributes)) {
      goog.dom.classes.add.apply(null, [element].concat(attributes));
    } else {
      goog.dom.setProperties(element, attributes);
    }
  }

  if (args.length > 2) {
    goog.dom.append_(doc, element, args, 2);
  }

  return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function(doc, parent, args, startIndex) {
  function childHandler(child) {
    // TODO(user): More coercion, ala MochiKit?
    if (child) {
      parent.appendChild(goog.isString(child) ?
          doc.createTextNode(child) : child);
    }
  }

  for (var i = startIndex; i < args.length; i++) {
    var arg = args[i];
    // TODO(attila): Fix isArrayLike to return false for a text node.
    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
      // If the argument is a node list, not a real array, use a clone,
      // because forEach can't be used to mutate a NodeList.
      goog.array.forEach(goog.dom.isNodeList(arg) ?
          goog.array.toArray(arg) : arg,
          childHandler);
    } else {
      childHandler(arg);
    }
  }
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(string|Object)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array, its
 *     children will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.createElement = function(name) {
  return document.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function(content) {
  return document.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {
  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Create a table.
 * @param {!Document} doc Document object to use to create the table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean} fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 * @private
 */
goog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {
  var rowHtml = ['<tr>'];
  for (var i = 0; i < columns; i++) {
    rowHtml.push(fillWithNbsp ? '<td>&nbsp;</td>' : '<td></td>');
  }
  rowHtml.push('</tr>');
  rowHtml = rowHtml.join('');
  var totalHtml = ['<table>'];
  for (i = 0; i < rows; i++) {
    totalHtml.push(rowHtml);
  }
  totalHtml.push('</table>');

  var elem = doc.createElement(goog.dom.TagName.DIV);
  elem.innerHTML = totalHtml.join('');
  return /** @type {!Element} */ (elem.removeChild(elem.firstChild));
};


/**
 * Converts an HTML string into a document fragment. The string must be
 * sanitized in order to avoid cross-site scripting. For example
 * {@code goog.dom.htmlToDocumentFragment('&lt;img src=x onerror=alert(0)&gt;')}
 * triggers an alert in all browsers, even if the returned document fragment
 * is thrown away immediately.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 */
goog.dom.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(document, htmlString);
};


/**
 * Helper for {@code htmlToDocumentFragment}.
 *
 * @param {!Document} doc The document.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 * @private
 */
goog.dom.htmlToDocumentFragment_ = function(doc, htmlString) {
  var tempDiv = doc.createElement('div');
  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
    tempDiv.innerHTML = '<br>' + htmlString;
    tempDiv.removeChild(tempDiv.firstChild);
  } else {
    tempDiv.innerHTML = htmlString;
  }
  if (tempDiv.childNodes.length == 1) {
    return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
  } else {
    var fragment = doc.createDocumentFragment();
    while (tempDiv.firstChild) {
      fragment.appendChild(tempDiv.firstChild);
    }
    return fragment;
  }
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(document);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @param {Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function(doc) {
  if (goog.dom.COMPAT_MODE_KNOWN_) {
    return goog.dom.ASSUME_STANDARDS_MODE;
  }

  return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = document.createElement('br');
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *   console.log(a.childNodes.length);  // 2
 *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * For more information, see:
 * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
 *
 * TODO(user): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren = function(node) {
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    return false;
  }
  switch (node.tagName) {
    case goog.dom.TagName.APPLET:
    case goog.dom.TagName.AREA:
    case goog.dom.TagName.BASE:
    case goog.dom.TagName.BR:
    case goog.dom.TagName.COL:
    case goog.dom.TagName.COMMAND:
    case goog.dom.TagName.EMBED:
    case goog.dom.TagName.FRAME:
    case goog.dom.TagName.HR:
    case goog.dom.TagName.IMG:
    case goog.dom.TagName.INPUT:
    case goog.dom.TagName.IFRAME:
    case goog.dom.TagName.ISINDEX:
    case goog.dom.TagName.KEYGEN:
    case goog.dom.TagName.LINK:
    case goog.dom.TagName.NOFRAMES:
    case goog.dom.TagName.NOSCRIPT:
    case goog.dom.TagName.META:
    case goog.dom.TagName.OBJECT:
    case goog.dom.TagName.PARAM:
    case goog.dom.TagName.SCRIPT:
    case goog.dom.TagName.SOURCE:
    case goog.dom.TagName.STYLE:
    case goog.dom.TagName.TRACK:
    case goog.dom.TagName.WBR:
      return false;
  }
  return true;
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function(parent, child) {
  parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function(parent, var_args) {
  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.removeChildren = function(node) {
  // Note: Iterations over live collections can be slow, this is the fastest
  // we could find. The double parenthesis are used to prevent JsCompiler and
  // strict warnings.
  var child;
  while ((child = node.firstChild)) {
    node.removeChild(child);
  }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode);
  }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.insertSiblingAfter = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  }
};


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.insertChildAt = function(parent, child, index) {
  // Note that if the second argument is null, insertBefore
  // will append the child at the end of the list of children.
  parent.insertBefore(child, parent.childNodes[index] || null);
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the document
 *     to begin with.
 */
goog.dom.flattenElement = function(element) {
  var child, parent = element.parentNode;
  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
    // Use IE DOM method (supported by Opera too) if available
    if (element.removeNode) {
      return /** @type {Element} */ (element.removeNode(false));
    } else {
      // Move all children of the original node up one level.
      while ((child = element.firstChild)) {
        parent.insertBefore(child, element);
      }

      // Detach the original element.
      return /** @type {Element} */ (goog.dom.removeNode(element));
    }
  }
};


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.getChildren = function(element) {
  // We check if the children attribute is supported for child elements
  // since IE8 misuses the attribute by also including comments.
  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&
      element.children != undefined) {
    return element.children;
  }
  // Fall back to manually filtering the element's child nodes.
  return goog.array.filter(element.childNodes, function(node) {
    return node.nodeType == goog.dom.NodeType.ELEMENT;
  });
};


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.getFirstElementChild = function(node) {
  if (node.firstElementChild != undefined) {
    return /** @type {Element} */(node).firstElementChild;
  }
  return goog.dom.getNextElementNode_(node.firstChild, true);
};


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.getLastElementChild = function(node) {
  if (node.lastElementChild != undefined) {
    return /** @type {Element} */(node).lastElementChild;
  }
  return goog.dom.getNextElementNode_(node.lastChild, false);
};


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.getNextElementSibling = function(node) {
  if (node.nextElementSibling != undefined) {
    return /** @type {Element} */(node).nextElementSibling;
  }
  return goog.dom.getNextElementNode_(node.nextSibling, true);
};


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.getPreviousElementSibling = function(node) {
  if (node.previousElementSibling != undefined) {
    return /** @type {Element} */(node).previousElementSibling;
  }
  return goog.dom.getNextElementNode_(node.previousSibling, false);
};


/**
 * Returns the first node that is an element in the specified direction,
 * starting with {@code node}.
 * @param {Node} node The node to get the next element from.
 * @param {boolean} forward Whether to look forwards or backwards.
 * @return {Element} The first element.
 * @private
 */
goog.dom.getNextElementNode_ = function(node, forward) {
  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
    node = forward ? node.nextSibling : node.previousSibling;
  }

  return /** @type {Element} */ (node);
};


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.getNextNode = function(node) {
  if (!node) {
    return null;
  }

  if (node.firstChild) {
    return node.firstChild;
  }

  while (node && !node.nextSibling) {
    node = node.parentNode;
  }

  return node ? node.nextSibling : null;
};


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.getPreviousNode = function(node) {
  if (!node) {
    return null;
  }

  if (!node.previousSibling) {
    return node.parentNode;
  }

  node = node.previousSibling;
  while (node && node.lastChild) {
    node = node.lastChild;
  }

  return node;
};


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function(obj) {
  return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.isElement = function(obj) {
  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
};


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.isWindow = function(obj) {
  return goog.isObject(obj) && obj['window'] == obj;
};


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.getParentElement = function(element) {
  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
    var isIe9 = goog.userAgent.IE &&
        goog.userAgent.isVersionOrHigher('9') &&
        !goog.userAgent.isVersionOrHigher('10');
    // SVG elements in IE9 can't use the parentElement property.
    // goog.global['SVGElement'] is not defined in IE9 quirks mode.
    if (!(isIe9 && goog.global['SVGElement'] &&
        element instanceof goog.global['SVGElement'])) {
      return element.parentElement;
    }
  }
  var parent = element.parentNode;
  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
};


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.contains = function(parent, descendant) {
  // We use browser specific methods for this if available since it is faster
  // that way.

  // IE DOM
  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
    return parent == descendant || parent.contains(descendant);
  }

  // W3C DOM Level 3
  if (typeof parent.compareDocumentPosition != 'undefined') {
    return parent == descendant ||
        Boolean(parent.compareDocumentPosition(descendant) & 16);
  }

  // W3C DOM Level 1
  while (descendant && parent != descendant) {
    descendant = descendant.parentNode;
  }
  return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function(node1, node2) {
  // Fall out quickly for equality.
  if (node1 == node2) {
    return 0;
  }

  // Use compareDocumentPosition where available
  if (node1.compareDocumentPosition) {
    // 4 is the bitmask for FOLLOWS.
    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
  }

  // Special case for document nodes on IE 7 and 8.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
      return -1;
    }
    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
      return 1;
    }
  }

  // Process in IE using sourceIndex - we check to see if the first node has
  // a source index or if its parent has one.
  if ('sourceIndex' in node1 ||
      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

    if (isElement1 && isElement2) {
      return node1.sourceIndex - node2.sourceIndex;
    } else {
      var parent1 = node1.parentNode;
      var parent2 = node2.parentNode;

      if (parent1 == parent2) {
        return goog.dom.compareSiblingOrder_(node1, node2);
      }

      if (!isElement1 && goog.dom.contains(parent1, node2)) {
        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
      }


      if (!isElement2 && goog.dom.contains(parent2, node1)) {
        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
      }

      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
             (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
    }
  }

  // For Safari, we compare ranges.
  var doc = goog.dom.getOwnerDocument(node1);

  var range1, range2;
  range1 = doc.createRange();
  range1.selectNode(node1);
  range1.collapse(true);

  range2 = doc.createRange();
  range2.selectNode(node2);
  range2.collapse(true);

  return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END,
      range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
  var parent = textNode.parentNode;
  if (parent == node) {
    // If textNode is a child of node, then node comes first.
    return -1;
  }
  var sibling = node;
  while (sibling.parentNode != parent) {
    sibling = sibling.parentNode;
  }
  return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function(node1, node2) {
  var s = node2;
  while ((s = s.previousSibling)) {
    if (s == node1) {
      // We just found node1 before node2.
      return -1;
    }
  }

  // Since we didn't find it, node1 must be after node2.
  return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function(var_args) {
  var i, count = arguments.length;
  if (!count) {
    return null;
  } else if (count == 1) {
    return arguments[0];
  }

  var paths = [];
  var minLength = Infinity;
  for (i = 0; i < count; i++) {
    // Compute the list of ancestors.
    var ancestors = [];
    var node = arguments[i];
    while (node) {
      ancestors.unshift(node);
      node = node.parentNode;
    }

    // Save the list for comparison.
    paths.push(ancestors);
    minLength = Math.min(minLength, ancestors.length);
  }
  var output = null;
  for (i = 0; i < minLength; i++) {
    var first = paths[0][i];
    for (var j = 1; j < count; j++) {
      if (first != paths[j][i]) {
        return output;
      }
    }
    output = first;
  }
  return output;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function(node) {
  // TODO(arv): Remove IE5 code.
  // IE5 uses document instead of ownerDocument
  return /** @type {!Document} */ (
      node.nodeType == goog.dom.NodeType.DOCUMENT ? node :
      node.ownerDocument || node.document);
};


/**
 * Cross-browser function for getting the document element of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {!Document} The frame content document.
 */
goog.dom.getFrameContentDocument = function(frame) {
  var doc = frame.contentDocument || frame.contentWindow.document;
  return doc;
};


/**
 * Cross-browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.getFrameContentWindow = function(frame) {
  return frame.contentWindow ||
      goog.dom.getWindow(goog.dom.getFrameContentDocument(frame));
};


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.setTextContent = function(node, text) {
  goog.asserts.assert(node != null,
      'goog.dom.setTextContent expects a non-null value for node');

  if ('textContent' in node) {
    node.textContent = text;
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    node.data = text;
  } else if (node.firstChild &&
             node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
    // If the first child is a text node we just change its data and remove the
    // rest of the children.
    while (node.lastChild != node.firstChild) {
      node.removeChild(node.lastChild);
    }
    node.firstChild.data = text;
  } else {
    goog.dom.removeChildren(node);
    var doc = goog.dom.getOwnerDocument(node);
    node.appendChild(doc.createTextNode(String(text)));
  }
};


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function(element) {
  // IE, Opera and WebKit all have outerHTML.
  if ('outerHTML' in element) {
    return element.outerHTML;
  } else {
    var doc = goog.dom.getOwnerDocument(element);
    var div = doc.createElement('div');
    div.appendChild(element.cloneNode(true));
    return div.innerHTML;
  }
};


/**
 * Finds the first descendant node that matches the filter function, using
 * a depth first search. This function offers the most general purpose way
 * of finding a matching element. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.
 * @see goog.dom.query
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.findNode = function(root, p) {
  var rv = [];
  var found = goog.dom.findNodes_(root, p, rv, true);
  return found ? rv[0] : undefined;
};


/**
 * Finds all the descendant nodes that match the filter function, using a
 * a depth first search. This function offers the most general-purpose way
 * of finding a set of matching elements. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.

 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {!Array.<!Node>} The found nodes or an empty array if none are found.
 */
goog.dom.findNodes = function(root, p) {
  var rv = [];
  goog.dom.findNodes_(root, p, rv, false);
  return rv;
};


/**
 * Finds the first or all the descendant nodes that match the filter function,
 * using a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @param {!Array.<!Node>} rv The found nodes are added to this array.
 * @param {boolean} findOne If true we exit after the first found node.
 * @return {boolean} Whether the search is complete or not. True in case findOne
 *     is true and the node is found. False otherwise.
 * @private
 */
goog.dom.findNodes_ = function(root, p, rv, findOne) {
  if (root != null) {
    var child = root.firstChild;
    while (child) {
      if (p(child)) {
        rv.push(child);
        if (findOne) {
          return true;
        }
      }
      if (goog.dom.findNodes_(child, p, rv, findOne)) {
        return true;
      }
      child = child.nextSibling;
    }
  }
  return false;
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @type {Object}
 * @private
 */
goog.dom.TAGS_TO_IGNORE_ = {
  'SCRIPT': 1,
  'STYLE': 1,
  'HEAD': 1,
  'IFRAME': 1,
  'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @type {Object}
 * @private
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {'IMG': ' ', 'BR': '\n'};


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 * @see http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 */
goog.dom.isFocusableTabIndex = function(element) {
  return goog.dom.hasSpecifiedTabIndex_(element) &&
         goog.dom.isTabIndexFocusable_(element);
};


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.setFocusableTabIndex = function(element, enable) {
  if (enable) {
    element.tabIndex = 0;
  } else {
    // Set tabIndex to -1 first, then remove it. This is a workaround for
    // Safari (confirmed in version 4 on Windows). When removing the attribute
    // without setting it to -1 first, the element remains keyboard focusable
    // despite not having a tabIndex attribute anymore.
    element.tabIndex = -1;
    element.removeAttribute('tabIndex'); // Must be camelCase!
  }
};


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.isFocusable = function(element) {
  var focusable;
  // Some elements can have unspecified tab index and still receive focus.
  if (goog.dom.nativelySupportsFocus_(element)) {
    // Make sure the element is not disabled ...
    focusable = !element.disabled &&
        // ... and if a tab index is specified, it allows focus.
        (!goog.dom.hasSpecifiedTabIndex_(element) ||
         goog.dom.isTabIndexFocusable_(element));
  } else {
    focusable = goog.dom.isFocusableTabIndex(element);
  }

  // IE requires elements to be visible in order to focus them.
  return focusable && goog.userAgent.IE ?
             goog.dom.hasNonZeroBoundingRect_(element) : focusable;
};


/**
 * Returns true if the element has a specified tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a specified tab index.
 * @private
 */
goog.dom.hasSpecifiedTabIndex_ = function(element) {
  // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),
  // which returns an object with a 'specified' property if tabIndex is
  // specified.  This works on other browsers, too.
  var attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!
  return goog.isDefAndNotNull(attrNode) && attrNode.specified;
};


/**
 * Returns true if the element's tab index allows the element to be focused.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element's tab index allows focus.
 * @private
 */
goog.dom.isTabIndexFocusable_ = function(element) {
  var index = element.tabIndex;
  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
  return goog.isNumber(index) && index >= 0 && index < 32768;
};


/**
 * Returns true if the element is focusable even when tabIndex is not set.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element natively supports focus.
 * @private
 */
goog.dom.nativelySupportsFocus_ = function(element) {
  return element.tagName == goog.dom.TagName.A ||
         element.tagName == goog.dom.TagName.INPUT ||
         element.tagName == goog.dom.TagName.TEXTAREA ||
         element.tagName == goog.dom.TagName.SELECT ||
         element.tagName == goog.dom.TagName.BUTTON;
};


/**
 * Returns true if the element has a bounding rectangle that would be visible
 * (i.e. its width and height are greater than zero).
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a non-zero bounding rectangle.
 * @private
 */
goog.dom.hasNonZeroBoundingRect_ = function(element) {
  var rect = goog.isFunction(element['getBoundingClientRect']) ?
      element.getBoundingClientRect() :
      {'height': element.offsetHeight, 'width': element.offsetWidth};
  return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;
};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function(node) {
  var textContent;
  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include
  // text nodes in script tags. So we revert to use a user agent test here.
  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && ('innerText' in node)) {
    textContent = goog.string.canonicalizeNewlines(node.innerText);
    // Unfortunately .innerText() returns text with &shy; symbols
    // We need to filter it out and then remove duplicate whitespaces
  } else {
    var buf = [];
    goog.dom.getTextContent_(node, buf, true);
    textContent = buf.join('');
  }

  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
  textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
  textContent = textContent.replace(/\u200B/g, '');

  // Skip this replacement on old browsers with working innerText, which
  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading
  // innerText.
  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {
    textContent = textContent.replace(/ +/g, ' ');
  }
  if (textContent != ' ') {
    textContent = textContent.replace(/^\s*/, '');
  }

  return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike {@code getTextContent} this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function(node) {
  var buf = [];
  goog.dom.getTextContent_(node, buf, false);

  return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
    // ignore certain tags
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    if (normalizeWhitespace) {
      buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      buf.push(node.nodeValue);
    }
  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
  } else {
    var child = node.firstChild;
    while (child) {
      goog.dom.getTextContent_(child, buf, normalizeWhitespace);
      child = child.nextSibling;
    }
  }
};


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.getNodeTextLength = function(node) {
  return goog.dom.getTextContent(node).length;
};


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by goog.dom.getNodeTextLength.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent The node relative to which the offset will
 *     be calculated. Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.getNodeTextOffset = function(node, opt_offsetParent) {
  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
  var buf = [];
  while (node && node != root) {
    var cur = node;
    while ((cur = cur.previousSibling)) {
      buf.unshift(goog.dom.getTextContent(cur));
    }
    node = node.parentNode;
  }
  // Trim left to deal with FF cases when there might be line breaks and empty
  // nodes at the front of the text
  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
};


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.getNodeAtOffset = function(parent, offset, opt_result) {
  var stack = [parent], pos = 0, cur = null;
  while (stack.length > 0 && pos < offset) {
    cur = stack.pop();
    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
      // ignore certain tags
    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {
      var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
      pos += text.length;
    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
    } else {
      for (var i = cur.childNodes.length - 1; i >= 0; i--) {
        stack.push(cur.childNodes[i]);
      }
    }
  }
  if (goog.isObject(opt_result)) {
    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
    opt_result.node = cur;
  }

  return cur;
};


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function(val) {
  // TODO(attila): Now the isNodeList is part of goog.dom we can use
  // goog.userAgent to make this simpler.
  // A NodeList must have a length property of type 'number' on all platforms.
  if (val && typeof val.length == 'number') {
    // A NodeList is an object everywhere except Safari, where it's a function.
    if (goog.isObject(val)) {
      // A NodeList must have an item function (on non-IE platforms) or an item
      // property of type 'string' (on IE).
      return typeof val.item == 'function' || typeof val.item == 'string';
    } else if (goog.isFunction(val)) {
      // On Safari, a NodeList is a function with an item property that is also
      // a function.
      return typeof val.item == 'function';
    }
  }

  // Not a NodeList.
  return false;
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.getAncestorByTagNameAndClass = function(element, opt_tag, opt_class) {
  if (!opt_tag && !opt_class) {
    return null;
  }
  var tagName = opt_tag ? opt_tag.toUpperCase() : null;
  return /** @type {Element} */ (goog.dom.getAncestor(element,
      function(node) {
        return (!tagName || node.nodeName == tagName) &&
               (!opt_class || goog.dom.classes.has(node, opt_class));
      }, true));
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} className The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.getAncestorByClass = function(element, className) {
  return goog.dom.getAncestorByTagNameAndClass(element, null, className);
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.getAncestor = function(
    element, matcher, opt_includeNode, opt_maxSearchSteps) {
  if (!opt_includeNode) {
    element = element.parentNode;
  }
  var ignoreSearchSteps = opt_maxSearchSteps == null;
  var steps = 0;
  while (element && (ignoreSearchSteps || steps <= opt_maxSearchSteps)) {
    if (matcher(element)) {
      return element;
    }
    element = element.parentNode;
    steps++;
  }
  // Reached the root of the DOM without a match
  return null;
};


/**
 * Determines the active element in the given document.
 * @param {Document} doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.getActiveElement = function(doc) {
  try {
    return doc && doc.activeElement;
  } catch (e) {
    // NOTE(nicksantos): Sometimes, evaluating document.activeElement in IE
    // throws an exception. I'm not 100% sure why, but I suspect it chokes
    // on document.activeElement if the activeElement has been recently
    // removed from the DOM by a JS operation.
    //
    // We assume that an exception here simply means
    // "there is no active element."
  }

  return null;
};


/**
 * @private {number} Cached version of the devicePixelRatio.
 */
goog.dom.devicePixelRatio_;


/**
 * Gives the devicePixelRatio, or attempts to determine if not present.
 *
 * By default, this is the same value given by window.devicePixelRatio. If
 * devicePixelRatio is not defined, the ratio is calculated with
 * window.matchMedia, if present. Otherwise, gives 1.0.
 *
 * This function is cached so that the pixel ratio is calculated only once
 * and only calculated when first requested.
 *
 * @return {number} The number of actual pixels per virtual pixel.
 */
goog.dom.getPixelRatio = goog.functions.cacheReturnValue(function() {
  var win = goog.dom.getWindow();

  // devicePixelRatio does not work on Mobile firefox.
  // TODO(user): Enable this check on a known working mobile Gecko version.
  // Filed a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=896804
  var isFirefoxMobile = goog.userAgent.GECKO && goog.userAgent.MOBILE;

  if (goog.isDef(win.devicePixelRatio) && !isFirefoxMobile) {
    return win.devicePixelRatio;
  } else if (win.matchMedia) {
    return goog.dom.matchesPixelRatio_(.75) ||
           goog.dom.matchesPixelRatio_(1.5) ||
           goog.dom.matchesPixelRatio_(2) ||
           goog.dom.matchesPixelRatio_(3) || 1;
  }
  return 1;
});


/**
 * Calculates a mediaQuery to check if the current device supports the
 * given actual to virtual pixel ratio.
 * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
 * @return {number} pixelRatio if applicable, otherwise 0.
 * @private
 */
goog.dom.matchesPixelRatio_ = function(pixelRatio) {
  var win = goog.dom.getWindow();
  var query = ('(-webkit-min-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min-resolution: ' + pixelRatio + 'dppx)');
  return win.matchMedia(query).matches ? pixelRatio : 0;
};



/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function(opt_document) {
  /**
   * Reference to the document object to use
   * @type {!Document}
   * @private
   */
  this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function(document) {
  this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function() {
  return this.document_;
};


/**
 * Alias for {@code getElementById}. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function(element) {
  return goog.dom.getElementHelper_(this.document_, element);
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.DomHelper.prototype.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(this.document_, id);
};


/**
 * Alias for {@code getElement}.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name or * for all tags.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag,
                                                                     opt_class,
                                                                     opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag,
                                                opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Element|Document)=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementByClass(className, doc);
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(!Element|!Document)=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item found with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.DomHelper.prototype.getRequiredElementByClass = function(className,
                                                                  opt_root) {
  var root = opt_root || this.document_;
  return goog.dom.getRequiredElementByClass(className, root);
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument. That breaks the rule of a
  // a DomHelper representing a single frame/window/document.
  return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the document.
 */
goog.dom.DomHelper.prototype.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom('div', null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.DomHelper.prototype.createDom = function(tagName,
                                                  opt_attributes,
                                                  var_args) {
  return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(Object|string)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
 *     text nodes.  If one of the var_args is an array, its children will be
 *     added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.DomHelper.prototype.createElement = function(name) {
  return this.document_.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function(content) {
  return this.document_.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.DomHelper.prototype.createTable = function(rows, columns,
    opt_fillWithNbsp) {
  return goog.dom.createTable_(this.document_, rows, columns,
      !!opt_fillWithNbsp);
};


/**
 * Converts an HTML string into a node or a document fragment.  A single Node
 * is used if the {@code htmlString} only generates a single node.  If the
 * {@code htmlString} generates multiple nodes then these are put inside a
 * {@code DocumentFragment}.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.DomHelper.prototype.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(this.document_, htmlString);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.DomHelper.prototype.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(this.document_);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function() {
  return goog.dom.getWindow_(this.document_);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.DomHelper.prototype.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(this.document_);
};


/**
 * Gets the document scroll distance as a coordinate object.
 * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
 */
goog.dom.DomHelper.prototype.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(this.document_);
};


/**
 * Determines the active element in the given document.
 * @param {Document=} opt_doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {
  return goog.dom.getActiveElement(opt_doc || this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getFirstElementChild =
    goog.dom.getFirstElementChild;


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getNextElementSibling =
    goog.dom.getNextElementSibling;


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.DomHelper.prototype.getPreviousElementSibling =
    goog.dom.getPreviousElementSibling;


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Cross browser function for getting the document element of an iframe.
 * @param {Element} iframe Iframe element.
 * @return {!Document} The frame content document.
 */
goog.dom.DomHelper.prototype.getFrameContentDocument =
    goog.dom.getFrameContentDocument;


/**
 * Cross browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.DomHelper.prototype.getFrameContentWindow =
    goog.dom.getFrameContentWindow;


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;


/**
 * Finds the first descendant node that matches the filter function. This does
 * a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;


/**
 * Finds all the descendant nodes that matches the filter function. This does a
 * depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Array.<Node>} The found nodes or an empty array if none are found.
 */
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.DomHelper.prototype.setFocusableTabIndex =
    goog.dom.setFocusableTabIndex;


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by
 * {@code goog.dom.getNodeTextLength}.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =
    goog.dom.getAncestorByTagNameAndClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} class The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.DomHelper.prototype.getAncestorByClass =
    goog.dom.getAncestorByClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides utility methods to render soy template.
 */

goog.provide('goog.soy');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.soy.data.SanitizedContent');
goog.require('goog.soy.data.SanitizedContentKind');
goog.require('goog.string');


/**
 * @define {boolean} Whether to require all Soy templates to be "strict html".
 * Soy templates that use strict autoescaping forbid noAutoescape along with
 * many dangerous directives, and return a runtime type SanitizedContent that
 * marks them as safe.
 *
 * If this flag is enabled, Soy templates will fail to render if a template
 * returns plain text -- indicating it is a non-strict template.
 */
goog.define('goog.soy.REQUIRE_STRICT_AUTOESCAPE', false);


/**
 * Renders a Soy template and then set the output string as
 * the innerHTML of an element. It is recommended to use this helper function
 * instead of directly setting innerHTML in your hand-written code, so that it
 * will be easier to audit the code for cross-site scripting vulnerabilities.
 *
 * @param {Element} element The element whose content we are rendering into.
 * @param {null|function(ARG_TYPES, null=, Object.<string, *>=):*} template
 *     The Soy template defining the element's content.
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @template ARG_TYPES
 */
goog.soy.renderElement = function(element, template, opt_templateData,
                                  opt_injectedData) {
  // Soy template parameter is only nullable for historical reasons.
  goog.asserts.assert(template, 'Soy template may not be null.');
  element.innerHTML = goog.soy.ensureTemplateOutputHtml_(template(
      opt_templateData || goog.soy.defaultTemplateData_, undefined,
      opt_injectedData));
};


/**
 * Renders a Soy template into a single node or a document
 * fragment. If the rendered HTML string represents a single node, then that
 * node is returned (note that this is *not* a fragment, despite them name of
 * the method). Otherwise a document fragment is returned containing the
 * rendered nodes.
 *
 * @param {null|function(ARG_TYPES, null=, Object.<string, *>=):*} template
 *     The Soy template defining the element's content.
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @param {goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to {@code goog.dom.getDomHelper}.
 * @return {!Node} The resulting node or document fragment.
 * @template ARG_TYPES
 */
goog.soy.renderAsFragment = function(template, opt_templateData,
                                     opt_injectedData, opt_domHelper) {
  // Soy template parameter is only nullable for historical reasons.
  goog.asserts.assert(template, 'Soy template may not be null.');
  var dom = opt_domHelper || goog.dom.getDomHelper();
  var html = goog.soy.ensureTemplateOutputHtml_(
      template(opt_templateData || goog.soy.defaultTemplateData_,
               undefined, opt_injectedData));
  goog.soy.assertFirstTagValid_(html);
  return dom.htmlToDocumentFragment(html);
};


/**
 * Renders a Soy template into a single node. If the rendered
 * HTML string represents a single node, then that node is returned. Otherwise,
 * a DIV element is returned containing the rendered nodes.
 *
 * @param {null|function(ARG_TYPES, null=, Object.<string, *>=):*} template
 *     The Soy template defining the element's content.
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @param {goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to {@code goog.dom.getDomHelper}.
 * @return {!Element} Rendered template contents, wrapped in a parent DIV
 *     element if necessary.
 * @template ARG_TYPES
 */
goog.soy.renderAsElement = function(template, opt_templateData,
                                    opt_injectedData, opt_domHelper) {
  // Soy template parameter is only nullable for historical reasons.
  goog.asserts.assert(template, 'Soy template may not be null.');
  var dom = opt_domHelper || goog.dom.getDomHelper();
  var wrapper = dom.createElement(goog.dom.TagName.DIV);
  var html = goog.soy.ensureTemplateOutputHtml_(template(
      opt_templateData || goog.soy.defaultTemplateData_,
      undefined, opt_injectedData));
  goog.soy.assertFirstTagValid_(html);
  wrapper.innerHTML = html;

  // If the template renders as a single element, return it.
  if (wrapper.childNodes.length == 1) {
    var firstChild = wrapper.firstChild;
    if (firstChild.nodeType == goog.dom.NodeType.ELEMENT) {
      return /** @type {!Element} */ (firstChild);
    }
  }

  // Otherwise, return the wrapper DIV.
  return wrapper;
};


/**
 * Ensures the result is "safe" to insert as HTML.
 *
 * Note if the template has non-strict autoescape, the guarantees here are very
 * weak. It is recommended applications switch to requiring strict
 * autoescaping over time by tweaking goog.soy.REQUIRE_STRICT_AUTOESCAPE.
 *
 * In the case the argument is a SanitizedContent object, it either must
 * already be of kind HTML, or if it is kind="text", the output will be HTML
 * escaped.
 *
 * @param {*} templateResult The template result.
 * @return {string} The assumed-safe HTML output string.
 * @private
 */
goog.soy.ensureTemplateOutputHtml_ = function(templateResult) {
  // Allow strings as long as strict autoescaping is not mandated. Note we
  // allow everything that isn't an object, because some non-escaping templates
  // end up returning non-strings if their only print statement is a
  // non-escaped argument, plus some unit tests spoof templates.
  // TODO(gboyer): Track down and fix these cases.
  if (!goog.soy.REQUIRE_STRICT_AUTOESCAPE && !goog.isObject(templateResult)) {
    return String(templateResult);
  }

  // Allow SanitizedContent of kind HTML.
  if (templateResult instanceof goog.soy.data.SanitizedContent) {
    templateResult = /** @type {!goog.soy.data.SanitizedContent} */ (
        templateResult);
    var ContentKind = goog.soy.data.SanitizedContentKind;
    if (templateResult.contentKind === ContentKind.HTML) {
      return goog.asserts.assertString(templateResult.content);
    }
    if (templateResult.contentKind === ContentKind.TEXT) {
      // Allow text to be rendered, as long as we escape it. Other content
      // kinds will fail, since we don't know what to do with them.
      // TODO(gboyer): Perhaps also include URI in this case.
      return goog.string.htmlEscape(templateResult.content);
    }
  }

  goog.asserts.fail('Soy template output is unsafe for use as HTML: ' +
      templateResult);

  // In production, return a safe string, rather than failing hard.
  return 'zSoyz';
};


/**
 * Checks that the rendered HTML does not start with an invalid tag that would
 * likely cause unexpected output from renderAsElement or renderAsFragment.
 * See {@link http://www.w3.org/TR/html5/semantics.html#semantics} for reference
 * as to which HTML elements can be parents of each other.
 * @param {string} html The output of a template.
 * @private
 */
goog.soy.assertFirstTagValid_ = function(html) {
  if (goog.asserts.ENABLE_ASSERTS) {
    var matches = html.match(goog.soy.INVALID_TAG_TO_RENDER_);
    goog.asserts.assert(!matches, 'This template starts with a %s, which ' +
        'cannot be a child of a <div>, as required by soy internals. ' +
        'Consider using goog.soy.renderElement instead.\nTemplate output: %s',
        matches && matches[0], html);
  }
};


/**
 * A pattern to find templates that cannot be rendered by renderAsElement or
 * renderAsFragment, as these elements cannot exist as the child of a <div>.
 * @type {!RegExp}
 * @private
 */
goog.soy.INVALID_TAG_TO_RENDER_ =
    /^<(body|caption|col|colgroup|head|html|tr|td|tbody|thead|tfoot)>/i;


/**
 * Immutable object that is passed into templates that are rendered
 * without any data.
 * @type {Object}
 * @private
 */
goog.soy.defaultTemplateData_ = {};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides inversion and inversion map functionality for storing
 * integer ranges and corresponding values.
 *
 */

goog.provide('goog.structs.InversionMap');

goog.require('goog.array');



/**
 * Maps ranges to values.
 * @param {Array.<number>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {Array.<T>} valueArray An array of corresponding values.
 *     Length must be the same as rangeArray.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 * @constructor
 * @template T
 */
goog.structs.InversionMap = function(rangeArray, valueArray, opt_delta) {
  /**
   * @protected {Array}
   */
  this.rangeArray = null;

  if (rangeArray.length != valueArray.length) {
    // rangeArray and valueArray has to match in number of entries.
    return null;
  }
  this.storeInversion_(rangeArray, opt_delta);

  /** @protected {Array.<T>} */
  this.values = valueArray;
};


/**
 * Stores the integers as ranges (half-open).
 * If delta is true, the integers are delta from the previous value and
 * will be restored to the absolute value.
 * When used as a set, even indices are IN, and odd are OUT.
 * @param {Array.<number?>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 * @private
 */
goog.structs.InversionMap.prototype.storeInversion_ = function(rangeArray,
    opt_delta) {
  this.rangeArray = rangeArray;

  for (var i = 1; i < rangeArray.length; i++) {
    if (rangeArray[i] == null) {
      rangeArray[i] = rangeArray[i - 1] + 1;
    } else if (opt_delta) {
      rangeArray[i] += rangeArray[i - 1];
    }
  }
};


/**
 * Splices a range -> value map into this inversion map.
 * @param {Array.<number>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {Array.<T>} valueArray An array of corresponding values.
 *     Length must be the same as rangeArray.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 */
goog.structs.InversionMap.prototype.spliceInversion = function(
    rangeArray, valueArray, opt_delta) {
  // By building another inversion map, we build the arrays that we need
  // to splice in.
  var otherMap = new goog.structs.InversionMap(
      rangeArray, valueArray, opt_delta);

  // Figure out where to splice those arrays.
  var startRange = otherMap.rangeArray[0];
  var endRange =
      /** @type {number} */ (goog.array.peek(otherMap.rangeArray));
  var startSplice = this.getLeast(startRange);
  var endSplice = this.getLeast(endRange);

  // The inversion map works by storing the start points of ranges...
  if (startRange != this.rangeArray[startSplice]) {
    // ...if we're splicing in a start point that isn't already here,
    // then we need to insert it after the insertion point.
    startSplice++;
  } // otherwise we overwrite the insertion point.

  var spliceLength = endSplice - startSplice + 1;
  goog.partial(goog.array.splice, this.rangeArray, startSplice,
      spliceLength).apply(null, otherMap.rangeArray);
  goog.partial(goog.array.splice, this.values, startSplice,
      spliceLength).apply(null, otherMap.values);
};


/**
 * Gets the value corresponding to a number from the inversion map.
 * @param {number} intKey The number for which value needs to be retrieved
 *     from inversion map.
 * @return {T|null} Value retrieved from inversion map; null if not found.
 */
goog.structs.InversionMap.prototype.at = function(intKey) {
  var index = this.getLeast(intKey);
  if (index < 0) {
    return null;
  }
  return this.values[index];
};


/**
 * Gets the largest index such that rangeArray[index] <= intKey from the
 * inversion map.
 * @param {number} intKey The probe for which rangeArray is searched.
 * @return {number} Largest index such that rangeArray[index] <= intKey.
 * @protected
 */
goog.structs.InversionMap.prototype.getLeast = function(intKey) {
  var arr = this.rangeArray;
  var low = 0;
  var high = arr.length;
  while (high - low > 8) {
    var mid = (high + low) >> 1;
    if (arr[mid] <= intKey) {
      low = mid;
    } else {
      high = mid;
    }
  }
  for (; low < high; ++low) {
    if (intKey < arr[low]) {
      break;
    }
  }
  return low - 1;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Detect Grapheme Cluster Break in a pair of codepoints. Follows
 * Unicode 5.1 UAX#29. Tailoring for Virama  Indic Consonants is used.
 *
 */

goog.provide('goog.i18n.GraphemeBreak');
goog.require('goog.structs.InversionMap');


/**
 * Enum for all Grapheme Cluster Break properties.
 * These enums directly corresponds to Grapheme_Cluster_Break property values
 * mentioned in http://unicode.org/reports/tr29 table 2. VIRAMA and
 * INDIC_CONSONANT are for the Virama  Base tailoring mentioned in the notes.
 *
 * CR and LF are moved to the bottom of the list because they occur only once
 * and so good candidates to take 2 decimal digit values.
 * @enum {number}
 * @protected
 */
goog.i18n.GraphemeBreak.property = {
  ANY: 0,
  CONTROL: 1,
  EXTEND: 2,
  PREPEND: 3,
  SPACING_MARK: 4,
  INDIC_CONSONANT: 5,
  VIRAMA: 6,
  L: 7,
  V: 8,
  T: 9,
  LV: 10,
  LVT: 11,
  CR: 12,
  LF: 13,
  REGIONAL_INDICATOR: 14
};


/**
 * Grapheme Cluster Break property values for all codepoints as inversion map.
 * Constructed lazily.
 *
 * @type {goog.structs.InversionMap}
 * @private
 */
goog.i18n.GraphemeBreak.inversions_ = null;


/**
 * There are two kinds of grapheme clusters: 1) Legacy 2)Extended. This method
 * is to check for legacy rules.
 *
 * @param {number} prop_a The property enum value of the first character.
 * @param {number} prop_b The property enum value of the second character.
 * @return {boolean} True if a & b do not form a cluster; False otherwise.
 * @private
 */
goog.i18n.GraphemeBreak.applyLegacyBreakRules_ = function(prop_a, prop_b) {

  var prop = goog.i18n.GraphemeBreak.property;

  if (prop_a == prop.CR && prop_b == prop.LF) {
    return false;
  }
  if (prop_a == prop.CONTROL || prop_a == prop.CR || prop_a == prop.LF) {
    return true;
  }
  if (prop_b == prop.CONTROL || prop_b == prop.CR || prop_b == prop.LF) {
    return true;
  }
  if ((prop_a == prop.L) &&
      (prop_b == prop.L || prop_b == prop.V ||
      prop_b == prop.LV || prop_b == prop.LVT)) {
    return false;
  }
  if ((prop_a == prop.LV || prop_a == prop.V) &&
      (prop_b == prop.V || prop_b == prop.T)) {
    return false;
  }
  if ((prop_a == prop.LVT || prop_a == prop.T) && (prop_b == prop.T)) {
    return false;
  }
  if (prop_b == prop.EXTEND || prop_b == prop.VIRAMA) {
    return false;
  }
  if (prop_a == prop.VIRAMA && prop_b == prop.INDIC_CONSONANT) {
    return false;
  }
  return true;
};


/**
 * Method to return property enum value of the codepoint. If it is Hangul LV or
 * LVT, then it is computed; for the rest it is picked from the inversion map.
 * @param {number} acode The code point value of the character.
 * @return {number} Property enum value of codepoint.
 * @private
 */
goog.i18n.GraphemeBreak.getBreakProp_ = function(acode) {
  if (0xAC00 <= acode && acode <= 0xD7A3) {
    var prop = goog.i18n.GraphemeBreak.property;
    if (acode % 0x1C == 0x10) {
      return prop.LV;
    }
    return prop.LVT;
  } else {
    if (!goog.i18n.GraphemeBreak.inversions_) {
      goog.i18n.GraphemeBreak.inversions_ = new goog.structs.InversionMap(
          [0, 10, 1, 2, 1, 18, 95, 33, 13, 1, 594, 112, 275, 7, 263, 45, 1, 1,
           1, 2, 1, 2, 1, 1, 56, 5, 11, 11, 48, 21, 16, 1, 101, 7, 1, 1, 6, 2,
           2, 1, 4, 33, 1, 1, 1, 30, 27, 91, 11, 58, 9, 34, 4, 1, 9, 1, 3, 1,
           5, 43, 3, 136, 31, 1, 17, 37, 1, 1, 1, 1, 3, 8, 4, 1, 2, 1, 7, 8, 2,
           2, 21, 8, 1, 2, 17, 39, 1, 1, 1, 2, 6, 6, 1, 9, 5, 4, 2, 2, 12, 2,
           15, 2, 1, 17, 39, 2, 3, 12, 4, 8, 6, 17, 2, 3, 14, 1, 17, 39, 1, 1,
           3, 8, 4, 1, 20, 2, 29, 1, 2, 17, 39, 1, 1, 2, 1, 6, 6, 9, 6, 4, 2,
           2, 13, 1, 16, 1, 18, 41, 1, 1, 1, 12, 1, 9, 1, 41, 3, 17, 37, 4, 3,
           5, 7, 8, 3, 2, 8, 2, 30, 2, 17, 39, 1, 1, 1, 1, 2, 1, 3, 1, 5, 1, 8,
           9, 1, 3, 2, 30, 2, 17, 38, 3, 1, 2, 5, 7, 1, 9, 1, 10, 2, 30, 2, 22,
           48, 5, 1, 2, 6, 7, 19, 2, 13, 46, 2, 1, 1, 1, 6, 1, 12, 8, 50, 46,
           2, 1, 1, 1, 9, 11, 6, 14, 2, 58, 2, 27, 1, 1, 1, 1, 1, 4, 2, 49, 14,
           1, 4, 1, 1, 2, 5, 48, 9, 1, 57, 33, 12, 4, 1, 6, 1, 2, 2, 2, 1, 16,
           2, 4, 2, 2, 4, 3, 1, 3, 2, 7, 3, 4, 13, 1, 1, 1, 2, 6, 1, 1, 14, 1,
           98, 96, 72, 88, 349, 3, 931, 15, 2, 1, 14, 15, 2, 1, 14, 15, 2, 15,
           15, 14, 35, 17, 2, 1, 7, 8, 1, 2, 9, 1, 1, 9, 1, 45, 3, 155, 1, 87,
           31, 3, 4, 2, 9, 1, 6, 3, 20, 19, 29, 44, 9, 3, 2, 1, 69, 23, 2, 3,
           4, 45, 6, 2, 1, 1, 1, 8, 1, 1, 1, 2, 8, 6, 13, 128, 4, 1, 14, 33, 1,
           1, 5, 1, 1, 5, 1, 1, 1, 7, 31, 9, 12, 2, 1, 7, 23, 1, 4, 2, 2, 2, 2,
           2, 11, 3, 2, 36, 2, 1, 1, 2, 3, 1, 1, 3, 2, 12, 36, 8, 8, 2, 2, 21,
           3, 128, 3, 1, 13, 1, 7, 4, 1, 4, 2, 1, 203, 64, 523, 1, 2, 2, 24, 7,
           49, 16, 96, 33, 3070, 3, 141, 1, 96, 32, 554, 6, 105, 2, 30164, 4,
           1, 10, 33, 1, 80, 2, 272, 1, 3, 1, 4, 1, 23, 2, 2, 1, 24, 30, 4, 4,
           3, 8, 1, 1, 13, 2, 16, 34, 16, 1, 27, 18, 24, 24, 4, 8, 2, 23, 11,
           1, 1, 12, 32, 3, 1, 5, 3, 3, 36, 1, 2, 4, 2, 1, 3, 1, 69, 35, 6, 2,
           2, 2, 2, 12, 1, 8, 1, 1, 18, 16, 1, 3, 6, 1, 5, 48, 1, 1, 3, 2, 2,
           5, 2, 1, 1, 32, 9, 1, 2, 2, 5, 1, 1, 201, 14, 2, 1, 1, 9, 8, 2, 1,
           2, 1, 2, 1, 1, 1, 18, 11184, 27, 49, 1028, 1024, 6942, 1, 737, 16,
           16, 7, 216, 1, 158, 2, 89, 3, 513, 1, 2051, 15, 40, 7, 1, 1472, 1,
           1, 1, 53, 14, 1, 57, 2, 1, 45, 3, 4, 2, 1, 1, 2, 1, 66, 3, 36, 5, 1,
           6, 2, 75, 2, 1, 48, 3, 9, 1, 1, 1258, 1, 1, 1, 2, 6, 1, 1, 22681,
           62, 4, 25042, 1, 1, 3, 3, 1, 5, 8, 8, 2, 7, 30, 4, 148, 3, 8097, 26,
           790017, 255],
          [1, 13, 1, 12, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
           2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 1, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0,
           2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 4, 0, 5, 2, 4, 2,
           0, 4, 2, 4, 6, 4, 0, 2, 5, 0, 2, 0, 5, 2, 4, 0, 5, 2, 0, 2, 4, 2, 4,
           6, 0, 2, 5, 0, 2, 0, 5, 0, 2, 4, 0, 5, 2, 4, 2, 6, 2, 5, 0, 2, 0, 2,
           4, 0, 5, 2, 0, 4, 2, 4, 6, 0, 2, 0, 2, 4, 0, 5, 2, 0, 2, 4, 2, 4, 6,
           2, 5, 0, 2, 0, 5, 0, 2, 0, 5, 2, 4, 2, 4, 6, 0, 2, 0, 4, 0, 5, 0, 2,
           4, 2, 6, 2, 5, 0, 2, 0, 4, 0, 5, 2, 0, 4, 2, 4, 2, 4, 2, 4, 2, 6, 2,
           5, 0, 2, 0, 4, 0, 5, 0, 2, 4, 2, 4, 6, 0, 2, 0, 2, 0, 4, 0, 5, 6, 2,
           4, 2, 4, 2, 4, 0, 5, 0, 2, 0, 4, 2, 6, 0, 2, 0, 5, 0, 2, 0, 4, 2, 0,
           2, 0, 5, 0, 2, 0, 2, 0, 2, 0, 2, 0, 4, 5, 2, 4, 2, 6, 0, 2, 0, 2, 0,
           2, 0, 5, 0, 2, 4, 2, 0, 6, 4, 2, 5, 0, 5, 0, 4, 2, 5, 2, 5, 0, 5, 0,
           5, 2, 5, 2, 0, 4, 2, 0, 2, 5, 0, 2, 0, 7, 8, 9, 0, 2, 0, 5, 2, 6, 0,
           5, 2, 6, 0, 5, 2, 0, 5, 2, 5, 0, 2, 4, 2, 4, 2, 4, 2, 6, 2, 0, 2, 0,
           2, 0, 2, 0, 5, 2, 4, 2, 4, 2, 4, 2, 0, 5, 0, 5, 0, 4, 0, 4, 0, 5, 2,
           4, 0, 5, 0, 5, 4, 2, 4, 2, 6, 0, 2, 0, 2, 4, 2, 0, 2, 4, 0, 5, 2, 4,
           2, 4, 2, 4, 2, 4, 6, 5, 0, 2, 0, 2, 4, 0, 5, 4, 2, 4, 2, 6, 4, 5, 0,
           5, 0, 5, 0, 2, 4, 2, 4, 2, 4, 2, 6, 0, 5, 4, 2, 4, 2, 0, 5, 0, 2, 0,
           2, 4, 2, 0, 2, 0, 4, 2, 0, 2, 0, 1, 2, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0,
           6, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 6, 5, 2, 5, 4,
           2, 4, 0, 5, 0, 5, 0, 5, 0, 5, 0, 4, 0, 5, 4, 6, 0, 2, 0, 5, 0, 2, 0,
           5, 2, 4, 6, 0, 7, 2, 4, 0, 5, 0, 5, 2, 4, 2, 4, 2, 4, 6, 0, 5, 2, 4,
           2, 4, 2, 0, 2, 0, 2, 4, 0, 5, 0, 5, 0, 5, 0, 5, 2, 0, 2, 0, 2, 0, 2,
           0, 2, 0, 5, 4, 2, 4, 0, 4, 6, 0, 5, 0, 5, 0, 5, 0, 4, 2, 4, 2, 4, 0,
           4, 6, 0, 11, 8, 9, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 1, 0, 2,
           0, 2, 0, 2, 6, 0, 4, 2, 4, 0, 2, 6, 0, 2, 4, 0, 4, 2, 4, 6, 2, 0, 1,
           0, 2, 0, 2, 4, 2, 6, 0, 2, 4, 0, 4, 2, 4, 6, 0, 2, 4, 2, 4, 2, 6, 2,
           0, 4, 2, 0, 2, 4, 2, 0, 4, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 14, 0, 1,
           2],
          true);
    }
    return /** @type {number} */ (
        goog.i18n.GraphemeBreak.inversions_.at(acode));
  }
};


/**
 * There are two kinds of grapheme clusters: 1) Legacy 2)Extended. This method
 * is to check for both using a boolean flag to switch between them.
 * @param {number} a The code point value of the first character.
 * @param {number} b The code point value of the second character.
 * @param {boolean=} opt_extended If true, indicates extended grapheme cluster;
 *     If false, indicates legacy cluster.
 * @return {boolean} True if a & b do not form a cluster; False otherwise.
 */
goog.i18n.GraphemeBreak.hasGraphemeBreak = function(a, b, opt_extended) {

  var prop_a = goog.i18n.GraphemeBreak.getBreakProp_(a);
  var prop_b = goog.i18n.GraphemeBreak.getBreakProp_(b);
  var prop = goog.i18n.GraphemeBreak.property;

  return goog.i18n.GraphemeBreak.applyLegacyBreakRules_(prop_a, prop_b) &&
      !(opt_extended &&
          (prop_a == prop.PREPEND || prop_b == prop.SPACING_MARK));
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides utility functions for formatting strings, numbers etc.
 *
 */

goog.provide('goog.format');

goog.require('goog.i18n.GraphemeBreak');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Formats a number of bytes in human readable form.
 * 54, 450K, 1.3M, 5G etc.
 * @param {number} bytes The number of bytes to show.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @return {string} The human readable form of the byte size.
 */
goog.format.fileSize = function(bytes, opt_decimals) {
  return goog.format.numBytesToString(bytes, opt_decimals, false);
};


/**
 * Checks whether string value containing scaling units (K, M, G, T, P, m,
 * u, n) can be converted to a number.
 *
 * Where there is a decimal, there must be a digit to the left of the
 * decimal point.
 *
 * Negative numbers are valid.
 *
 * Examples:
 *   0, 1, 1.0, 10.4K, 2.3M, -0.3P, 1.2m
 *
 * @param {string} val String value to check.
 * @return {boolean} True if string could be converted to a numeric value.
 */
goog.format.isConvertableScaledNumber = function(val) {
  return goog.format.SCALED_NUMERIC_RE_.test(val);
};


/**
 * Converts a string to numeric value, taking into account the units.
 * If string ends in 'B', use binary conversion.
 * @param {string} stringValue String to be converted to numeric value.
 * @return {number} Numeric value for string.
 */
goog.format.stringToNumericValue = function(stringValue) {
  if (goog.string.endsWith(stringValue, 'B')) {
    return goog.format.stringToNumericValue_(
        stringValue, goog.format.NUMERIC_SCALES_BINARY_);
  }
  return goog.format.stringToNumericValue_(
      stringValue, goog.format.NUMERIC_SCALES_SI_);
};


/**
 * Converts a string to number of bytes, taking into account the units.
 * Binary conversion.
 * @param {string} stringValue String to be converted to numeric value.
 * @return {number} Numeric value for string.
 */
goog.format.stringToNumBytes = function(stringValue) {
  return goog.format.stringToNumericValue_(
      stringValue, goog.format.NUMERIC_SCALES_BINARY_);
};


/**
 * Converts a numeric value to string representation. SI conversion.
 * @param {number} val Value to be converted.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @return {string} String representation of number.
 */
goog.format.numericValueToString = function(val, opt_decimals) {
  return goog.format.numericValueToString_(
      val, goog.format.NUMERIC_SCALES_SI_, opt_decimals);
};


/**
 * Converts number of bytes to string representation. Binary conversion.
 * Default is to return the additional 'B' suffix, e.g. '10.5KB' to minimize
 * confusion with counts that are scaled by powers of 1000.
 * @param {number} val Value to be converted.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @param {boolean=} opt_suffix If true, include trailing 'B' in returned
 *     string.  Default is true.
 * @param {boolean=} opt_useSeparator If true, number and scale will be
 *     separated by a no break space. Default is false.
 * @return {string} String representation of number of bytes.
 */
goog.format.numBytesToString = function(val, opt_decimals, opt_suffix,
    opt_useSeparator) {
  var suffix = '';
  if (!goog.isDef(opt_suffix) || opt_suffix) {
    suffix = 'B';
  }
  return goog.format.numericValueToString_(
      val, goog.format.NUMERIC_SCALES_BINARY_, opt_decimals, suffix,
      opt_useSeparator);
};


/**
 * Converts a string to numeric value, taking into account the units.
 * @param {string} stringValue String to be converted to numeric value.
 * @param {Object} conversion Dictionary of conversion scales.
 * @return {number} Numeric value for string.  If it cannot be converted,
 *    returns NaN.
 * @private
 */
goog.format.stringToNumericValue_ = function(stringValue, conversion) {
  var match = stringValue.match(goog.format.SCALED_NUMERIC_RE_);
  if (!match) {
    return NaN;
  }
  var val = match[1] * conversion[match[2]];
  return val;
};


/**
 * Converts a numeric value to string, using specified conversion
 * scales.
 * @param {number} val Value to be converted.
 * @param {Object} conversion Dictionary of scaling factors.
 * @param {number=} opt_decimals The number of decimals to use.  Default is 2.
 * @param {string=} opt_suffix Optional suffix to append.
 * @param {boolean=} opt_useSeparator If true, number and scale will be
 *     separated by a space. Default is false.
 * @return {string} The human readable form of the byte size.
 * @private
 */
goog.format.numericValueToString_ = function(val, conversion,
    opt_decimals, opt_suffix, opt_useSeparator) {
  var prefixes = goog.format.NUMERIC_SCALE_PREFIXES_;
  var orig_val = val;
  var symbol = '';
  var separator = '';
  var scale = 1;
  if (val < 0) {
    val = -val;
  }
  for (var i = 0; i < prefixes.length; i++) {
    var unit = prefixes[i];
    scale = conversion[unit];
    if (val >= scale || (scale <= 1 && val > 0.1 * scale)) {
      // Treat values less than 1 differently, allowing 0.5 to be "0.5" rather
      // than "500m"
      symbol = unit;
      break;
    }
  }
  if (!symbol) {
    scale = 1;
  } else {
    if (opt_suffix) {
      symbol += opt_suffix;
    }
    if (opt_useSeparator) {
      separator = ' ';
    }
  }
  var ex = Math.pow(10, goog.isDef(opt_decimals) ? opt_decimals : 2);
  return Math.round(orig_val / scale * ex) / ex + separator + symbol;
};


/**
 * Regular expression for detecting scaling units, such as K, M, G, etc. for
 * converting a string representation to a numeric value.
 *
 * Also allow 'k' to be aliased to 'K'.  These could be used for SI (powers
 * of 1000) or Binary (powers of 1024) conversions.
 *
 * Also allow final 'B' to be interpreted as byte-count, implicitly triggering
 * binary conversion (e.g., '10.2MB').
 *
 * @type {RegExp}
 * @private
 */
goog.format.SCALED_NUMERIC_RE_ = /^([-]?\d+\.?\d*)([K,M,G,T,P,k,m,u,n]?)[B]?$/;


/**
 * Ordered list of scaling prefixes in decreasing order.
 * @type {Array}
 * @private
 */
goog.format.NUMERIC_SCALE_PREFIXES_ = [
  'P', 'T', 'G', 'M', 'K', '', 'm', 'u', 'n'
];


/**
 * Scaling factors for conversion of numeric value to string.  SI conversion.
 * @type {Object}
 * @private
 */
goog.format.NUMERIC_SCALES_SI_ = {
  '': 1,
  'n': 1e-9,
  'u': 1e-6,
  'm': 1e-3,
  'k': 1e3,
  'K': 1e3,
  'M': 1e6,
  'G': 1e9,
  'T': 1e12,
  'P': 1e15
};


/**
 * Scaling factors for conversion of numeric value to string.  Binary
 * conversion.
 * @type {Object}
 * @private
 */
goog.format.NUMERIC_SCALES_BINARY_ = {
  '': 1,
  'n': Math.pow(1024, -3),
  'u': Math.pow(1024, -2),
  'm': 1.0 / 1024,
  'k': 1024,
  'K': 1024,
  'M': Math.pow(1024, 2),
  'G': Math.pow(1024, 3),
  'T': Math.pow(1024, 4),
  'P': Math.pow(1024, 5)
};


/**
 * First Unicode code point that has the Mark property.
 * @type {number}
 * @private
 */
goog.format.FIRST_GRAPHEME_EXTEND_ = 0x300;


/**
 * Returns true if and only if given character should be treated as a breaking
 * space. All ASCII control characters, the main Unicode range of spacing
 * characters (U+2000 to U+200B inclusive except for U+2007), and several other
 * Unicode space characters are treated as breaking spaces.
 * @param {number} charCode The character code under consideration.
 * @return {boolean} True if the character is a breaking space.
 * @private
 */
goog.format.isTreatedAsBreakingSpace_ = function(charCode) {
  return (charCode <= goog.format.WbrToken_.SPACE) ||
         (charCode >= 0x1000 &&
          ((charCode >= 0x2000 && charCode <= 0x2006) ||
           (charCode >= 0x2008 && charCode <= 0x200B) ||
           charCode == 0x1680 ||
           charCode == 0x180E ||
           charCode == 0x2028 ||
           charCode == 0x2029 ||
           charCode == 0x205f ||
           charCode == 0x3000));
};


/**
 * Returns true if and only if given character is an invisible formatting
 * character.
 * @param {number} charCode The character code under consideration.
 * @return {boolean} True if the character is an invisible formatting character.
 * @private
 */
goog.format.isInvisibleFormattingCharacter_ = function(charCode) {
  // See: http://unicode.org/charts/PDF/U2000.pdf
  return (charCode >= 0x200C && charCode <= 0x200F) ||
         (charCode >= 0x202A && charCode <= 0x202E);
};


/**
 * Inserts word breaks into an HTML string at a given interval.  The counter is
 * reset if a space or a character which behaves like a space is encountered,
 * but it isn't incremented if an invisible formatting character is encountered.
 * WBRs aren't inserted into HTML tags or entities.  Entities count towards the
 * character count, HTML tags do not.
 *
 * With common strings aliased, objects allocations are constant based on the
 * length of the string: N + 3. This guarantee does not hold if the string
 * contains an element >= U+0300 and hasGraphemeBreak is non-trivial.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {function(number, number, boolean): boolean} hasGraphemeBreak A
 *     function determining if there is a grapheme break between two characters,
 *     in the same signature as goog.i18n.GraphemeBreak.hasGraphemeBreak.
 * @param {number=} opt_maxlen Maximum length after which to ensure
 *     there is a break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 * @private
 */
goog.format.insertWordBreaksGeneric_ = function(str, hasGraphemeBreak,
    opt_maxlen) {
  var maxlen = opt_maxlen || 10;
  if (maxlen > str.length) return str;

  var rv = [];
  var n = 0; // The length of the current token

  // This will contain the ampersand or less-than character if one of the
  // two has been seen; otherwise, the value is zero.
  var nestingCharCode = 0;

  // First character position from input string that has not been outputted.
  var lastDumpPosition = 0;

  var charCode = 0;
  for (var i = 0; i < str.length; i++) {
    // Using charCodeAt versus charAt avoids allocating new string objects.
    var lastCharCode = charCode;
    charCode = str.charCodeAt(i);

    // Don't add a WBR before characters that might be grapheme extending.
    var isPotentiallyGraphemeExtending =
        charCode >= goog.format.FIRST_GRAPHEME_EXTEND_ &&
        !hasGraphemeBreak(lastCharCode, charCode, true);

    // Don't add a WBR at the end of a word. For the purposes of determining
    // work breaks, all ASCII control characters and some commonly encountered
    // Unicode spacing characters are treated as breaking spaces.
    if (n >= maxlen &&
        !goog.format.isTreatedAsBreakingSpace_(charCode) &&
        !isPotentiallyGraphemeExtending) {
      // Flush everything seen so far, and append a word break.
      rv.push(str.substring(lastDumpPosition, i), goog.format.WORD_BREAK_HTML);
      lastDumpPosition = i;
      n = 0;
    }

    if (!nestingCharCode) {
      // Not currently within an HTML tag or entity

      if (charCode == goog.format.WbrToken_.LT ||
          charCode == goog.format.WbrToken_.AMP) {

        // Entering an HTML Entity '&' or open tag '<'
        nestingCharCode = charCode;
      } else if (goog.format.isTreatedAsBreakingSpace_(charCode)) {

        // A space or control character -- reset the token length
        n = 0;
      } else if (!goog.format.isInvisibleFormattingCharacter_(charCode)) {

        // A normal flow character - increment.  For grapheme extending
        // characters, this is not *technically* a new character.  However,
        // since the grapheme break detector might be overly conservative,
        // we have to continue incrementing, or else we won't even be able
        // to add breaks when we get to things like punctuation.  For the
        // case where we have a full grapheme break detector, it is okay if
        // we occasionally break slightly early.
        n++;
      }
    } else if (charCode == goog.format.WbrToken_.GT &&
        nestingCharCode == goog.format.WbrToken_.LT) {

      // Leaving an HTML tag, treat the tag as zero-length
      nestingCharCode = 0;
    } else if (charCode == goog.format.WbrToken_.SEMI_COLON &&
        nestingCharCode == goog.format.WbrToken_.AMP) {

      // Leaving an HTML entity, treat it as length one
      nestingCharCode = 0;
      n++;
    }
  }

  // Take care of anything we haven't flushed so far.
  rv.push(str.substr(lastDumpPosition));

  return rv.join('');
};


/**
 * Inserts word breaks into an HTML string at a given interval.
 *
 * This method is as aggressive as possible, using a full table of Unicode
 * characters where it is legal to insert word breaks; however, this table
 * comes at a 2.5k pre-gzip (~1k post-gzip) size cost.  Consider using
 * insertWordBreaksBasic to minimize the size impact.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {number=} opt_maxlen Maximum length after which to ensure there is a
 *     break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 */
goog.format.insertWordBreaks = function(str, opt_maxlen) {
  return goog.format.insertWordBreaksGeneric_(str,
      goog.i18n.GraphemeBreak.hasGraphemeBreak, opt_maxlen);
};


/**
 * Determines conservatively if a character has a Grapheme break.
 *
 * Conforms to a similar signature as goog.i18n.GraphemeBreak, but is overly
 * conservative, returning true only for characters in common scripts that
 * are simple to account for.
 *
 * @param {number} lastCharCode The previous character code.  Ignored.
 * @param {number} charCode The character code under consideration.  It must be
 *     at least \u0300 as a precondition -- this case is covered by
 *     insertWordBreaksGeneric_.
 * @param {boolean=} opt_extended Ignored, to conform with the interface.
 * @return {boolean} Whether it is one of the recognized subsets of characters
 *     with a grapheme break.
 * @private
 */
goog.format.conservativelyHasGraphemeBreak_ = function(
    lastCharCode, charCode, opt_extended) {
  // Return false for everything except the most common Cyrillic characters.
  // Don't worry about Latin characters, because insertWordBreaksGeneric_
  // itself already handles those.
  // TODO(gboyer): Also account for Greek, Armenian, and Georgian if it is
  // simple to do so.
  return charCode >= 0x400 && charCode < 0x523;
};


// TODO(gboyer): Consider using a compile-time flag to switch implementations
// rather than relying on the developers to toggle implementations.
/**
 * Inserts word breaks into an HTML string at a given interval.
 *
 * This method is less aggressive than insertWordBreaks, only inserting
 * breaks next to punctuation and between Latin or Cyrillic characters.
 * However, this is good enough for the common case of URLs.  It also
 * works for all Latin and Cyrillic languages, plus CJK has no need for word
 * breaks.  When this method is used, goog.i18n.GraphemeBreak may be dead
 * code eliminated.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {number=} opt_maxlen Maximum length after which to ensure there is a
 *     break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 */
goog.format.insertWordBreaksBasic = function(str, opt_maxlen) {
  return goog.format.insertWordBreaksGeneric_(str,
      goog.format.conservativelyHasGraphemeBreak_, opt_maxlen);
};


/**
 * True iff the current userAgent is IE8 or above.
 * @type {boolean}
 * @private
 */
goog.format.IS_IE8_OR_ABOVE_ = goog.userAgent.IE &&
    goog.userAgent.isVersionOrHigher(8);


/**
 * Constant for the WBR replacement used by insertWordBreaks.  Safari requires
 * <wbr></wbr>, Opera needs the &shy; entity, though this will give a visible
 * hyphen at breaks.  IE8 uses a zero width space.
 * Other browsers just use <wbr>.
 * @type {string}
 */
goog.format.WORD_BREAK_HTML =
    goog.userAgent.WEBKIT ?
        '<wbr></wbr>' : goog.userAgent.OPERA ?
            '&shy;' : goog.format.IS_IE8_OR_ABOVE_ ?
                '&#8203;' : '<wbr>';


/**
 * Tokens used within insertWordBreaks.
 * @private
 * @enum {number}
 */
goog.format.WbrToken_ = {
  LT: 60, // '<'.charCodeAt(0)
  GT: 62, // '>'.charCodeAt(0)
  AMP: 38, // '&'.charCodeAt(0)
  SEMI_COLON: 59, // ';'.charCodeAt(0)
  SPACE: 32 // ' '.charCodeAt(0)
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility for formatting text for display in a potentially
 * opposite-directionality context without garbling.
 * Mostly a port of http://go/formatter.cc.
 */


goog.provide('goog.i18n.BidiFormatter');

goog.require('goog.i18n.bidi');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.Format');
goog.require('goog.string');



/**
 * Utility class for formatting text for display in a potentially
 * opposite-directionality context without garbling. Provides the following
 * functionality:
 *
 * 1. BiDi Wrapping
 * When text in one language is mixed into a document in another, opposite-
 * directionality language, e.g. when an English business name is embedded in a
 * Hebrew web page, both the inserted string and the text following it may be
 * displayed incorrectly unless the inserted string is explicitly separated
 * from the surrounding text in a "wrapper" that declares its directionality at
 * the start and then resets it back at the end. This wrapping can be done in
 * HTML mark-up (e.g. a 'span dir="rtl"' tag) or - only in contexts where
 * mark-up can not be used - in Unicode BiDi formatting codes (LRE|RLE and PDF).
 * Providing such wrapping services is the basic purpose of the BiDi formatter.
 *
 * 2. Directionality estimation
 * How does one know whether a string about to be inserted into surrounding
 * text has the same directionality? Well, in many cases, one knows that this
 * must be the case when writing the code doing the insertion, e.g. when a
 * localized message is inserted into a localized page. In such cases there is
 * no need to involve the BiDi formatter at all. In the remaining cases, e.g.
 * when the string is user-entered or comes from a database, the language of
 * the string (and thus its directionality) is not known a priori, and must be
 * estimated at run-time. The BiDi formatter does this automatically.
 *
 * 3. Escaping
 * When wrapping plain text - i.e. text that is not already HTML or HTML-
 * escaped - in HTML mark-up, the text must first be HTML-escaped to prevent XSS
 * attacks and other nasty business. This of course is always true, but the
 * escaping can not be done after the string has already been wrapped in
 * mark-up, so the BiDi formatter also serves as a last chance and includes
 * escaping services.
 *
 * Thus, in a single call, the formatter will escape the input string as
 * specified, determine its directionality, and wrap it as necessary. It is
 * then up to the caller to insert the return value in the output.
 *
 * See http://wiki/Main/TemplatesAndBiDi for more information.
 *
 * @param {goog.i18n.bidi.Dir|number|boolean|null} contextDir The context
 *     directionality, in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant. NEUTRAL is treated the same as null,
 *        i.e. unknown, for backward compatibility with legacy calls.
 *     2. A number (positive = LTR, negative = RTL, 0 = unknown).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @param {boolean=} opt_alwaysSpan Whether {@link #spanWrap} should always
 *     use a 'span' tag, even when the input directionality is neutral or
 *     matches the context, so that the DOM structure of the output does not
 *     depend on the combination of directionalities. Default: false.
 * @constructor
 * @final
 */
goog.i18n.BidiFormatter = function(contextDir, opt_alwaysSpan) {
  /**
   * The overall directionality of the context in which the formatter is being
   * used.
   * @type {?goog.i18n.bidi.Dir}
   * @private
   */
  this.contextDir_ = goog.i18n.bidi.toDir(contextDir, true /* opt_noNeutral */);

  /**
   * Whether {@link #spanWrap} and similar methods should always use the same
   * span structure, regardless of the combination of directionalities, for a
   * stable DOM structure.
   * @type {boolean}
   * @private
   */
  this.alwaysSpan_ = !!opt_alwaysSpan;
};


/**
 * @return {?goog.i18n.bidi.Dir} The context directionality.
 */
goog.i18n.BidiFormatter.prototype.getContextDir = function() {
  return this.contextDir_;
};


/**
 * @return {boolean} Whether alwaysSpan is set.
 */
goog.i18n.BidiFormatter.prototype.getAlwaysSpan = function() {
  return this.alwaysSpan_;
};


/**
 * @param {goog.i18n.bidi.Dir|number|boolean|null} contextDir The context
 *     directionality, in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant. NEUTRAL is treated the same as null,
 *        i.e. unknown.
 *     2. A number (positive = LTR, negative = RTL, 0 = unknown).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 */
goog.i18n.BidiFormatter.prototype.setContextDir = function(contextDir) {
  this.contextDir_ = goog.i18n.bidi.toDir(contextDir, true /* opt_noNeutral */);
};


/**
 * @param {boolean} alwaysSpan Whether {@link #spanWrap} should always use a
 *     'span' tag, even when the input directionality is neutral or matches the
 *     context, so that the DOM structure of the output does not depend on the
 *     combination of directionalities.
 */
goog.i18n.BidiFormatter.prototype.setAlwaysSpan = function(alwaysSpan) {
  this.alwaysSpan_ = alwaysSpan;
};


/**
 * Returns the directionality of input argument {@code str}.
 * Identical to {@link goog.i18n.bidi.estimateDirection}.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
 */
goog.i18n.BidiFormatter.prototype.estimateDirection =
    goog.i18n.bidi.estimateDirection;


/**
 * Returns true if two given directionalities are opposite.
 * Note: the implementation is based on the numeric values of the Dir enum.
 *
 * @param {?goog.i18n.bidi.Dir} dir1 1st directionality.
 * @param {?goog.i18n.bidi.Dir} dir2 2nd directionality.
 * @return {boolean} Whether the directionalities are opposite.
 * @private
 */
goog.i18n.BidiFormatter.prototype.areDirectionalitiesOpposite_ = function(dir1,
    dir2) {
  return dir1 * dir2 < 0;
};


/**
 * Returns a unicode BiDi mark matching the context directionality (LRM or
 * RLM) if {@code opt_dirReset}, and if either the directionality or the exit
 * directionality of {@code str} is opposite to the context directionality.
 * Otherwise returns the empty string.
 *
 * @param {string} str The input text.
 * @param {goog.i18n.bidi.Dir} dir {@code str}'s overall directionality.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to perform the reset. Default: false.
 * @return {string} A unicode BiDi mark or the empty string.
 * @private
 */
goog.i18n.BidiFormatter.prototype.dirResetIfNeeded_ = function(str, dir,
    opt_isHtml, opt_dirReset) {
  // endsWithRtl and endsWithLtr are called only if needed (short-circuit).
  if (opt_dirReset &&
      (this.areDirectionalitiesOpposite_(dir, this.contextDir_) ||
       (this.contextDir_ == goog.i18n.bidi.Dir.LTR &&
        goog.i18n.bidi.endsWithRtl(str, opt_isHtml)) ||
       (this.contextDir_ == goog.i18n.bidi.Dir.RTL &&
        goog.i18n.bidi.endsWithLtr(str, opt_isHtml)))) {
    return this.contextDir_ == goog.i18n.bidi.Dir.LTR ?
        goog.i18n.bidi.Format.LRM : goog.i18n.bidi.Format.RLM;
  } else {
    return '';
  }
};


/**
 * Returns "rtl" if {@code str}'s estimated directionality is RTL, and "ltr" if
 * it is LTR. In case it's NEUTRAL, returns "rtl" if the context directionality
 * is RTL, and "ltr" otherwise.
 * Needed for GXP, which can't handle dirAttr.
 * Example use case:
 * &lt;td expr:dir='bidiFormatter.dirAttrValue(foo)'&gt;
 *   &lt;gxp:eval expr='foo'&gt;
 * &lt;/td&gt;
 *
 * @param {string} str Text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} "rtl" or "ltr", according to the logic described above.
 */
goog.i18n.BidiFormatter.prototype.dirAttrValue = function(str, opt_isHtml) {
  return this.knownDirAttrValue(this.estimateDirection(str, opt_isHtml));
};


/**
 * Returns "rtl" if the given directionality is RTL, and "ltr" if it is LTR. In
 * case it's NEUTRAL, returns "rtl" if the context directionality is RTL, and
 * "ltr" otherwise.
 *
 * @param {goog.i18n.bidi.Dir} dir A directionality.
 * @return {string} "rtl" or "ltr", according to the logic described above.
 */
goog.i18n.BidiFormatter.prototype.knownDirAttrValue = function(dir) {
  var resolvedDir = dir == goog.i18n.bidi.Dir.NEUTRAL ? this.contextDir_ : dir;
  return resolvedDir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on {@code str}'s estimated
 * directionality, if it is not the same as the context directionality.
 * Otherwise, returns the empty string.
 *
 * @param {string} str Text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} 'dir="rtl"' for RTL text in non-RTL context; 'dir="ltr"' for
 *     LTR text in non-LTR context; else, the empty string.
 */
goog.i18n.BidiFormatter.prototype.dirAttr = function(str, opt_isHtml) {
  return this.knownDirAttr(this.estimateDirection(str, opt_isHtml));
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on the given directionality, if
 * it is not the same as the context directionality. Otherwise, returns the
 * empty string.
 *
 * @param {goog.i18n.bidi.Dir} dir A directionality.
 * @return {string} 'dir="rtl"' for RTL text in non-RTL context; 'dir="ltr"' for
 *     LTR text in non-LTR context; else, the empty string.
 */
goog.i18n.BidiFormatter.prototype.knownDirAttr = function(dir) {
  if (dir != this.contextDir_) {
    return dir == goog.i18n.bidi.Dir.RTL ? 'dir="rtl"' :
        dir == goog.i18n.bidi.Dir.LTR ? 'dir="ltr"' : '';
  }
  return '';
};


/**
 * Formats a string of unknown directionality for use in HTML output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * The algorithm: estimates the directionality of input argument {@code str}. In
 * case its directionality doesn't match the context directionality, wraps it
 * with a 'span' tag and adds a "dir" attribute (either 'dir="rtl"' or
 * 'dir="ltr"'). If setAlwaysSpan(true) was used, the input is always wrapped
 * with 'span', skipping just the dir attribute when it's not needed.
 *
 * If {@code opt_dirReset}, and if the overall directionality or the exit
 * directionality of {@code str} are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appened
 * (LRM or RLM).
 *
 * If !{@code opt_isHtml}, HTML-escapes {@code str} regardless of wrapping.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.spanWrap = function(str, opt_isHtml,
    opt_dirReset) {
  return this.spanWrapWithKnownDir(null, str, opt_isHtml, opt_dirReset);
};


/**
 * Formats a string of given directionality for use in HTML output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * The algorithm: If {@code dir} doesn't match the context directionality, wraps
 * {@code str} with a 'span' tag and adds a "dir" attribute (either 'dir="rtl"'
 * or 'dir="ltr"'). If setAlwaysSpan(true) was used, the input is always wrapped
 * with 'span', skipping just the dir attribute when it's not needed.
 *
 * If {@code opt_dirReset}, and if {@code dir} or the exit directionality of
 * {@code str} are opposite to the context directionality, a trailing unicode
 * BiDi mark matching the context directionality is appened (LRM or RLM).
 *
 * If !{@code opt_isHtml}, HTML-escapes {@code str} regardless of wrapping.
 *
 * @param {?goog.i18n.bidi.Dir} dir {@code str}'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.spanWrapWithKnownDir = function(dir, str,
    opt_isHtml, opt_dirReset) {
  if (dir == null) {
    dir = this.estimateDirection(str, opt_isHtml);
  }
  return this.spanWrapWithKnownDir_(dir, str, opt_isHtml, opt_dirReset);
};


/**
 * The internal implementation of spanWrapWithKnownDir for non-null dir, to help
 * the compiler optimize.
 *
 * @param {goog.i18n.bidi.Dir} dir {@code str}'s overall directionality.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 * @private
 */
goog.i18n.BidiFormatter.prototype.spanWrapWithKnownDir_ = function(dir, str,
    opt_isHtml, opt_dirReset) {
  opt_dirReset = opt_dirReset || (opt_dirReset == undefined);
  if (!opt_isHtml) {
    str = goog.string.htmlEscape(str);
  }

  var result = [];
  // Whether to add the "dir" attribute.
  var dirCondition =
      dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_;
  if (this.alwaysSpan_ || dirCondition) {  // Wrap is needed
    result.push('<span');
    if (dirCondition) {
      result.push(dir == goog.i18n.bidi.Dir.RTL ? ' dir="rtl"' : ' dir="ltr"');
    }
    result.push('>' + str + '</span>');
  } else {
    result.push(str);
  }

  result.push(this.dirResetIfNeeded_(str, dir, true, opt_dirReset));
  return result.join('');
};


/**
 * Formats a string of unknown directionality for use in plain-text output of
 * the context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * As opposed to {@link #spanWrap}, this makes use of unicode BiDi formatting
 * characters. In HTML, its *only* valid use is inside of elements that do not
 * allow mark-up, e.g. an 'option' tag.
 * The algorithm: estimates the directionality of input argument {@code str}.
 * In case it doesn't match  the context directionality, wraps it with Unicode
 * BiDi formatting characters: RLE{@code str}PDF for RTL text, and
 * LRE{@code str}PDF for LTR text.
 *
 * If {@code opt_dirReset}, and if the overall directionality or the exit
 * directionality of {@code str} are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appended
 * (LRM or RLM).
 *
 * Does *not* do HTML-escaping regardless of the value of {@code opt_isHtml}.
 * The return value can be HTML-escaped as necessary.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.unicodeWrap = function(str, opt_isHtml,
    opt_dirReset) {
  return this.unicodeWrapWithKnownDir(null, str, opt_isHtml, opt_dirReset);
};


/**
 * Formats a string of given directionality for use in plain-text output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * As opposed to {@link #spanWrapWithKnownDir}, makes use of unicode BiDi
 * formatting characters. In HTML, its *only* valid use is inside of elements
 * that do not allow mark-up, e.g. an 'option' tag.
 * The algorithm: If {@code dir} doesn't match the context directionality, wraps
 * {@code str} with Unicode BiDi formatting characters: RLE{@code str}PDF for
 * RTL text, and LRE{@code str}PDF for LTR text.
 *
 * If {@code opt_dirReset}, and if the overall directionality or the exit
 * directionality of {@code str} are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appended
 * (LRM or RLM).
 *
 * Does *not* do HTML-escaping regardless of the value of {@code opt_isHtml}.
 * The return value can be HTML-escaped as necessary.
 *
 * @param {?goog.i18n.bidi.Dir} dir {@code str}'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir = function(dir, str,
    opt_isHtml, opt_dirReset) {
  if (dir == null) {
    dir = this.estimateDirection(str, opt_isHtml);
  }
  return this.unicodeWrapWithKnownDir_(dir, str, opt_isHtml, opt_dirReset);
};


/**
 * The internal implementation of unicodeWrapWithKnownDir for non-null dir, to
 * help the compiler optimize.
 *
 * @param {goog.i18n.bidi.Dir} dir {@code str}'s overall directionality.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow {@code str}. Default: true.
 * @return {string} Input text after applying the above processing.
 * @private
 */
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir_ = function(dir, str,
    opt_isHtml, opt_dirReset) {
  opt_dirReset = opt_dirReset || (opt_dirReset == undefined);
  var result = [];
  if (dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_) {
    result.push(dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.Format.RLE :
                                                goog.i18n.bidi.Format.LRE);
    result.push(str);
    result.push(goog.i18n.bidi.Format.PDF);
  } else {
    result.push(str);
  }

  result.push(this.dirResetIfNeeded_(str, dir, opt_isHtml, opt_dirReset));
  return result.join('');
};


/**
 * Returns a Unicode BiDi mark matching the context directionality (LRM or RLM)
 * if the directionality or the exit directionality of {@code str} are opposite
 * to the context directionality. Otherwise returns the empty string.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching the global directionality or
 *     the empty string.
 */
goog.i18n.BidiFormatter.prototype.markAfter = function(str, opt_isHtml) {
  return this.markAfterKnownDir(null, str, opt_isHtml);
};


/**
 * Returns a Unicode BiDi mark matching the context directionality (LRM or RLM)
 * if the given directionality or the exit directionality of {@code str} are
 * opposite to the context directionality. Otherwise returns the empty string.
 *
 * @param {?goog.i18n.bidi.Dir} dir {@code str}'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether {@code str} is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching the global directionality or
 *     the empty string.
 */
goog.i18n.BidiFormatter.prototype.markAfterKnownDir = function(
    dir, str, opt_isHtml) {
  if (dir == null) {
    dir = this.estimateDirection(str, opt_isHtml);
  }
  return this.dirResetIfNeeded_(str, dir, opt_isHtml, true);
};


/**
 * Returns the Unicode BiDi mark matching the context directionality (LRM for
 * LTR context directionality, RLM for RTL context directionality), or the
 * empty string for neutral / unknown context directionality.
 *
 * @return {string} LRM for LTR context directionality and RLM for RTL context
 *     directionality.
 */
goog.i18n.BidiFormatter.prototype.mark = function() {
  switch (this.contextDir_) {
    case (goog.i18n.bidi.Dir.LTR):
      return goog.i18n.bidi.Format.LRM;
    case (goog.i18n.bidi.Dir.RTL):
      return goog.i18n.bidi.Format.RLM;
    default:
      return '';
  }
};


/**
 * Returns 'right' for RTL context directionality. Otherwise (LTR or neutral /
 * unknown context directionality) returns 'left'.
 *
 * @return {string} 'right' for RTL context directionality and 'left' for other
 *     context directionality.
 */
goog.i18n.BidiFormatter.prototype.startEdge = function() {
  return this.contextDir_ == goog.i18n.bidi.Dir.RTL ?
      goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
};


/**
 * Returns 'left' for RTL context directionality. Otherwise (LTR or neutral /
 * unknown context directionality) returns 'right'.
 *
 * @return {string} 'left' for RTL context directionality and 'right' for other
 *     context directionality.
 */
goog.i18n.BidiFormatter.prototype.endEdge = function() {
  return this.contextDir_ == goog.i18n.bidi.Dir.RTL ?
      goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
};
/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview
 * Utility functions and classes for Soy.
 *
 * <p>
 * The top portion of this file contains utilities for Soy users:<ul>
 *   <li> soy.StringBuilder: Compatible with the 'stringbuilder' code style.
 *   <li> soy.renderElement: Render template and set as innerHTML of an element.
 *   <li> soy.renderAsFragment: Render template and return as HTML fragment.
 * </ul>
 *
 * <p>
 * The bottom portion of this file contains utilities that should only be called
 * by Soy-generated JS code. Please do not use these functions directly from
 * your hand-writen code. Their names all start with '$$'.
 *
 * @author Garrett Boyer
 * @author Mike Samuel
 * @author Kai Huang
 * @author Aharon Lanin
 */

goog.provide('soy');
goog.provide('soy.StringBuilder');
goog.provide('soy.esc');
goog.provide('soydata');
goog.provide('soydata.SanitizedHtml');
goog.provide('soydata.SanitizedHtmlAttribute');
goog.provide('soydata.SanitizedJs');
goog.provide('soydata.SanitizedJsStrChars');
goog.provide('soydata.SanitizedUri');
goog.provide('soydata.VERY_UNSAFE');

goog.require('goog.asserts');
goog.require('goog.dom.DomHelper');
goog.require('goog.format');
goog.require('goog.i18n.BidiFormatter');
goog.require('goog.i18n.bidi');
goog.require('goog.soy');
goog.require('goog.soy.data.SanitizedContentKind');
goog.require('goog.string');
goog.require('goog.string.StringBuffer');


// -----------------------------------------------------------------------------
// StringBuilder (compatible with the 'stringbuilder' code style).


/**
 * Utility class to facilitate much faster string concatenation in IE,
 * using Array.join() rather than the '+' operator. For other browsers
 * we simply use the '+' operator.
 *
 * @param {Object} var_args Initial items to append,
 *     e.g., new soy.StringBuilder('foo', 'bar').
 * @constructor
 */
soy.StringBuilder = goog.string.StringBuffer;


// -----------------------------------------------------------------------------
// soydata: Defines typed strings, e.g. an HTML string {@code "a<b>c"} is
// semantically distinct from the plain text string {@code "a<b>c"} and smart
// templates can take that distinction into account.

/**
 * A type of textual content.
 *
 * This is an enum of type Object so that these values are unforgeable.
 *
 * @enum {!Object}
 */
soydata.SanitizedContentKind = goog.soy.data.SanitizedContentKind;


/**
 * Content of type {@link soydata.SanitizedContentKind.HTML}.
 *
 * The content is a string of HTML that can safely be embedded in a PCDATA
 * context in your app.  If you would be surprised to find that an HTML
 * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
 * you wouldn't write a template that produces {@code s} on security or privacy
 * grounds, then don't pass {@code s} here.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedHtml = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedHtml, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedHtml.prototype.contentKind = soydata.SanitizedContentKind.HTML;


/**
 * Content of type {@link soydata.SanitizedContentKind.JS}.
 *
 * The content is Javascript source that when evaluated does not execute any
 * attacker-controlled scripts.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedJs = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedJs, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedJs.prototype.contentKind =
    soydata.SanitizedContentKind.JS;


/**
 * Content of type {@link soydata.SanitizedContentKind.JS_STR_CHARS}.
 *
 * The content can be safely inserted as part of a single- or double-quoted
 * string without terminating the string.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedJsStrChars = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedJsStrChars, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedJsStrChars.prototype.contentKind =
    soydata.SanitizedContentKind.JS_STR_CHARS;


/**
 * Content of type {@link soydata.SanitizedContentKind.URI}.
 *
 * The content is a URI chunk that the caller knows is safe to emit in a
 * template.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedUri = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedUri, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedUri.prototype.contentKind = soydata.SanitizedContentKind.URI;


/**
 * Content of type {@link soydata.SanitizedContentKind.ATTRIBUTES}.
 *
 * The content should be safely embeddable within an open tag, such as a
 * key="value" pair.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedHtmlAttribute = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedHtmlAttribute, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedHtmlAttribute.prototype.contentKind =
    soydata.SanitizedContentKind.ATTRIBUTES;


/**
 * Content of type {@link soydata.SanitizedContentKind.CSS}.
 *
 * The content is non-attacker-exploitable CSS, such as {@code color:#c3d9ff}.
 *
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.SanitizedCss = function() {
  goog.soy.data.SanitizedContent.call(this);  // Throws an exception.
};
goog.inherits(soydata.SanitizedCss, goog.soy.data.SanitizedContent);

/** @override */
soydata.SanitizedCss.prototype.contentKind =
    soydata.SanitizedContentKind.CSS;


/**
 * Unsanitized plain text string.
 *
 * While all strings are effectively safe to use as a plain text, there are no
 * guarantees about safety in any other context such as HTML. This is
 * sometimes used to mark that should never be used unescaped.
 *
 * @param {*} content Plain text with no guarantees.
 * @constructor
 * @extends {goog.soy.data.SanitizedContent}
 */
soydata.UnsanitizedText = function(content) {
  /** @override */
  this.content = String(content);
};
goog.inherits(soydata.UnsanitizedText, goog.soy.data.SanitizedContent);

/** @override */
soydata.UnsanitizedText.prototype.contentKind =
    soydata.SanitizedContentKind.TEXT;


/**
 * Creates a factory for SanitizedContent types.
 *
 * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
 * instantiate Sanitized* classes, without making the Sanitized* constructors
 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
 * helps callers and their reviewers easily tell that creating SanitizedContent
 * is not always safe and calls for careful review.
 *
 * @param {function(new: T, string)} ctor A constructor.
 * @return {!function(*): T} A factory that takes content and returns a
 *     new instance.
 * @template T
 * @private
 */
soydata.$$makeSanitizedContentFactory_ = function(ctor) {
  /** @constructor */
  function InstantiableCtor() {}
  InstantiableCtor.prototype = ctor.prototype;
  return function(content) {
    var result = new InstantiableCtor();
    result.content = String(content);
    return result;
  };
};


// -----------------------------------------------------------------------------
// Sanitized content ordainers. Please use these with extreme caution (with the
// exception of markUnsanitizedText). A good recommendation is to limit usage
// of these to just a handful of files in your source tree where usages can be
// carefully audited.


/**
 * Protects a string from being used in an noAutoescaped context.
 *
 * This is useful for content where there is significant risk of accidental
 * unescaped usage in a Soy template. A great case is for user-controlled
 * data that has historically been a source of vulernabilities.
 *
 * @param {*} content Text to protect.
 * @return {!soydata.UnsanitizedText} A wrapper that is rejected by the
 *     Soy noAutoescape print directive.
 */
soydata.markUnsanitizedText = function(content) {
  return new soydata.UnsanitizedText(content);
};


/**
 * Takes a leap of faith that the provided content is "safe" HTML.
 *
 * @param {*} content A string of HTML that can safely be embedded in
 *     a PCDATA context in your app. If you would be surprised to find that an
 *     HTML sanitizer produced {@code s} (e.g. it runs code or fetches bad URLs)
 *     and you wouldn't write a template that produces {@code s} on security or
 *     privacy grounds, then don't pass {@code s} here.
 * @return {!soydata.SanitizedHtml} Sanitized content wrapper that
 *     indicates to Soy not to escape when printed as HTML.
 */
soydata.VERY_UNSAFE.ordainSanitizedHtml =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedHtml);


/**
 * Takes a leap of faith that the provided content is "safe" (non-attacker-
 * controlled, XSS-free) Javascript.
 *
 * @param {*} content Javascript source that when evaluated does not
 *     execute any attacker-controlled scripts.
 * @return {!soydata.SanitizedJs} Sanitized content wrapper that indicates to
 *     Soy not to escape when printed as Javascript source.
 */
soydata.VERY_UNSAFE.ordainSanitizedJs =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedJs);


// TODO: This function is probably necessary, either externally or internally
// as an implementation detail. Generally, plain text will always work here,
// as there's no harm to unescaping the string and then re-escaping when
// finally printed.
/**
 * Takes a leap of faith that the provided content can be safely embedded in
 * a Javascript string without re-esacping.
 *
 * @param {*} content Content that can be safely inserted as part of a
 *     single- or double-quoted string without terminating the string.
 * @return {!soydata.SanitizedJsStrChars} Sanitized content wrapper that
 *     indicates to Soy not to escape when printed in a JS string.
 */
soydata.VERY_UNSAFE.ordainSanitizedJsStrChars =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedJsStrChars);


/**
 * Takes a leap of faith that the provided content is "safe" to use as a URI
 * in a Soy template.
 *
 * This creates a Soy SanitizedContent object which indicates to Soy there is
 * no need to escape it when printed as a URI (e.g. in an href or src
 * attribute), such as if it's already been encoded or  if it's a Javascript:
 * URI.
 *
 * @param {*} content A chunk of URI that the caller knows is safe to
 *     emit in a template.
 * @return {!soydata.SanitizedUri} Sanitized content wrapper that indicates to
 *     Soy not to escape or filter when printed in URI context.
 */
soydata.VERY_UNSAFE.ordainSanitizedUri =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedUri);


/**
 * Takes a leap of faith that the provided content is "safe" to use as an
 * HTML attribute.
 *
 * @param {*} content An attribute name and value, such as
 *     {@code dir="ltr"}.
 * @return {!soydata.SanitizedHtmlAttribute} Sanitized content wrapper that
 *     indicates to Soy not to escape when printed as an HTML attribute.
 */
soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedHtmlAttribute);


/**
 * Takes a leap of faith that the provided content is "safe" to use as CSS
 * in a style attribute or block.
 *
 * @param {*} content CSS, such as {@code color:#c3d9ff}.
 * @return {!soydata.SanitizedCss} Sanitized CSS wrapper that indicates to
 *     Soy there is no need to escape or filter when printed in CSS context.
 */
soydata.VERY_UNSAFE.ordainSanitizedCss =
    soydata.$$makeSanitizedContentFactory_(soydata.SanitizedCss);


// -----------------------------------------------------------------------------
// Public utilities.


/**
 * Helper function to render a Soy template and then set the output string as
 * the innerHTML of an element. It is recommended to use this helper function
 * instead of directly setting innerHTML in your hand-written code, so that it
 * will be easier to audit the code for cross-site scripting vulnerabilities.
 *
 * NOTE: New code should consider using goog.soy.renderElement instead.
 *
 * @param {Element} element The element whose content we are rendering.
 * @param {Function} template The Soy template defining the element's content.
 * @param {Object=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 */
soy.renderElement = goog.soy.renderElement;


/**
 * Helper function to render a Soy template into a single node or a document
 * fragment. If the rendered HTML string represents a single node, then that
 * node is returned (note that this is *not* a fragment, despite them name of
 * the method). Otherwise a document fragment is returned containing the
 * rendered nodes.
 *
 * NOTE: New code should consider using goog.soy.renderAsFragment
 * instead (note that the arguments are different).
 *
 * @param {Function} template The Soy template defining the element's content.
 * @param {Object=} opt_templateData The data for the template.
 * @param {Document=} opt_document The document used to create DOM nodes. If not
 *     specified, global document object is used.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @return {!Node} The resulting node or document fragment.
 */
soy.renderAsFragment = function(
    template, opt_templateData, opt_document, opt_injectedData) {
  return goog.soy.renderAsFragment(
      template, opt_templateData, opt_injectedData,
      new goog.dom.DomHelper(opt_document));
};


/**
 * Helper function to render a Soy template into a single node. If the rendered
 * HTML string represents a single node, then that node is returned. Otherwise,
 * a DIV element is returned containing the rendered nodes.
 *
 * NOTE: New code should consider using goog.soy.renderAsElement
 * instead (note that the arguments are different).
 *
 * @param {Function} template The Soy template defining the element's content.
 * @param {Object=} opt_templateData The data for the template.
 * @param {Document=} opt_document The document used to create DOM nodes. If not
 *     specified, global document object is used.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @return {!Element} Rendered template contents, wrapped in a parent DIV
 *     element if necessary.
 */
soy.renderAsElement = function(
    template, opt_templateData, opt_document, opt_injectedData) {
  return goog.soy.renderAsElement(
      template, opt_templateData, opt_injectedData,
      new goog.dom.DomHelper(opt_document));
};


// -----------------------------------------------------------------------------
// Below are private utilities to be used by Soy-generated code only.


/**
 * Builds an augmented map. The returned map will contain mappings from both
 * the base map and the additional map. If the same key appears in both, then
 * the value from the additional map will be visible, while the value from the
 * base map will be hidden. The base map will be used, but not modified.
 *
 * @param {!Object} baseMap The original map to augment.
 * @param {!Object} additionalMap A map containing the additional mappings.
 * @return {!Object} An augmented map containing both the original and
 *     additional mappings.
 */
soy.$$augmentMap = function(baseMap, additionalMap) {

  // Create a new map whose '__proto__' field is set to baseMap.
  /** @constructor */
  function TempCtor() {}
  TempCtor.prototype = baseMap;
  var augmentedMap = new TempCtor();

  // Add the additional mappings to the new map.
  for (var key in additionalMap) {
    augmentedMap[key] = additionalMap[key];
  }

  return augmentedMap;
};


/**
 * Checks that the given map key is a string.
 * @param {*} key Key to check.
 * @return {string} The given key.
 */
soy.$$checkMapKey = function(key) {
  if ((typeof key) != 'string') {
    throw Error(
        'Map literal\'s key expression must evaluate to string' +
        ' (encountered type "' + (typeof key) + '").');
  }
  return key;
};


/**
 * Gets the keys in a map as an array. There are no guarantees on the order.
 * @param {Object} map The map to get the keys of.
 * @return {Array.<string>} The array of keys in the given map.
 */
soy.$$getMapKeys = function(map) {
  var mapKeys = [];
  for (var key in map) {
    mapKeys.push(key);
  }
  return mapKeys;
};


/**
 * Gets a consistent unique id for the given delegate template name. Two calls
 * to this function will return the same id if and only if the input names are
 * the same.
 *
 * <p> Important: This function must always be called with a string constant.
 *
 * <p> If Closure Compiler is not being used, then this is just this identity
 * function. If Closure Compiler is being used, then each call to this function
 * will be replaced with a short string constant, which will be consistent per
 * input name.
 *
 * @param {string} delTemplateName The delegate template name for which to get a
 *     consistent unique id.
 * @return {string} A unique id that is consistent per input name.
 *
 * @consistentIdGenerator
 */
soy.$$getDelTemplateId = function(delTemplateName) {
  return delTemplateName;
};


/**
 * Map from registered delegate template key to the priority of the
 * implementation.
 * @type {Object}
 * @private
 */
soy.$$DELEGATE_REGISTRY_PRIORITIES_ = {};

/**
 * Map from registered delegate template key to the implementation function.
 * @type {Object}
 * @private
 */
soy.$$DELEGATE_REGISTRY_FUNCTIONS_ = {};


/**
 * Registers a delegate implementation. If the same delegate template key (id
 * and variant) has been registered previously, then priority values are
 * compared and only the higher priority implementation is stored (if
 * priorities are equal, an error is thrown).
 *
 * @param {string} delTemplateId The delegate template id.
 * @param {string} delTemplateVariant The delegate template variant (can be
 *     empty string).
 * @param {number} delPriority The implementation's priority value.
 * @param {Function} delFn The implementation function.
 */
soy.$$registerDelegateFn = function(
    delTemplateId, delTemplateVariant, delPriority, delFn) {

  var mapKey = 'key_' + delTemplateId + ':' + delTemplateVariant;
  var currPriority = soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];
  if (currPriority === undefined || delPriority > currPriority) {
    // Registering new or higher-priority function: replace registry entry.
    soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority;
    soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
  } else if (delPriority == currPriority) {
    // Registering same-priority function: error.
    throw Error(
        'Encountered two active delegates with the same priority ("' +
            delTemplateId + ':' + delTemplateVariant + '").');
  } else {
    // Registering lower-priority function: do nothing.
  }
};


/**
 * Retrieves the (highest-priority) implementation that has been registered for
 * a given delegate template key (id and variant). If no implementation has
 * been registered for the key, then the fallback is the same id with empty
 * variant. If the fallback is also not registered, and allowsEmptyDefault is
 * true, then returns an implementation that is equivalent to an empty template
 * (i.e. rendered output would be empty string).
 *
 * @param {string} delTemplateId The delegate template id.
 * @param {string} delTemplateVariant The delegate template variant (can be
 *     empty string).
 * @param {boolean} allowsEmptyDefault Whether to default to the empty template
 *     function if there's no active implementation.
 * @return {Function} The retrieved implementation function.
 */
soy.$$getDelegateFn = function(
    delTemplateId, delTemplateVariant, allowsEmptyDefault) {

  var delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_[
      'key_' + delTemplateId + ':' + delTemplateVariant];
  if (! delFn && delTemplateVariant != '') {
    // Fallback to empty variant.
    delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':'];
  }

  if (delFn) {
    return delFn;
  } else if (allowsEmptyDefault) {
    return soy.$$EMPTY_TEMPLATE_FN_;
  } else {
    throw Error(
        'Found no active impl for delegate call to "' + delTemplateId + ':' +
            delTemplateVariant + '" (and not allowemptydefault="true").');
  }
};


/**
 * Private helper soy.$$getDelegateFn(). This is the empty template function
 * that is returned whenever there's no delegate implementation found.
 *
 * @param {Object.<string, *>=} opt_data
 * @param {soy.StringBuilder=} opt_sb
 * @param {Object.<string, *>=} opt_ijData
 * @return {string}
 * @private
 */
soy.$$EMPTY_TEMPLATE_FN_ = function(opt_data, opt_sb, opt_ijData) {
  return '';
};


// -----------------------------------------------------------------------------
// Escape/filter/normalize.


/**
 * Escapes HTML special characters in a string. Escapes double quote '"' in
 * addition to '&', '<', and '>' so that a string can be included in an HTML
 * tag attribute value within double quotes.
 * Will emit known safe HTML as-is.
 *
 * @param {*} value The string-like value to be escaped. May not be a string,
 *     but the value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeHtml = function(value) {
  // TODO: Perhaps we should just ignore the contentKind property and instead
  // look only at the constructor.
  if (value && value.contentKind &&
      value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
    goog.asserts.assert(
        value.constructor === soydata.SanitizedHtml);
    return value.content;
  }
  return soy.esc.$$escapeHtmlHelper(value);
};


/**
 * Strips unsafe tags to convert a string of untrusted HTML into HTML that
 * is safe to embed.
 *
 * @param {*} value The string-like value to be escaped. May not be a string,
 *     but the value will be coerced to a string.
 * @return {string} A sanitized and normalized version of value.
 */
soy.$$cleanHtml = function(value) {
  if (value && value.contentKind &&
      value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
    goog.asserts.assert(
        value.constructor === soydata.SanitizedHtml);
    return value.content;
  }
  return soy.$$stripHtmlTags(value, soy.esc.$$SAFE_TAG_WHITELIST_);
};


/**
 * Escapes HTML special characters in a string so that it can be embedded in
 * RCDATA.
 * <p>
 * Escapes HTML special characters so that the value will not prematurely end
 * the body of a tag like {@code <textarea>} or {@code <title>}. RCDATA tags
 * cannot contain other HTML entities, so it is not strictly necessary to escape
 * HTML special characters except when part of that text looks like an HTML
 * entity or like a close tag : {@code </textarea>}.
 * <p>
 * Will normalize known safe HTML to make sure that sanitized HTML (which could
 * contain an innocuous {@code </textarea>} don't prematurely end an RCDATA
 * element.
 *
 * @param {*} value The string-like value to be escaped. May not be a string,
 *     but the value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeHtmlRcdata = function(value) {
  if (value && value.contentKind &&
      value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
    goog.asserts.assert(
        value.constructor === soydata.SanitizedHtml);
    return soy.esc.$$normalizeHtmlHelper(value.content);
  }
  return soy.esc.$$escapeHtmlHelper(value);
};


/**
 * Matches any/only HTML5 void elements' start tags.
 * See http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
 * @type {RegExp}
 * @private
 */
soy.$$HTML5_VOID_ELEMENTS_ = new RegExp(
    '^<(?:area|base|br|col|command|embed|hr|img|input' +
    '|keygen|link|meta|param|source|track|wbr)\\b');


/**
 * Removes HTML tags from a string of known safe HTML.
 * If opt_tagWhitelist is not specified or is empty, then
 * the result can be used as an attribute value.
 *
 * @param {*} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @param {Object.<string, number>=} opt_tagWhitelist Has an own property whose
 *     name is a lower-case tag name and whose value is {@code 1} for
 *     each element that is allowed in the output.
 * @return {string} A representation of value without disallowed tags,
 *     HTML comments, or other non-text content.
 */
soy.$$stripHtmlTags = function(value, opt_tagWhitelist) {
  if (!opt_tagWhitelist) {
    // If we have no white-list, then use a fast track which elides all tags.
    return String(value).replace(soy.esc.$$HTML_TAG_REGEX_, '')
        // This is just paranoia since callers should normalize the result
        // anyway, but if they didn't, it would be necessary to ensure that
        // after the first replace non-tag uses of < do not recombine into
        // tags as in "<<foo>script>alert(1337)</<foo>script>".
        .replace(soy.esc.$$LT_REGEX_, '&lt;');
  }

  // Escapes '[' so that we can use [123] below to mark places where tags
  // have been removed.
  var html = String(value).replace(/\[/g, '&#91;');

  // Consider all uses of '<' and replace whitelisted tags with markers like
  // [1] which are indices into a list of approved tag names.
  // Replace all other uses of < and > with entities.
  var tags = [];
  html = html.replace(
    soy.esc.$$HTML_TAG_REGEX_,
    function(tok, tagName) {
      if (tagName) {
        tagName = tagName.toLowerCase();
        if (opt_tagWhitelist.hasOwnProperty(tagName) &&
            opt_tagWhitelist[tagName]) {
          var start = tok.charAt(1) === '/' ? '</' : '<';
          var index = tags.length;
          tags[index] = start + tagName + '>';
          return '[' + index + ']';
        }
      }
      return '';
    });

  // Escape HTML special characters. Now there are no '<' in html that could
  // start a tag.
  html = soy.esc.$$normalizeHtmlHelper(html);

  var finalCloseTags = soy.$$balanceTags_(tags);

  // Now html contains no tags or less-than characters that could become
  // part of a tag via a replacement operation and tags only contains
  // approved tags.
  // Reinsert the white-listed tags.
  html = html.replace(
       /\[(\d+)\]/g, function(_, index) { return tags[index]; });

  // Close any still open tags.
  // This prevents unclosed formatting elements like <ol> and <table> from
  // breaking the layout of containing HTML.
  return html + finalCloseTags;
};


/**
 * Throw out any close tags that don't correspond to start tags.
 * If {@code <table>} is used for formatting, embedded HTML shouldn't be able
 * to use a mismatched {@code </table>} to break page layout.
 *
 * @param {Array.<string>} tags an array of tags that will be modified in place
 *    include tags, the empty string, or concatenations of empty tags.
 * @return {string} zero or more closed tags that close all elements that are
 *    opened in tags but not closed.
 * @private
 */
soy.$$balanceTags_ = function(tags) {
  var open = [];
  for (var i = 0, n = tags.length; i < n; ++i) {
    var tag = tags[i];
    if (tag.charAt(1) === '/') {
      var openTagIndex = open.length - 1;
      // NOTE: This is essentially lastIndexOf, but it's not supported in IE.
      while (openTagIndex >= 0 && open[openTagIndex] != tag) {
        openTagIndex--;
      }
      if (openTagIndex < 0) {
        tags[i] = '';  // Drop close tag.
      } else {
        tags[i] = open.slice(openTagIndex).reverse().join('');
        open.length = openTagIndex;
      }
    } else if (!soy.$$HTML5_VOID_ELEMENTS_.test(tag)) {
      open.push('</' + tag.substring(1));
    }
  }
  return open.reverse().join('');
};


/**
 * Escapes HTML special characters in an HTML attribute value.
 *
 * @param {*} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeHtmlAttribute = function(value) {
  if (value && value.contentKind) {
    // NOTE: We don't accept ATTRIBUTES here because ATTRIBUTES is
    // actually not the attribute value context, but instead k/v pairs.
    if (value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
      // NOTE: After removing tags, we also escape quotes ("normalize") so that
      // the HTML can be embedded in attribute context.
      goog.asserts.assert(
          value.constructor === soydata.SanitizedHtml);
      return soy.esc.$$normalizeHtmlHelper(soy.$$stripHtmlTags(value.content));
    }
  }
  return soy.esc.$$escapeHtmlHelper(value);
};


/**
 * Escapes HTML special characters in a string including space and other
 * characters that can end an unquoted HTML attribute value.
 *
 * @param {*} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeHtmlAttributeNospace = function(value) {
  if (value && value.contentKind) {
    if (value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
      goog.asserts.assert(value.constructor ===
          soydata.SanitizedHtml);
      return soy.esc.$$normalizeHtmlNospaceHelper(
          soy.$$stripHtmlTags(value.content));
    }
  }
  return soy.esc.$$escapeHtmlNospaceHelper(value);
};


/**
 * Filters out strings that cannot be a substring of a valid HTML attribute.
 *
 * Note the input is expected to be key=value pairs.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A valid HTML attribute name part or name/value pair.
 *     {@code "zSoyz"} if the input is invalid.
 */
soy.$$filterHtmlAttributes = function(value) {
  // NOTE: Explicitly no support for SanitizedContentKind.HTML, since that is
  // meaningless in this context, which is generally *between* html attributes.
  if (value &&
      value.contentKind === goog.soy.data.SanitizedContentKind.ATTRIBUTES) {
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedHtmlAttribute);
    // Add a space at the end to ensure this won't get merged into following
    // attributes, unless the interpretation is unambiguous (ending with quotes
    // or a space).
    return value.content.replace(/([^"'\s])$/, '$1 ');
  }
  // TODO: Dynamically inserting attributes that aren't marked as trusted is
  // probably unnecessary.  Any filtering done here will either be inadequate
  // for security or not flexible enough.  Having clients use kind="attributes"
  // in parameters seems like a wiser idea.
  return soy.esc.$$filterHtmlAttributesHelper(value);
};


/**
 * Filters out strings that cannot be a substring of a valid HTML element name.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A valid HTML element name part.
 *     {@code "zSoyz"} if the input is invalid.
 */
soy.$$filterHtmlElementName = function(value) {
  // NOTE: We don't accept any SanitizedContent here. HTML indicates valid
  // PCDATA, not tag names. A sloppy developer shouldn't be able to cause an
  // exploit:
  // ... {let userInput}script src=http://evil.com/evil.js{/let} ...
  // ... {param tagName kind="html"}{$userInput}{/param} ...
  // ... <{$tagName}>Hello World</{$tagName}>
  return soy.esc.$$filterHtmlElementNameHelper(value);
};


/**
 * Escapes characters in the value to make it valid content for a JS string
 * literal.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 * @deprecated
 */
soy.$$escapeJs = function(value) {
  return soy.$$escapeJsString(value);
};


/**
 * Escapes characters in the value to make it valid content for a JS string
 * literal.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeJsString = function(value) {
  if (value &&
      value.contentKind === goog.soy.data.SanitizedContentKind.JS_STR_CHARS) {
    // TODO: It might still be worthwhile to normalize it to remove
    // unescaped quotes, null, etc: replace(/(?:^|[^\])['"]/g, '\\$
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedJsStrChars);
    return value.content;
  }
  return soy.esc.$$escapeJsStringHelper(value);
};


/**
 * Encodes a value as a JavaScript literal.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A JavaScript code representation of the input.
 */
soy.$$escapeJsValue = function(value) {
  // We surround values with spaces so that they can't be interpolated into
  // identifiers by accident.
  // We could use parentheses but those might be interpreted as a function call.
  if (value == null) {  // Intentionally matches undefined.
    // Java returns null from maps where there is no corresponding key while
    // JS returns undefined.
    // We always output null for compatibility with Java which does not have a
    // distinct undefined value.
    return ' null ';
  }
  if (value.contentKind == goog.soy.data.SanitizedContentKind.JS) {
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedJs);
    return value.content;
  }
  switch (typeof value) {
    case 'boolean': case 'number':
      return ' ' + value + ' ';
    default:
      return "'" + soy.esc.$$escapeJsStringHelper(String(value)) + "'";
  }
};


/**
 * Escapes characters in the string to make it valid content for a JS regular
 * expression literal.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeJsRegex = function(value) {
  return soy.esc.$$escapeJsRegexHelper(value);
};


/**
 * Matches all URI mark characters that conflict with HTML attribute delimiters
 * or that cannot appear in a CSS uri.
 * From <a href="http://www.w3.org/TR/CSS2/grammar.html">G.2: CSS grammar</a>
 * <pre>
 *     url        ([!#$%&*-~]|{nonascii}|{escape})*
 * </pre>
 *
 * @type {RegExp}
 * @private
 */
soy.$$problematicUriMarks_ = /['()]/g;

/**
 * @param {string} ch A single character in {@link soy.$$problematicUriMarks_}.
 * @return {string}
 * @private
 */
soy.$$pctEncode_ = function(ch) {
  return '%' + ch.charCodeAt(0).toString(16);
};

/**
 * Escapes a string so that it can be safely included in a URI.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeUri = function(value) {
  if (value && value.contentKind === goog.soy.data.SanitizedContentKind.URI) {
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedUri);
    return soy.$$normalizeUri(value);
  }
  // Apostophes and parentheses are not matched by encodeURIComponent.
  // They are technically special in URIs, but only appear in the obsolete mark
  // production in Appendix D.2 of RFC 3986, so can be encoded without changing
  // semantics.
  var encoded = soy.esc.$$escapeUriHelper(value);
  soy.$$problematicUriMarks_.lastIndex = 0;
  if (soy.$$problematicUriMarks_.test(encoded)) {
    return encoded.replace(soy.$$problematicUriMarks_, soy.$$pctEncode_);
  }
  return encoded;
};


/**
 * Removes rough edges from a URI by escaping any raw HTML/JS string delimiters.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$normalizeUri = function(value) {
  return soy.esc.$$normalizeUriHelper(value);
};


/**
 * Vets a URI's protocol and removes rough edges from a URI by escaping
 * any raw HTML/JS string delimiters.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$filterNormalizeUri = function(value) {
  if (value && value.contentKind == goog.soy.data.SanitizedContentKind.URI) {
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedUri);
    return soy.$$normalizeUri(value);
  }
  return soy.esc.$$filterNormalizeUriHelper(value);
};


/**
 * Escapes a string so it can safely be included inside a quoted CSS string.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
soy.$$escapeCssString = function(value) {
  return soy.esc.$$escapeCssStringHelper(value);
};


/**
 * Encodes a value as a CSS identifier part, keyword, or quantity.
 *
 * @param {*} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A safe CSS identifier part, keyword, or quanitity.
 */
soy.$$filterCssValue = function(value) {
  if (value && value.contentKind === goog.soy.data.SanitizedContentKind.CSS) {
    goog.asserts.assert(value.constructor ===
        soydata.SanitizedCss);
    return value.content;
  }
  // Uses == to intentionally match null and undefined for Java compatibility.
  if (value == null) {
    return '';
  }
  return soy.esc.$$filterCssValueHelper(value);
};


/**
 * Sanity-checks noAutoescape input for explicitly tainted content.
 *
 * SanitizedContentKind.TEXT is used to explicitly mark input that was never
 * meant to be used unescaped.
 *
 * @param {*} value The value to filter.
 * @return {string} The value, that we dearly hope will not cause an attack.
 */
soy.$$filterNoAutoescape = function(value) {
  if (value && value.contentKind === goog.soy.data.SanitizedContentKind.TEXT) {
    // Fail in development mode.
    goog.asserts.fail(
        'Tainted SanitizedContentKind.TEXT for |noAutoescape: `%s`',
        [value.content]);
    // Return innocuous data in production.
    return 'zSoyz';
  }
  return String(value);
};


// -----------------------------------------------------------------------------
// Basic directives/functions.


/**
 * Converts \r\n, \r, and \n to <br>s
 * @param {*} str The string in which to convert newlines.
 * @return {string} A copy of {@code str} with converted newlines.
 */
soy.$$changeNewlineToBr = function(str) {
  return goog.string.newLineToBr(String(str), false);
};


/**
 * Inserts word breaks ('wbr' tags) into a HTML string at a given interval. The
 * counter is reset if a space is encountered. Word breaks aren't inserted into
 * HTML tags or entities. Entites count towards the character count; HTML tags
 * do not.
 *
 * @param {*} str The HTML string to insert word breaks into. Can be other
 *     types, but the value will be coerced to a string.
 * @param {number} maxCharsBetweenWordBreaks Maximum number of non-space
 *     characters to allow before adding a word break.
 * @return {string} The string including word breaks.
 */
soy.$$insertWordBreaks = function(str, maxCharsBetweenWordBreaks) {
  return goog.format.insertWordBreaks(String(str), maxCharsBetweenWordBreaks);
};


/**
 * Truncates a string to a given max length (if it's currently longer),
 * optionally adding ellipsis at the end.
 *
 * @param {*} str The string to truncate. Can be other types, but the value will
 *     be coerced to a string.
 * @param {number} maxLen The maximum length of the string after truncation
 *     (including ellipsis, if applicable).
 * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
 *     truncation.
 * @return {string} The string after truncation.
 */
soy.$$truncate = function(str, maxLen, doAddEllipsis) {

  str = String(str);
  if (str.length <= maxLen) {
    return str;  // no need to truncate
  }

  // If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
  // too small, just turn off doAddEllipsis.
  if (doAddEllipsis) {
    if (maxLen > 3) {
      maxLen -= 3;
    } else {
      doAddEllipsis = false;
    }
  }

  // Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
  if (soy.$$isHighSurrogate_(str.charAt(maxLen - 1)) &&
      soy.$$isLowSurrogate_(str.charAt(maxLen))) {
    maxLen -= 1;
  }

  // Truncate.
  str = str.substring(0, maxLen);

  // Add ellipsis.
  if (doAddEllipsis) {
    str += '...';
  }

  return str;
};

/**
 * Private helper for $$truncate() to check whether a char is a high surrogate.
 * @param {string} ch The char to check.
 * @return {boolean} Whether the given char is a unicode high surrogate.
 * @private
 */
soy.$$isHighSurrogate_ = function(ch) {
  return 0xD800 <= ch && ch <= 0xDBFF;
};

/**
 * Private helper for $$truncate() to check whether a char is a low surrogate.
 * @param {string} ch The char to check.
 * @return {boolean} Whether the given char is a unicode low surrogate.
 * @private
 */
soy.$$isLowSurrogate_ = function(ch) {
  return 0xDC00 <= ch && ch <= 0xDFFF;
};


// -----------------------------------------------------------------------------
// Bidi directives/functions.


/**
 * Cache of bidi formatter by context directionality, so we don't keep on
 * creating new objects.
 * @type {!Object.<!goog.i18n.BidiFormatter>}
 * @private
 */
soy.$$bidiFormatterCache_ = {};


/**
 * Returns cached bidi formatter for bidiGlobalDir, or creates a new one.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @return {goog.i18n.BidiFormatter} A formatter for bidiGlobalDir.
 * @private
 */
soy.$$getBidiFormatterInstance_ = function(bidiGlobalDir) {
  return soy.$$bidiFormatterCache_[bidiGlobalDir] ||
         (soy.$$bidiFormatterCache_[bidiGlobalDir] =
             new goog.i18n.BidiFormatter(bidiGlobalDir));
};


/**
 * Estimate the overall directionality of text. If opt_isHtml, makes sure to
 * ignore the LTR nature of the mark-up and escapes in text, making the logic
 * suitable for HTML and HTML-escaped text.
 * @param {string} text The text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {number} 1 if text is LTR, -1 if it is RTL, and 0 if it is neutral.
 */
soy.$$bidiTextDir = function(text, opt_isHtml) {
  if (!text) {
    return 0;
  }
  return goog.i18n.bidi.detectRtlDirectionality(text, opt_isHtml) ? -1 : 1;
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on text's estimated
 * directionality, if it is not the same as bidiGlobalDir.
 * Otherwise, returns the empty string.
 * If opt_isHtml, makes sure to ignore the LTR nature of the mark-up and escapes
 * in text, making the logic suitable for HTML and HTML-escaped text.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {string} text The text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {soydata.SanitizedHtmlAttribute} 'dir="rtl"' for RTL text in non-RTL
 *     context; 'dir="ltr"' for LTR text in non-LTR context;
 *     else, the empty string.
 */
soy.$$bidiDirAttr = function(bidiGlobalDir, text, opt_isHtml) {
  return soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute(
      soy.$$getBidiFormatterInstance_(bidiGlobalDir).dirAttr(text, opt_isHtml));
};


/**
 * Returns a Unicode BiDi mark matching bidiGlobalDir (LRM or RLM) if the
 * directionality or the exit directionality of text are opposite to
 * bidiGlobalDir. Otherwise returns the empty string.
 * If opt_isHtml, makes sure to ignore the LTR nature of the mark-up and escapes
 * in text, making the logic suitable for HTML and HTML-escaped text.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {string} text The text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching bidiGlobalDir, or the empty
 *     string when text's overall and exit directionalities both match
 *     bidiGlobalDir, or bidiGlobalDir is 0 (unknown).
 */
soy.$$bidiMarkAfter = function(bidiGlobalDir, text, opt_isHtml) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir);
  return formatter.markAfter(text, opt_isHtml);
};


/**
 * Returns str wrapped in a <span dir="ltr|rtl"> according to its directionality
 * - but only if that is neither neutral nor the same as the global context.
 * Otherwise, returns str unchanged.
 * Always treats str as HTML/HTML-escaped, i.e. ignores mark-up and escapes when
 * estimating str's directionality.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {*} str The string to be wrapped. Can be other types, but the value
 *     will be coerced to a string.
 * @return {string} The wrapped string.
 */
soy.$$bidiSpanWrap = function(bidiGlobalDir, str) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir);
  return formatter.spanWrap(str + '', true);
};


/**
 * Returns str wrapped in Unicode BiDi formatting characters according to its
 * directionality, i.e. either LRE or RLE at the beginning and PDF at the end -
 * but only if str's directionality is neither neutral nor the same as the
 * global context. Otherwise, returns str unchanged.
 * Always treats str as HTML/HTML-escaped, i.e. ignores mark-up and escapes when
 * estimating str's directionality.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {*} str The string to be wrapped. Can be other types, but the value
 *     will be coerced to a string.
 * @return {string} The wrapped string.
 */
soy.$$bidiUnicodeWrap = function(bidiGlobalDir, str) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir);
  return formatter.unicodeWrap(str + '', true);
};


// -----------------------------------------------------------------------------
// Generated code.




// START GENERATED CODE FOR ESCAPERS.

/**
 * @type {function (*) : string}
 */
soy.esc.$$escapeUriHelper = function(v) {
  return goog.string.urlEncode(String(v));
};

/**
 * Maps charcters to the escaped versions for the named escape directives.
 * @type {Object.<string, string>}
 * @private
 */
soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = {
  '\x00': '\x26#0;',
  '\x22': '\x26quot;',
  '\x26': '\x26amp;',
  '\x27': '\x26#39;',
  '\x3c': '\x26lt;',
  '\x3e': '\x26gt;',
  '\x09': '\x26#9;',
  '\x0a': '\x26#10;',
  '\x0b': '\x26#11;',
  '\x0c': '\x26#12;',
  '\x0d': '\x26#13;',
  ' ': '\x26#32;',
  '-': '\x26#45;',
  '\/': '\x26#47;',
  '\x3d': '\x26#61;',
  '`': '\x26#96;',
  '\x85': '\x26#133;',
  '\xa0': '\x26#160;',
  '\u2028': '\x26#8232;',
  '\u2029': '\x26#8233;'
};

/**
 * A function that can be used with String.replace..
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 * @private
 */
soy.esc.$$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_[ch];
};

/**
 * Maps charcters to the escaped versions for the named escape directives.
 * @type {Object.<string, string>}
 * @private
 */
soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = {
  '\x00': '\\x00',
  '\x08': '\\x08',
  '\x09': '\\t',
  '\x0a': '\\n',
  '\x0b': '\\x0b',
  '\x0c': '\\f',
  '\x0d': '\\r',
  '\x22': '\\x22',
  '\x26': '\\x26',
  '\x27': '\\x27',
  '\/': '\\\/',
  '\x3c': '\\x3c',
  '\x3d': '\\x3d',
  '\x3e': '\\x3e',
  '\\': '\\\\',
  '\x85': '\\x85',
  '\u2028': '\\u2028',
  '\u2029': '\\u2029',
  '$': '\\x24',
  '(': '\\x28',
  ')': '\\x29',
  '*': '\\x2a',
  '+': '\\x2b',
  ',': '\\x2c',
  '-': '\\x2d',
  '.': '\\x2e',
  ':': '\\x3a',
  '?': '\\x3f',
  '[': '\\x5b',
  ']': '\\x5d',
  '^': '\\x5e',
  '{': '\\x7b',
  '|': '\\x7c',
  '}': '\\x7d'
};

/**
 * A function that can be used with String.replace..
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 * @private
 */
soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_[ch];
};

/**
 * Maps charcters to the escaped versions for the named escape directives.
 * @type {Object.<string, string>}
 * @private
 */
soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_ = {
  '\x00': '\\0 ',
  '\x08': '\\8 ',
  '\x09': '\\9 ',
  '\x0a': '\\a ',
  '\x0b': '\\b ',
  '\x0c': '\\c ',
  '\x0d': '\\d ',
  '\x22': '\\22 ',
  '\x26': '\\26 ',
  '\x27': '\\27 ',
  '(': '\\28 ',
  ')': '\\29 ',
  '*': '\\2a ',
  '\/': '\\2f ',
  ':': '\\3a ',
  ';': '\\3b ',
  '\x3c': '\\3c ',
  '\x3d': '\\3d ',
  '\x3e': '\\3e ',
  '@': '\\40 ',
  '\\': '\\5c ',
  '{': '\\7b ',
  '}': '\\7d ',
  '\x85': '\\85 ',
  '\xa0': '\\a0 ',
  '\u2028': '\\2028 ',
  '\u2029': '\\2029 '
};

/**
 * A function that can be used with String.replace..
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 * @private
 */
soy.esc.$$REPLACER_FOR_ESCAPE_CSS_STRING_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_[ch];
};

/**
 * Maps charcters to the escaped versions for the named escape directives.
 * @type {Object.<string, string>}
 * @private
 */
soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = {
  '\x00': '%00',
  '\x01': '%01',
  '\x02': '%02',
  '\x03': '%03',
  '\x04': '%04',
  '\x05': '%05',
  '\x06': '%06',
  '\x07': '%07',
  '\x08': '%08',
  '\x09': '%09',
  '\x0a': '%0A',
  '\x0b': '%0B',
  '\x0c': '%0C',
  '\x0d': '%0D',
  '\x0e': '%0E',
  '\x0f': '%0F',
  '\x10': '%10',
  '\x11': '%11',
  '\x12': '%12',
  '\x13': '%13',
  '\x14': '%14',
  '\x15': '%15',
  '\x16': '%16',
  '\x17': '%17',
  '\x18': '%18',
  '\x19': '%19',
  '\x1a': '%1A',
  '\x1b': '%1B',
  '\x1c': '%1C',
  '\x1d': '%1D',
  '\x1e': '%1E',
  '\x1f': '%1F',
  ' ': '%20',
  '\x22': '%22',
  '\x27': '%27',
  '(': '%28',
  ')': '%29',
  '\x3c': '%3C',
  '\x3e': '%3E',
  '\\': '%5C',
  '{': '%7B',
  '}': '%7D',
  '\x7f': '%7F',
  '\x85': '%C2%85',
  '\xa0': '%C2%A0',
  '\u2028': '%E2%80%A8',
  '\u2029': '%E2%80%A9',
  '\uff01': '%EF%BC%81',
  '\uff03': '%EF%BC%83',
  '\uff04': '%EF%BC%84',
  '\uff06': '%EF%BC%86',
  '\uff07': '%EF%BC%87',
  '\uff08': '%EF%BC%88',
  '\uff09': '%EF%BC%89',
  '\uff0a': '%EF%BC%8A',
  '\uff0b': '%EF%BC%8B',
  '\uff0c': '%EF%BC%8C',
  '\uff0f': '%EF%BC%8F',
  '\uff1a': '%EF%BC%9A',
  '\uff1b': '%EF%BC%9B',
  '\uff1d': '%EF%BC%9D',
  '\uff1f': '%EF%BC%9F',
  '\uff20': '%EF%BC%A0',
  '\uff3b': '%EF%BC%BB',
  '\uff3d': '%EF%BC%BD'
};

/**
 * A function that can be used with String.replace..
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 * @private
 */
soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_[ch];
};

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_ESCAPE_HTML_ = /[\x00\x22\x26\x27\x3c\x3e]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_ = /[\x00\x22\x27\x3c\x3e]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_ESCAPE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x26\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_ESCAPE_JS_STRING_ = /[\x00\x08-\x0d\x22\x26\x27\/\x3c-\x3e\\\x85\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_ESCAPE_JS_REGEX_ = /[\x00\x08-\x0d\x22\x24\x26-\/\x3a\x3c-\x3f\x5b-\x5e\x7b-\x7d\x85\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_ESCAPE_CSS_STRING_ = /[\x00\x08-\x0d\x22\x26-\x2a\/\x3a-\x3e@\\\x7b\x7d\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = /[\x00- \x22\x27-\x29\x3c\x3e\\\x7b\x7d\x7f\x85\xa0\u2028\u2029\uff01\uff03\uff04\uff06-\uff0c\uff0f\uff1a\uff1b\uff1d\uff1f\uff20\uff3b\uff3d]/g;

/**
 * A pattern that vets values produced by the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$FILTER_FOR_FILTER_CSS_VALUE_ = /^(?!-*(?:expression|(?:moz-)?binding))(?:[.#]?-?(?:[_a-z0-9-]+)(?:-[_a-z0-9-]+)*-?|-?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)(?:[a-z]{1,2}|%)?|!important|)$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$FILTER_FOR_FILTER_NORMALIZE_URI_ = /^(?:(?:https?|mailto):|[^&:\/?#]*(?:[\/?#]|$))/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$FILTER_FOR_FILTER_HTML_ATTRIBUTES_ = /^(?!style|on|action|archive|background|cite|classid|codebase|data|dsync|href|longdesc|src|usemap)(?:[a-z0-9_$:-]*)$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type RegExp
 * @private
 */
soy.esc.$$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_ = /^(?!script|style|title|textarea|xmp|no)[a-z0-9_$:-]*$/i;

/**
 * A helper for the Soy directive |escapeHtml
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$escapeHtmlHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_ESCAPE_HTML_,
      soy.esc.$$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |normalizeHtml
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$normalizeHtmlHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_,
      soy.esc.$$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |escapeHtmlNospace
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$escapeHtmlNospaceHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_ESCAPE_HTML_NOSPACE_,
      soy.esc.$$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |normalizeHtmlNospace
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$normalizeHtmlNospaceHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_,
      soy.esc.$$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |escapeJsString
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$escapeJsStringHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_ESCAPE_JS_STRING_,
      soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};

/**
 * A helper for the Soy directive |escapeJsRegex
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$escapeJsRegexHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_ESCAPE_JS_REGEX_,
      soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};

/**
 * A helper for the Soy directive |escapeCssString
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$escapeCssStringHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_ESCAPE_CSS_STRING_,
      soy.esc.$$REPLACER_FOR_ESCAPE_CSS_STRING_);
};

/**
 * A helper for the Soy directive |filterCssValue
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$filterCssValueHelper = function(value) {
  var str = String(value);
  if (!soy.esc.$$FILTER_FOR_FILTER_CSS_VALUE_.test(str)) {
    goog.asserts.fail('Bad value `%s` for |filterCssValue', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |normalizeUri
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$normalizeUriHelper = function(value) {
  var str = String(value);
  return str.replace(
      soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_,
      soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_);
};

/**
 * A helper for the Soy directive |filterNormalizeUri
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$filterNormalizeUriHelper = function(value) {
  var str = String(value);
  if (!soy.esc.$$FILTER_FOR_FILTER_NORMALIZE_URI_.test(str)) {
    goog.asserts.fail('Bad value `%s` for |filterNormalizeUri', [str]);
    return '#zSoyz';
  }
  return str.replace(
      soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_,
      soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_);
};

/**
 * A helper for the Soy directive |filterHtmlAttributes
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$filterHtmlAttributesHelper = function(value) {
  var str = String(value);
  if (!soy.esc.$$FILTER_FOR_FILTER_HTML_ATTRIBUTES_.test(str)) {
    goog.asserts.fail('Bad value `%s` for |filterHtmlAttributes', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterHtmlElementName
 * @param {*} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
soy.esc.$$filterHtmlElementNameHelper = function(value) {
  var str = String(value);
  if (!soy.esc.$$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_.test(str)) {
    goog.asserts.fail('Bad value `%s` for |filterHtmlElementName', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * Matches all tags, HTML comments, and DOCTYPEs in tag soup HTML.
 * By removing these, and replacing any '<' or '>' characters with
 * entities we guarantee that the result can be embedded into a
 * an attribute without introducing a tag boundary.
 *
 * @type {RegExp}
 * @private
 */
soy.esc.$$HTML_TAG_REGEX_ = /<(?:!|\/?([a-zA-Z][a-zA-Z0-9:\-]*))(?:[^>'"]|"[^"]*"|'[^']*')*>/g;

/**
 * Matches all occurrences of '<'.
 *
 * @type {RegExp}
 * @private
 */
soy.esc.$$LT_REGEX_ = /</g;

/**
 * Maps lower-case names of innocuous tags to 1.
 *
 * @type {Object.<string,number>}
 * @private
 */
soy.esc.$$SAFE_TAG_WHITELIST_ = {'b': 1, 'br': 1, 'em': 1, 'i': 1, 's': 1, 'sub': 1, 'sup': 1, 'u': 1};

// END GENERATED CODE
// This file was automatically generated from debug.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.debug');

goog.require('soy');
goog.require('soydata');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.Debugger = function(opt_data, opt_ignored) {
  return '<div id="debugger"><div class="header"><h4>Debugger</h4><div class="button display"></div></div><ul></ul></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.DebugView = function(opt_data, opt_ignored) {
  return '<li class="debugView" id="' + opt_data.id + '"><div class="header"><h5>' + opt_data.title + '</h5><div class="button display"></div></div><div class="body">' + opt_data.body + '</div></li>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.CameraDebugView = function(opt_data, opt_ignored) {
  return '\t' + feng.templates.debug.DebugView({id: 'debug-camera', title: 'Camera Controls', body: '<div class="viewPanel"><div><select></select><button type="button" class="button use"></button><div class="button visible"></div></div><ul><li><label>fov</label><input name="fov" type="number"></li><li><label>position x</label><input name="position-x" type="number"></li><li><label>position y</label><input name="position-y" type="number"></li><li><label>position z</label><input name="position-z" type="number"></li><li><label>rotation x</label><input name="rotation-x" type="number"></li><li><label>rotation y</label><input name="rotation-y" type="number"></li><li><label>rotation z</label><input name="rotation-z" type="number"></li><li><input class="degrees" type="checkbox">in degrees</li><li><input class="helpers" type="checkbox" checked>show helpers</li></ul></div>'});
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.ManipulateDebugView = function(opt_data, opt_ignored) {
  return '\t' + feng.templates.debug.DebugView({id: 'debug-manipulate', title: 'Manipulate', body: '<div class="viewPanel"></div>'});
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.PathfindingDebugView = function(opt_data, opt_ignored) {
  return '\t' + feng.templates.debug.DebugView({id: 'debug-pathfinding', title: 'Pathfinding', body: '<div class="canvasContainer"></div>'});
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.AchievementsDebugView = function(opt_data, opt_ignored) {
  var output = '\t';
  var param459 = '<div class="tipsPanel"><button class="unlock-all">Unlock All</button><ul class="tips">';
  var tipList461 = opt_data.tips;
  var tipListLen461 = tipList461.length;
  for (var tipIndex461 = 0; tipIndex461 < tipListLen461; tipIndex461++) {
    var tipData461 = tipList461[tipIndex461];
    param459 += '<li data-tip-id="' + tipData461.id + '" data-view-id="' + tipData461.view + '" data-section-id="' + tipData461.section + '"><div class="icon icon-' + tipData461.icon + '"></div><div class="caption"><p>' + tipData461.id + '</p><p>' + tipData461.view + '</p><p>' + tipData461.section + '</p></div></li>';
  }
  param459 += '</ul></div>';
  output += feng.templates.debug.DebugView({id: 'debug-achievements', title: 'Achievements', body: param459});
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.debug.PathTrackDebugView = function(opt_data, opt_ignored) {
  return '\t' + feng.templates.debug.DebugView({id: 'debug-pathtrack', title: 'Path Track', body: '<div class="editPanel"><div class="scene"><label>Scene</label><select></select></div><button type="button" class="button output"></button><input type="file" class="button import"><textarea rows="10"></textarea></div><div class="pointPanel"><label>Control Point</label><button type="button" class="button add"></button><button type="button" class="button remove"></button><ul><li><label>x</label><input name="x" type="number"></li><li><label>y</label><input name="y" type="number"></li><li><label>z</label><input name="z" type="number"></li><li><label>tipid</label><input name="tipid" type="text"></li></ul></div><div class="playbackPanel"><label>Playback</label><div class="controls"><button type="button" class="button play"></button><button type="button" class="button camera fly"></button><input type="range" min="0" max="100" value="0"></div></div>'});
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.events.EventId');



/**
 * A templated class that is used when registering for events. Typical usage:
 * <code>
 *   /** @type {goog.events.EventId.<MyEventObj>}
 *   var myEventId = new goog.events.EventId(
 *       goog.events.getUniqueId(('someEvent'));
 *
 *   // No need to cast or declare here since the compiler knows the correct
 *   // type of 'evt' (MyEventObj).
 *   something.listen(myEventId, function(evt) {});
 * </code>
 *
 * @param {string} eventId
 * @template T
 * @constructor
 * @struct
 * @final
 */
goog.events.EventId = function(eventId) {
  /** @const */ this.id = eventId;
};


/**
 * @override
 */
goog.events.EventId.prototype.toString = function() {
  return this.id;
};
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An interface for a listenable JavaScript object.
 */

goog.provide('goog.events.Listenable');
goog.provide('goog.events.ListenableKey');

/** @suppress {extraRequire} */
goog.require('goog.events.EventId');



/**
 * A listenable interface. A listenable is an object with the ability
 * to dispatch/broadcast events to "event listeners" registered via
 * listen/listenOnce.
 *
 * The interface allows for an event propagation mechanism similar
 * to one offered by native browser event targets, such as
 * capture/bubble mechanism, stopping propagation, and preventing
 * default actions. Capture/bubble mechanism depends on the ancestor
 * tree constructed via {@code #getParentEventTarget}; this tree
 * must be directed acyclic graph. The meaning of default action(s)
 * in preventDefault is specific to a particular use case.
 *
 * Implementations that do not support capture/bubble or can not have
 * a parent listenable can simply not implement any ability to set the
 * parent listenable (and have {@code #getParentEventTarget} return
 * null).
 *
 * Implementation of this class can be used with or independently from
 * goog.events.
 *
 * Implementation must call {@code #addImplementation(implClass)}.
 *
 * @interface
 * @see goog.events
 * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html
 */
goog.events.Listenable = function() {};


/**
 * An expando property to indicate that an object implements
 * goog.events.Listenable.
 *
 * See addImplementation/isImplementedBy.
 *
 * @type {string}
 * @const
 */
goog.events.Listenable.IMPLEMENTED_BY_PROP =
    'closure_listenable_' + ((Math.random() * 1e6) | 0);


/**
 * Marks a given class (constructor) as an implementation of
 * Listenable, do that we can query that fact at runtime. The class
 * must have already implemented the interface.
 * @param {!Function} cls The class constructor. The corresponding
 *     class must have already implemented the interface.
 */
goog.events.Listenable.addImplementation = function(cls) {
  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;
};


/**
 * @param {Object} obj The object to check.
 * @return {boolean} Whether a given instance implements
 *     Listenable. The class/superclass of the instance must call
 *     addImplementation.
 */
goog.events.Listenable.isImplementedBy = function(obj) {
  try {
    return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);
  } catch (e) {
    return false;
  }
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listen;


/**
 * Adds an event listener that is removed automatically after the
 * listener fired once.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listenOnce;


/**
 * Removes an event listener which was added with listen() or listenOnce().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.unlisten;


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.ListenableKey} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 */
goog.events.Listenable.prototype.unlistenByKey;


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 */
goog.events.Listenable.prototype.dispatchEvent;


/**
 * Removes all listeners from this listenable. If type is specified,
 * it will only remove listeners of the particular type. otherwise all
 * registered listeners will be removed.
 *
 * @param {string=} opt_type Type of event to remove, default is to
 *     remove all types.
 * @return {number} Number of listeners removed.
 */
goog.events.Listenable.prototype.removeAllListeners;


/**
 * Returns the parent of this event target to use for capture/bubble
 * mechanism.
 *
 * NOTE(user): The name reflects the original implementation of
 * custom event target ({@code goog.events.EventTarget}). We decided
 * that changing the name is not worth it.
 *
 * @return {goog.events.Listenable} The parent EventTarget or null if
 *     there is no parent.
 */
goog.events.Listenable.prototype.getParentEventTarget;


/**
 * Fires all registered listeners in this listenable for the given
 * type and capture mode, passing them the given eventObject. This
 * does not perform actual capture/bubble. Only implementors of the
 * interface should be using this.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The type of the
 *     listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @param {EVENTOBJ} eventObject The event object to fire.
 * @return {boolean} Whether all listeners succeeded without
 *     attempting to prevent default behavior. If any listener returns
 *     false or called goog.events.Event#preventDefault, this returns
 *     false.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.fireListeners;


/**
 * Gets all listeners in this listenable for the given type and
 * capture mode.
 *
 * @param {string|!goog.events.EventId} type The type of the listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @return {!Array.<goog.events.ListenableKey>} An array of registered
 *     listeners.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.getListeners;


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The name of the event
 *     without the 'on' prefix.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The
 *     listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.getListener;


/**
 * Whether there is any active listeners matching the specified
 * signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble
 *     listeners.
 * @return {boolean} Whether there is any active listeners matching
 *     the requested type and/or capture phase.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.hasListener;



/**
 * An interface that describes a single registered listener.
 * @interface
 */
goog.events.ListenableKey = function() {};


/**
 * Counter used to create a unique key
 * @type {number}
 * @private
 */
goog.events.ListenableKey.counter_ = 0;


/**
 * Reserves a key to be used for ListenableKey#key field.
 * @return {number} A number to be used to fill ListenableKey#key
 *     field.
 */
goog.events.ListenableKey.reserveKey = function() {
  return ++goog.events.ListenableKey.counter_;
};


/**
 * The source event target.
 * @type {!(Object|goog.events.Listenable|goog.events.EventTarget)}
 */
goog.events.ListenableKey.prototype.src;


/**
 * The event type the listener is listening to.
 * @type {string}
 */
goog.events.ListenableKey.prototype.type;


/**
 * The listener function.
 * @type {function(?):?|{handleEvent:function(?):?}|null}
 */
goog.events.ListenableKey.prototype.listener;


/**
 * Whether the listener works on capture phase.
 * @type {boolean}
 */
goog.events.ListenableKey.prototype.capture;


/**
 * The 'this' object for the listener function's scope.
 * @type {Object}
 */
goog.events.ListenableKey.prototype.handler;


/**
 * A globally unique number to identify the key.
 * @type {number}
 */
goog.events.ListenableKey.prototype.key;
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Listener object.
 * @see ../demos/events.html
 */

goog.provide('goog.events.Listener');

goog.require('goog.events.ListenableKey');



/**
 * Simple class that stores information about a listener
 * @param {!Function} listener Callback function.
 * @param {Function} proxy Wrapper for the listener that patches the event.
 * @param {EventTarget|goog.events.Listenable} src Source object for
 *     the event.
 * @param {string} type Event type.
 * @param {boolean} capture Whether in capture or bubble phase.
 * @param {Object=} opt_handler Object in whose context to execute the callback.
 * @implements {goog.events.ListenableKey}
 * @constructor
 */
goog.events.Listener = function(
    listener, proxy, src, type, capture, opt_handler) {
  if (goog.events.Listener.ENABLE_MONITORING) {
    this.creationStack = new Error().stack;
  }

  /**
   * Callback function.
   * @type {Function}
   */
  this.listener = listener;

  /**
   * A wrapper over the original listener. This is used solely to
   * handle native browser events (it is used to simulate the capture
   * phase and to patch the event object).
   * @type {Function}
   */
  this.proxy = proxy;

  /**
   * Object or node that callback is listening to
   * @type {EventTarget|goog.events.Listenable}
   */
  this.src = src;

  /**
   * The event type.
   * @const {string}
   */
  this.type = type;

  /**
   * Whether the listener is being called in the capture or bubble phase
   * @const {boolean}
   */
  this.capture = !!capture;

  /**
   * Optional object whose context to execute the listener in
   * @type {Object|undefined}
   */
  this.handler = opt_handler;

  /**
   * The key of the listener.
   * @const {number}
   * @override
   */
  this.key = goog.events.ListenableKey.reserveKey();

  /**
   * Whether to remove the listener after it has been called.
   * @type {boolean}
   */
  this.callOnce = false;

  /**
   * Whether the listener has been removed.
   * @type {boolean}
   */
  this.removed = false;
};


/**
 * @define {boolean} Whether to enable the monitoring of the
 *     goog.events.Listener instances. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.events.Listener.ENABLE_MONITORING', false);


/**
 * If monitoring the goog.events.Listener instances is enabled, stores the
 * creation stack trace of the Disposable instance.
 * @type {string}
 */
goog.events.Listener.prototype.creationStack;


/**
 * Marks this listener as removed. This also remove references held by
 * this listener object (such as listener and event source).
 */
goog.events.Listener.prototype.markAsRemoved = function() {
  this.removed = true;
  this.listener = null;
  this.proxy = null;
  this.src = null;
  this.handler = null;
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A map of listeners that provides utility functions to
 * deal with listeners on an event target. Used by
 * {@code goog.events.EventTarget}.
 *
 * WARNING: Do not use this class from outside goog.events package.
 *
 * @visibility {//closure/goog/bin/sizetests:__pkg__}
 * @visibility {//closure/goog/events:__pkg__}
 * @visibility {//closure/goog/labs/events:__pkg__}
 */

goog.provide('goog.events.ListenerMap');

goog.require('goog.array');
goog.require('goog.events.Listener');
goog.require('goog.object');



/**
 * Creates a new listener map.
 * @param {EventTarget|goog.events.Listenable} src The src object.
 * @constructor
 * @final
 */
goog.events.ListenerMap = function(src) {
  /** @type {EventTarget|goog.events.Listenable} */
  this.src = src;

  /**
   * Maps of event type to an array of listeners.
   * @type {Object.<string, !Array.<!goog.events.Listener>>}
   */
  this.listeners = {};

  /**
   * The count of types in this map that have registered listeners.
   * @private {number}
   */
  this.typeCount_ = 0;
};


/**
 * @return {number} The count of event types in this map that actually
 *     have registered listeners.
 */
goog.events.ListenerMap.prototype.getTypeCount = function() {
  return this.typeCount_;
};


/**
 * @return {number} Total number of registered listeners.
 */
goog.events.ListenerMap.prototype.getListenerCount = function() {
  var count = 0;
  for (var type in this.listeners) {
    count += this.listeners[type].length;
  }
  return count;
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {string} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 */
goog.events.ListenerMap.prototype.add = function(
    type, listener, callOnce, opt_useCapture, opt_listenerScope) {
  var listenerArray = this.listeners[type];
  if (!listenerArray) {
    listenerArray = this.listeners[type] = [];
    this.typeCount_++;
  }

  var listenerObj;
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    listenerObj = listenerArray[index];
    if (!callOnce) {
      // Ensure that, if there is an existing callOnce listener, it is no
      // longer a callOnce listener.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = new goog.events.Listener(
        listener, null, this.src, type, !!opt_useCapture, opt_listenerScope);
    listenerObj.callOnce = callOnce;
    listenerArray.push(listenerObj);
  }
  return listenerObj;
};


/**
 * Removes a matching listener.
 * @param {string} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {boolean} Whether any listener was removed.
 */
goog.events.ListenerMap.prototype.remove = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  if (!(type in this.listeners)) {
    return false;
  }

  var listenerArray = this.listeners[type];
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    var listenerObj = listenerArray[index];
    listenerObj.markAsRemoved();
    goog.array.removeAt(listenerArray, index);
    if (listenerArray.length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
    return true;
  }
  return false;
};


/**
 * Removes the given listener object.
 * @param {goog.events.ListenableKey} listener The listener to remove.
 * @return {boolean} Whether the listener is removed.
 */
goog.events.ListenerMap.prototype.removeByKey = function(listener) {
  var type = listener.type;
  if (!(type in this.listeners)) {
    return false;
  }

  var removed = goog.array.remove(this.listeners[type], listener);
  if (removed) {
    listener.markAsRemoved();
    if (this.listeners[type].length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return removed;
};


/**
 * Removes all listeners from this map. If opt_type is provided, only
 * listeners that match the given type are removed.
 * @param {string=} opt_type Type of event to remove.
 * @return {number} Number of listeners removed.
 */
goog.events.ListenerMap.prototype.removeAll = function(opt_type) {
  var count = 0;
  for (var type in this.listeners) {
    if (!opt_type || type == opt_type) {
      var listenerArray = this.listeners[type];
      for (var i = 0; i < listenerArray.length; i++) {
        ++count;
        listenerArray[i].markAsRemoved();
      }
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return count;
};


/**
 * Gets all listeners that match the given type and capture mode. The
 * returned array is a copy (but the listener objects are not).
 * @param {string} type The type of the listeners to retrieve.
 * @param {boolean} capture The capture mode of the listeners to retrieve.
 * @return {!Array.<goog.events.ListenableKey>} An array of matching
 *     listeners.
 */
goog.events.ListenerMap.prototype.getListeners = function(type, capture) {
  var listenerArray = this.listeners[type];
  var rv = [];
  if (listenerArray) {
    for (var i = 0; i < listenerArray.length; ++i) {
      var listenerObj = listenerArray[i];
      if (listenerObj.capture == capture) {
        rv.push(listenerObj);
      }
    }
  }
  return rv;
};


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string} type The type of the listener to retrieve.
 * @param {!Function} listener The listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.ListenerMap.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  var listenerArray = this.listeners[type];
  var i = -1;
  if (listenerArray) {
    i = goog.events.ListenerMap.findListenerIndex_(
        listenerArray, listener, capture, opt_listenerScope);
  }
  return i > -1 ? listenerArray[i] : null;
};


/**
 * Whether there is a matching listener. If either the type or capture
 * parameters are unspecified, the function will match on the
 * remaining criteria.
 *
 * @param {string=} opt_type The type of the listener.
 * @param {boolean=} opt_capture The capture mode of the listener.
 * @return {boolean} Whether there is an active listener matching
 *     the requested type and/or capture phase.
 */
goog.events.ListenerMap.prototype.hasListener = function(
    opt_type, opt_capture) {
  var hasType = goog.isDef(opt_type);
  var hasCapture = goog.isDef(opt_capture);

  return goog.object.some(
      this.listeners, function(listenerArray, type) {
        for (var i = 0; i < listenerArray.length; ++i) {
          if ((!hasType || listenerArray[i].type == opt_type) &&
              (!hasCapture || listenerArray[i].capture == opt_capture)) {
            return true;
          }
        }

        return false;
      });
};


/**
 * Finds the index of a matching goog.events.Listener in the given
 * listenerArray.
 * @param {!Array.<!goog.events.Listener>} listenerArray Array of listener.
 * @param {!Function} listener The listener function.
 * @param {boolean=} opt_useCapture The capture flag for the listener.
 * @param {Object=} opt_listenerScope The listener scope.
 * @return {number} The index of the matching listener within the
 *     listenerArray.
 * @private
 */
goog.events.ListenerMap.findListenerIndex_ = function(
    listenerArray, listener, opt_useCapture, opt_listenerScope) {
  for (var i = 0; i < listenerArray.length; ++i) {
    var listenerObj = listenerArray[i];
    if (!listenerObj.removed &&
        listenerObj.listener == listener &&
        listenerObj.capture == !!opt_useCapture &&
        listenerObj.handler == opt_listenerScope) {
      return i;
    }
  }
  return -1;
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the events package.
 *
 */


goog.provide('goog.events.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.events.BrowserFeature = {
  /**
   * Whether the button attribute of the event is W3C compliant.  False in
   * Internet Explorer prior to version 9; document-version dependent.
   */
  HAS_W3C_BUTTON: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether the browser supports full W3C event model.
   */
  HAS_W3C_EVENT_SUPPORT: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * To prevent default in IE7-8 for certain keydown events we need set the
   * keyCode to -1.
   */
  SET_KEY_CODE_TO_PREVENT_DEFAULT: goog.userAgent.IE &&
      !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether the {@code navigator.onLine} property is supported.
   */
  HAS_NAVIGATOR_ONLINE_PROPERTY: !goog.userAgent.WEBKIT ||
      goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network online/offline events are supported.
   */
  HAS_HTML5_NETWORK_EVENT_SUPPORT:
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||
      goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||
      goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network events fire on document.body, or otherwise the
   * window.
   */
  HTML5_NETWORK_EVENTS_FIRE_ON_BODY:
      goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether touch is enabled in the browser.
   */
  TOUCH_ENABLED:
      ('ontouchstart' in goog.global ||
          !!(goog.global['document'] &&
             document.documentElement &&
             'ontouchstart' in document.documentElement) ||
          // IE10 uses non-standard touch events, so it has a different check.
          !!(goog.global['navigator'] &&
              goog.global['navigator']['msMaxTouchPoints']))
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A global registry for entry points into a program,
 * so that they can be instrumented. Each module should register their
 * entry points with this registry. Designed to be compiled out
 * if no instrumentation is requested.
 *
 * Entry points may be registered before or after a call to
 * goog.debug.entryPointRegistry.monitorAll. If an entry point is registered
 * later, the existing monitor will instrument the new entry point.
 *
 * @author nicksantos@google.com (Nick Santos)
 */

goog.provide('goog.debug.EntryPointMonitor');
goog.provide('goog.debug.entryPointRegistry');

goog.require('goog.asserts');



/**
 * @interface
 */
goog.debug.EntryPointMonitor = function() {};


/**
 * Instruments a function.
 *
 * @param {!Function} fn A function to instrument.
 * @return {!Function} The instrumented function.
 */
goog.debug.EntryPointMonitor.prototype.wrap;


/**
 * Try to remove an instrumentation wrapper created by this monitor.
 * If the function passed to unwrap is not a wrapper created by this
 * monitor, then we will do nothing.
 *
 * Notice that some wrappers may not be unwrappable. For example, if other
 * monitors have applied their own wrappers, then it will be impossible to
 * unwrap them because their wrappers will have captured our wrapper.
 *
 * So it is important that entry points are unwrapped in the reverse
 * order that they were wrapped.
 *
 * @param {!Function} fn A function to unwrap.
 * @return {!Function} The unwrapped function, or {@code fn} if it was not
 *     a wrapped function created by this monitor.
 */
goog.debug.EntryPointMonitor.prototype.unwrap;


/**
 * An array of entry point callbacks.
 * @type {!Array.<function(!Function)>}
 * @private
 */
goog.debug.entryPointRegistry.refList_ = [];


/**
 * Monitors that should wrap all the entry points.
 * @type {!Array.<!goog.debug.EntryPointMonitor>}
 * @private
 */
goog.debug.entryPointRegistry.monitors_ = [];


/**
 * Whether goog.debug.entryPointRegistry.monitorAll has ever been called.
 * Checking this allows the compiler to optimize out the registrations.
 * @type {boolean}
 * @private
 */
goog.debug.entryPointRegistry.monitorsMayExist_ = false;


/**
 * Register an entry point with this module.
 *
 * The entry point will be instrumented when a monitor is passed to
 * goog.debug.entryPointRegistry.monitorAll. If this has already occurred, the
 * entry point is instrumented immediately.
 *
 * @param {function(!Function)} callback A callback function which is called
 *     with a transforming function to instrument the entry point. The callback
 *     is responsible for wrapping the relevant entry point with the
 *     transforming function.
 */
goog.debug.entryPointRegistry.register = function(callback) {
  // Don't use push(), so that this can be compiled out.
  goog.debug.entryPointRegistry.refList_[
      goog.debug.entryPointRegistry.refList_.length] = callback;
  // If no one calls monitorAll, this can be compiled out.
  if (goog.debug.entryPointRegistry.monitorsMayExist_) {
    var monitors = goog.debug.entryPointRegistry.monitors_;
    for (var i = 0; i < monitors.length; i++) {
      callback(goog.bind(monitors[i].wrap, monitors[i]));
    }
  }
};


/**
 * Configures a monitor to wrap all entry points.
 *
 * Entry points that have already been registered are immediately wrapped by
 * the monitor. When an entry point is registered in the future, it will also
 * be wrapped by the monitor when it is registered.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor An entry point monitor.
 */
goog.debug.entryPointRegistry.monitorAll = function(monitor) {
  goog.debug.entryPointRegistry.monitorsMayExist_ = true;
  var transformer = goog.bind(monitor.wrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  goog.debug.entryPointRegistry.monitors_.push(monitor);
};


/**
 * Try to unmonitor all the entry points that have already been registered. If
 * an entry point is registered in the future, it will not be wrapped by the
 * monitor when it is registered. Note that this may fail if the entry points
 * have additional wrapping.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor The last monitor to wrap
 *     the entry points.
 * @throws {Error} If the monitor is not the most recently configured monitor.
 */
goog.debug.entryPointRegistry.unmonitorAllIfPossible = function(monitor) {
  var monitors = goog.debug.entryPointRegistry.monitors_;
  goog.asserts.assert(monitor == monitors[monitors.length - 1],
      'Only the most recent monitor can be unwrapped.');
  var transformer = goog.bind(monitor.unwrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  monitors.length--;
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Event Types.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author mirkov@google.com (Mirko Visontai)
 */


goog.provide('goog.events.EventType');

goog.require('goog.userAgent');


/**
 * Returns a prefixed event name for the current browser.
 * @param {string} eventName The name of the event.
 * @return {string} The prefixed event name.
 * @suppress {missingRequire|missingProvide}
 * @private
 */
goog.events.getVendorPrefixedName_ = function(eventName) {
  return goog.userAgent.WEBKIT ? 'webkit' + eventName :
      (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :
          eventName.toLowerCase());
};


/**
 * Constants for event names.
 * @enum {string}
 */
goog.events.EventType = {
  // Mouse events
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  MOUSEDOWN: 'mousedown',
  MOUSEUP: 'mouseup',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEMOVE: 'mousemove',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  // Select start is non-standard.
  // See http://msdn.microsoft.com/en-us/library/ie/ms536969(v=vs.85).aspx.
  SELECTSTART: 'selectstart', // IE, Safari, Chrome

  // Key events
  KEYPRESS: 'keypress',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',

  // Focus
  BLUR: 'blur',
  FOCUS: 'focus',
  DEACTIVATE: 'deactivate', // IE only
  // NOTE: The following two events are not stable in cross-browser usage.
  //     WebKit and Opera implement DOMFocusIn/Out.
  //     IE implements focusin/out.
  //     Gecko implements neither see bug at
  //     https://bugzilla.mozilla.org/show_bug.cgi?id=396927.
  // The DOM Events Level 3 Draft deprecates DOMFocusIn in favor of focusin:
  //     http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html
  // You can use FOCUS in Capture phase until implementations converge.
  FOCUSIN: goog.userAgent.IE ? 'focusin' : 'DOMFocusIn',
  FOCUSOUT: goog.userAgent.IE ? 'focusout' : 'DOMFocusOut',

  // Forms
  CHANGE: 'change',
  SELECT: 'select',
  SUBMIT: 'submit',
  INPUT: 'input',
  PROPERTYCHANGE: 'propertychange', // IE only

  // Drag and drop
  DRAGSTART: 'dragstart',
  DRAG: 'drag',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DRAGLEAVE: 'dragleave',
  DROP: 'drop',
  DRAGEND: 'dragend',

  // WebKit touch events.
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  TOUCHCANCEL: 'touchcancel',

  // Misc
  BEFOREUNLOAD: 'beforeunload',
  CONSOLEMESSAGE: 'consolemessage',
  CONTEXTMENU: 'contextmenu',
  DOMCONTENTLOADED: 'DOMContentLoaded',
  ERROR: 'error',
  HELP: 'help',
  LOAD: 'load',
  LOSECAPTURE: 'losecapture',
  ORIENTATIONCHANGE: 'orientationchange',
  READYSTATECHANGE: 'readystatechange',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  UNLOAD: 'unload',

  // HTML 5 History events
  // See http://www.w3.org/TR/html5/history.html#event-definitions
  HASHCHANGE: 'hashchange',
  PAGEHIDE: 'pagehide',
  PAGESHOW: 'pageshow',
  POPSTATE: 'popstate',

  // Copy and Paste
  // Support is limited. Make sure it works on your favorite browser
  // before using.
  // http://www.quirksmode.org/dom/events/cutcopypaste.html
  COPY: 'copy',
  PASTE: 'paste',
  CUT: 'cut',
  BEFORECOPY: 'beforecopy',
  BEFORECUT: 'beforecut',
  BEFOREPASTE: 'beforepaste',

  // HTML5 online/offline events.
  // http://www.w3.org/TR/offline-webapps/#related
  ONLINE: 'online',
  OFFLINE: 'offline',

  // HTML 5 worker events
  MESSAGE: 'message',
  CONNECT: 'connect',

  // CSS animation events.
  /** @suppress {missingRequire} */
  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),
  /** @suppress {missingRequire} */
  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),
  /** @suppress {missingRequire} */
  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),

  // CSS transition events. Based on the browser support described at:
  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility
  /** @suppress {missingRequire} */
  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),

  // W3C Pointer Events
  // http://www.w3.org/TR/pointerevents/
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTERCANCEL: 'pointercancel',
  POINTERMOVE: 'pointermove',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',

  // IE specific events.
  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
  // Note: these events will be supplanted in IE11.
  MSGESTURECHANGE: 'MSGestureChange',
  MSGESTUREEND: 'MSGestureEnd',
  MSGESTUREHOLD: 'MSGestureHold',
  MSGESTURESTART: 'MSGestureStart',
  MSGESTURETAP: 'MSGestureTap',
  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',
  MSINERTIASTART: 'MSInertiaStart',
  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',
  MSPOINTERCANCEL: 'MSPointerCancel',
  MSPOINTERDOWN: 'MSPointerDown',
  MSPOINTERENTER: 'MSPointerEnter',
  MSPOINTERHOVER: 'MSPointerHover',
  MSPOINTERLEAVE: 'MSPointerLeave',
  MSPOINTERMOVE: 'MSPointerMove',
  MSPOINTEROUT: 'MSPointerOut',
  MSPOINTEROVER: 'MSPointerOver',
  MSPOINTERUP: 'MSPointerUp',

  // Native IMEs/input tools events.
  TEXTINPUT: 'textinput',
  COMPOSITIONSTART: 'compositionstart',
  COMPOSITIONUPDATE: 'compositionupdate',
  COMPOSITIONEND: 'compositionend',

  // Webview tag events
  // See http://developer.chrome.com/dev/apps/webview_tag.html
  EXIT: 'exit',
  LOADABORT: 'loadabort',
  LOADCOMMIT: 'loadcommit',
  LOADREDIRECT: 'loadredirect',
  LOADSTART: 'loadstart',
  LOADSTOP: 'loadstop',
  RESPONSIVE: 'responsive',
  SIZECHANGED: 'sizechanged',
  UNRESPONSIVE: 'unresponsive',

  // HTML5 Page Visibility API.  See details at
  // {@code goog.labs.dom.PageVisibilityMonitor}.
  VISIBILITYCHANGE: 'visibilitychange',

  // LocalStorage event.
  STORAGE: 'storage'
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 * @author nnaze@google.com (Nathan Naze)
 */


goog.provide('goog.disposable.IDisposable');



/**
 * Interface for a disposable object.  If a instance requires cleanup
 * (references COM objects, DOM notes, or other disposable objects), it should
 * implement this interface (it may subclass goog.Disposable).
 * @interface
 */
goog.disposable.IDisposable = function() {};


/**
 * Disposes of the object and its resources.
 * @return {void} Nothing.
 */
goog.disposable.IDisposable.prototype.dispose;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.disposable.IDisposable.prototype.isDisposed;
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implements the disposable interface. The dispose method is used
 * to clean up references and resources.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.Disposable');
/** @suppress {extraProvide} */
goog.provide('goog.dispose');
/** @suppress {extraProvide} */
goog.provide('goog.disposeAll');

goog.require('goog.disposable.IDisposable');



/**
 * Class that provides the basic implementation for disposable objects. If your
 * class holds one or more references to COM objects, DOM nodes, or other
 * disposable objects, it should extend this class or implement the disposable
 * interface (defined in goog.disposable.IDisposable).
 * @constructor
 * @implements {goog.disposable.IDisposable}
 */
goog.Disposable = function() {
  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {
      this.creationStack = new Error().stack;
    }
    goog.Disposable.instances_[goog.getUid(this)] = this;
  }
};


/**
 * @enum {number} Different monitoring modes for Disposable.
 */
goog.Disposable.MonitoringMode = {
  /**
   * No monitoring.
   */
  OFF: 0,
  /**
   * Creating and disposing the goog.Disposable instances is monitored. All
   * disposable objects need to call the {@code goog.Disposable} base
   * constructor. The PERMANENT mode must be switched on before creating any
   * goog.Disposable instances.
   */
  PERMANENT: 1,
  /**
   * INTERACTIVE mode can be switched on and off on the fly without producing
   * errors. It also doesn't warn if the disposable objects don't call the
   * {@code goog.Disposable} base constructor.
   */
  INTERACTIVE: 2
};


/**
 * @define {number} The monitoring mode of the goog.Disposable
 *     instances. Default is OFF. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.Disposable.MONITORING_MODE', 0);


/**
 * @define {boolean} Whether to attach creation stack to each created disposable
 *     instance; This is only relevant for when MonitoringMode != OFF.
 */
goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);


/**
 * Maps the unique ID of every undisposed {@code goog.Disposable} object to
 * the object itself.
 * @type {!Object.<number, !goog.Disposable>}
 * @private
 */
goog.Disposable.instances_ = {};


/**
 * @return {!Array.<!goog.Disposable>} All {@code goog.Disposable} objects that
 *     haven't been disposed of.
 */
goog.Disposable.getUndisposedObjects = function() {
  var ret = [];
  for (var id in goog.Disposable.instances_) {
    if (goog.Disposable.instances_.hasOwnProperty(id)) {
      ret.push(goog.Disposable.instances_[Number(id)]);
    }
  }
  return ret;
};


/**
 * Clears the registry of undisposed objects but doesn't dispose of them.
 */
goog.Disposable.clearUndisposedObjects = function() {
  goog.Disposable.instances_ = {};
};


/**
 * Whether the object has been disposed of.
 * @type {boolean}
 * @private
 */
goog.Disposable.prototype.disposed_ = false;


/**
 * Callbacks to invoke when this object is disposed.
 * @type {Array.<!Function>}
 * @private
 */
goog.Disposable.prototype.onDisposeCallbacks_;


/**
 * If monitoring the goog.Disposable instances is enabled, stores the creation
 * stack trace of the Disposable instance.
 * @type {string}
 */
goog.Disposable.prototype.creationStack;


/**
 * @return {boolean} Whether the object has been disposed of.
 * @override
 */
goog.Disposable.prototype.isDisposed = function() {
  return this.disposed_;
};


/**
 * @return {boolean} Whether the object has been disposed of.
 * @deprecated Use {@link #isDisposed} instead.
 */
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;


/**
 * Disposes of the object. If the object hasn't already been disposed of, calls
 * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should
 * override {@link #disposeInternal} in order to delete references to COM
 * objects, DOM nodes, and other disposable objects. Reentrant.
 *
 * @return {void} Nothing.
 * @override
 */
goog.Disposable.prototype.dispose = function() {
  if (!this.disposed_) {
    // Set disposed_ to true first, in case during the chain of disposal this
    // gets disposed recursively.
    this.disposed_ = true;
    this.disposeInternal();
    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
      var uid = goog.getUid(this);
      if (goog.Disposable.MONITORING_MODE ==
          goog.Disposable.MonitoringMode.PERMANENT &&
          !goog.Disposable.instances_.hasOwnProperty(uid)) {
        throw Error(this + ' did not call the goog.Disposable base ' +
            'constructor or was disposed of after a clearUndisposedObjects ' +
            'call');
      }
      delete goog.Disposable.instances_[uid];
    }
  }
};


/**
 * Associates a disposable object with this object so that they will be disposed
 * together.
 * @param {goog.disposable.IDisposable} disposable that will be disposed when
 *     this object is disposed.
 */
goog.Disposable.prototype.registerDisposable = function(disposable) {
  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));
};


/**
 * Invokes a callback function when this object is disposed. Callbacks are
 * invoked in the order in which they were added.
 * @param {function(this:T):?} callback The callback function.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @template T
 */
goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {
  if (!this.onDisposeCallbacks_) {
    this.onDisposeCallbacks_ = [];
  }
  this.onDisposeCallbacks_.push(goog.bind(callback, opt_scope));
};


/**
 * Deletes or nulls out any references to COM objects, DOM nodes, or other
 * disposable objects. Classes that extend {@code goog.Disposable} should
 * override this method.
 * Not reentrant. To avoid calling it twice, it must only be called from the
 * subclass' {@code disposeInternal} method. Everywhere else the public
 * {@code dispose} method must be used.
 * For example:
 * <pre>
 *   mypackage.MyClass = function() {
 *     goog.base(this);
 *     // Constructor logic specific to MyClass.
 *     ...
 *   };
 *   goog.inherits(mypackage.MyClass, goog.Disposable);
 *
 *   mypackage.MyClass.prototype.disposeInternal = function() {
 *     // Dispose logic specific to MyClass.
 *     ...
 *     // Call superclass's disposeInternal at the end of the subclass's, like
 *     // in C++, to avoid hard-to-catch issues.
 *     goog.base(this, 'disposeInternal');
 *   };
 * </pre>
 * @protected
 */
goog.Disposable.prototype.disposeInternal = function() {
  if (this.onDisposeCallbacks_) {
    while (this.onDisposeCallbacks_.length) {
      this.onDisposeCallbacks_.shift()();
    }
  }
};


/**
 * Returns True if we can verify the object is disposed.
 * Calls {@code isDisposed} on the argument if it supports it.  If obj
 * is not an object with an isDisposed() method, return false.
 * @param {*} obj The object to investigate.
 * @return {boolean} True if we can verify the object is disposed.
 */
goog.Disposable.isDisposed = function(obj) {
  if (obj && typeof obj.isDisposed == 'function') {
    return obj.isDisposed();
  }
  return false;
};


/**
 * Calls {@code dispose} on the argument if it supports it. If obj is not an
 *     object with a dispose() method, this is a no-op.
 * @param {*} obj The object to dispose of.
 */
goog.dispose = function(obj) {
  if (obj && typeof obj.dispose == 'function') {
    obj.dispose();
  }
};


/**
 * Calls {@code dispose} on each member of the list that supports it. (If the
 * member is an ArrayLike, then {@code goog.disposeAll()} will be called
 * recursively on each of its members.) If the member is not an object with a
 * {@code dispose()} method, then it is ignored.
 * @param {...*} var_args The list.
 */
goog.disposeAll = function(var_args) {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    var disposable = arguments[i];
    if (goog.isArrayLike(disposable)) {
      goog.disposeAll.apply(null, disposable);
    } else {
      goog.dispose(disposable);
    }
  }
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A base class for event objects.
 *
 */


goog.provide('goog.events.Event');
goog.provide('goog.events.EventLike');

/**
 * goog.events.Event no longer depends on goog.Disposable. Keep requiring
 * goog.Disposable here to not break projects which assume this dependency.
 * @suppress {extraRequire}
 */
goog.require('goog.Disposable');
goog.require('goog.events.EventId');


/**
 * A typedef for event like objects that are dispatchable via the
 * goog.events.dispatchEvent function. strings are treated as the type for a
 * goog.events.Event. Objects are treated as an extension of a new
 * goog.events.Event with the type property of the object being used as the type
 * of the Event.
 * @typedef {string|Object|goog.events.Event|goog.events.EventId}
 */
goog.events.EventLike;



/**
 * A base class for event objects, so that they can support preventDefault and
 * stopPropagation.
 *
 * @param {string|!goog.events.EventId} type Event Type.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the {@code EventTarget} interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 */
goog.events.Event = function(type, opt_target) {
  /**
   * Event type.
   * @type {string}
   */
  this.type = type instanceof goog.events.EventId ? String(type) : type;

  /**
   * Target of the event.
   * @type {Object|undefined}
   */
  this.target = opt_target;

  /**
   * Object that had the listener attached.
   * @type {Object|undefined}
   */
  this.currentTarget = this.target;

  /**
   * Whether to cancel the event in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.propagationStopped_ = false;

  /**
   * Whether the default action has been prevented.
   * This is a property to match the W3C specification at
   * {@link http://www.w3.org/TR/DOM-Level-3-Events/
   * #events-event-type-defaultPrevented}.
   * Must be treated as read-only outside the class.
   * @type {boolean}
   */
  this.defaultPrevented = false;

  /**
   * Return value for in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.returnValue_ = true;
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.disposeInternal = function() {
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.dispose = function() {
};


/**
 * Stops event propagation.
 */
goog.events.Event.prototype.stopPropagation = function() {
  this.propagationStopped_ = true;
};


/**
 * Prevents the default action, for example a link redirecting to a url.
 */
goog.events.Event.prototype.preventDefault = function() {
  this.defaultPrevented = true;
  this.returnValue_ = false;
};


/**
 * Stops the propagation of the event. It is equivalent to
 * {@code e.stopPropagation()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.stopPropagation = function(e) {
  e.stopPropagation();
};


/**
 * Prevents the default action. It is equivalent to
 * {@code e.preventDefault()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.preventDefault = function(e) {
  e.preventDefault();
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Useful compiler idioms.
 *
 */

goog.provide('goog.reflect');


/**
 * Syntax for object literal casts.
 * @see http://go/jscompiler-renaming
 * @see http://code.google.com/p/closure-compiler/wiki/
 *      ExperimentalTypeBasedPropertyRenaming
 *
 * Use this if you have an object literal whose keys need to have the same names
 * as the properties of some class even after they are renamed by the compiler.
 *
 * @param {!Function} type Type to cast to.
 * @param {Object} object Object literal to cast.
 * @return {Object} The object literal.
 */
goog.reflect.object = function(type, object) {
  return object;
};


/**
 * To assert to the compiler that an operation is needed when it would
 * otherwise be stripped. For example:
 * <code>
 *     // Force a layout
 *     goog.reflect.sinkValue(dialog.offsetHeight);
 * </code>
 * @type {!Function}
 */
goog.reflect.sinkValue = function(x) {
  goog.reflect.sinkValue[' '](x);
  return x;
};


/**
 * The compiler should optimize this function away iff no one ever uses
 * goog.reflect.sinkValue.
 */
goog.reflect.sinkValue[' '] = goog.nullFunction;


/**
 * Check if a property can be accessed without throwing an exception.
 * @param {Object} obj The owner of the property.
 * @param {string} prop The property name.
 * @return {boolean} Whether the property is accessible. Will also return true
 *     if obj is null.
 */
goog.reflect.canAccessProperty = function(obj, prop) {
  /** @preserveTry */
  try {
    goog.reflect.sinkValue(obj[prop]);
    return true;
  } catch (e) {}
  return false;
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A patched, standardized event object for browser events.
 *
 * <pre>
 * The patched event object contains the following members:
 * - type           {string}    Event type, e.g. 'click'
 * - timestamp      {Date}      A date object for when the event was fired
 * - target         {Object}    The element that actually triggered the event
 * - currentTarget  {Object}    The element the listener is attached to
 * - relatedTarget  {Object}    For mouseover and mouseout, the previous object
 * - offsetX        {number}    X-coordinate relative to target
 * - offsetY        {number}    Y-coordinate relative to target
 * - clientX        {number}    X-coordinate relative to viewport
 * - clientY        {number}    Y-coordinate relative to viewport
 * - screenX        {number}    X-coordinate relative to the edge of the screen
 * - screenY        {number}    Y-coordinate relative to the edge of the screen
 * - button         {number}    Mouse button. Use isButton() to test.
 * - keyCode        {number}    Key-code
 * - ctrlKey        {boolean}   Was ctrl key depressed
 * - altKey         {boolean}   Was alt key depressed
 * - shiftKey       {boolean}   Was shift key depressed
 * - metaKey        {boolean}   Was meta key depressed
 * - defaultPrevented {boolean} Whether the default action has been prevented
 * - state          {Object}    History state object
 *
 * NOTE: The keyCode member contains the raw browser keyCode. For normalized
 * key and character code use {@link goog.events.KeyHandler}.
 * </pre>
 *
 */

goog.provide('goog.events.BrowserEvent');
goog.provide('goog.events.BrowserEvent.MouseButton');

goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Event');
goog.require('goog.events.EventType');
goog.require('goog.reflect');
goog.require('goog.userAgent');



/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * The content of this object will not be initialized if no event object is
 * provided. If this is the case, init() needs to be invoked separately.
 * @param {Event=} opt_e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 * @constructor
 * @extends {goog.events.Event}
 */
goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {
  goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');

  /**
   * Target that fired the event.
   * @override
   * @type {Node}
   */
  this.target = null;

  /**
   * Node that had the listener attached.
   * @override
   * @type {Node|undefined}
   */
  this.currentTarget = null;

  /**
   * For mouseover and mouseout events, the related object for the event.
   * @type {Node}
   */
  this.relatedTarget = null;

  /**
   * X-coordinate relative to target.
   * @type {number}
   */
  this.offsetX = 0;

  /**
   * Y-coordinate relative to target.
   * @type {number}
   */
  this.offsetY = 0;

  /**
   * X-coordinate relative to the window.
   * @type {number}
   */
  this.clientX = 0;

  /**
   * Y-coordinate relative to the window.
   * @type {number}
   */
  this.clientY = 0;

  /**
   * X-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenX = 0;

  /**
   * Y-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenY = 0;

  /**
   * Which mouse button was pressed.
   * @type {number}
   */
  this.button = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.charCode = 0;

  /**
   * Whether control was pressed at time of event.
   * @type {boolean}
   */
  this.ctrlKey = false;

  /**
   * Whether alt was pressed at time of event.
   * @type {boolean}
   */
  this.altKey = false;

  /**
   * Whether shift was pressed at time of event.
   * @type {boolean}
   */
  this.shiftKey = false;

  /**
   * Whether the meta key was pressed at time of event.
   * @type {boolean}
   */
  this.metaKey = false;

  /**
   * History state object, only set for PopState events where it's a copy of the
   * state object provided to pushState or replaceState.
   * @type {Object}
   */
  this.state = null;

  /**
   * Whether the default platform modifier key was pressed at time of event.
   * (This is control for all platforms except Mac, where it's Meta.)
   * @type {boolean}
   */
  this.platformModifierKey = false;

  /**
   * The browser event object.
   * @private {Event}
   */
  this.event_ = null;

  if (opt_e) {
    this.init(opt_e, opt_currentTarget);
  }
};
goog.inherits(goog.events.BrowserEvent, goog.events.Event);


/**
 * Normalized button constants for the mouse.
 * @enum {number}
 */
goog.events.BrowserEvent.MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};


/**
 * Static data for mapping mouse buttons.
 * @type {!Array.<number>}
 */
goog.events.BrowserEvent.IEButtonMap = [
  1, // LEFT
  4, // MIDDLE
  2  // RIGHT
];


/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * @param {Event} e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 */
goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {
  var type = this.type = e.type;

  // TODO(nicksantos): Change this.target to type EventTarget.
  this.target = /** @type {Node} */ (e.target) || e.srcElement;

  // TODO(nicksantos): Change this.currentTarget to type EventTarget.
  this.currentTarget = /** @type {Node} */ (opt_currentTarget);

  var relatedTarget = /** @type {Node} */ (e.relatedTarget);
  if (relatedTarget) {
    // There's a bug in FireFox where sometimes, relatedTarget will be a
    // chrome element, and accessing any property of it will get a permission
    // denied exception. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780
    if (goog.userAgent.GECKO) {
      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {
        relatedTarget = null;
      }
    }
    // TODO(arv): Use goog.events.EventType when it has been refactored into its
    // own file.
  } else if (type == goog.events.EventType.MOUSEOVER) {
    relatedTarget = e.fromElement;
  } else if (type == goog.events.EventType.MOUSEOUT) {
    relatedTarget = e.toElement;
  }

  this.relatedTarget = relatedTarget;

  // Webkit emits a lame warning whenever layerX/layerY is accessed.
  // http://code.google.com/p/chromium/issues/detail?id=101733
  this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?
      e.offsetX : e.layerX;
  this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?
      e.offsetY : e.layerY;

  this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
  this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
  this.screenX = e.screenX || 0;
  this.screenY = e.screenY || 0;

  this.button = e.button;

  this.keyCode = e.keyCode || 0;
  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);
  this.ctrlKey = e.ctrlKey;
  this.altKey = e.altKey;
  this.shiftKey = e.shiftKey;
  this.metaKey = e.metaKey;
  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
  this.state = e.state;
  this.event_ = e;
  if (e.defaultPrevented) {
    this.preventDefault();
  }
};


/**
 * Tests to see which button was pressed during the event. This is really only
 * useful in IE and Gecko browsers. And in IE, it's only useful for
 * mousedown/mouseup events, because click only fires for the left mouse button.
 *
 * Safari 2 only reports the left button being clicked, and uses the value '1'
 * instead of 0. Opera only reports a mousedown event for the middle button, and
 * no mouse events for the right button. Opera has default behavior for left and
 * middle click that can only be overridden via a configuration setting.
 *
 * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.
 *
 * @param {goog.events.BrowserEvent.MouseButton} button The button
 *     to test for.
 * @return {boolean} True if button was pressed.
 */
goog.events.BrowserEvent.prototype.isButton = function(button) {
  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {
    if (this.type == 'click') {
      return button == goog.events.BrowserEvent.MouseButton.LEFT;
    } else {
      return !!(this.event_.button &
          goog.events.BrowserEvent.IEButtonMap[button]);
    }
  } else {
    return this.event_.button == button;
  }
};


/**
 * Whether this has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @return {boolean} The result.
 */
goog.events.BrowserEvent.prototype.isMouseActionButton = function() {
  // Webkit does not ctrl+click to be a right-click, so we
  // normalize it to behave like Gecko and Opera.
  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&
      !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.stopPropagation = function() {
  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
  if (this.event_.stopPropagation) {
    this.event_.stopPropagation();
  } else {
    this.event_.cancelBubble = true;
  }
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.preventDefault = function() {
  goog.events.BrowserEvent.superClass_.preventDefault.call(this);
  var be = this.event_;
  if (!be.preventDefault) {
    be.returnValue = false;
    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {
      /** @preserveTry */
      try {
        // Most keys can be prevented using returnValue. Some special keys
        // require setting the keyCode to -1 as well:
        //
        // In IE7:
        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)
        //
        // In IE8:
        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)
        //
        // We therefore do this for all function keys as well as when Ctrl key
        // is pressed.
        var VK_F1 = 112;
        var VK_F12 = 123;
        if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {
          be.keyCode = -1;
        }
      } catch (ex) {
        // IE throws an 'access denied' exception when trying to change
        // keyCode in some situations (e.g. srcElement is input[type=file],
        // or srcElement is an anchor tag rewritten by parent's innerHTML).
        // Do nothing in this case.
      }
    }
  } else {
    be.preventDefault();
  }
};


/**
 * @return {Event} The underlying browser event object.
 */
goog.events.BrowserEvent.prototype.getBrowserEvent = function() {
  return this.event_;
};


/** @override */
goog.events.BrowserEvent.prototype.disposeInternal = function() {
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An event manager for both native browser event
 * targets and custom JavaScript event targets
 * ({@code goog.events.Listenable}). This provides an abstraction
 * over browsers' event systems.
 *
 * It also provides a simulation of W3C event model's capture phase in
 * Internet Explorer (IE 8 and below). Caveat: the simulation does not
 * interact well with listeners registered directly on the elements
 * (bypassing goog.events) or even with listeners registered via
 * goog.events in a separate JS binary. In these cases, we provide
 * no ordering guarantees.
 *
 * The listeners will receive a "patched" event object. Such event object
 * contains normalized values for certain event properties that differs in
 * different browsers.
 *
 * Example usage:
 * <pre>
 * goog.events.listen(myNode, 'click', function(e) { alert('woo') });
 * goog.events.listen(myNode, 'mouseover', mouseHandler, true);
 * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);
 * goog.events.removeAll(myNode);
 * </pre>
 *
 *                                            in IE and event object patching]
 *
 * @see ../demos/events.html
 * @see ../demos/event-propagation.html
 * @see ../demos/stopevent.html
 */

// IMPLEMENTATION NOTES:
// goog.events stores an auxiliary data structure on each EventTarget
// source being listened on. This allows us to take advantage of GC,
// having the data structure GC'd when the EventTarget is GC'd. This
// GC behavior is equivalent to using W3C DOM Events directly.

goog.provide('goog.events');
goog.provide('goog.events.CaptureSimulationMode');
goog.provide('goog.events.Key');
goog.provide('goog.events.ListenableType');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');


/**
 * @typedef {number|goog.events.ListenableKey}
 */
goog.events.Key;


/**
 * @typedef {EventTarget|goog.events.Listenable}
 */
goog.events.ListenableType;


/**
 * Container for storing event listeners and their proxies
 *
 * TODO(user): Remove this when all external usage is
 * purged. goog.events no longer use goog.events.listeners_ for
 * anything meaningful.
 *
 * @private {!Object.<goog.events.ListenableKey>}
 */
goog.events.listeners_ = {};


/**
 * Property name on a native event target for the listener map
 * associated with the event target.
 * @const
 * @private
 */
goog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);


/**
 * String used to prepend to IE event types.
 * @const
 * @private
 */
goog.events.onString_ = 'on';


/**
 * Map of computed "on<eventname>" strings for IE event types. Caching
 * this removes an extra object allocation in goog.events.listen which
 * improves IE6 performance.
 * @const
 * @dict
 * @private
 */
goog.events.onStringMap_ = {};


/**
 * @enum {number} Different capture simulation mode for IE8-.
 */
goog.events.CaptureSimulationMode = {
  /**
   * Does not perform capture simulation. Will asserts in IE8- when you
   * add capture listeners.
   */
  OFF_AND_FAIL: 0,

  /**
   * Does not perform capture simulation, silently ignore capture
   * listeners.
   */
  OFF_AND_SILENT: 1,

  /**
   * Performs capture simulation.
   */
  ON: 2
};


/**
 * @define {number} The capture simulation mode for IE8-. By default,
 *     this is ON.
 */
goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);


/**
 * Estimated count of total native listeners.
 * @private {number}
 */
goog.events.listenerCountEstimate_ = 0;


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. A listener can only be added once
 * to an object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>} type Event type or array of event types.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 *     WARNING: passing an Object is now softly deprecated.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T
 */
goog.events.listen = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listen(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listen(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        type, listener, /* callOnce */ false, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener for a specific event on a native event
 * target. A listener can only be added once to an object and if it
 * is added again the key for the listener is returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {EventTarget} src The node to listen to events on.
 * @param {?string} type Event type or array of event types.
 * @param {!Function} listener Callback function.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener or otherwise.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @private
 */
goog.events.listen_ = function(
    src, type, listener, callOnce, opt_capt, opt_handler) {
  if (!type) {
    throw Error('Invalid event type');
  }

  var capture = !!opt_capt;
  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
      goog.asserts.fail('Can not register capture listener in IE8-.');
      return null;
    } else if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {
      return null;
    }
  }

  var listenerMap = goog.events.getListenerMap_(src);
  if (!listenerMap) {
    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
        new goog.events.ListenerMap(src);
  }

  var listenerObj = listenerMap.add(
      type, listener, callOnce, opt_capt, opt_handler);

  // If the listenerObj already has a proxy, it has been set up
  // previously. We simply return.
  if (listenerObj.proxy) {
    return listenerObj;
  }

  var proxy = goog.events.getProxy();
  listenerObj.proxy = proxy;

  proxy.src = src;
  proxy.listener = listenerObj;

  // Attach the proxy through the browser's API
  if (src.addEventListener) {
    src.addEventListener(type, proxy, capture);
  } else {
    // The else above used to be else if (src.attachEvent) and then there was
    // another else statement that threw an exception warning the developer
    // they made a mistake. This resulted in an extra object allocation in IE6
    // due to a wrapper object that had to be implemented around the element
    // and so was removed.
    src.attachEvent(goog.events.getOnString_(type), proxy);
  }

  goog.events.listenerCountEstimate_++;
  return listenerObj;
};


/**
 * Helper function for returning a proxy function.
 * @return {Function} A new or reused function object.
 */
goog.events.getProxy = function() {
  var proxyCallbackFunction = goog.events.handleBrowserEvent_;
  // Use a local var f to prevent one allocation.
  var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ?
      function(eventObject) {
        return proxyCallbackFunction.call(f.src, f.listener, eventObject);
      } :
      function(eventObject) {
        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
        // NOTE(user): In IE, we hack in a capture phase. However, if
        // there is inline event handler which tries to prevent default (for
        // example <a href="..." onclick="return false">...</a>) in a
        // descendant element, the prevent default will be overridden
        // by this listener if this listener were to return true. Hence, we
        // return undefined.
        if (!v) return v;
      };
  return f;
};


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. After the event has fired the event
 * listener is removed from the target.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>} type Event type or array of event types.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method.
 * @param {boolean=} opt_capt Fire in capture phase?.
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T
 */
goog.events.listenOnce = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listenOnce(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listenOnce(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        type, listener, /* callOnce */ true, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.Listenable}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.Listenable} src The target to
 *     listen to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @template T
 */
goog.events.listenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.listen(src, listener, opt_capt, opt_handler);
};


/**
 * Removes an event listener which was added with listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {string|Array.<string>} type The name of the event without the 'on'
 *     prefix.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {?boolean} indicating whether the listener was there to remove.
 */
goog.events.unlisten = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.unlisten(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlisten(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  }

  if (!src) {
    // TODO(user): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return false;
  }

  var capture = !!opt_capt;
  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    var listenerObj = listenerMap.getListener(
        /** @type {string} */ (type), listener, capture, opt_handler);
    if (listenerObj) {
      return goog.events.unlistenByKey(listenerObj);
    }
  }

  return false;
};


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.Key} key The key returned by listen() for this
 *     event listener.
 * @return {boolean} indicating whether the listener was there to remove.
 */
goog.events.unlistenByKey = function(key) {
  // TODO(user): Remove this check when tests that rely on this
  // are fixed.
  if (goog.isNumber(key)) {
    return false;
  }

  var listener = /** @type {goog.events.ListenableKey} */ (key);
  if (!listener || listener.removed) {
    return false;
  }

  var src = listener.src;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlistenByKey(listener);
  }

  var type = listener.type;
  var proxy = listener.proxy;
  if (src.removeEventListener) {
    src.removeEventListener(type, proxy, listener.capture);
  } else if (src.detachEvent) {
    src.detachEvent(goog.events.getOnString_(type), proxy);
  }
  goog.events.listenerCountEstimate_--;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  // TODO(user): Try to remove this conditional and execute the
  // first branch always. This should be safe.
  if (listenerMap) {
    listenerMap.removeByKey(listener);
    if (listenerMap.getTypeCount() == 0) {
      // Null the src, just because this is simple to do (and useful
      // for IE <= 7).
      listenerMap.src = null;
      // We don't use delete here because IE does not allow delete
      // on a window object.
      src[goog.events.LISTENER_MAP_PROP_] = null;
    }
  } else {
    listener.markAsRemoved();
  }

  return true;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 */
goog.events.unlistenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.unlisten(src, listener, opt_capt, opt_handler);
};


/**
 * Removes all listeners from an object. You can also optionally
 * remove listeners of a particular type.
 *
 * @param {Object=} opt_obj Object to remove listeners from. Not
 *     specifying opt_obj is now DEPRECATED (it used to remove all
 *     registered listeners).
 * @param {string=} opt_type Type of event to, default is all types.
 * @return {number} Number of listeners removed.
 */
goog.events.removeAll = function(opt_obj, opt_type) {
  // TODO(user): Change the type of opt_obj from Object= to
  // !EventTarget|goog.events.Listenable). And replace this with an
  // assertion.
  if (!opt_obj) {
    return 0;
  }

  if (goog.events.Listenable.isImplementedBy(opt_obj)) {
    return opt_obj.removeAllListeners(opt_type);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (opt_obj));
  if (!listenerMap) {
    return 0;
  }

  var count = 0;
  for (var type in listenerMap.listeners) {
    if (!opt_type || type == opt_type) {
      // Clone so that we don't need to worry about unlistenByKey
      // changing the content of the ListenerMap.
      var listeners = goog.array.clone(listenerMap.listeners[type]);
      for (var i = 0; i < listeners.length; ++i) {
        if (goog.events.unlistenByKey(listeners[i])) {
          ++count;
        }
      }
    }
  }
  return count;
};


/**
 * Removes all native listeners registered via goog.events. Native
 * listeners are listeners on native browser objects (such as DOM
 * elements). In particular, goog.events.Listenable and
 * goog.events.EventTarget listeners will NOT be removed.
 * @return {number} Number of listeners removed.
 * @deprecated This doesn't do anything, now that Closure no longer
 * stores a central listener registry.
 */
goog.events.removeAllNativeListeners = function() {
  goog.events.listenerCountEstimate_ = 0;
  return 0;
};


/**
 * Gets the listeners for a given object, type and capture phase.
 *
 * @param {Object} obj Object to get listeners for.
 * @param {string} type Event type.
 * @param {boolean} capture Capture phase?.
 * @return {Array.<goog.events.Listener>} Array of listener objects.
 */
goog.events.getListeners = function(obj, type, capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.getListeners(type, capture);
  } else {
    if (!obj) {
      // TODO(user): We should tighten the API to accept
      // !EventTarget|goog.events.Listenable, and add an assertion here.
      return [];
    }

    var listenerMap = goog.events.getListenerMap_(
        /** @type {EventTarget} */ (obj));
    return listenerMap ? listenerMap.getListeners(type, capture) : [];
  }
};


/**
 * Gets the goog.events.Listener for the event or null if no such listener is
 * in use.
 *
 * @param {EventTarget|goog.events.Listenable} src The target from
 *     which to get listeners.
 * @param {?string} type The name of the event without the 'on' prefix.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to get.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *                            whether the listener is fired during the
 *                            capture or bubble phase of the event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
  // TODO(user): Change type from ?string to string, or add assertion.
  type = /** @type {string} */ (type);
  listener = goog.events.wrapListener(listener);
  var capture = !!opt_capt;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.getListener(type, listener, capture, opt_handler);
  }

  if (!src) {
    // TODO(user): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return null;
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    return listenerMap.getListener(type, listener, capture, opt_handler);
  }
  return null;
};


/**
 * Returns whether an event target has any active listeners matching the
 * specified signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {EventTarget|goog.events.Listenable} obj Target to get
 *     listeners for.
 * @param {string=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
 *     listeners.
 * @return {boolean} Whether an event target has one or more listeners matching
 *     the requested type and/or capture phase.
 */
goog.events.hasListener = function(obj, opt_type, opt_capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.hasListener(opt_type, opt_capture);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);
};


/**
 * Provides a nice string showing the normalized event objects public members
 * @param {Object} e Event Object.
 * @return {string} String of the public members of the normalized event object.
 */
goog.events.expose = function(e) {
  var str = [];
  for (var key in e) {
    if (e[key] && e[key].id) {
      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');
    } else {
      str.push(key + ' = ' + e[key]);
    }
  }
  return str.join('\n');
};


/**
 * Returns a string with on prepended to the specified type. This is used for IE
 * which expects "on" to be prepended. This function caches the string in order
 * to avoid extra allocations in steady state.
 * @param {string} type Event type.
 * @return {string} The type string with 'on' prepended.
 * @private
 */
goog.events.getOnString_ = function(type) {
  if (type in goog.events.onStringMap_) {
    return goog.events.onStringMap_[type];
  }
  return goog.events.onStringMap_[type] = goog.events.onString_ + type;
};


/**
 * Fires an object's listeners of a particular type and phase
 *
 * @param {Object} obj Object whose listeners to call.
 * @param {string} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 */
goog.events.fireListeners = function(obj, type, capture, eventObject) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.fireListeners(type, capture, eventObject);
  }

  return goog.events.fireListeners_(obj, type, capture, eventObject);
};


/**
 * Fires an object's listeners of a particular type and phase.
 * @param {Object} obj Object whose listeners to call.
 * @param {string} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 * @private
 */
goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
  var retval = 1;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  if (listenerMap) {
    // TODO(user): Original code avoids array creation when there
    // is no listener, so we do the same. If this optimization turns
    // out to be not required, we can replace this with
    // listenerMap.getListeners(type, capture) instead, which is simpler.
    var listenerArray = listenerMap.listeners[type];
    if (listenerArray) {
      listenerArray = goog.array.clone(listenerArray);
      for (var i = 0; i < listenerArray.length; i++) {
        var listener = listenerArray[i];
        // We might not have a listener if the listener was removed.
        if (listener && listener.capture == capture && !listener.removed) {
          retval &=
              goog.events.fireListener(listener, eventObject) !== false;
        }
      }
    }
  }
  return Boolean(retval);
};


/**
 * Fires a listener with a set of arguments
 *
 * @param {goog.events.Listener} listener The listener object to call.
 * @param {Object} eventObject The event object to pass to the listener.
 * @return {boolean} Result of listener.
 */
goog.events.fireListener = function(listener, eventObject) {
  var listenerFn = listener.listener;
  var listenerHandler = listener.handler || listener.src;

  if (listener.callOnce) {
    goog.events.unlistenByKey(listener);
  }
  return listenerFn.call(listenerHandler, eventObject);
};


/**
 * Gets the total number of listeners currently in the system.
 * @return {number} Number of listeners.
 * @deprecated This returns estimated count, now that Closure no longer
 * stores a central listener registry. We still return an estimation
 * to keep existing listener-related tests passing. In the near future,
 * this function will be removed.
 */
goog.events.getTotalListenerCount = function() {
  return goog.events.listenerCountEstimate_;
};


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.Listenable} src The event target.
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false) this will also return false.
 *     If there are no handlers, or if all handlers return true, this returns
 *     true.
 */
goog.events.dispatchEvent = function(src, e) {
  goog.asserts.assert(
      goog.events.Listenable.isImplementedBy(src),
      'Can not use goog.events.dispatchEvent with ' +
      'non-goog.events.Listenable instance.');
  return src.dispatchEvent(e);
};


/**
 * Installs exception protection for the browser event entry point using the
 * given error handler.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point.
 */
goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
  goog.events.handleBrowserEvent_ = errorHandler.protectEntryPoint(
      goog.events.handleBrowserEvent_);
};


/**
 * Handles an event and dispatches it to the correct listeners. This
 * function is a proxy for the real listener the user specified.
 *
 * @param {goog.events.Listener} listener The listener object.
 * @param {Event=} opt_evt Optional event object that gets passed in via the
 *     native event handlers.
 * @return {boolean} Result of the event handler.
 * @this {EventTarget} The object or Element that fired the event.
 * @private
 */
goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
  if (listener.removed) {
    return true;
  }

  // Synthesize event propagation if the browser does not support W3C
  // event model.
  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    var ieEvent = opt_evt ||
        /** @type {Event} */ (goog.getObjectByName('window.event'));
    var evt = new goog.events.BrowserEvent(ieEvent, this);
    var retval = true;

    if (goog.events.CAPTURE_SIMULATION_MODE ==
            goog.events.CaptureSimulationMode.ON) {
      // If we have not marked this event yet, we should perform capture
      // simulation.
      if (!goog.events.isMarkedIeEvent_(ieEvent)) {
        goog.events.markIeEvent_(ieEvent);

        var ancestors = [];
        for (var parent = evt.currentTarget; parent;
             parent = parent.parentNode) {
          ancestors.push(parent);
        }

        // Fire capture listeners.
        var type = listener.type;
        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;
             i--) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, true, evt);
        }

        // Fire bubble listeners.
        //
        // We can technically rely on IE to perform bubble event
        // propagation. However, it turns out that IE fires events in
        // opposite order of attachEvent registration, which broke
        // some code and tests that rely on the order. (While W3C DOM
        // Level 2 Events TR leaves the event ordering unspecified,
        // modern browsers and W3C DOM Level 3 Events Working Draft
        // actually specify the order as the registration order.)
        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, false, evt);
        }
      }
    } else {
      retval = goog.events.fireListener(listener, evt);
    }
    return retval;
  }

  // Otherwise, simply fire the listener.
  return goog.events.fireListener(
      listener, new goog.events.BrowserEvent(opt_evt, this));
};


/**
 * This is used to mark the IE event object so we do not do the Closure pass
 * twice for a bubbling event.
 * @param {Event} e The IE browser event.
 * @private
 */
goog.events.markIeEvent_ = function(e) {
  // Only the keyCode and the returnValue can be changed. We use keyCode for
  // non keyboard events.
  // event.returnValue is a bit more tricky. It is undefined by default. A
  // boolean false prevents the default action. In a window.onbeforeunload and
  // the returnValue is non undefined it will be alerted. However, we will only
  // modify the returnValue for keyboard events. We can get a problem if non
  // closure events sets the keyCode or the returnValue

  var useReturnValue = false;

  if (e.keyCode == 0) {
    // We cannot change the keyCode in case that srcElement is input[type=file].
    // We could test that that is the case but that would allocate 3 objects.
    // If we use try/catch we will only allocate extra objects in the case of a
    // failure.
    /** @preserveTry */
    try {
      e.keyCode = -1;
      return;
    } catch (ex) {
      useReturnValue = true;
    }
  }

  if (useReturnValue ||
      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
    e.returnValue = true;
  }
};


/**
 * This is used to check if an IE event has already been handled by the Closure
 * system so we do not do the Closure pass twice for a bubbling event.
 * @param {Event} e  The IE browser event.
 * @return {boolean} True if the event object has been marked.
 * @private
 */
goog.events.isMarkedIeEvent_ = function(e) {
  return e.keyCode < 0 || e.returnValue != undefined;
};


/**
 * Counter to create unique event ids.
 * @private {number}
 */
goog.events.uniqueIdCounter_ = 0;


/**
 * Creates a unique event id.
 *
 * @param {string} identifier The identifier.
 * @return {string} A unique identifier.
 * @idGenerator
 */
goog.events.getUniqueId = function(identifier) {
  return identifier + '_' + goog.events.uniqueIdCounter_++;
};


/**
 * @param {EventTarget} src The source object.
 * @return {goog.events.ListenerMap} A listener map for the given
 *     source object, or null if none exists.
 * @private
 */
goog.events.getListenerMap_ = function(src) {
  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
  // IE serializes the property as well (e.g. when serializing outer
  // HTML). So we must check that the value is of the correct type.
  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
};


/**
 * Expando property for listener function wrapper for Object with
 * handleEvent.
 * @const
 * @private
 */
goog.events.LISTENER_WRAPPER_PROP_ = '__closure_events_fn_' +
    ((Math.random() * 1e9) >>> 0);


/**
 * @param {Object|Function} listener The listener function or an
 *     object that contains handleEvent method.
 * @return {!Function} Either the original function or a function that
 *     calls obj.handleEvent. If the same listener is passed to this
 *     function more than once, the same function is guaranteed to be
 *     returned.
 */
goog.events.wrapListener = function(listener) {
  goog.asserts.assert(listener, 'Listener can not be null.');

  if (goog.isFunction(listener)) {
    return listener;
  }

  goog.asserts.assert(
      listener.handleEvent, 'An object listener must have handleEvent method.');
  return listener[goog.events.LISTENER_WRAPPER_PROP_] ||
      (listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
        return listener.handleEvent(e);
      });
};


// Register the browser event handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.events.handleBrowserEvent_ = transformer(
          goog.events.handleBrowserEvent_);
    });
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class to create objects which want to handle multiple events
 * and have their listeners easily cleaned up via a dispose method.
 *
 * Example:
 * <pre>
 * function Something() {
 *   goog.base(this);
 *
 *   ... set up object ...
 *
 *   // Add event listeners
 *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);
 *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);
 *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);
 * }
 * goog.inherits(Something, goog.events.EventHandler);
 *
 * Something.prototype.disposeInternal = function() {
 *   goog.base(this, 'disposeInternal');
 *   goog.dom.removeNode(this.container);
 * };
 *
 *
 * // Then elsewhere:
 *
 * var activeSomething = null;
 * function openSomething() {
 *   activeSomething = new Something();
 * }
 *
 * function closeSomething() {
 *   if (activeSomething) {
 *     activeSomething.dispose();  // Remove event listeners
 *     activeSomething = null;
 *   }
 * }
 * </pre>
 *
 */

goog.provide('goog.events.EventHandler');

goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.object');



/**
 * Super class for objects that want to easily manage a number of event
 * listeners.  It allows a short cut to listen and also provides a quick way
 * to remove all events listeners belonging to this object.
 * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.
 * @constructor
 * @extends {goog.Disposable}
 * @template SCOPE
 */
goog.events.EventHandler = function(opt_scope) {
  goog.Disposable.call(this);
  // TODO(user): Rename this to this.scope_ and fix the classes in google3
  // that access this private variable. :(
  this.handler_ = opt_scope;

  /**
   * Keys for events that are being listened to.
   * @type {!Object.<!goog.events.Key>}
   * @private
   */
  this.keys_ = {};
};
goog.inherits(goog.events.EventHandler, goog.Disposable);


/**
 * Utility array used to unify the cases of listening for an array of types
 * and listening for a single event, without using recursion or allocating
 * an array each time.
 * @type {Array.<string>}
 * @private
 */
goog.events.EventHandler.typeArray_ = [];


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null=} opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listen = function(
    src, type, opt_fn, opt_capture) {
  return this.listen_(src, type, opt_fn, opt_capture);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenWithScope = function(
    src, type, fn, capture, scope) {
  // TODO(user): Deprecate this function.
  return this.listen_(src, type, fn, capture, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *     callback function to be used as the listener or an object with
 *     handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listen_ = function(src, type, opt_fn,
                                                      opt_capture,
                                                      opt_scope) {
  if (!goog.isArray(type)) {
    goog.events.EventHandler.typeArray_[0] = /** @type {string} */(type);
    type = goog.events.EventHandler.typeArray_;
  }
  for (var i = 0; i < type.length; i++) {
    var listenerObj = goog.events.listen(
        src, type[i], opt_fn || this.handleEvent,
        opt_capture || false,
        opt_scope || this.handler_ || this);

    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return this;
    }

    var key = listenerObj.key;
    this.keys_[key] = listenerObj;
  }

  return this;
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null=} opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listenOnce = function(
    src, type, opt_fn, opt_capture) {
  // TODO(user): Remove the opt_scope from this function and then
  // templatize it.
  return this.listenOnce_(src, type, opt_fn, opt_capture);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenOnceWithScope = function(
    src, type, fn, capture, scope) {
  // TODO(user): Deprecate this function.
  return this.listenOnce_(src, type, fn, capture, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired
 * the event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *    callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listenOnce_ = function(
    src, type, opt_fn, opt_capture, opt_scope) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      this.listenOnce_(src, type[i], opt_fn, opt_capture, opt_scope);
    }
  } else {
    var listenerObj = goog.events.listenOnce(
        src, type, opt_fn || this.handleEvent, opt_capture,
        opt_scope || this.handler_ || this);
    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return this;
    }

    var key = listenerObj.key;
    this.keys_[key] = listenerObj;
  }

  return this;
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listenWithWrapper = function(
    src, wrapper, listener, opt_capt) {
  // TODO(user): Remove the opt_scope from this function and then
  // templatize it.
  return this.listenWithWrapper_(src, wrapper, listener, opt_capt);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}
 *     listener Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenWithWrapperAndScope = function(
    src, wrapper, listener, capture, scope) {
  // TODO(user): Deprecate this function.
  return this.listenWithWrapper_(src, wrapper, listener, capture, scope);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listenWithWrapper_ = function(
    src, wrapper, listener, opt_capt, opt_scope) {
  wrapper.listen(src, listener, opt_capt, opt_scope || this.handler_ || this,
                 this);
  return this;
};


/**
 * @return {number} Number of listeners registered by this handler.
 */
goog.events.EventHandler.prototype.getListenerCount = function() {
  var count = 0;
  for (var key in this.keys_) {
    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {
      count++;
    }
  }
  return count;
};


/**
 * Unlistens on an event.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *    callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.unlisten = function(src, type, opt_fn,
                                                       opt_capture,
                                                       opt_scope) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      this.unlisten(src, type[i], opt_fn, opt_capture, opt_scope);
    }
  } else {
    var listener = goog.events.getListener(src, type,
        opt_fn || this.handleEvent,
        opt_capture, opt_scope || this.handler_ || this);

    if (listener) {
      goog.events.unlistenByKey(listener);
      delete this.keys_[listener.key];
    }
  }

  return this;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.EventTarget} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.unlistenWithWrapper = function(src, wrapper,
    listener, opt_capt, opt_scope) {
  wrapper.unlisten(src, listener, opt_capt,
                   opt_scope || this.handler_ || this, this);
  return this;
};


/**
 * Unlistens to all events.
 */
goog.events.EventHandler.prototype.removeAll = function() {
  goog.object.forEach(this.keys_, goog.events.unlistenByKey);
  this.keys_ = {};
};


/**
 * Disposes of this EventHandler and removes all listeners that it registered.
 * @override
 * @protected
 */
goog.events.EventHandler.prototype.disposeInternal = function() {
  goog.events.EventHandler.superClass_.disposeInternal.call(this);
  this.removeAll();
};


/**
 * Default event handler
 * @param {goog.events.Event} e Event object.
 */
goog.events.EventHandler.prototype.handleEvent = function(e) {
  throw Error('EventHandler.handleEvent not implemented');
};
// Copyright 2005-2009, The Dojo Foundation
// Modifications Copyright 2008 The Closure Library Authors.
// All Rights Reserved.

/**
 * @license Portions of this code are from the Dojo Toolkit, received by
 * The Closure Library Authors under the BSD license. All other code is
 * Copyright 2005-2009 The Closure Library Authors. All Rights Reserved.

The "New" BSD License:

Copyright (c) 2005-2009, The Dojo Foundation
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  * Neither the name of the Dojo Foundation nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @fileoverview This code was ported from the Dojo Toolkit
   http://dojotoolkit.org and modified slightly for Closure.
 *
 *  goog.dom.query is a relatively full-featured CSS3 query function. It is
 *  designed to take any valid CSS3 selector and return the nodes matching
 *  the selector. To do this quickly, it processes queries in several
 *  steps, applying caching where profitable.
 *    The steps (roughly in reverse order of the way they appear in the code):
 *    1.) check to see if we already have a "query dispatcher"
 *      - if so, use that with the given parameterization. Skip to step 4.
 *    2.) attempt to determine which branch to dispatch the query to:
 *      - JS (optimized DOM iteration)
 *      - native (FF3.1, Safari 3.2+, Chrome, some IE 8 doctypes). If native,
 *        skip to step 4, using a stub dispatcher for QSA queries.
 *    3.) tokenize and convert to executable "query dispatcher"
 *        assembled as a chain of "yes/no" test functions pertaining to
 *        a section of a simple query statement (".blah:nth-child(odd)"
 *        but not "div div", which is 2 simple statements).
 *    4.) the resulting query dispatcher is called in the passed scope
 *        (by default the top-level document)
 *      - for DOM queries, this results in a recursive, top-down
 *        evaluation of nodes based on each simple query section
 *      - querySelectorAll is used instead of DOM where possible. If a query
 *        fails in this mode, it is re-run against the DOM evaluator and all
 *        future queries using the same selector evaluate against the DOM branch
 *        too.
 *    5.) matched nodes are pruned to ensure they are unique
 * @deprecated This is an all-software query selector. When developing for
 *     recent browsers, use document.querySelector. See information at
 *     http://caniuse.com/queryselector and
 *     https://developer.mozilla.org/en-US/docs/DOM/Document.querySelector .
 */

goog.provide('goog.dom.query');

goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.functions');
goog.require('goog.string');
goog.require('goog.userAgent');

  /**
   * Returns nodes which match the given CSS3 selector, searching the
   * entire document by default but optionally taking a node to scope
   * the search by.
   *
   * dojo.query() is the swiss army knife of DOM node manipulation in
   * Dojo. Much like Prototype's "$$" (bling-bling) function or JQuery's
   * "$" function, dojo.query provides robust, high-performance
   * CSS-based node selector support with the option of scoping searches
   * to a particular sub-tree of a document.
   *
   * Supported Selectors:
   * --------------------
   *
   * dojo.query() supports a rich set of CSS3 selectors, including:
   *
   *   * class selectors (e.g., `.foo`)
   *   * node type selectors like `span`
   *   * ` ` descendant selectors
   *   * `>` child element selectors
   *   * `#foo` style ID selectors
   *   * `*` universal selector
   *   * `~`, the immediately preceded-by sibling selector
   *   * `+`, the preceded-by sibling selector
   *   * attribute queries:
   *   |  * `[foo]` attribute presence selector
   *   |  * `[foo='bar']` attribute value exact match
   *   |  * `[foo~='bar']` attribute value list item match
   *   |  * `[foo^='bar']` attribute start match
   *   |  * `[foo$='bar']` attribute end match
   *   |  * `[foo*='bar']` attribute substring match
   *   * `:first-child`, `:last-child` positional selectors
   *   * `:empty` content empty selector
   *   * `:empty` content empty selector
   *   * `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
   *   * `:nth-child(even)`, `:nth-child(odd)` positional selectors
   *   * `:not(...)` negation pseudo selectors
   *
   * Any legal combination of these selectors will work with
   * `dojo.query()`, including compound selectors ("," delimited).
   * Very complex and useful searches can be constructed with this
   * palette of selectors.
   *
   * Unsupported Selectors:
   * ----------------------
   *
   * While dojo.query handles many CSS3 selectors, some fall outside of
   * what's reasonable for a programmatic node querying engine to
   * handle. Currently unsupported selectors include:
   *
   *   * namespace-differentiated selectors of any form
   *   * all `::` pseudo-element selectors
   *   * certain pseudo-selectors which don't get a lot of day-to-day use:
   *   |  * `:root`, `:lang()`, `:target`, `:focus`
   *   * all visual and state selectors:
   *   |  * `:root`, `:active`, `:hover`, `:visited`, `:link`,
   *       `:enabled`, `:disabled`, `:checked`
   *   * `:*-of-type` pseudo selectors
   *
   * dojo.query and XML Documents:
   * -----------------------------
   *
   * `dojo.query` currently only supports searching XML documents
   * whose tags and attributes are 100% lower-case. This is a known
   * limitation and will [be addressed soon]
   * (http://trac.dojotoolkit.org/ticket/3866)
   *
   * Non-selector Queries:
   * ---------------------
   *
   * If something other than a String is passed for the query,
   * `dojo.query` will return a new array constructed from
   * that parameter alone and all further processing will stop. This
   * means that if you have a reference to a node or array or nodes, you
   * can quickly construct a new array of nodes from the original by
   * calling `dojo.query(node)` or `dojo.query(array)`.
   *
   * example:
   *   search the entire document for elements with the class "foo":
   * |  dojo.query(".foo");
   *   these elements will match:
   * |  <span class="foo"></span>
   * |  <span class="foo bar"></span>
   * |  <p class="thud foo"></p>
   * example:
   *   search the entire document for elements with the classes "foo" *and*
   *   "bar":
   * |  dojo.query(".foo.bar");
   *   these elements will match:
   * |  <span class="foo bar"></span>
   *   while these will not:
   * |  <span class="foo"></span>
   * |  <p class="thud foo"></p>
   * example:
   *   find `<span>` elements which are descendants of paragraphs and
   *   which have a "highlighted" class:
   * |  dojo.query("p span.highlighted");
   *   the innermost span in this fragment matches:
   * |  <p class="foo">
   * |    <span>...
   * |      <span class="highlighted foo bar">...</span>
   * |    </span>
   * |  </p>
   * example:
   *   find all odd table rows inside of the table
   *   `#tabular_data`, using the `>` (direct child) selector to avoid
   *   affecting any nested tables:
   * |  dojo.query("#tabular_data > tbody > tr:nth-child(odd)");
   *
   * @param {string|Array} query The CSS3 expression to match against.
   *     For details on the syntax of CSS3 selectors, see
   *     http://www.w3.org/TR/css3-selectors/#selectors.
   * @param {(string|Node)=} opt_root A Node (or node id) to scope the search
   *     from (optional).
   * @return { {length: number} } The elements that matched the query.
   *
   * @deprecated This is an all-software query selector. Use
   *     document.querySelector. See
   *     https://developer.mozilla.org/en-US/docs/DOM/Document.querySelector .
   */
goog.dom.query = (function() {
  ////////////////////////////////////////////////////////////////////////
  // Global utilities
  ////////////////////////////////////////////////////////////////////////

  var cssCaseBug = (goog.userAgent.WEBKIT &&
                     ((goog.dom.getDocument().compatMode) == 'BackCompat')
                   );

  // On browsers that support the "children" collection we can avoid a lot of
  // iteration on chaff (non-element) nodes.
  var childNodesName = !!goog.dom.getDocument().firstChild['children'] ?
                          'children' :
                          'childNodes';

  var specials = '>~+';

  // Global thunk to determine whether we should treat the current query as
  // case sensitive or not. This switch is flipped by the query evaluator based
  // on the document passed as the context to search.
  var caseSensitive = false;


  ////////////////////////////////////////////////////////////////////////
  // Tokenizer
  ////////////////////////////////////////////////////////////////////////

  var getQueryParts = function(query) {
    //  summary:
    //    state machine for query tokenization
    //  description:
    //    instead of using a brittle and slow regex-based CSS parser,
    //    dojo.query implements an AST-style query representation. This
    //    representation is only generated once per query. For example,
    //    the same query run multiple times or under different root nodes
    //    does not re-parse the selector expression but instead uses the
    //    cached data structure. The state machine implemented here
    //    terminates on the last " " (space) character and returns an
    //    ordered array of query component structures (or "parts"). Each
    //    part represents an operator or a simple CSS filtering
    //    expression. The structure for parts is documented in the code
    //    below.


    // NOTE:
    //    this code is designed to run fast and compress well. Sacrifices
    //    to readability and maintainability have been made.
    if (specials.indexOf(query.slice(-1)) >= 0) {
      // If we end with a ">", "+", or "~", that means we're implicitly
      // searching all children, so make it explicit.
      query += ' * '
    } else {
      // if you have not provided a terminator, one will be provided for
      // you...
      query += ' ';
    }

    var ts = function(/*Integer*/ s, /*Integer*/ e) {
      // trim and slice.

      // take an index to start a string slice from and an end position
      // and return a trimmed copy of that sub-string
      return goog.string.trim(query.slice(s, e));
    };

    // The overall data graph of the full query, as represented by queryPart
    // objects.
    var queryParts = [];


    // state keeping vars
    var inBrackets = -1,
        inParens = -1,
        inMatchFor = -1,
        inPseudo = -1,
        inClass = -1,
        inId = -1,
        inTag = -1,
        lc = '',
        cc = '',
        pStart;

    // iteration vars
    var x = 0, // index in the query
        ql = query.length,
        currentPart = null, // data structure representing the entire clause
        cp = null; // the current pseudo or attr matcher

    // several temporary variables are assigned to this structure during a
    // potential sub-expression match:
    //    attr:
    //      a string representing the current full attribute match in a
    //      bracket expression
    //    type:
    //      if there's an operator in a bracket expression, this is
    //      used to keep track of it
    //    value:
    //      the internals of parenthetical expression for a pseudo. for
    //      :nth-child(2n+1), value might be '2n+1'

    var endTag = function() {
      // called when the tokenizer hits the end of a particular tag name.
      // Re-sets state variables for tag matching and sets up the matcher
      // to handle the next type of token (tag or operator).
      if (inTag >= 0) {
        var tv = (inTag == x) ? null : ts(inTag, x);
        if (specials.indexOf(tv) < 0) {
          currentPart.tag = tv;
        } else {
          currentPart.oper = tv;
        }
        inTag = -1;
      }
    };

    var endId = function() {
      // Called when the tokenizer might be at the end of an ID portion of a
      // match.
      if (inId >= 0) {
        currentPart.id = ts(inId, x).replace(/\\/g, '');
        inId = -1;
      }
    };

    var endClass = function() {
      // Called when the tokenizer might be at the end of a class name
      // match. CSS allows for multiple classes, so we augment the
      // current item with another class in its list.
      if (inClass >= 0) {
        currentPart.classes.push(ts(inClass + 1, x).replace(/\\/g, ''));
        inClass = -1;
      }
    };

    var endAll = function() {
      // at the end of a simple fragment, so wall off the matches
      endId(); endTag(); endClass();
    };

    var endPart = function() {
      endAll();
      if (inPseudo >= 0) {
        currentPart.pseudos.push({ name: ts(inPseudo + 1, x) });
      }
      // Hint to the selector engine to tell it whether or not it
      // needs to do any iteration. Many simple selectors don't, and
      // we can avoid significant construction-time work by advising
      // the system to skip them.
      currentPart.loops = currentPart.pseudos.length ||
                          currentPart.attrs.length ||
                          currentPart.classes.length;

      // save the full expression as a string
      currentPart.oquery = currentPart.query = ts(pStart, x);


      // otag/tag are hints to suggest to the system whether or not
      // it's an operator or a tag. We save a copy of otag since the
      // tag name is cast to upper-case in regular HTML matches. The
      // system has a global switch to figure out if the current
      // expression needs to be case sensitive or not and it will use
      // otag or tag accordingly
      currentPart.otag = currentPart.tag = (currentPart.oper) ?
                                                     null :
                                                     (currentPart.tag || '*');

      if (currentPart.tag) {
        // if we're in a case-insensitive HTML doc, we likely want
        // the toUpperCase when matching on element.tagName. If we
        // do it here, we can skip the string op per node
        // comparison
        currentPart.tag = currentPart.tag.toUpperCase();
      }

      // add the part to the list
      if (queryParts.length && (queryParts[queryParts.length - 1].oper)) {
        // operators are always infix, so we remove them from the
        // list and attach them to the next match. The evaluator is
        // responsible for sorting out how to handle them.
        currentPart.infixOper = queryParts.pop();
        currentPart.query = currentPart.infixOper.query + ' ' +
            currentPart.query;
      }
      queryParts.push(currentPart);

      currentPart = null;
    }

    // iterate over the query, character by character, building up a
    // list of query part objects
    for (; lc = cc, cc = query.charAt(x), x < ql; x++) {
      //    cc: the current character in the match
      //    lc: the last character (if any)

      // someone is trying to escape something, so don't try to match any
      // fragments. We assume we're inside a literal.
      if (lc == '\\') {
        continue;
      }
      if (!currentPart) { // a part was just ended or none has yet been created
        // NOTE: I hate all this alloc, but it's shorter than writing tons of
        // if's
        pStart = x;
        //  rules describe full CSS sub-expressions, like:
        //    #someId
        //    .className:first-child
        //  but not:
        //    thinger > div.howdy[type=thinger]
        //  the individual components of the previous query would be
        //  split into 3 parts that would be represented a structure
        //  like:
        //    [
        //      {
        //        query: 'thinger',
        //        tag: 'thinger',
        //      },
        //      {
        //        query: 'div.howdy[type=thinger]',
        //        classes: ['howdy'],
        //        infixOper: {
        //          query: '>',
        //          oper: '>',
        //        }
        //      },
        //    ]
        currentPart = {
          query: null, // the full text of the part's rule
          pseudos: [], // CSS supports multiple pseudo-class matches in a single
              // rule
          attrs: [],  // CSS supports multi-attribute match, so we need an array
          classes: [], // class matches may be additive,
              // e.g.: .thinger.blah.howdy
          tag: null,  // only one tag...
          oper: null, // ...or operator per component. Note that these wind up
              // being exclusive.
          id: null,   // the id component of a rule
          getTag: function() {
            return (caseSensitive) ? this.otag : this.tag;
          }
        };

        // if we don't have a part, we assume we're going to start at
        // the beginning of a match, which should be a tag name. This
        // might fault a little later on, but we detect that and this
        // iteration will still be fine.
        inTag = x;
      }

      if (inBrackets >= 0) {
        // look for a the close first
        if (cc == ']') { // if we're in a [...] clause and we end, do assignment
          if (!cp.attr) {
            // no attribute match was previously begun, so we
            // assume this is an attribute existence match in the
            // form of [someAttributeName]
            cp.attr = ts(inBrackets + 1, x);
          } else {
            // we had an attribute already, so we know that we're
            // matching some sort of value, as in [attrName=howdy]
            cp.matchFor = ts((inMatchFor || inBrackets + 1), x);
          }
          var cmf = cp.matchFor;
          if (cmf) {
            // try to strip quotes from the matchFor value. We want
            // [attrName=howdy] to match the same
            //  as [attrName = 'howdy' ]
            if ((cmf.charAt(0) == '"') || (cmf.charAt(0) == "'")) {
              cp.matchFor = cmf.slice(1, -1);
            }
          }
          // end the attribute by adding it to the list of attributes.
          currentPart.attrs.push(cp);
          cp = null; // necessary?
          inBrackets = inMatchFor = -1;
        } else if (cc == '=') {
          // if the last char was an operator prefix, make sure we
          // record it along with the '=' operator.
          var addToCc = ('|~^$*'.indexOf(lc) >= 0) ? lc : '';
          cp.type = addToCc + cc;
          cp.attr = ts(inBrackets + 1, x - addToCc.length);
          inMatchFor = x + 1;
        }
        // now look for other clause parts
      } else if (inParens >= 0) {
        // if we're in a parenthetical expression, we need to figure
        // out if it's attached to a pseudo-selector rule like
        // :nth-child(1)
        if (cc == ')') {
          if (inPseudo >= 0) {
            cp.value = ts(inParens + 1, x);
          }
          inPseudo = inParens = -1;
        }
      } else if (cc == '#') {
        // start of an ID match
        endAll();
        inId = x + 1;
      } else if (cc == '.') {
        // start of a class match
        endAll();
        inClass = x;
      } else if (cc == ':') {
        // start of a pseudo-selector match
        endAll();
        inPseudo = x;
      } else if (cc == '[') {
        // start of an attribute match.
        endAll();
        inBrackets = x;
        // provide a new structure for the attribute match to fill-in
        cp = {
          /*=====
          attr: null, type: null, matchFor: null
          =====*/
        };
      } else if (cc == '(') {
        // we really only care if we've entered a parenthetical
        // expression if we're already inside a pseudo-selector match
        if (inPseudo >= 0) {
          // provide a new structure for the pseudo match to fill-in
          cp = {
            name: ts(inPseudo + 1, x),
            value: null
          }
          currentPart.pseudos.push(cp);
        }
        inParens = x;
      } else if (
        (cc == ' ') &&
        // if it's a space char and the last char is too, consume the
        // current one without doing more work
        (lc != cc)
      ) {
        endPart();
      }
    }
    return queryParts;
  };


  ////////////////////////////////////////////////////////////////////////
  // DOM query infrastructure
  ////////////////////////////////////////////////////////////////////////

  var agree = function(first, second) {
    // the basic building block of the yes/no chaining system. agree(f1,
    // f2) generates a new function which returns the boolean results of
    // both of the passed functions to a single logical-anded result. If
    // either are not passed, the other is used exclusively.
    if (!first) {
      return second;
    }
    if (!second) {
      return first;
    }

    return function() {
      return first.apply(window, arguments) && second.apply(window, arguments);
    }
  };

  /**
   * @param {Array=} opt_arr
   */
  function getArr(i, opt_arr) {
    // helps us avoid array alloc when we don't need it
    var r = opt_arr || [];
    if (i) {
      r.push(i);
    }
    return r;
  };

  var isElement = function(n) {
    return (1 == n.nodeType);
  };

  // FIXME: need to coalesce getAttr with defaultGetter
  var blank = '';
  var getAttr = function(elem, attr) {
    if (!elem) {
      return blank;
    }
    if (attr == 'class') {
      return elem.className || blank;
    }
    if (attr == 'for') {
      return elem.htmlFor || blank;
    }
    if (attr == 'style') {
      return elem.style.cssText || blank;
    }
    return (caseSensitive ? elem.getAttribute(attr) :
        elem.getAttribute(attr, 2)) || blank;
  };

  var attrs = {
    '*=': function(attr, value) {
      return function(elem) {
        // E[foo*="bar"]
        //    an E element whose "foo" attribute value contains
        //    the substring "bar"
        return (getAttr(elem, attr).indexOf(value) >= 0);
      }
    },
    '^=': function(attr, value) {
      // E[foo^="bar"]
      //    an E element whose "foo" attribute value begins exactly
      //    with the string "bar"
      return function(elem) {
        return (getAttr(elem, attr).indexOf(value) == 0);
      }
    },
    '$=': function(attr, value) {
      // E[foo$="bar"]
      //    an E element whose "foo" attribute value ends exactly
      //    with the string "bar"
      var tval = ' ' + value;
      return function(elem) {
        var ea = ' ' + getAttr(elem, attr);
        return (ea.lastIndexOf(value) == (ea.length - value.length));
      }
    },
    '~=': function(attr, value) {
      // E[foo~="bar"]
      //    an E element whose "foo" attribute value is a list of
      //    space-separated values, one of which is exactly equal
      //    to "bar"

      var tval = ' ' + value + ' ';
      return function(elem) {
        var ea = ' ' + getAttr(elem, attr) + ' ';
        return (ea.indexOf(tval) >= 0);
      }
    },
    '|=': function(attr, value) {
      // E[hreflang|="en"]
      //    an E element whose "hreflang" attribute has a
      //    hyphen-separated list of values beginning (from the
      //    left) with "en"
      value = ' ' + value;
      return function(elem) {
        var ea = ' ' + getAttr(elem, attr);
        return (
          (ea == value) ||
          (ea.indexOf(value + '-') == 0)
        );
      }
    },
    '=': function(attr, value) {
      return function(elem) {
        return (getAttr(elem, attr) == value);
      }
    }
  };

  // avoid testing for node type if we can. Defining this in the negative
  // here to avoid negation in the fast path.
  var noNextElementSibling = (
    typeof goog.dom.getDocument().firstChild.nextElementSibling == 'undefined'
  );
  var nSibling = !noNextElementSibling ? 'nextElementSibling' : 'nextSibling';
  var pSibling = !noNextElementSibling ?
                    'previousElementSibling' :
                    'previousSibling';
  var simpleNodeTest = (noNextElementSibling ? isElement : goog.functions.TRUE);

  var _lookLeft = function(node) {
    while (node = node[pSibling]) {
      if (simpleNodeTest(node)) {
        return false;
      }
    }
    return true;
  };

  var _lookRight = function(node) {
    while (node = node[nSibling]) {
      if (simpleNodeTest(node)) {
        return false;
      }
    }
    return true;
  };

  var getNodeIndex = function(node) {
    var root = node.parentNode;
    var i = 0,
        tret = root[childNodesName],
        ci = (node['_i'] || -1),
        cl = (root['_l'] || -1);

    if (!tret) {
      return -1;
    }
    var l = tret.length;

    // we calculate the parent length as a cheap way to invalidate the
    // cache. It's not 100% accurate, but it's much more honest than what
    // other libraries do
    if (cl == l && ci >= 0 && cl >= 0) {
      // if it's legit, tag and release
      return ci;
    }

    // else re-key things
    root['_l'] = l;
    ci = -1;
    var te = root['firstElementChild'] || root['firstChild'];
    for (; te; te = te[nSibling]) {
      if (simpleNodeTest(te)) {
        te['_i'] = ++i;
        if (node === te) {
          // NOTE:
          //  shortcutting the return at this step in indexing works
          //  very well for benchmarking but we avoid it here since
          //  it leads to potential O(n^2) behavior in sequential
          //  getNodexIndex operations on a previously un-indexed
          //  parent. We may revisit this at a later time, but for
          //  now we just want to get the right answer more often
          //  than not.
          ci = i;
        }
      }
    }
    return ci;
  };

  var isEven = function(elem) {
    return !((getNodeIndex(elem)) % 2);
  };

  var isOdd = function(elem) {
    return (getNodeIndex(elem)) % 2;
  };

  var pseudos = {
    'checked': function(name, condition) {
      return function(elem) {
        return elem.checked || elem.attributes['checked'];
      }
    },
    'first-child': function() {
      return _lookLeft;
    },
    'last-child': function() {
      return _lookRight;
    },
    'only-child': function(name, condition) {
      return function(node) {
        if (!_lookLeft(node)) {
          return false;
        }
        if (!_lookRight(node)) {
          return false;
        }
        return true;
      };
    },
    'empty': function(name, condition) {
      return function(elem) {
        // DomQuery and jQuery get this wrong, oddly enough.
        // The CSS 3 selectors spec is pretty explicit about it, too.
        var cn = elem.childNodes;
        var cnl = elem.childNodes.length;
        // if(!cnl) { return true; }
        for (var x = cnl - 1; x >= 0; x--) {
          var nt = cn[x].nodeType;
          if ((nt === 1) || (nt == 3)) {
            return false;
          }
        }
        return true;
      }
    },
    'contains': function(name, condition) {
      var cz = condition.charAt(0);
      if (cz == '"' || cz == "'") { // Remove quotes.
        condition = condition.slice(1, -1);
      }
      return function(elem) {
        return (elem.innerHTML.indexOf(condition) >= 0);
      }
    },
    'not': function(name, condition) {
      var p = getQueryParts(condition)[0];
      var ignores = { el: 1 };
      if (p.tag != '*') {
        ignores.tag = 1;
      }
      if (!p.classes.length) {
        ignores.classes = 1;
      }
      var ntf = getSimpleFilterFunc(p, ignores);
      return function(elem) {
        return !ntf(elem);
      }
    },
    'nth-child': function(name, condition) {
      function pi(n) {
        return parseInt(n, 10);
      }
      // avoid re-defining function objects if we can
      if (condition == 'odd') {
        return isOdd;
      } else if (condition == 'even') {
        return isEven;
      }
      // FIXME: can we shorten this?
      if (condition.indexOf('n') != -1) {
        var tparts = condition.split('n', 2);
        var pred = tparts[0] ? ((tparts[0] == '-') ? -1 : pi(tparts[0])) : 1;
        var idx = tparts[1] ? pi(tparts[1]) : 0;
        var lb = 0, ub = -1;
        if (pred > 0) {
          if (idx < 0) {
            idx = (idx % pred) && (pred + (idx % pred));
          } else if (idx > 0) {
            if (idx >= pred) {
              lb = idx - idx % pred;
            }
            idx = idx % pred;
          }
        } else if (pred < 0) {
          pred *= -1;
          // idx has to be greater than 0 when pred is negative;
          // shall we throw an error here?
          if (idx > 0) {
            ub = idx;
            idx = idx % pred;
          }
        }
        if (pred > 0) {
          return function(elem) {
            var i = getNodeIndex(elem);
            return (i >= lb) && (ub < 0 || i <= ub) && ((i % pred) == idx);
          }
        } else {
          condition = idx;
        }
      }
      var ncount = pi(condition);
      return function(elem) {
        return (getNodeIndex(elem) == ncount);
      }
    }
  };

  var defaultGetter = (goog.userAgent.IE) ? function(cond) {
    var clc = cond.toLowerCase();
    if (clc == 'class') {
      cond = 'className';
    }
    return function(elem) {
      return caseSensitive ? elem.getAttribute(cond) : elem[cond] || elem[clc];
    }
  } : function(cond) {
    return function(elem) {
      return elem && elem.getAttribute && elem.hasAttribute(cond);
    }
  };

  var getSimpleFilterFunc = function(query, ignores) {
    // Generates a node tester function based on the passed query part. The
    // query part is one of the structures generated by the query parser when it
    // creates the query AST. The 'ignores' object specifies which (if any)
    // tests to skip, allowing the system to avoid duplicating work where it
    // may have already been taken into account by other factors such as how
    // the nodes to test were fetched in the first place.
    if (!query) {
      return goog.functions.TRUE;
    }
    ignores = ignores || {};

    var ff = null;

    if (!ignores.el) {
      ff = agree(ff, isElement);
    }

    if (!ignores.tag) {
      if (query.tag != '*') {
        ff = agree(ff, function(elem) {
          return (elem && (elem.tagName == query.getTag()));
        });
      }
    }

    if (!ignores.classes) {
      goog.array.forEach(query.classes, function(cname, idx, arr) {
        // Get the class name.
        var re = new RegExp('(?:^|\\s)' + cname + '(?:\\s|$)');
        ff = agree(ff, function(elem) {
          return re.test(elem.className);
        });
        ff.count = idx;
      });
    }

    if (!ignores.pseudos) {
      goog.array.forEach(query.pseudos, function(pseudo) {
        var pn = pseudo.name;
        if (pseudos[pn]) {
          ff = agree(ff, pseudos[pn](pn, pseudo.value));
        }
      });
    }

    if (!ignores.attrs) {
      goog.array.forEach(query.attrs, function(attr) {
        var matcher;
        var a = attr.attr;
        // type, attr, matchFor
        if (attr.type && attrs[attr.type]) {
          matcher = attrs[attr.type](a, attr.matchFor);
        } else if (a.length) {
          matcher = defaultGetter(a);
        }
        if (matcher) {
          ff = agree(ff, matcher);
        }
      });
    }

    if (!ignores.id) {
      if (query.id) {
        ff = agree(ff, function(elem) {
          return (!!elem && (elem.id == query.id));
        });
      }
    }

    if (!ff) {
      if (!('default' in ignores)) {
        ff = goog.functions.TRUE;
      }
    }
    return ff;
  };

  var nextSiblingIterator = function(filterFunc) {
    return function(node, ret, bag) {
      while (node = node[nSibling]) {
        if (noNextElementSibling && (!isElement(node))) {
          continue;
        }
        if (
          (!bag || _isUnique(node, bag)) &&
          filterFunc(node)
        ) {
          ret.push(node);
        }
        break;
      }
      return ret;
    };
  };

  var nextSiblingsIterator = function(filterFunc) {
    return function(root, ret, bag) {
      var te = root[nSibling];
      while (te) {
        if (simpleNodeTest(te)) {
          if (bag && !_isUnique(te, bag)) {
            break;
          }
          if (filterFunc(te)) {
            ret.push(te);
          }
        }
        te = te[nSibling];
      }
      return ret;
    };
  };

  // Get an array of child *elements*, skipping text and comment nodes
  var _childElements = function(filterFunc) {
    filterFunc = filterFunc || goog.functions.TRUE;
    return function(root, ret, bag) {
      var te, x = 0, tret = root[childNodesName];
      while (te = tret[x++]) {
        if (
          simpleNodeTest(te) &&
          (!bag || _isUnique(te, bag)) &&
          (filterFunc(te, x))
        ) {
          ret.push(te);
        }
      }
      return ret;
    };
  };

  // test to see if node is below root
  var _isDescendant = function(node, root) {
    var pn = node.parentNode;
    while (pn) {
      if (pn == root) {
        break;
      }
      pn = pn.parentNode;
    }
    return !!pn;
  };

  var _getElementsFuncCache = {};

  var getElementsFunc = function(query) {
    var retFunc = _getElementsFuncCache[query.query];
    // If we've got a cached dispatcher, just use that.
    if (retFunc) {
      return retFunc;
    }
    // Else, generate a new one.

    // NOTE:
    //    This function returns a function that searches for nodes and
    //    filters them. The search may be specialized by infix operators
    //    (">", "~", or "+") else it will default to searching all
    //    descendants (the " " selector). Once a group of children is
    //    found, a test function is applied to weed out the ones we
    //    don't want. Many common cases can be fast-pathed. We spend a
    //    lot of cycles to create a dispatcher that doesn't do more work
    //    than necessary at any point since, unlike this function, the
    //    dispatchers will be called every time. The logic of generating
    //    efficient dispatchers looks like this in pseudo code:
    //
    //    # if it's a purely descendant query (no ">", "+", or "~" modifiers)
    //    if infixOperator == " ":
    //      if only(id):
    //        return def(root):
    //          return d.byId(id, root);
    //
    //      elif id:
    //        return def(root):
    //          return filter(d.byId(id, root));
    //
    //      elif cssClass && getElementsByClassName:
    //        return def(root):
    //          return filter(root.getElementsByClassName(cssClass));
    //
    //      elif only(tag):
    //        return def(root):
    //          return root.getElementsByTagName(tagName);
    //
    //      else:
    //        # search by tag name, then filter
    //        return def(root):
    //          return filter(root.getElementsByTagName(tagName||"*"));
    //
    //    elif infixOperator == ">":
    //      # search direct children
    //      return def(root):
    //        return filter(root.children);
    //
    //    elif infixOperator == "+":
    //      # search next sibling
    //      return def(root):
    //        return filter(root.nextElementSibling);
    //
    //    elif infixOperator == "~":
    //      # search rightward siblings
    //      return def(root):
    //        return filter(nextSiblings(root));

    var io = query.infixOper;
    var oper = (io ? io.oper : '');
    // The default filter func which tests for all conditions in the query
    // part. This is potentially inefficient, so some optimized paths may
    // re-define it to test fewer things.
    var filterFunc = getSimpleFilterFunc(query, { el: 1 });
    var qt = query.tag;
    var wildcardTag = ('*' == qt);
    var ecs = goog.dom.getDocument()['getElementsByClassName'];

    if (!oper) {
      // If there's no infix operator, then it's a descendant query. ID
      // and "elements by class name" variants can be accelerated so we
      // call them out explicitly:
      if (query.id) {
        // Testing shows that the overhead of goog.functions.TRUE() is
        // acceptable and can save us some bytes vs. re-defining the function
        // everywhere.
        filterFunc = (!query.loops && wildcardTag) ?
          goog.functions.TRUE :
          getSimpleFilterFunc(query, { el: 1, id: 1 });

        retFunc = function(root, arr) {
          var te = goog.dom.getDomHelper(root).getElement(query.id);
          if (!te || !filterFunc(te)) {
            return;
          }
          if (9 == root.nodeType) { // If root's a doc, we just return directly.
            return getArr(te, arr);
          } else { // otherwise check ancestry
            if (_isDescendant(te, root)) {
              return getArr(te, arr);
            }
          }
        }
      } else if (
        ecs &&
        // isAlien check. Workaround for Prototype.js being totally evil/dumb.
        /\{\s*\[native code\]\s*\}/.test(String(ecs)) &&
        query.classes.length &&
        // WebKit bug where quirks-mode docs select by class w/o case
        // sensitivity.
        !cssCaseBug
      ) {
        // it's a class-based query and we've got a fast way to run it.

        // ignore class and ID filters since we will have handled both
        filterFunc = getSimpleFilterFunc(query, { el: 1, classes: 1, id: 1 });
        var classesString = query.classes.join(' ');
        retFunc = function(root, arr) {
          var ret = getArr(0, arr), te, x = 0;
          var tret = root.getElementsByClassName(classesString);
          while ((te = tret[x++])) {
            if (filterFunc(te, root)) {
              ret.push(te);
            }
          }
          return ret;
        };

      } else if (!wildcardTag && !query.loops) {
        // it's tag only. Fast-path it.
        retFunc = function(root, arr) {
          var ret = getArr(0, arr), te, x = 0;
          var tret = root.getElementsByTagName(query.getTag());
          while ((te = tret[x++])) {
            ret.push(te);
          }
          return ret;
        };
      } else {
        // the common case:
        //    a descendant selector without a fast path. By now it's got
        //    to have a tag selector, even if it's just "*" so we query
        //    by that and filter
        filterFunc = getSimpleFilterFunc(query, { el: 1, tag: 1, id: 1 });
        retFunc = function(root, arr) {
          var ret = getArr(0, arr), te, x = 0;
          // we use getTag() to avoid case sensitivity issues
          var tret = root.getElementsByTagName(query.getTag());
          while (te = tret[x++]) {
            if (filterFunc(te, root)) {
              ret.push(te);
            }
          }
          return ret;
        };
      }
    } else {
      // the query is scoped in some way. Instead of querying by tag we
      // use some other collection to find candidate nodes
      var skipFilters = { el: 1 };
      if (wildcardTag) {
        skipFilters.tag = 1;
      }
      filterFunc = getSimpleFilterFunc(query, skipFilters);
      if ('+' == oper) {
        retFunc = nextSiblingIterator(filterFunc);
      } else if ('~' == oper) {
        retFunc = nextSiblingsIterator(filterFunc);
      } else if ('>' == oper) {
        retFunc = _childElements(filterFunc);
      }
    }
    // cache it and return
    return _getElementsFuncCache[query.query] = retFunc;
  };

  var filterDown = function(root, queryParts) {
    // NOTE:
    //    this is the guts of the DOM query system. It takes a list of
    //    parsed query parts and a root and finds children which match
    //    the selector represented by the parts
    var candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;

    for (var i = 0; i < qpl; i++) {
      ret = [];
      qp = queryParts[i];
      x = candidates.length - 1;
      if (x > 0) {
        // if we have more than one root at this level, provide a new
        // hash to use for checking group membership but tell the
        // system not to post-filter us since we will already have been
        // guaranteed to be unique
        bag = {};
        ret.nozip = true;
      }
      var gef = getElementsFunc(qp);
      for (var j = 0; te = candidates[j]; j++) {
        // for every root, get the elements that match the descendant
        // selector, adding them to the 'ret' array and filtering them
        // via membership in this level's bag. If there are more query
        // parts, then this level's return will be used as the next
        // level's candidates
        gef(te, ret, bag);
      }
      if (!ret.length) { break; }
      candidates = ret;
    }
    return ret;
  };

  ////////////////////////////////////////////////////////////////////////
  // the query runner
  ////////////////////////////////////////////////////////////////////////

  // these are the primary caches for full-query results. The query
  // dispatcher functions are generated then stored here for hash lookup in
  // the future
  var _queryFuncCacheDOM = {},
    _queryFuncCacheQSA = {};

  // this is the second level of splitting, from full-length queries (e.g.,
  // 'div.foo .bar') into simple query expressions (e.g., ['div.foo',
  // '.bar'])
  var getStepQueryFunc = function(query) {
    var qparts = getQueryParts(goog.string.trim(query));

    // if it's trivial, avoid iteration and zipping costs
    if (qparts.length == 1) {
      // We optimize this case here to prevent dispatch further down the
      // chain, potentially slowing things down. We could more elegantly
      // handle this in filterDown(), but it's slower for simple things
      // that need to be fast (e.g., '#someId').
      var tef = getElementsFunc(qparts[0]);
      return function(root) {
        var r = tef(root, []);
        if (r) { r.nozip = true; }
        return r;
      }
    }

    // otherwise, break it up and return a runner that iterates over the parts
    // recursively
    return function(root) {
      return filterDown(root, qparts);
    }
  };

  // NOTES:
  //  * we can't trust QSA for anything but document-rooted queries, so
  //    caching is split into DOM query evaluators and QSA query evaluators
  //  * caching query results is dirty and leak-prone (or, at a minimum,
  //    prone to unbounded growth). Other toolkits may go this route, but
  //    they totally destroy their own ability to manage their memory
  //    footprint. If we implement it, it should only ever be with a fixed
  //    total element reference # limit and an LRU-style algorithm since JS
  //    has no weakref support. Caching compiled query evaluators is also
  //    potentially problematic, but even on large documents the size of the
  //    query evaluators is often < 100 function objects per evaluator (and
  //    LRU can be applied if it's ever shown to be an issue).
  //  * since IE's QSA support is currently only for HTML documents and even
  //    then only in IE 8's 'standards mode', we have to detect our dispatch
  //    route at query time and keep 2 separate caches. Ugg.

  var qsa = 'querySelectorAll';

  // some versions of Safari provided QSA, but it was buggy and crash-prone.
  // We need to detect the right 'internal' webkit version to make this work.
  var qsaAvail = (
    !!goog.dom.getDocument()[qsa] &&
    // see #5832
    (!goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher('526'))
  );

  /** @param {boolean=} opt_forceDOM */
  var getQueryFunc = function(query, opt_forceDOM) {

    if (qsaAvail) {
      // if we've got a cached variant and we think we can do it, run it!
      var qsaCached = _queryFuncCacheQSA[query];
      if (qsaCached && !opt_forceDOM) {
        return qsaCached;
      }
    }

    // else if we've got a DOM cached variant, assume that we already know
    // all we need to and use it
    var domCached = _queryFuncCacheDOM[query];
    if (domCached) {
      return domCached;
    }

    // TODO:
    //    today we're caching DOM and QSA branches separately so we
    //    recalc useQSA every time. If we had a way to tag root+query
    //    efficiently, we'd be in good shape to do a global cache.

    var qcz = query.charAt(0);
    var nospace = (-1 == query.indexOf(' '));

    // byId searches are wicked fast compared to QSA, even when filtering
    // is required
    if ((query.indexOf('#') >= 0) && (nospace)) {
      opt_forceDOM = true;
    }

    var useQSA = (
      qsaAvail && (!opt_forceDOM) &&
      // as per CSS 3, we can't currently start w/ combinator:
      //    http://www.w3.org/TR/css3-selectors/#w3cselgrammar
      (specials.indexOf(qcz) == -1) &&
      // IE's QSA impl sucks on pseudos
      (!goog.userAgent.IE || (query.indexOf(':') == -1)) &&

      (!(cssCaseBug && (query.indexOf('.') >= 0))) &&

      // FIXME:
      //    need to tighten up browser rules on ':contains' and '|=' to
      //    figure out which aren't good
      (query.indexOf(':contains') == -1) &&
      (query.indexOf('|=') == -1) // some browsers don't understand it
    );

    // TODO:
    //    if we've got a descendant query (e.g., '> .thinger' instead of
    //    just '.thinger') in a QSA-able doc, but are passed a child as a
    //    root, it should be possible to give the item a synthetic ID and
    //    trivially rewrite the query to the form '#synid > .thinger' to
    //    use the QSA branch


    if (useQSA) {
      var tq = (specials.indexOf(query.charAt(query.length - 1)) >= 0) ?
            (query + ' *') : query;
      return _queryFuncCacheQSA[query] = function(root) {
        try {
          // the QSA system contains an egregious spec bug which
          // limits us, effectively, to only running QSA queries over
          // entire documents.  See:
          //    http://ejohn.org/blog/thoughts-on-queryselectorall/
          //  despite this, we can also handle QSA runs on simple
          //  selectors, but we don't want detection to be expensive
          //  so we're just checking for the presence of a space char
          //  right now. Not elegant, but it's cheaper than running
          //  the query parser when we might not need to
          if (!((9 == root.nodeType) || nospace)) {
            throw '';
          }
          var r = root[qsa](tq);
          // IE QSA queries may incorrectly include comment nodes, so we throw
          // the zipping function into 'remove' comments mode instead of the
          // normal 'skip it' which every other QSA-clued browser enjoys
          // skip expensive duplication checks and just wrap in an array.
          if (goog.userAgent.IE) {
            r.commentStrip = true;
          } else {
            r.nozip = true;
          }
          return r;
        } catch (e) {
          // else run the DOM branch on this query, ensuring that we
          // default that way in the future
          return getQueryFunc(query, true)(root);
        }
      }
    } else {
      // DOM branch
      var parts = query.split(/\s*,\s*/);
      return _queryFuncCacheDOM[query] = ((parts.length < 2) ?
        // if not a compound query (e.g., '.foo, .bar'), cache and return a
        // dispatcher
        getStepQueryFunc(query) :
        // if it *is* a complex query, break it up into its
        // constituent parts and return a dispatcher that will
        // merge the parts when run
        function(root) {
          var pindex = 0, // avoid array alloc for every invocation
            ret = [],
            tp;
          while (tp = parts[pindex++]) {
            ret = ret.concat(getStepQueryFunc(tp)(root));
          }
          return ret;
        }
      );
    }
  };

  var _zipIdx = 0;

  // NOTE:
  //    this function is Moo inspired, but our own impl to deal correctly
  //    with XML in IE
  var _nodeUID = goog.userAgent.IE ? function(node) {
    if (caseSensitive) {
      // XML docs don't have uniqueID on their nodes
      return node.getAttribute('_uid') ||
          node.setAttribute('_uid', ++_zipIdx) || _zipIdx;

    } else {
      return node.uniqueID;
    }
  } :
  function(node) {
    return (node['_uid'] || (node['_uid'] = ++_zipIdx));
  };

  // determine if a node in is unique in a 'bag'. In this case we don't want
  // to flatten a list of unique items, but rather just tell if the item in
  // question is already in the bag. Normally we'd just use hash lookup to do
  // this for us but IE's DOM is busted so we can't really count on that. On
  // the upside, it gives us a built in unique ID function.
  var _isUnique = function(node, bag) {
    if (!bag) {
      return 1;
    }
    var id = _nodeUID(node);
    if (!bag[id]) {
      return bag[id] = 1;
    }
    return 0;
  };

  // attempt to efficiently determine if an item in a list is a dupe,
  // returning a list of 'uniques', hopefully in document order
  var _zipIdxName = '_zipIdx';
  var _zip = function(arr) {
    if (arr && arr.nozip) {
      return arr;
    }
    var ret = [];
    if (!arr || !arr.length) {
      return ret;
    }
    if (arr[0]) {
      ret.push(arr[0]);
    }
    if (arr.length < 2) {
      return ret;
    }

    _zipIdx++;

    // we have to fork here for IE and XML docs because we can't set
    // expandos on their nodes (apparently). *sigh*
    if (goog.userAgent.IE && caseSensitive) {
      var szidx = _zipIdx + '';
      arr[0].setAttribute(_zipIdxName, szidx);
      for (var x = 1, te; te = arr[x]; x++) {
        if (arr[x].getAttribute(_zipIdxName) != szidx) {
          ret.push(te);
        }
        te.setAttribute(_zipIdxName, szidx);
      }
    } else if (goog.userAgent.IE && arr.commentStrip) {
      try {
        for (var x = 1, te; te = arr[x]; x++) {
          if (isElement(te)) {
            ret.push(te);
          }
        }
      } catch (e) { /* squelch */ }
    } else {
      if (arr[0]) {
        arr[0][_zipIdxName] = _zipIdx;
      }
      for (var x = 1, te; te = arr[x]; x++) {
        if (arr[x][_zipIdxName] != _zipIdx) {
          ret.push(te);
        }
        te[_zipIdxName] = _zipIdx;
      }
    }
    return ret;
  };

  /**
   * The main executor. Type specification from above.
   * @param {string|Array} query The query.
   * @param {(string|Node)=} root The root.
   * @return {!Array} The elements that matched the query.
   */
  var query = function(query, root) {
    // NOTE: elementsById is not currently supported
    // NOTE: ignores xpath-ish queries for now

    //Set list constructor to desired value. This can change
    //between calls, so always re-assign here.

    if (!query) {
      return [];
    }

    if (query.constructor == Array) {
      return /** @type {!Array} */ (query);
    }

    if (!goog.isString(query)) {
      return [query];
    }

    if (goog.isString(root)) {
      root = goog.dom.getElement(root);
      if (!root) {
        return [];
      }
    }

    root = root || goog.dom.getDocument();
    var od = root.ownerDocument || root.documentElement;

    // throw the big case sensitivity switch

    // NOTE:
    //    Opera in XHTML mode doesn't detect case-sensitivity correctly
    //    and it's not clear that there's any way to test for it
    caseSensitive =
        root.contentType && root.contentType == 'application/xml' ||
        goog.userAgent.OPERA &&
          (root.doctype || od.toString() == '[object XMLDocument]') ||
        !!od &&
        (goog.userAgent.IE ? od.xml : (root.xmlVersion || od.xmlVersion));

    // NOTE:
    //    adding 'true' as the 2nd argument to getQueryFunc is useful for
    //    testing the DOM branch without worrying about the
    //    behavior/performance of the QSA branch.
    var r = getQueryFunc(query)(root);

    // FIXME(slightlyoff):
    //    need to investigate this branch WRT dojo:#8074 and dojo:#8075
    if (r && r.nozip) {
      return r;
    }
    return _zip(r);
  }

  // FIXME: need to add infrastructure for post-filtering pseudos, ala :last
  query.pseudos = pseudos;

  return query;
})();

// TODO(arv): Please don't export here since it clobbers dead code elimination.
goog.exportSymbol('goog.dom.query', goog.dom.query);
goog.exportSymbol('goog.dom.query.pseudos', goog.dom.query.pseudos);
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A disposable implementation of a custom
 * listenable/event target. See also: documentation for
 * {@code goog.events.Listenable}.
 *
 * @author arv@google.com (Erik Arvidsson) [Original implementation]
 * @author pupius@google.com (Daniel Pupius) [Port to use goog.events]
 * @see ../demos/eventtarget.html
 * @see goog.events.Listenable
 */

goog.provide('goog.events.EventTarget');

goog.require('goog.Disposable');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.require('goog.object');



/**
 * An implementation of {@code goog.events.Listenable} with full W3C
 * EventTarget-like support (capture/bubble mechanism, stopping event
 * propagation, preventing default actions).
 *
 * You may subclass this class to turn your class into a Listenable.
 *
 * Unless propagation is stopped, an event dispatched by an
 * EventTarget will bubble to the parent returned by
 * {@code getParentEventTarget}. To set the parent, call
 * {@code setParentEventTarget}. Subclasses that don't support
 * changing the parent can override the setter to throw an error.
 *
 * Example usage:
 * <pre>
 *   var source = new goog.events.EventTarget();
 *   function handleEvent(e) {
 *     alert('Type: ' + e.type + '; Target: ' + e.target);
 *   }
 *   source.listen('foo', handleEvent);
 *   // Or: goog.events.listen(source, 'foo', handleEvent);
 *   ...
 *   source.dispatchEvent('foo');  // will call handleEvent
 *   ...
 *   source.unlisten('foo', handleEvent);
 *   // Or: goog.events.unlisten(source, 'foo', handleEvent);
 * </pre>
 *
 * @constructor
 * @extends {goog.Disposable}
 * @implements {goog.events.Listenable}
 */
goog.events.EventTarget = function() {
  goog.Disposable.call(this);

  /**
   * Maps of event type to an array of listeners.
   * @private {!goog.events.ListenerMap}
   */
  this.eventTargetListeners_ = new goog.events.ListenerMap(this);

  /**
   * The object to use for event.target. Useful when mixing in an
   * EventTarget to another object.
   * @private {!Object}
   */
  this.actualEventTarget_ = this;
};
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);


/**
 * An artificial cap on the number of ancestors you can have. This is mainly
 * for loop detection.
 * @const {number}
 * @private
 */
goog.events.EventTarget.MAX_ANCESTORS_ = 1000;


/**
 * Parent event target, used during event bubbling.
 *
 * TODO(user): Change this to goog.events.Listenable. This
 * currently breaks people who expect getParentEventTarget to return
 * goog.events.EventTarget.
 *
 * @type {goog.events.EventTarget}
 * @private
 */
goog.events.EventTarget.prototype.parentEventTarget_ = null;


/**
 * Returns the parent of this event target to use for bubbling.
 *
 * @return {goog.events.EventTarget} The parent EventTarget or null if
 *     there is no parent.
 * @override
 */
goog.events.EventTarget.prototype.getParentEventTarget = function() {
  return this.parentEventTarget_;
};


/**
 * Sets the parent of this event target to use for capture/bubble
 * mechanism.
 * @param {goog.events.EventTarget} parent Parent listenable (null if none).
 */
goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {
  this.parentEventTarget_ = parent;
};


/**
 * Adds an event listener to the event target. The same handler can only be
 * added once per the type. Even if you add the same handler multiple times
 * using the same type then it will only be called once when the event is
 * dispatched.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #listen} instead, when possible. Otherwise, use
 *     {@code goog.events.listen} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.addEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);
};


/**
 * Removes an event listener from the event target. The handler must be the
 * same object as the one added. If the handler has not been added then
 * nothing is done.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #unlisten} instead, when possible. Otherwise, use
 *     {@code goog.events.unlisten} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.removeEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);
};


/** @override */
goog.events.EventTarget.prototype.dispatchEvent = function(e) {
  this.assertInitialized_();

  var ancestorsTree, ancestor = this.getParentEventTarget();
  if (ancestor) {
    ancestorsTree = [];
    var ancestorCount = 1;
    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
      ancestorsTree.push(ancestor);
      goog.asserts.assert(
          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),
          'infinite loop');
    }
  }

  return goog.events.EventTarget.dispatchEventInternal_(
      this.actualEventTarget_, e, ancestorsTree);
};


/**
 * Removes listeners from this object.  Classes that extend EventTarget may
 * need to override this method in order to remove references to DOM Elements
 * and additional listeners.
 * @override
 */
goog.events.EventTarget.prototype.disposeInternal = function() {
  goog.events.EventTarget.superClass_.disposeInternal.call(this);

  this.removeAllListeners();
  this.parentEventTarget_ = null;
};


/** @override */
goog.events.EventTarget.prototype.listen = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  this.assertInitialized_();
  return this.eventTargetListeners_.add(
      String(type), listener, false /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.listenOnce = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.add(
      String(type), listener, true /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlisten = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.remove(
      String(type), listener, opt_useCapture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlistenByKey = function(key) {
  return this.eventTargetListeners_.removeByKey(key);
};


/** @override */
goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {
  // TODO(user): Previously, removeAllListeners can be called on
  // uninitialized EventTarget, so we preserve that behavior. We
  // should remove this when usages that rely on that fact are purged.
  if (!this.eventTargetListeners_) {
    return 0;
  }
  return this.eventTargetListeners_.removeAll(opt_type);
};


/** @override */
goog.events.EventTarget.prototype.fireListeners = function(
    type, capture, eventObject) {
  // TODO(user): Original code avoids array creation when there
  // is no listener, so we do the same. If this optimization turns
  // out to be not required, we can replace this with
  // getListeners(type, capture) instead, which is simpler.
  var listenerArray = this.eventTargetListeners_.listeners[String(type)];
  if (!listenerArray) {
    return true;
  }
  listenerArray = goog.array.clone(listenerArray);

  var rv = true;
  for (var i = 0; i < listenerArray.length; ++i) {
    var listener = listenerArray[i];
    // We might not have a listener if the listener was removed.
    if (listener && !listener.removed && listener.capture == capture) {
      var listenerFn = listener.listener;
      var listenerHandler = listener.handler || listener.src;

      if (listener.callOnce) {
        this.unlistenByKey(listener);
      }
      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;
    }
  }

  return rv && eventObject.returnValue_ != false;
};


/** @override */
goog.events.EventTarget.prototype.getListeners = function(type, capture) {
  return this.eventTargetListeners_.getListeners(String(type), capture);
};


/** @override */
goog.events.EventTarget.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  return this.eventTargetListeners_.getListener(
      String(type), listener, capture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.hasListener = function(
    opt_type, opt_capture) {
  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;
  return this.eventTargetListeners_.hasListener(id, opt_capture);
};


/**
 * Sets the target to be used for {@code event.target} when firing
 * event. Mainly used for testing. For example, see
 * {@code goog.testing.events.mixinListenable}.
 * @param {!Object} target The target.
 */
goog.events.EventTarget.prototype.setTargetForTesting = function(target) {
  this.actualEventTarget_ = target;
};


/**
 * Asserts that the event target instance is initialized properly.
 * @private
 */
goog.events.EventTarget.prototype.assertInitialized_ = function() {
  goog.asserts.assert(
      this.eventTargetListeners_,
      'Event target is not initialized. Did you call the superclass ' +
      '(goog.events.EventTarget) constructor?');
};


/**
 * Dispatches the given event on the ancestorsTree.
 *
 * @param {!Object} target The target to dispatch on.
 * @param {goog.events.Event|Object|string} e The event object.
 * @param {Array.<goog.events.Listenable>=} opt_ancestorsTree The ancestors
 *     tree of the target, in reverse order from the closest ancestor
 *     to the root event target. May be null if the target has no ancestor.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 * @private
 */
goog.events.EventTarget.dispatchEventInternal_ = function(
    target, e, opt_ancestorsTree) {
  var type = e.type || /** @type {string} */ (e);

  // If accepting a string or object, create a custom event object so that
  // preventDefault and stopPropagation work with the event.
  if (goog.isString(e)) {
    e = new goog.events.Event(e, target);
  } else if (!(e instanceof goog.events.Event)) {
    var oldEvent = e;
    e = new goog.events.Event(type, target);
    goog.object.extend(e, oldEvent);
  } else {
    e.target = e.target || target;
  }

  var rv = true, currentTarget;

  // Executes all capture listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0;
         i--) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, true, e) && rv;
    }
  }

  // Executes capture and bubble listeners on the target.
  if (!e.propagationStopped_) {
    currentTarget = e.currentTarget = target;
    rv = currentTarget.fireListeners(type, true, e) && rv;
    if (!e.propagationStopped_) {
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  // Executes all bubble listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  return rv;
};
goog.provide('feng.views.debug.DebugView');

goog.require('soy');
goog.require('goog.dom');
goog.require('goog.dom.query');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');


/**
 * @constructor
 */
feng.views.debug.DebugView = function(template, templateData){
  goog.base(this);

  this.parentDom = goog.dom.query('#debugger > ul')[0];

  var placeholderDom = goog.dom.createDom('div');
	var frag = soy.renderAsFragment(template, templateData);
	goog.dom.appendChild(placeholderDom, frag);

	this.domElement = goog.dom.getFirstElementChild(placeholderDom);
	goog.dom.appendChild(this.parentDom, this.domElement);

	this._bodyDom = goog.dom.getElementByClass('body', this.domElement);
	this._displayButton = goog.dom.query('.button.display', this.domElement)[0];

  this._eventHandler = new goog.events.EventHandler(this);
	this._eventHandler.listen(this._displayButton, 'click', this.onClick, false, this);

	feng.pubsub.subscribe(feng.PubSub.Topic.SHOW_VIEW3D, this.onView3DShow, this);
	feng.pubsub.subscribe(feng.PubSub.Topic.HIDE_VIEW3D, this.onView3DHide, this);
};
goog.inherits(feng.views.debug.DebugView, goog.events.EventTarget);


feng.views.debug.DebugView.prototype.show = function() {

	goog.dom.classes.remove(this._displayButton, 'invisible');
	goog.style.showElement(this._bodyDom, true);
};


feng.views.debug.DebugView.prototype.hide = function() {

	goog.dom.classes.add(this._displayButton, 'invisible');
	goog.style.showElement(this._bodyDom, false);
};


feng.views.debug.DebugView.prototype.onView3DShow = function(view3d) {

};


feng.views.debug.DebugView.prototype.onView3DHide = function(view3d) {

};


feng.views.debug.DebugView.prototype.onClick = function(e) {
	switch(e.currentTarget) {
		case this._displayButton:
		if(!goog.dom.classes.has(this._displayButton, 'invisible')) {
			this.hide();
		}else {
			this.show();
		}
		break;

		default:
		break;
	}
};goog.provide('feng.views.debug.Manipulate');

goog.require('feng.views.debug.DebugView');
goog.require('feng.templates.debug');


/**
 * @constructor
 */
feng.views.debug.Manipulate = function(){
  goog.base(this, feng.templates.debug.ManipulateDebugView);

	this._viewPanelDom = goog.dom.getElementByClass('viewPanel', this.domElement);

	this.hide();
};
goog.inherits(feng.views.debug.Manipulate, feng.views.debug.DebugView);// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Event types for goog.history.
 *
 */


goog.provide('goog.history.EventType');


/**
 * Event types for goog.history.
 * @enum {string}
 */
goog.history.EventType = {
  NAVIGATE: 'navigate'
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview The event object dispatched when the history changes.
 *
 */


goog.provide('goog.history.Event');

goog.require('goog.events.Event');
goog.require('goog.history.EventType');



/**
 * Event object dispatched after the history state has changed.
 * @param {string} token The string identifying the new history state.
 * @param {boolean} isNavigation True if the event was triggered by a browser
 *     action, such as forward or back, clicking on a link, editing the URL, or
 *     calling {@code window.history.(go|back|forward)}.
 *     False if the token has been changed by a {@code setToken} or
 *     {@code replaceToken} call.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
goog.history.Event = function(token, isNavigation) {
  goog.events.Event.call(this, goog.history.EventType.NAVIGATE);

  /**
   * The current history state.
   * @type {string}
   */
  this.token = token;

  /**
   * Whether the event was triggered by browser navigation.
   * @type {boolean}
   */
  this.isNavigation = isNavigation;
};
goog.inherits(goog.history.Event, goog.events.Event);
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview HTML5 based history implementation, compatible with
 * goog.History.
 *
 * TODO(user): There should really be a history interface and multiple
 * implementations.
 *
 */


goog.provide('goog.history.Html5History');
goog.provide('goog.history.Html5History.TokenTransformer');

goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.history.Event');
goog.require('goog.history.EventType');



/**
 * An implementation compatible with goog.History that uses the HTML5
 * history APIs.
 *
 * @param {Window=} opt_win The window to listen/dispatch history events on.
 * @param {goog.history.Html5History.TokenTransformer=} opt_transformer
 *     The token transformer that is used to create URL from the token
 *     when storing token without using hash fragment.
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.history.Html5History = function(opt_win, opt_transformer) {
  goog.events.EventTarget.call(this);
  goog.asserts.assert(goog.history.Html5History.isSupported(opt_win),
      'HTML5 history is not supported.');

  /**
   * The window object to use for history tokens.  Typically the top window.
   * @type {Window}
   * @private
   */
  this.window_ = opt_win || window;

  /**
   * The token transformer that is used to create URL from the token
   * when storing token without using hash fragment.
   * @type {goog.history.Html5History.TokenTransformer}
   * @private
   */
  this.transformer_ = opt_transformer || null;

  goog.events.listen(this.window_, goog.events.EventType.POPSTATE,
      this.onHistoryEvent_, false, this);
  goog.events.listen(this.window_, goog.events.EventType.HASHCHANGE,
      this.onHistoryEvent_, false, this);
};
goog.inherits(goog.history.Html5History, goog.events.EventTarget);


/**
 * Returns whether Html5History is supported.
 * @param {Window=} opt_win Optional window to check.
 * @return {boolean} Whether html5 history is supported.
 */
goog.history.Html5History.isSupported = function(opt_win) {
  var win = opt_win || window;
  return !!(win.history && win.history.pushState);
};


/**
 * Status of when the object is active and dispatching events.
 * @type {boolean}
 * @private
 */
goog.history.Html5History.prototype.enabled_ = false;


/**
 * Whether to use the fragment to store the token, defaults to true.
 * @type {boolean}
 * @private
 */
goog.history.Html5History.prototype.useFragment_ = true;


/**
 * If useFragment is false the path will be used, the path prefix will be
 * prepended to all tokens. Defaults to '/'.
 * @type {string}
 * @private
 */
goog.history.Html5History.prototype.pathPrefix_ = '/';


/**
 * Starts or stops the History.  When enabled, the History object
 * will immediately fire an event for the current location. The caller can set
 * up event listeners between the call to the constructor and the call to
 * setEnabled.
 *
 * @param {boolean} enable Whether to enable history.
 */
goog.history.Html5History.prototype.setEnabled = function(enable) {
  if (enable == this.enabled_) {
    return;
  }

  this.enabled_ = enable;

  if (enable) {
    this.dispatchEvent(new goog.history.Event(this.getToken(), false));
  }
};


/**
 * Returns the current token.
 * @return {string} The current token.
 */
goog.history.Html5History.prototype.getToken = function() {
  if (this.useFragment_) {
    var loc = this.window_.location.href;
    var index = loc.indexOf('#');
    return index < 0 ? '' : loc.substring(index + 1);
  } else {
    return this.transformer_ ?
        this.transformer_.retrieveToken(
            this.pathPrefix_, this.window_.location) :
        this.window_.location.pathname.substr(this.pathPrefix_.length);
  }
};


/**
 * Sets the history state.
 * @param {string} token The history state identifier.
 * @param {string=} opt_title Optional title to associate with history entry.
 */
goog.history.Html5History.prototype.setToken = function(token, opt_title) {
  if (token == this.getToken()) {
    return;
  }

  // Per externs/gecko_dom.js document.title can be null.
  this.window_.history.pushState(null,
      opt_title || this.window_.document.title || '', this.getUrl_(token));
  this.dispatchEvent(new goog.history.Event(token, false));
};


/**
 * Replaces the current history state without affecting the rest of the history
 * stack.
 * @param {string} token The history state identifier.
 * @param {string=} opt_title Optional title to associate with history entry.
 */
goog.history.Html5History.prototype.replaceToken = function(token, opt_title) {
  // Per externs/gecko_dom.js document.title can be null.
  this.window_.history.replaceState(null,
      opt_title || this.window_.document.title || '', this.getUrl_(token));
  this.dispatchEvent(new goog.history.Event(token, false));
};


/** @override */
goog.history.Html5History.prototype.disposeInternal = function() {
  goog.events.unlisten(this.window_, goog.events.EventType.POPSTATE,
      this.onHistoryEvent_, false, this);
  if (this.useFragment_) {
    goog.events.unlisten(this.window_, goog.events.EventType.HASHCHANGE,
        this.onHistoryEvent_, false, this);
  }
};


/**
 * Sets whether to use the fragment to store tokens.
 * @param {boolean} useFragment Whether to use the fragment.
 */
goog.history.Html5History.prototype.setUseFragment = function(useFragment) {
  if (this.useFragment_ != useFragment) {
    if (useFragment) {
      goog.events.listen(this.window_, goog.events.EventType.HASHCHANGE,
          this.onHistoryEvent_, false, this);
    } else {
      goog.events.unlisten(this.window_, goog.events.EventType.HASHCHANGE,
          this.onHistoryEvent_, false, this);
    }
    this.useFragment_ = useFragment;
  }
};


/**
 * Sets the path prefix to use if storing tokens in the path. The path
 * prefix should start and end with slash.
 * @param {string} pathPrefix Sets the path prefix.
 */
goog.history.Html5History.prototype.setPathPrefix = function(pathPrefix) {
  this.pathPrefix_ = pathPrefix;
};


/**
 * Gets the path prefix.
 * @return {string} The path prefix.
 */
goog.history.Html5History.prototype.getPathPrefix = function() {
  return this.pathPrefix_;
};


/**
 * Gets the URL to set when calling history.pushState
 * @param {string} token The history token.
 * @return {string} The URL.
 * @private
 */
goog.history.Html5History.prototype.getUrl_ = function(token) {
  if (this.useFragment_) {
    return '#' + token;
  } else {
    return this.transformer_ ?
        this.transformer_.createUrl(
            token, this.pathPrefix_, this.window_.location) :
        this.pathPrefix_ + token + this.window_.location.search;
  }
};


/**
 * Handles history events dispatched by the browser.
 * @param {goog.events.BrowserEvent} e The browser event object.
 * @private
 */
goog.history.Html5History.prototype.onHistoryEvent_ = function(e) {
  if (this.enabled_) {
    this.dispatchEvent(new goog.history.Event(this.getToken(), true));
  }
};



/**
 * A token transformer that can create a URL from a history
 * token. This is used by {@code goog.history.Html5History} to create
 * URL when storing token without the hash fragment.
 *
 * Given a {@code window.location} object containing the location
 * created by {@code createUrl}, the token transformer allows
 * retrieval of the token back via {@code retrieveToken}.
 *
 * @interface
 */
goog.history.Html5History.TokenTransformer = function() {};


/**
 * Retrieves a history token given the path prefix and
 * {@code window.location} object.
 *
 * @param {string} pathPrefix The path prefix to use when storing token
 *     in a path; always begin with a slash.
 * @param {Location} location The {@code window.location} object.
 *     Treat this object as read-only.
 * @return {string} token The history token.
 */
goog.history.Html5History.TokenTransformer.prototype.retrieveToken = function(
    pathPrefix, location) {};


/**
 * Creates a URL to be pushed into HTML5 history stack when storing
 * token without using hash fragment.
 *
 * @param {string} token The history token.
 * @param {string} pathPrefix The path prefix to use when storing token
 *     in a path; always begin with a slash.
 * @param {Location} location The {@code window.location} object.
 *     Treat this object as read-only.
 * @return {string} url The complete URL string from path onwards
 *     (without {@code protocol://host:port} part); must begin with a
 *     slash.
 */
goog.history.Html5History.TokenTransformer.prototype.createUrl = function(
    token, pathPrefix, location) {};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A timer class to which other classes and objects can
 * listen on.  This is only an abstraction above setInterval.
 *
 * @see ../demos/timers.html
 */

goog.provide('goog.Timer');

goog.require('goog.events.EventTarget');



/**
 * Class for handling timing events.
 *
 * @param {number=} opt_interval Number of ms between ticks (Default: 1ms).
 * @param {Object=} opt_timerObject  An object that has setTimeout, setInterval,
 *     clearTimeout and clearInterval (eg Window).
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.Timer = function(opt_interval, opt_timerObject) {
  goog.events.EventTarget.call(this);

  /**
   * Number of ms between ticks
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 1;

  /**
   * An object that implements setTimeout, setInterval, clearTimeout and
   * clearInterval. We default to the window object. Changing this on
   * goog.Timer.prototype changes the object for all timer instances which can
   * be useful if your environment has some other implementation of timers than
   * the window object.
   * @type {Object}
   * @private
   */
  this.timerObject_ = opt_timerObject || goog.Timer.defaultTimerObject;

  /**
   * Cached tick_ bound to the object for later use in the timer.
   * @type {Function}
   * @private
   */
  this.boundTick_ = goog.bind(this.tick_, this);

  /**
   * Firefox browser often fires the timer event sooner
   * (sometimes MUCH sooner) than the requested timeout. So we
   * compare the time to when the event was last fired, and
   * reschedule if appropriate. See also goog.Timer.intervalScale
   * @type {number}
   * @private
   */
  this.last_ = goog.now();
};
goog.inherits(goog.Timer, goog.events.EventTarget);


/**
 * Maximum timeout value.
 *
 * Timeout values too big to fit into a signed 32-bit integer may cause
 * overflow in FF, Safari, and Chrome, resulting in the timeout being
 * scheduled immediately.  It makes more sense simply not to schedule these
 * timeouts, since 24.8 days is beyond a reasonable expectation for the
 * browser to stay open.
 *
 * @type {number}
 * @private
 */
goog.Timer.MAX_TIMEOUT_ = 2147483647;


/**
 * Whether this timer is enabled
 * @type {boolean}
 */
goog.Timer.prototype.enabled = false;


/**
 * An object that implements setTimout, setInterval, clearTimeout and
 * clearInterval. We default to the global object. Changing
 * goog.Timer.defaultTimerObject changes the object for all timer instances
 * which can be useful if your environment has some other implementation of
 * timers you'd like to use.
 * @type {Object}
 */
goog.Timer.defaultTimerObject = goog.global;


/**
 * A variable that controls the timer error correction. If the
 * timer is called before the requested interval times
 * intervalScale, which often happens on mozilla, the timer is
 * rescheduled. See also this.last_
 * @type {number}
 */
goog.Timer.intervalScale = 0.8;


/**
 * Variable for storing the result of setInterval
 * @type {?number}
 * @private
 */
goog.Timer.prototype.timer_ = null;


/**
 * Gets the interval of the timer.
 * @return {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.getInterval = function() {
  return this.interval_;
};


/**
 * Sets the interval of the timer.
 * @param {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.setInterval = function(interval) {
  this.interval_ = interval;
  if (this.timer_ && this.enabled) {
    // Stop and then start the timer to reset the interval.
    this.stop();
    this.start();
  } else if (this.timer_) {
    this.stop();
  }
};


/**
 * Callback for the setTimeout used by the timer
 * @private
 */
goog.Timer.prototype.tick_ = function() {
  if (this.enabled) {
    var elapsed = goog.now() - this.last_;
    if (elapsed > 0 &&
        elapsed < this.interval_ * goog.Timer.intervalScale) {
      this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
          this.interval_ - elapsed);
      return;
    }

    // Prevents setInterval from registering a duplicate timeout when called
    // in the timer event handler.
    if (this.timer_) {
      this.timerObject_.clearTimeout(this.timer_);
      this.timer_ = null;
    }

    this.dispatchTick();
    // The timer could be stopped in the timer event handler.
    if (this.enabled) {
      this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
          this.interval_);
      this.last_ = goog.now();
    }
  }
};


/**
 * Dispatches the TICK event. This is its own method so subclasses can override.
 */
goog.Timer.prototype.dispatchTick = function() {
  this.dispatchEvent(goog.Timer.TICK);
};


/**
 * Starts the timer.
 */
goog.Timer.prototype.start = function() {
  this.enabled = true;

  // If there is no interval already registered, start it now
  if (!this.timer_) {
    // IMPORTANT!
    // window.setInterval in FireFox has a bug - it fires based on
    // absolute time, rather than on relative time. What this means
    // is that if a computer is sleeping/hibernating for 24 hours
    // and the timer interval was configured to fire every 1000ms,
    // then after the PC wakes up the timer will fire, in rapid
    // succession, 3600*24 times.
    // This bug is described here and is already fixed, but it will
    // take time to propagate, so for now I am switching this over
    // to setTimeout logic.
    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643
    //
    this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
        this.interval_);
    this.last_ = goog.now();
  }
};


/**
 * Stops the timer.
 */
goog.Timer.prototype.stop = function() {
  this.enabled = false;
  if (this.timer_) {
    this.timerObject_.clearTimeout(this.timer_);
    this.timer_ = null;
  }
};


/** @override */
goog.Timer.prototype.disposeInternal = function() {
  goog.Timer.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.timerObject_;
};


/**
 * Constant for the timer's event type
 * @type {string}
 */
goog.Timer.TICK = 'tick';


/**
 * Calls the given function once, after the optional pause.
 *
 * The function is always called asynchronously, even if the delay is 0. This
 * is a common trick to schedule a function to run after a batch of browser
 * event processing.
 *
 * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function
 *     or object that has a handleEvent method.
 * @param {number=} opt_delay Milliseconds to wait; default is 0.
 * @param {SCOPE=} opt_handler Object in whose scope to call the listener.
 * @return {number} A handle to the timer ID.
 * @template SCOPE
 */
goog.Timer.callOnce = function(listener, opt_delay, opt_handler) {
  if (goog.isFunction(listener)) {
    if (opt_handler) {
      listener = goog.bind(listener, opt_handler);
    }
  } else if (listener && typeof listener.handleEvent == 'function') {
    // using typeof to prevent strict js warning
    listener = goog.bind(listener.handleEvent, listener);
  } else {
    throw Error('Invalid listener argument');
  }

  if (opt_delay > goog.Timer.MAX_TIMEOUT_) {
    // Timeouts greater than MAX_INT return immediately due to integer
    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don't
    // schedule anything at all.
    return -1;
  } else {
    return goog.Timer.defaultTimerObject.setTimeout(
        listener, opt_delay || 0);
  }
};


/**
 * Clears a timeout initiated by callOnce
 * @param {?number} timerId a timer ID.
 */
goog.Timer.clear = function(timerId) {
  goog.Timer.defaultTimerObject.clearTimeout(timerId);
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Tool for caching the result of expensive deterministic
 * functions.
 *
 * @see http://en.wikipedia.org/wiki/Memoization
 *
 */

goog.provide('goog.memoize');


/**
 * Decorator around functions that caches the inner function's return values.
 *
 * To cache parameterless functions, see goog.functions.cacheReturnValue.
 *
 * @param {Function} f The function to wrap. Its return value may only depend
 *     on its arguments and 'this' context. There may be further restrictions
 *     on the arguments depending on the capabilities of the serializer used.
 * @param {function(number, Object): string=} opt_serializer A function to
 *     serialize f's arguments. It must have the same signature as
 *     goog.memoize.simpleSerializer. It defaults to that function.
 * @this {Object} The object whose function is being wrapped.
 * @return {!Function} The wrapped function.
 */
goog.memoize = function(f, opt_serializer) {
  var serializer = opt_serializer || goog.memoize.simpleSerializer;

  return function() {
    if (goog.memoize.ENABLE_MEMOIZE) {
      // In the strict mode, when this function is called as a global function,
      // the value of 'this' is undefined instead of a global object. See:
      // https://developer.mozilla.org/en/JavaScript/Strict_mode
      var thisOrGlobal = this || goog.global;
      // Maps the serialized list of args to the corresponding return value.
      var cache = thisOrGlobal[goog.memoize.CACHE_PROPERTY_] ||
          (thisOrGlobal[goog.memoize.CACHE_PROPERTY_] = {});
      var key = serializer(goog.getUid(f), arguments);
      return cache.hasOwnProperty(key) ? cache[key] :
          (cache[key] = f.apply(this, arguments));
    } else {
      return f.apply(this, arguments);
    }
  };
};


/**
 * @define {boolean} Flag to disable memoization in unit tests.
 */
goog.define('goog.memoize.ENABLE_MEMOIZE', true);


/**
 * Clears the memoization cache on the given object.
 * @param {Object} cacheOwner The owner of the cache. This is the {@code this}
 *     context of the memoized function.
 */
goog.memoize.clearCache = function(cacheOwner) {
  cacheOwner[goog.memoize.CACHE_PROPERTY_] = {};
};


/**
 * Name of the property used by goog.memoize as cache.
 * @type {string}
 * @private
 */
goog.memoize.CACHE_PROPERTY_ = 'closure_memoize_cache_';


/**
 * Simple and fast argument serializer function for goog.memoize.
 * Supports string, number, boolean, null and undefined arguments. Doesn't
 * support \x0B characters in the strings.
 * @param {number} functionUid Unique identifier of the function whose result
 *     is cached.
 * @param {Object} args The arguments that the function to memoize is called
 *     with. Note: it is an array-like object, because supports indexing and
 *     has the length property.
 * @return {string} The list of arguments with type information concatenated
 *     with the functionUid argument, serialized as \x0B-separated string.
 */
goog.memoize.simpleSerializer = function(functionUid, args) {
  var context = [functionUid];
  for (var i = args.length - 1; i >= 0; --i) {
    context.push(typeof args[i], args[i]);
  }
  return context.join('\x0B');
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser history stack management class.
 *
 * The goog.History object allows a page to create history state without leaving
 * the current document. This allows users to, for example, hit the browser's
 * back button without leaving the current page.
 *
 * The history object can be instantiated in one of two modes. In user visible
 * mode, the current history state is shown in the browser address bar as a
 * document location fragment (the portion of the URL after the '#'). These
 * addresses can be bookmarked, copied and pasted into another browser, and
 * modified directly by the user like any other URL.
 *
 * If the history object is created in invisible mode, the user can still
 * affect the state using the browser forward and back buttons, but the current
 * state is not displayed in the browser address bar. These states are not
 * bookmarkable or editable.
 *
 * It is possible to use both types of history object on the same page, but not
 * currently recommended due to browser deficiencies.
 *
 * Tested to work in:
 * <ul>
 *   <li>Firefox 1.0-4.0
 *   <li>Internet Explorer 5.5-9.0
 *   <li>Opera 9+
 *   <li>Safari 4+
 * </ul>
 *
 * @author brenneman@google.com (Shawn Brenneman)
 * @see ../demos/history1.html
 * @see ../demos/history2.html
 */

/* Some browser specific implementation notes:
 *
 * Firefox (through version 2.0.0.1):
 *
 * Ideally, navigating inside the hidden iframe could be done using
 * about:blank#state instead of a real page on the server. Setting the hash on
 * about:blank creates history entries, but the hash is not recorded and is lost
 * when the user hits the back button. This is true in Opera as well. A blank
 * HTML page must be provided for invisible states to be recorded in the iframe
 * hash.
 *
 * After leaving the page with the History object and returning to it (by
 * hitting the back button from another site), the last state of the iframe is
 * overwritten. The most recent state is saved in a hidden input field so the
 * previous state can be restored.
 *
 * Firefox does not store the previous value of dynamically generated input
 * elements. To save the state, the hidden element must be in the HTML document,
 * either in the original source or added with document.write. If a reference
 * to the input element is not provided as a constructor argument, then the
 * history object creates one using document.write, in which case the history
 * object must be created from a script in the body element of the page.
 *
 * Manually editing the address field to a different hash link prevents further
 * updates to the address bar. The page continues to work as normal, but the
 * address shown will be incorrect until the page is reloaded.
 *
 * NOTE(user): It should be noted that Firefox will URL encode any non-regular
 * ascii character, along with |space|, ", <, and >, when added to the fragment.
 * If you expect these characters in your tokens you should consider that
 * setToken('<b>') would result in the history fragment "%3Cb%3E", and
 * "esp&eacute;re" would show "esp%E8re".  (IE allows unicode characters in the
 * fragment)
 *
 * TODO(user): Should we encapsulate this escaping into the API for visible
 * history and encode all characters that aren't supported by Firefox?  It also
 * needs to be optional so apps can elect to handle the escaping themselves.
 *
 *
 * Internet Explorer (through version 7.0):
 *
 * IE does not modify the history stack when the document fragment is changed.
 * We create history entries instead by using document.open and document.write
 * into a hidden iframe.
 *
 * IE destroys the history stack when navigating from /foo.html#someFragment to
 * /foo.html. The workaround is to always append the # to the URL. This is
 * somewhat unfortunate when loading the page without any # specified, because
 * a second "click" sound will play on load as the fragment is automatically
 * appended. If the hash is always present, this can be avoided.
 *
 * Manually editing the hash in the address bar in IE6 and then hitting the back
 * button can replace the page with a blank page. This is a Bad User Experience,
 * but probably not preventable.
 *
 * IE also has a bug when the page is loaded via a server redirect, setting
 * a new hash value on the window location will force a page reload. This will
 * happen the first time setToken is called with a new token. The only known
 * workaround is to force a client reload early, for example by setting
 * window.location.hash = window.location.hash, which will otherwise be a no-op.
 *
 * Internet Explorer 8.0, Webkit 532.1 and Gecko 1.9.2:
 *
 * IE8 has introduced the support to the HTML5 onhashchange event, which means
 * we don't have to do any polling to detect fragment changes. Chrome and
 * Firefox have added it on their newer builds, wekbit 532.1 and gecko 1.9.2.
 * http://www.w3.org/TR/html5/history.html
 * NOTE(goto): it is important to note that the document needs to have the
 * <!DOCTYPE html> tag to enable the IE8 HTML5 mode. If the tag is not present,
 * IE8 will enter IE7 compatibility mode (which can also be enabled manually).
 *
 * Opera (through version 9.02):
 *
 * Navigating through pages at a rate faster than some threshhold causes Opera
 * to cancel all outstanding timeouts and intervals, including the location
 * polling loop. Since this condition cannot be detected, common input events
 * are captured to cause the loop to restart.
 *
 * location.replace is adding a history entry inside setHash_, despite
 * documentation that suggests it should not.
 *
 *
 * Safari (through version 2.0.4):
 *
 * After hitting the back button, the location.hash property is no longer
 * readable from JavaScript. This is fixed in later WebKit builds, but not in
 * currently shipping Safari. For now, the only recourse is to disable history
 * states in Safari. Pages are still navigable via the History object, but the
 * back button cannot restore previous states.
 *
 * Safari sets history states on navigation to a hashlink, but doesn't allow
 * polling of the hash, so following actual anchor links in the page will create
 * useless history entries. Using location.replace does not seem to prevent
 * this. Not a terribly good user experience, but fixed in later Webkits.
 *
 *
 * WebKit (nightly version 420+):
 *
 * This almost works. Returning to a page with an invisible history object does
 * not restore the old state, however, and there is no pageshow event that fires
 * in this browser. Holding off on finding a solution for now.
 *
 *
 * HTML5 capable browsers (Firefox 4, Chrome, Safari 5)
 *
 * No known issues. The goog.history.Html5History class provides a simpler
 * implementation more suitable for recent browsers. These implementations
 * should be merged so the history class automatically invokes the correct
 * implementation.
 */


goog.provide('goog.History');
goog.provide('goog.History.Event');
goog.provide('goog.History.EventType');

goog.require('goog.Timer');
goog.require('goog.dom');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.history.Event');
goog.require('goog.history.EventType');
goog.require('goog.memoize');
goog.require('goog.string');
goog.require('goog.userAgent');



/**
 * A history management object. Can be instantiated in user-visible mode (uses
 * the address fragment to manage state) or in hidden mode. This object should
 * be created from a script in the document body before the document has
 * finished loading.
 *
 * To store the hidden states in browsers other than IE, a hidden iframe is
 * used. It must point to a valid html page on the same domain (which can and
 * probably should be blank.)
 *
 * Sample instantiation and usage:
 *
 * <pre>
 * // Instantiate history to use the address bar for state.
 * var h = new goog.History();
 * goog.events.listen(h, goog.history.EventType.NAVIGATE, navCallback);
 * h.setEnabled(true);
 *
 * // Any changes to the location hash will call the following function.
 * function navCallback(e) {
 *   alert('Navigated to state "' + e.token + '"');
 * }
 *
 * // The history token can also be set from code directly.
 * h.setToken('foo');
 * </pre>
 *
 * @param {boolean=} opt_invisible True to use hidden history states instead of
 *     the user-visible location hash.
 * @param {string=} opt_blankPageUrl A URL to a blank page on the same server.
 *     Required if opt_invisible is true.  This URL is also used as the src
 *     for the iframe used to track history state in IE (if not specified the
 *     iframe is not given a src attribute).  Access is Denied error may
 *     occur in IE7 if the window's URL's scheme is https, and this URL is
 *     not specified.
 * @param {HTMLInputElement=} opt_input The hidden input element to be used to
 *     store the history token.  If not provided, a hidden input element will
 *     be created using document.write.
 * @param {HTMLIFrameElement=} opt_iframe The hidden iframe that will be used by
 *     IE for pushing history state changes, or by all browsers if opt_invisible
 *     is true. If not provided, a hidden iframe element will be created using
 *     document.write.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.History = function(opt_invisible, opt_blankPageUrl, opt_input,
                        opt_iframe) {
  goog.events.EventTarget.call(this);

  if (opt_invisible && !opt_blankPageUrl) {
    throw Error('Can\'t use invisible history without providing a blank page.');
  }

  var input;
  if (opt_input) {
    input = opt_input;
  } else {
    var inputId = 'history_state' + goog.History.historyCount_;
    document.write(goog.string.subs(goog.History.INPUT_TEMPLATE_,
                                    inputId, inputId));
    input = goog.dom.getElement(inputId);
  }

  /**
   * An input element that stores the current iframe state. Used to restore
   * the state when returning to the page on non-IE browsers.
   * @type {HTMLInputElement}
   * @private
   */
  this.hiddenInput_ = /** @type {HTMLInputElement} */ (input);

  /**
   * The window whose location contains the history token fragment. This is
   * the window that contains the hidden input. It's typically the top window.
   * It is not necessarily the same window that the js code is loaded in.
   * @type {Window}
   * @private
   */
  this.window_ = opt_input ?
      goog.dom.getWindow(goog.dom.getOwnerDocument(opt_input)) : window;

  /**
   * The base URL for the hidden iframe. Must refer to a document in the
   * same domain as the main page.
   * @type {string|undefined}
   * @private
   */
  this.iframeSrc_ = opt_blankPageUrl;

  if (goog.userAgent.IE && !opt_blankPageUrl) {
    this.iframeSrc_ = window.location.protocol == 'https' ? 'https:///' :
                                                            'javascript:""';
  }

  /**
   * A timer for polling the current history state for changes.
   * @type {goog.Timer}
   * @private
   */
  this.timer_ = new goog.Timer(goog.History.PollingType.NORMAL);
  this.registerDisposable(this.timer_);

  /**
   * True if the state tokens are displayed in the address bar, false for hidden
   * history states.
   * @type {boolean}
   * @private
   */
  this.userVisible_ = !opt_invisible;

  /**
   * An object to keep track of the history event listeners.
   * @type {goog.events.EventHandler.<!goog.History>}
   * @private
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  if (opt_invisible || goog.History.LEGACY_IE) {
    var iframe;
    if (opt_iframe) {
      iframe = opt_iframe;
    } else {
      var iframeId = 'history_iframe' + goog.History.historyCount_;
      var srcAttribute = this.iframeSrc_ ?
          'src="' + goog.string.htmlEscape(this.iframeSrc_) + '"' :
          '';
      document.write(goog.string.subs(goog.History.IFRAME_TEMPLATE_,
                                      iframeId,
                                      srcAttribute));
      iframe = goog.dom.getElement(iframeId);
    }

    /**
     * Internet Explorer uses a hidden iframe for all history changes. Other
     * browsers use the iframe only for pushing invisible states.
     * @type {HTMLIFrameElement}
     * @private
     */
    this.iframe_ = /** @type {HTMLIFrameElement} */ (iframe);

    /**
     * Whether the hidden iframe has had a document written to it yet in this
     * session.
     * @type {boolean}
     * @private
     */
    this.unsetIframe_ = true;
  }

  if (goog.History.LEGACY_IE) {
    // IE relies on the hidden input to restore the history state from previous
    // sessions, but input values are only restored after window.onload. Set up
    // a callback to poll the value after the onload event.
    this.eventHandler_.listen(this.window_,
                              goog.events.EventType.LOAD,
                              this.onDocumentLoaded);

    /**
     * IE-only variable for determining if the document has loaded.
     * @type {boolean}
     * @protected
     */
    this.documentLoaded = false;

    /**
     * IE-only variable for storing whether the history object should be enabled
     * once the document finishes loading.
     * @type {boolean}
     * @private
     */
    this.shouldEnable_ = false;
  }

  // Set the initial history state.
  if (this.userVisible_) {
    this.setHash_(this.getToken(), true);
  } else {
    this.setIframeToken_(this.hiddenInput_.value);
  }

  goog.History.historyCount_++;
};
goog.inherits(goog.History, goog.events.EventTarget);


/**
 * Status of when the object is active and dispatching events.
 * @type {boolean}
 * @private
 */
goog.History.prototype.enabled_ = false;


/**
 * Whether the object is performing polling with longer intervals. This can
 * occur for instance when setting the location of the iframe when in invisible
 * mode and the server that is hosting the blank html page is down. In FF, this
 * will cause the location of the iframe to no longer be accessible, with
 * permision denied exceptions being thrown on every access of the history
 * token. When this occurs, the polling interval is elongated. This causes
 * exceptions to be thrown at a lesser rate while allowing for the history
 * object to resurrect itself when the html page becomes accessible.
 * @type {boolean}
 * @private
 */
goog.History.prototype.longerPolling_ = false;


/**
 * The last token set by the history object, used to poll for changes.
 * @type {?string}
 * @private
 */
goog.History.prototype.lastToken_ = null;


/**
 * Whether the browser supports HTML5 history management's onhashchange event.
 * {@link http://www.w3.org/TR/html5/history.html}. IE 9 in compatibility mode
 * indicates that onhashchange is in window, but testing reveals the event
 * isn't actually fired.
 * @return {boolean} Whether onhashchange is supported.
 */
goog.History.isOnHashChangeSupported = goog.memoize(function() {
  return goog.userAgent.IE ?
      document.documentMode >= 8 :
      'onhashchange' in goog.global;
});


/**
 * Whether the current browser is Internet Explorer prior to version 8. Many IE
 * specific workarounds developed before version 8 are unnecessary in more
 * current versions.
 * @type {boolean}
 */
goog.History.LEGACY_IE = goog.userAgent.IE &&
    !goog.userAgent.isDocumentModeOrHigher(8);


/**
 * Whether the browser always requires the hash to be present. Internet Explorer
 * before version 8 will reload the HTML page if the hash is omitted.
 * @type {boolean}
 */
goog.History.HASH_ALWAYS_REQUIRED = goog.History.LEGACY_IE;


/**
 * If not null, polling in the user invisible mode will be disabled until this
 * token is seen. This is used to prevent a race condition where the iframe
 * hangs temporarily while the location is changed.
 * @type {?string}
 * @private
 */
goog.History.prototype.lockedToken_ = null;


/** @override */
goog.History.prototype.disposeInternal = function() {
  goog.History.superClass_.disposeInternal.call(this);
  this.eventHandler_.dispose();
  this.setEnabled(false);
};


/**
 * Starts or stops the History polling loop. When enabled, the History object
 * will immediately fire an event for the current location. The caller can set
 * up event listeners between the call to the constructor and the call to
 * setEnabled.
 *
 * On IE, actual startup may be delayed until the iframe and hidden input
 * element have been loaded and can be polled. This behavior is transparent to
 * the caller.
 *
 * @param {boolean} enable Whether to enable the history polling loop.
 */
goog.History.prototype.setEnabled = function(enable) {

  if (enable == this.enabled_) {
    return;
  }

  if (goog.History.LEGACY_IE && !this.documentLoaded) {
    // Wait until the document has actually loaded before enabling the
    // object or any saved state from a previous session will be lost.
    this.shouldEnable_ = enable;
    return;
  }

  if (enable) {
    if (goog.userAgent.OPERA) {
      // Capture events for common user input so we can restart the timer in
      // Opera if it fails. Yes, this is distasteful. See operaDefibrillator_.
      this.eventHandler_.listen(this.window_.document,
                                goog.History.INPUT_EVENTS_,
                                this.operaDefibrillator_);
    } else if (goog.userAgent.GECKO) {
      // Firefox will not restore the correct state after navigating away from
      // and then back to the page with the history object. This can be fixed
      // by restarting the history object on the pageshow event.
      this.eventHandler_.listen(this.window_, 'pageshow', this.onShow_);
    }

    // TODO(user): make HTML5 and invisible history work by listening to the
    // iframe # changes instead of the window.
    if (goog.History.isOnHashChangeSupported() &&
        this.userVisible_) {
      this.eventHandler_.listen(
          this.window_, goog.events.EventType.HASHCHANGE, this.onHashChange_);
      this.enabled_ = true;
      this.dispatchEvent(new goog.history.Event(this.getToken(), false));
    } else if (!goog.userAgent.IE || this.documentLoaded) {
      // Start dispatching history events if all necessary loading has
      // completed (always true for browsers other than IE.)
      this.eventHandler_.listen(this.timer_, goog.Timer.TICK,
          goog.bind(this.check_, this, true));

      this.enabled_ = true;

      // Initialize last token at startup except on IE < 8, where the last token
      // must only be set in conjunction with IFRAME updates, or the IFRAME will
      // start out of sync and remove any pre-existing URI fragment.
      if (!goog.History.LEGACY_IE) {
        this.lastToken_ = this.getToken();
        this.dispatchEvent(new goog.history.Event(this.getToken(), false));
      }

      this.timer_.start();
    }

  } else {
    this.enabled_ = false;
    this.eventHandler_.removeAll();
    this.timer_.stop();
  }
};


/**
 * Callback for the window onload event in IE. This is necessary to read the
 * value of the hidden input after restoring a history session. The value of
 * input elements is not viewable until after window onload for some reason (the
 * iframe state is similarly unavailable during the loading phase.)  If
 * setEnabled is called before the iframe has completed loading, the history
 * object will actually be enabled at this point.
 * @protected
 */
goog.History.prototype.onDocumentLoaded = function() {
  this.documentLoaded = true;

  if (this.hiddenInput_.value) {
    // Any saved value in the hidden input can only be read after the document
    // has been loaded due to an IE limitation. Restore the previous state if
    // it has been set.
    this.setIframeToken_(this.hiddenInput_.value, true);
  }

  this.setEnabled(this.shouldEnable_);
};


/**
 * Handler for the Gecko pageshow event. Restarts the history object so that the
 * correct state can be restored in the hash or iframe.
 * @param {goog.events.BrowserEvent} e The browser event.
 * @private
 */
goog.History.prototype.onShow_ = function(e) {
  // NOTE(user): persisted is a property passed in the pageshow event that
  // indicates whether the page is being persisted from the cache or is being
  // loaded for the first time.
  if (e.getBrowserEvent()['persisted']) {
    this.setEnabled(false);
    this.setEnabled(true);
  }
};


/**
 * Handles HTML5 onhashchange events on browsers where it is supported.
 * This is very similar to {@link #check_}, except that it is not executed
 * continuously. It is only used when
 * {@code goog.History.isOnHashChangeSupported()} is true.
 * @param {goog.events.BrowserEvent} e The browser event.
 * @private
 */
goog.History.prototype.onHashChange_ = function(e) {
  var hash = this.getLocationFragment_(this.window_);
  if (hash != this.lastToken_) {
    this.update_(hash, true);
  }
};


/**
 * @return {string} The current token.
 */
goog.History.prototype.getToken = function() {
  if (this.lockedToken_ != null) {
    return this.lockedToken_;
  } else if (this.userVisible_) {
    return this.getLocationFragment_(this.window_);
  } else {
    return this.getIframeToken_() || '';
  }
};


/**
 * Sets the history state. When user visible states are used, the URL fragment
 * will be set to the provided token.  Sometimes it is necessary to set the
 * history token before the document title has changed, in this case IE's
 * history drop down can be out of sync with the token.  To get around this
 * problem, the app can pass in a title to use with the hidden iframe.
 * @param {string} token The history state identifier.
 * @param {string=} opt_title Optional title used when setting the hidden iframe
 *     title in IE.
 */
goog.History.prototype.setToken = function(token, opt_title) {
  this.setHistoryState_(token, false, opt_title);
};


/**
 * Replaces the current history state without affecting the rest of the history
 * stack.
 * @param {string} token The history state identifier.
 * @param {string=} opt_title Optional title used when setting the hidden iframe
 *     title in IE.
 */
goog.History.prototype.replaceToken = function(token, opt_title) {
  this.setHistoryState_(token, true, opt_title);
};


/**
 * Gets the location fragment for the current URL.  We don't use location.hash
 * directly as the browser helpfully urlDecodes the string for us which can
 * corrupt the tokens.  For example, if we want to store: label/%2Froot it would
 * be returned as label//root.
 * @param {Window} win The window object to use.
 * @return {string} The fragment.
 * @private
 */
goog.History.prototype.getLocationFragment_ = function(win) {
  var href = win.location.href;
  var index = href.indexOf('#');
  return index < 0 ? '' : href.substring(index + 1);
};


/**
 * Sets the history state. When user visible states are used, the URL fragment
 * will be set to the provided token. Setting opt_replace to true will cause the
 * navigation to occur, but will replace the current history entry without
 * affecting the length of the stack.
 *
 * @param {string} token The history state identifier.
 * @param {boolean} replace Set to replace the current history entry instead of
 *    appending a new history state.
 * @param {string=} opt_title Optional title used when setting the hidden iframe
 *     title in IE.
 * @private
 */
goog.History.prototype.setHistoryState_ = function(token, replace, opt_title) {
  if (this.getToken() != token) {
    if (this.userVisible_) {
      this.setHash_(token, replace);

      if (!goog.History.isOnHashChangeSupported()) {
        if (goog.userAgent.IE) {
          // IE must save state using the iframe.
          this.setIframeToken_(token, replace, opt_title);
        }
      }

      // This condition needs to be called even if
      // goog.History.isOnHashChangeSupported() is true so the NAVIGATE event
      // fires sychronously.
      if (this.enabled_) {
        this.check_(false);
      }
    } else {
      // Fire the event immediately so that setting history is synchronous, but
      // set a suspendToken so that polling doesn't trigger a 'back'.
      this.setIframeToken_(token, replace);
      this.lockedToken_ = this.lastToken_ = this.hiddenInput_.value = token;
      this.dispatchEvent(new goog.history.Event(token, false));
    }
  }
};


/**
 * Sets or replaces the URL fragment. The token does not need to be URL encoded
 * according to the URL specification, though certain characters (like newline)
 * are automatically stripped.
 *
 * If opt_replace is not set, non-IE browsers will append a new entry to the
 * history list. Setting the hash does not affect the history stack in IE
 * (unless there is a pre-existing named anchor for that hash.)
 *
 * Older versions of Webkit cannot query the location hash, but it still can be
 * set. If we detect one of these versions, always replace instead of creating
 * new history entries.
 *
 * window.location.replace replaces the current state from the history stack.
 * http://www.whatwg.org/specs/web-apps/current-work/#dom-location-replace
 * http://www.whatwg.org/specs/web-apps/current-work/#replacement-enabled
 *
 * @param {string} token The new string to set.
 * @param {boolean=} opt_replace Set to true to replace the current token
 *    without appending a history entry.
 * @private
 */
goog.History.prototype.setHash_ = function(token, opt_replace) {
  // If the page uses a BASE element, setting location.hash directly will
  // navigate away from the current document. Also, the original URL path may
  // possibly change from HTML5 history pushState. To account for these, the
  // full path is always specified.
  var loc = this.window_.location;
  var url = loc.href.split('#')[0];

  // If a hash has already been set, then removing it programmatically will
  // reload the page. Once there is a hash, we won't remove it.
  var hasHash = goog.string.contains(loc.href, '#');

  if (goog.History.HASH_ALWAYS_REQUIRED || hasHash || token) {
    url += '#' + token;
  }

  if (url != loc.href) {
    if (opt_replace) {
      loc.replace(url);
    } else {
      loc.href = url;
    }
  }
};


/**
 * Sets the hidden iframe state. On IE, this is accomplished by writing a new
 * document into the iframe. In Firefox, the iframe's URL fragment stores the
 * state instead.
 *
 * Older versions of webkit cannot set the iframe, so ignore those browsers.
 *
 * @param {string} token The new string to set.
 * @param {boolean=} opt_replace Set to true to replace the current iframe state
 *     without appending a new history entry.
 * @param {string=} opt_title Optional title used when setting the hidden iframe
 *     title in IE.
 * @private
 */
goog.History.prototype.setIframeToken_ = function(token,
                                                  opt_replace,
                                                  opt_title) {
  if (this.unsetIframe_ || token != this.getIframeToken_()) {

    this.unsetIframe_ = false;
    token = goog.string.urlEncode(token);

    if (goog.userAgent.IE) {
      // Caching the iframe document results in document permission errors after
      // leaving the page and returning. Access it anew each time instead.
      var doc = goog.dom.getFrameContentDocument(this.iframe_);

      doc.open('text/html', opt_replace ? 'replace' : undefined);
      doc.write(goog.string.subs(
          goog.History.IFRAME_SOURCE_TEMPLATE_,
          goog.string.htmlEscape(
              /** @type {string} */ (opt_title || this.window_.document.title)),
          token));
      doc.close();
    } else {
      var url = this.iframeSrc_ + '#' + token;

      // In Safari, it is possible for the contentWindow of the iframe to not
      // be present when the page is loading after a reload.
      var contentWindow = this.iframe_.contentWindow;
      if (contentWindow) {
        if (opt_replace) {
          contentWindow.location.replace(url);
        } else {
          contentWindow.location.href = url;
        }
      }
    }
  }
};


/**
 * Return the current state string from the hidden iframe. On internet explorer,
 * this is stored as a string in the document body. Other browsers use the
 * location hash of the hidden iframe.
 *
 * Older versions of webkit cannot access the iframe location, so always return
 * null in that case.
 *
 * @return {?string} The state token saved in the iframe (possibly null if the
 *     iframe has never loaded.).
 * @private
 */
goog.History.prototype.getIframeToken_ = function() {
  if (goog.userAgent.IE) {
    var doc = goog.dom.getFrameContentDocument(this.iframe_);
    return doc.body ? goog.string.urlDecode(doc.body.innerHTML) : null;
  } else {
    // In Safari, it is possible for the contentWindow of the iframe to not
    // be present when the page is loading after a reload.
    var contentWindow = this.iframe_.contentWindow;
    if (contentWindow) {
      var hash;
      /** @preserveTry */
      try {
        // Iframe tokens are urlEncoded
        hash = goog.string.urlDecode(this.getLocationFragment_(contentWindow));
      } catch (e) {
        // An exception will be thrown if the location of the iframe can not be
        // accessed (permission denied). This can occur in FF if the the server
        // that is hosting the blank html page goes down and then a new history
        // token is set. The iframe will navigate to an error page, and the
        // location of the iframe can no longer be accessed. Due to the polling,
        // this will cause constant exceptions to be thrown. In this case,
        // we enable longer polling. We do not have to attempt to reset the
        // iframe token because (a) we already fired the NAVIGATE event when
        // setting the token, (b) we can rely on the locked token for current
        // state, and (c) the token is still in the history and
        // accesible on forward/back.
        if (!this.longerPolling_) {
          this.setLongerPolling_(true);
        }

        return null;
      }

      // There was no exception when getting the hash so turn off longer polling
      // if it is on.
      if (this.longerPolling_) {
        this.setLongerPolling_(false);
      }

      return hash || null;
    } else {
      return null;
    }
  }
};


/**
 * Checks the state of the document fragment and the iframe title to detect
 * navigation changes. If {@code goog.HistoryisOnHashChangeSupported()} is
 * {@code false}, then this runs approximately twenty times per second.
 * @param {boolean} isNavigation True if the event was initiated by a browser
 *     action, false if it was caused by a setToken call. See
 *     {@link goog.history.Event}.
 * @private
 */
goog.History.prototype.check_ = function(isNavigation) {
  if (this.userVisible_) {
    var hash = this.getLocationFragment_(this.window_);
    if (hash != this.lastToken_) {
      this.update_(hash, isNavigation);
    }
  }

  // Old IE uses the iframe for both visible and non-visible versions.
  if (!this.userVisible_ || goog.History.LEGACY_IE) {
    var token = this.getIframeToken_() || '';
    if (this.lockedToken_ == null || token == this.lockedToken_) {
      this.lockedToken_ = null;
      if (token != this.lastToken_) {
        this.update_(token, isNavigation);
      }
    }
  }
};


/**
 * Updates the current history state with a given token. Called after a change
 * to the location or the iframe state is detected by poll_.
 *
 * @param {string} token The new history state.
 * @param {boolean} isNavigation True if the event was initiated by a browser
 *     action, false if it was caused by a setToken call. See
 *     {@link goog.history.Event}.
 * @private
 */
goog.History.prototype.update_ = function(token, isNavigation) {
  this.lastToken_ = this.hiddenInput_.value = token;

  if (this.userVisible_) {
    if (goog.History.LEGACY_IE) {
      this.setIframeToken_(token);
    }

    this.setHash_(token);
  } else {
    this.setIframeToken_(token);
  }

  this.dispatchEvent(new goog.history.Event(this.getToken(), isNavigation));
};


/**
 * Sets if the history oject should use longer intervals when polling.
 *
 * @param {boolean} longerPolling Whether to enable longer polling.
 * @private
 */
goog.History.prototype.setLongerPolling_ = function(longerPolling) {
  if (this.longerPolling_ != longerPolling) {
    this.timer_.setInterval(longerPolling ?
        goog.History.PollingType.LONG : goog.History.PollingType.NORMAL);
  }
  this.longerPolling_ = longerPolling;
};


/**
 * Opera cancels all outstanding timeouts and intervals after any rapid
 * succession of navigation events, including the interval used to detect
 * navigation events. This function restarts the interval so that navigation can
 * continue. Ideally, only events which would be likely to cause a navigation
 * change (mousedown and keydown) would be bound to this function. Since Opera
 * seems to ignore keydown events while the alt key is pressed (such as
 * alt-left or right arrow), this function is also bound to the much more
 * frequent mousemove event. This way, when the update loop freezes, it will
 * unstick itself as the user wiggles the mouse in frustration.
 * @private
 */
goog.History.prototype.operaDefibrillator_ = function() {
  this.timer_.stop();
  this.timer_.start();
};


/**
 * List of user input event types registered in Opera to restart the history
 * timer (@see goog.History#operaDefibrillator_).
 * @type {Array.<string>}
 * @private
 */
goog.History.INPUT_EVENTS_ = [
  goog.events.EventType.MOUSEDOWN,
  goog.events.EventType.KEYDOWN,
  goog.events.EventType.MOUSEMOVE
];


/**
 * Minimal HTML page used to populate the iframe in Internet Explorer. The title
 * is visible in the history dropdown menu, the iframe state is stored as the
 * body innerHTML.
 * @type {string}
 * @private
 */
goog.History.IFRAME_SOURCE_TEMPLATE_ = '<title>%s</title><body>%s</body>';


/**
 * HTML template for an invisible iframe.
 * @type {string}
 * @private
 */
goog.History.IFRAME_TEMPLATE_ =
    '<iframe id="%s" style="display:none" %s></iframe>';


/**
 * HTML template for an invisible named input element.
 * @type {string}
 * @private
 */
goog.History.INPUT_TEMPLATE_ =
    '<input type="text" name="%s" id="%s" style="display:none">';


/**
 * Counter for the number of goog.History objects that have been instantiated.
 * Used to create unique IDs.
 * @type {number}
 * @private
 */
goog.History.historyCount_ = 0;


/**
 * Types of polling. The values are in ms of the polling interval.
 * @enum {number}
 */
goog.History.PollingType = {
  NORMAL: 150,
  LONG: 10000
};


/**
 * Constant for the history change event type.
 * @enum {string}
 * @deprecated Use goog.history.EventType.
 */
goog.History.EventType = goog.history.EventType;



/**
 * Constant for the history change event type.
 * @param {string} token The string identifying the new history state.
 * @extends {goog.events.Event}
 * @constructor
 * @deprecated Use goog.history.Event.
 * @final
 */
goog.History.Event = goog.history.Event;
goog.provide('feng.controllers.NavigationController');

goog.require('goog.events.EventTarget');
goog.require('goog.events');
goog.require('goog.History');
goog.require('goog.history.Html5History');
goog.require('goog.history.EventType');
goog.require('goog.string');

/**
 * @constructor
 */
feng.controllers.NavigationController = function(){
	
  goog.base(this);

  // a toggle of whether to use history API
  this._useHistoryAPI = (feng.controllers.NavigationController.Implementation === feng.controllers.NavigationController.HISTORY_API);

  if(this._useHistoryAPI) {
  	this._navHistory = new goog.history.Html5History();
  	this._navHistory.setUseFragment(false);
  }else {
  	var hideHistory = false;
  	var input = goog.dom.createDom('input');
  	var iframe = goog.dom.createDom('iframe');
  	this._navHistory = new goog.History(hideHistory, null, input, iframe);
  }

  // the current token
  // "token/token/..."
  this._token = null;

  goog.events.listen(this._navHistory, goog.history.EventType.NAVIGATE, this.onNavigate, false, this);
};
goog.inherits(feng.controllers.NavigationController, goog.events.EventTarget);
goog.addSingletonGetter(feng.controllers.NavigationController);


feng.controllers.NavigationController.prototype.init = function(){

  this._navHistory.setEnabled(true);
};


feng.controllers.NavigationController.prototype.testToken = function( token, tokenToTest ){

  var tokenArr = goog.isArray( token ) ? token : token.split('/');
  var tokenToTestArr = tokenToTest.replace('#/', '').split('/');

  var result;

  if(tokenArr.length !== tokenToTestArr.length) {

  	result = null;

  }else {

  	var result = {};

  	var i, l = tokenArr.length;
  	var regex = /{(.*?)}/;

  	for(i = 0; i < l; i++) {

  		var tokenStr = tokenArr[i];
  		var tokenToTestStr = tokenToTestArr[i];

  		var isVariable = regex.test( tokenToTestStr );

  		if(isVariable) {

  			var key = tokenToTestStr.replace(/{|}/g, '');
  			result[ key ] = tokenStr;

  		}else if( tokenStr != tokenToTestStr ){

  			result = null;
  			break;
  		}
  	}
  }

  return result;
};


feng.controllers.NavigationController.prototype.setToken = function(token, title){

	var token = goog.isArray(token) ? this.getTokenFromArray( token ) : token;
	token = token.replace('#', '');
	
	this._navHistory.setToken(token, title);
};


feng.controllers.NavigationController.prototype.replaceToken = function(token, title){

	var token = goog.isArray(token) ? this.getTokenFromArray( token ) : token;
	token = token.replace('#', '');

	this._navHistory.replaceToken(token ,title);
};


feng.controllers.NavigationController.prototype.getTokenFromArray = function(tokens){

  var token = tokens.join('/');
  return token;
};


feng.controllers.NavigationController.prototype.getTokenString = function(){

	return this._token || this._navHistory.getToken();
};


feng.controllers.NavigationController.prototype.getTokenArray = function(){

	var tokens = (this._token || this._navHistory.getToken()).split('/');

	if(tokens.length > 0) {
		if(tokens[0] === '') tokens.shift();
	}else {
		tokens = null;
	}

	return tokens;
};


feng.controllers.NavigationController.prototype.handleToken = function(tokenString, tokenArray){

	console.log('handle token: ' + tokenString);

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		tokenString: tokenString,
		tokenArray: tokenArray
	});
};


feng.controllers.NavigationController.prototype.getUrlBeforeHash = function(token){
	
	var url = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '') + window.location.pathname;
	return url;
};


feng.controllers.NavigationController.prototype.onNavigate = function(e){

	// normalize event token format between history api and hash
	// always being 'token/token...'
	var eToken = e.token;

	if(goog.string.startsWith(eToken, '#/')) {
		eToken.replace('#/', '');
	}else if(goog.string.startsWith(eToken, '/')) {
		eToken.replace('/', '');
	}

	if(this._token === eToken) return false;
	else this._token = eToken;

	this.handleToken( this.getTokenString(), this.getTokenArray() );
};


feng.controllers.NavigationController.HASH = 'hash';
feng.controllers.NavigationController.HISTORY_API = 'history_api';
feng.controllers.NavigationController.Implementation = (goog.history.Html5History.isSupported() ? feng.controllers.NavigationController.HISTORY_API : feng.controllers.NavigationController.HASH);

feng.controllers.NavigationController.Token = {
	HOME: '#/home',
	STUDIO: '#/studio',
	HOUSE: '#/house',
	BOOK: '#/book',
	SECTION: '#/{sectionId}',
	VIEW: '#/{sectionId}/{viewId}',
	READ_TIP: '#/book/{tipId}',
	GO_TIP: '#/{sectionId}/{viewId}/{objectId}',
	TEST_TIP: '#/testtip/{sectionId}/{viewId}/{tipId}'
};goog.provide('feng.events');

goog.require('goog.userAgent');

/**
 * Event Types
 */
feng.events.EventType = {
	LOAD: 'load',
	LOAD_COMPLETE: 'load_complete',
	PROGRESS: 'progress',
	COMPLETE: 'complete',
	ERROR: 'error',
	UPDATE: 'update',
	CHANGE: 'change',
	CANCEL: 'cancel',
	START: 'start',
	END: 'end',
	PLAY: 'play',
	STOP: 'stop',
	PAUSE: 'pause',
	ADD: 'add',
	REMOVE: 'remove',
	SHOW: 'show',
	HIDE: 'hide',
	OPEN: 'open',
	CLOSE: 'close',
	TOGGLE: 'toggle',
	ANIMATE_IN: 'animate_in',
	ANIMATE_OUT: 'animate_out',
	ANIMATED_IN: 'animated_in',
	ANIMATED_OUT: 'animated_out',
	UNLOCK: 'unlock',
	DRAG: 'drag',
	DRAG_END: 'drag_end',
	MUTE: 'mute',
	UNMUTE: 'unmute',
	CLICK_COMPASS: 'click_compass',
	CLICK_GATEWAY: 'click_gateway',
	INPUT_DOWN: (goog.userAgent.MOBILE) ? goog.events.EventType.TOUCHSTART : goog.events.EventType.MOUSEDOWN,
	INPUT_MOVE: (goog.userAgent.MOBILE) ? goog.events.EventType.TOUCHMOVE : goog.events.EventType.MOUSEMOVE,
	INPUT_UP: (goog.userAgent.MOBILE) ? [goog.events.EventType.TOUCHEND, goog.events.EventType.TOUCHCANCEL] : goog.events.EventType.MOUSEUP,
	INPUT_OVER: (goog.userAgent.MOBILE) ? goog.events.EventType.TOUCHSTART : goog.events.EventType.MOUSEOVER
};goog.provide('feng.models.achievements.Tip');

goog.require('goog.events.EventTarget');
goog.require('feng.events');
goog.require('feng.controllers.NavigationController');

/**
 * @constructor
 */
feng.models.achievements.Tip = function( tipId, viewId, sectionId, data ){

  goog.base(this);

  this.id = tipId;
  this.viewId = viewId;
  this.sectionId = sectionId;

  this.isMandatory = data['mandatory'];
  this.isFinal = data['final'];
  this.reminder = data['reminder'];
  this.character = data['character'];
  this.name = data['name'];
  this.icon = data['icon'];
  this.prompt = data['prompt'];
  this.advice = data['advice'];
  this.problem = data['problem'];
  this.hint = data['hint'];
  this.details = data['details'] || {};

  this.shareImageUrl = feng.Config['assetsPath'] + 'images/share/' + this.id + '.jpg';

  this.readTipToken = feng.controllers.NavigationController.Token.READ_TIP.replace('{tipId}', this.id);

  this.unlocked = (feng.storageController.isTipUnlocked( this.id ) === true) ? true : data['unlocked'];

  this._requiredTipId = null;
  this._providedTipId = null;
};
goog.inherits(feng.models.achievements.Tip, goog.events.EventTarget);


feng.models.achievements.Tip.prototype.getRequiredTip = function() {

  if(!this._requiredTipId) return null;

  var achievements = feng.models.achievements.Achievements.getInstance();
  var requiredTip = achievements.getTip( this._requiredTipId, this.viewId, this.sectionId );

  return requiredTip;
};


feng.models.achievements.Tip.prototype.getProvidedTip = function() {

  if(!this._providedTipId) return null;

  var achievements = feng.models.achievements.Achievements.getInstance();
  var providedTip = achievements.getTip( this._providedTipId, this.viewId, this.sectionId );

  return providedTip;
};


feng.models.achievements.Tip.prototype.require = function( tipId ) {

  this._requiredTipId = tipId;
  return this;
};


feng.models.achievements.Tip.prototype.provide = function( tipId ) {

  this._providedTipId = tipId;
  return this;
};


feng.models.achievements.Tip.prototype.unlock = function() {

  if(this._requiredTipId) {

    this.unlocked = this.getRequiredTip().unlocked;
  }else {

    this.unlocked = true;
  }

  if(this.unlocked) {
    
    this.dispatchEvent({
      type: feng.events.EventType.UNLOCK,
      tip: this
    });
  }

  return this.unlocked;
};goog.provide('feng.models.achievements.Achievements');

goog.require('goog.array');
goog.require('goog.object');
goog.require('feng.models.achievements.Tip');

/**
 * @constructor
 */
feng.models.achievements.Achievements = function(){

  this._sections = {
    /*
    'sectionId': {
      'viewId': [
        new feng.models.achievements.Tip('tipId', 'viewId', 'sectionId').require('requireId')
      ]
    }*/
  };
};
goog.addSingletonGetter(feng.models.achievements.Achievements);


feng.models.achievements.Achievements.prototype.init = function( tipsData ) {

  goog.array.forEach(tipsData, function(tipData) {

    var viewId = tipData['view'];
    var sectionId = tipData['section'];
    var tipId = tipData['id'];
    var requireId = tipData['require'];
    var provideId = tipData['provide'];

    this._sections[sectionId] = this._sections[sectionId] || {};
    this._sections[sectionId][viewId] = this._sections[sectionId][viewId] || [];

    var tip = new feng.models.achievements.Tip( tipId, viewId, sectionId, tipData ).provide( provideId ).require( requireId );
    this._sections[sectionId][viewId].push( tip );

  }, this);
};


feng.models.achievements.Achievements.prototype.getTip = function(tipId, viewId, sectionId) {

  var tips = this.getTipsOfView( viewId, sectionId );
  var tip = goog.array.find(tips, function(t) {
    return t.id === tipId;
  });

  return tip;
};


feng.models.achievements.Achievements.prototype.getTipsOfView = function(viewId, sectionId, onlyMandatory, onlyFinal) {

  var tips = this._sections[ sectionId ][ viewId ];
  
  tips = goog.array.filter(tips, function(tip) {

    if(onlyMandatory && onlyFinal) {

      return (tip.isMandatory && tip.isFinal);

    }else if(onlyMandatory && !onlyFinal) {

      return tip.isMandatory;

    }else if(!onlyMandatory && onlyFinal) {

      return tip.isFinal;
    }

    return true;
  });

  return tips;
};


feng.models.achievements.Achievements.prototype.getTipsOfSection = function(sectionId, onlyMandatory) {

  var tips = [];
  var views = this._sections[ sectionId ];
  goog.object.forEach(views, function(viewTips) {
    goog.array.extend(tips, viewTips);
  });

  if(onlyMandatory) {
    tips = goog.array.filter(tips, function(tip) {
      return tip.isMandatory;
    });
  }

  return tips;
};


feng.models.achievements.Achievements.prototype.getAllTips = function() {

  var tips = [];

  goog.object.forEach(this._sections, function(section) {
    goog.object.forEach(section, function(view) {
      goog.array.forEach(view, function(tip) {
        tips.push(tip);
      });
    });
  });

  return tips;
};


feng.models.achievements.Achievements.prototype.isAllUnlocked = function(){

  var allTips = this.getAllTips();
  var i, l = allTips.length;

  for(i = 0; i < l; i ++) {
    if(!allTips[i].unlocked) {
      return false;
    }
  }

  return true;
};goog.provide('feng.views.debug.Achievements');

goog.require('feng.events');
goog.require('feng.views.debug.DebugView');
goog.require('feng.templates.debug');
goog.require('feng.models.achievements.Achievements');


/**
 * @constructor
 */
feng.views.debug.Achievements = function( tipsData ){

  this._achievementsModel = feng.models.achievements.Achievements.getInstance();

  this._tips = this._achievementsModel.getAllTips();

  var templateData = {
    tips: tipsData
  };

  goog.base(this, feng.templates.debug.AchievementsDebugView, templateData);

  this._unlockAllButton = goog.dom.query('.unlock-all', this.domElement)[0];

  this._eventHandler.listen( this._unlockAllButton, 'click', this.onClickUnlockAll, false, this );

  this._tipEls = goog.dom.query('.tips li', this.domElement);

  goog.array.forEach(this._tipEls, function(tipEl) {
    this._eventHandler.listen(tipEl, 'click', this.onClickTip, false, this);
  }, this);

  goog.array.forEach(this._tips, function(tip) {
    this._eventHandler.listen(tip, feng.events.EventType.UNLOCK, this.onUnlock, false, this);
  }, this);
};
goog.inherits(feng.views.debug.Achievements, feng.views.debug.DebugView);


feng.views.debug.Achievements.prototype.getTipByAttributes = function(tipId, viewId, sectionId){

  return goog.dom.query('.tips li[data-tip-id='+tipId+'][data-view-id='+viewId+'][data-section-id='+sectionId+']', this.domElement)[0];
};


feng.views.debug.Achievements.prototype.onUnlock = function(e){

  var tipId = e.currentTarget.id;
  var viewId = e.currentTarget.viewId;
  var sectionId = e.currentTarget.sectionId;

  var tipEl = this.getTipByAttributes(tipId, viewId, sectionId);
  goog.dom.classlist.add(tipEl, 'unlocked');
};


feng.views.debug.Achievements.prototype.onClickTip = function(e){

  goog.array.forEach(this._tipEls, function(tipEl) {
    goog.dom.classlist.remove(tipEl, 'clicked');
    goog.dom.classlist.remove(tipEl, 'required');
  });

  var tipId = e.currentTarget.getAttribute('data-tip-id');
  var viewId = e.currentTarget.getAttribute('data-view-id');
  var sectionId = e.currentTarget.getAttribute('data-section-id');

  var clickedTip = this._achievementsModel.getTip(tipId, viewId, sectionId);
  var requiredTip = clickedTip.getRequiredTip();

  goog.dom.classlist.add(e.currentTarget, 'clicked');

  if(requiredTip) {
    var requireTipEl = goog.dom.query('.tips li[data-tip-id="' + requiredTip.id + '"]')[0];
    goog.dom.classlist.add(requireTipEl, 'required');
  }
};


feng.views.debug.Achievements.prototype.onClickUnlockAll = function(e){

  goog.array.forEach(this._tips, function(tip) {
    tip.unlock();
  }, this);
};goog.provide('feng.views.debug.PathTrack');

goog.require('feng.views.debug.DebugView');
goog.require('feng.templates.debug');


/**
 * @constructor
 */
feng.views.debug.PathTrack = function(){

  goog.base(this, feng.templates.debug.PathTrackDebugView);

  this._pathEditApp = feng.apps.PathEdit.getInstance();
  this._selectDom = goog.dom.query('select', this.domElement)[0];
  this._addButton = goog.dom.query('.button.add', this.domElement)[0];
  this._removeButton = goog.dom.query('.button.remove', this.domElement)[0];
  this._outputButton = goog.dom.query('.button.output', this.domElement)[0];
  this._textarea = goog.dom.query('textarea', this.domElement)[0];
  this._playButton = goog.dom.query('.button.play', this.domElement)[0];
  this._cameraButton = goog.dom.query('.button.camera', this.domElement)[0];
  this._range = goog.dom.query('input[type="range"]', this.domElement)[0];
  this._importInput = goog.dom.query('.button.import', this.domElement)[0];
  this._xInput = goog.dom.query('input[name="x"]', this.domElement)[0];
  this._yInput = goog.dom.query('input[name="y"]', this.domElement)[0];
  this._zInput = goog.dom.query('input[name="z"]', this.domElement)[0];
  this._tipIdInput = goog.dom.query('input[name="tipid"]', this.domElement)[0];

  this._pathTrack = null;
  this._controlPoint = null;

  this._eventHandler.listen(this._selectDom, feng.events.EventType.CHANGE, this.setScene, false, this);
  this._eventHandler.listen(this._addButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._removeButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._outputButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._playButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._cameraButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._range, feng.events.EventType.CHANGE, this.onProgressChange, false, this);

  this._eventHandler.listen(this._importInput, feng.events.EventType.CHANGE, this.onFileImport, false, this);
  this._eventHandler.listen(this._xInput, feng.events.EventType.CHANGE, this.onPointPropertyChange, false, this);
  this._eventHandler.listen(this._yInput, feng.events.EventType.CHANGE, this.onPointPropertyChange, false, this);
  this._eventHandler.listen(this._zInput, feng.events.EventType.CHANGE, this.onPointPropertyChange, false, this);
  this._eventHandler.listen(this._tipIdInput, feng.events.EventType.CHANGE, this.onPointPropertyChange, false, this);

  this._eventHandler.listen(this._pathEditApp, feng.events.EventType.CHANGE, this.onPathEditChange, false, this);
  this._eventHandler.listenOnce(this._pathEditApp, feng.events.EventType.LOAD_COMPLETE, this.onScenesLoadComplete, false, this);

  this.show();
};
goog.inherits(feng.views.debug.PathTrack, feng.views.debug.DebugView);


feng.views.debug.PathTrack.prototype.setScene = function(){

  this._pathEditApp.dispatchEvent({
    type: feng.events.EventType.CHANGE,
    sceneName: this._selectDom.value
  });
};


feng.views.debug.PathTrack.prototype.updatePointFields = function(){

  if(this._controlPoint) {
    this._xInput.value = this._controlPoint.x;
    this._yInput.value = this._controlPoint.y;
    this._zInput.value = this._controlPoint.z;
    this._tipIdInput.value = this._controlPoint.tipId || '';
  }

  var shouldDisable = this._controlPoint ? false : true;
  this._xInput.disabled = shouldDisable;
  this._yInput.disabled = shouldDisable;
  this._zInput.disabled = shouldDisable;
  this._tipIdInput.disabled = shouldDisable;
};


feng.views.debug.PathTrack.prototype.onScenesLoadComplete = function(e){

  goog.array.forEach(e.scenes, function(scene) {

    var optionDom = goog.dom.createDom('option', {
      'value': scene.name
    }, scene.name);

    this._selectDom.add( optionDom );

  }, this);
};


feng.views.debug.PathTrack.prototype.onClick = function(e){

  goog.base(this, 'onClick', e);

  switch(e.currentTarget) {

    case this._addButton:
    this._pathEditApp.dispatchEvent({
      type: feng.events.EventType.ADD
    });
    break;

    case this._removeButton:
    this._pathEditApp.dispatchEvent({
      type: feng.events.EventType.REMOVE
    });
    break;

    case this._outputButton:
    var output = {
      controlPoints: []
    };

    goog.array.forEach(this._pathTrack.controlPoints, function(controlPoint) {
      var pointData = {
        'x': controlPoint.x,
        'y': controlPoint.y,
        'z': controlPoint.z,
        'tipid': controlPoint.tipId || ''
      };
      output.controlPoints.push(pointData);
    });

    this._textarea.value = JSON.stringify(output, null, '\t');
    break;

    case this._playButton:
    if(goog.dom.classes.has(this._playButton, 'paused')) {
      goog.dom.classes.remove(this._playButton, 'paused');

      this._pathEditApp.dispatchEvent({
        type: feng.events.EventType.PAUSE
      });
    }else {
      goog.dom.classes.add(this._playButton, 'paused');

      this._pathEditApp.dispatchEvent({
        type: feng.events.EventType.PLAY
      });
    }
    break;

    case this._cameraButton:
    if(goog.dom.classes.has(this._cameraButton, 'fly')) {
      goog.dom.classes.remove(this._cameraButton, 'fly');

      this._pathEditApp.dispatchEvent({
        type: feng.events.EventType.CHANGE,
        fly: true
      });
    }else {
      goog.dom.classes.add(this._cameraButton, 'fly');

      this._pathEditApp.dispatchEvent({
        type: feng.events.EventType.CHANGE,
        fly: false
      });
    }
    break;
  }
};


feng.views.debug.PathTrack.prototype.onPointPropertyChange = function(e){

  var x = parseFloat(this._xInput.value);
  var y = parseFloat(this._yInput.value);
  var z = parseFloat(this._zInput.value);
  var tipId = this._tipIdInput.value;

  this._controlPoint.set(x, y, z);
  this._controlPoint.tipId = tipId;

  this._pathTrack.updateTrack();
};


feng.views.debug.PathTrack.prototype.onProgressChange = function(e){

  this._pathEditApp.dispatchEvent({
    type: feng.events.EventType.PROGRESS,
    progress: this._range.value / 100
  });
};


feng.views.debug.PathTrack.prototype.onPathEditChange = function(e){

  if(goog.isDef(e.controlPoint)) {
    var disabled = !goog.isDefAndNotNull(e.controlPoint);
    this._addButton.disabled = disabled;
    this._removeButton.disabled = disabled;
    this._outputButton.disabled = disabled;
    this._controlPoint = e.controlPoint;

    this.updatePointFields();
  }

  if(goog.isDef(e.pathTrack)) {
    this._pathTrack = e.pathTrack;
  }

  if(goog.isNumber(e.progress)) {
    this._range.value = Math.round(e.progress * 100);
  }

  if(e.complete === true) {
    goog.dom.classes.remove(this._playButton, 'paused');
  }
};


feng.views.debug.PathTrack.prototype.onFileImport = function(e){

  var file = e.target.files[0];

  var reader = new FileReader();

  reader.onload = goog.bind(function(e) {

    var parsedJSON = JSON.parse( e.target.result );
    var controlPointsData = parsedJSON['controlPoints'];
    var controlPoints = goog.array.map(controlPointsData, function(data) {
      var point = new THREE.Vector3(data['x'], data['y'], data['z']);
      point['tipid'] = data['tipid'];
      return point;
    });

    this._pathTrack.create( controlPoints );
    
  }, this);

  reader.readAsText(file);
};goog.provide('feng.views.debug.Camera');

goog.require('feng.views.debug.DebugView');
goog.require('feng.templates.debug');


/**
 * @constructor
 */
feng.views.debug.Camera = function(){

  goog.base(this, feng.templates.debug.CameraDebugView);

  this._fovInput = goog.dom.query('input[name="fov"]', this.domElement)[0];
  this._positionXInput = goog.dom.query('input[name="position-x"]', this.domElement)[0];
  this._positionYInput = goog.dom.query('input[name="position-y"]', this.domElement)[0];
  this._positionZInput = goog.dom.query('input[name="position-z"]', this.domElement)[0];
  this._rotationXInput = goog.dom.query('input[name="rotation-x"]', this.domElement)[0];
  this._rotationYInput = goog.dom.query('input[name="rotation-y"]', this.domElement)[0];
  this._rotationZInput = goog.dom.query('input[name="rotation-z"]', this.domElement)[0];
  this._degreesCheckbox = goog.dom.query('.degrees', this.domElement)[0];
  this._helpersCheckbox = goog.dom.query('.helpers', this.domElement)[0];
  this._selectDom = goog.dom.query('select', this.domElement)[0];
  this._textarea = goog.dom.query('textarea', this.domElement)[0];
  this._visibleButton = goog.dom.query('.visible.button', this.domElement)[0];
  this._useButton = goog.dom.query('.use.button', this.domElement)[0];

  this._isInputFocused = false;

  this._camera = null;
  this._cameraController = null;

  this._controls = null;
  this._modeController = null;

  this._eventHandler.listen(this._selectDom, feng.events.EventType.CHANGE, this.setSelectedCamera, false, this);
  this._eventHandler.listen(this._visibleButton, 'click', this.onClick, false, this);
  this._eventHandler.listen(this._useButton, 'click', this.onClick, false, this);

  var inputs = goog.dom.query('input[type="number"]', this.domElement);
  goog.array.forEach(inputs, function(input) {
  	this._eventHandler.listen(input, 'focus', this.onFocus, false, this);
  	this._eventHandler.listen(input, 'blur', this.onBlur, false, this);
  	this._eventHandler.listen(input, 'change', this.onInputChange, false, this);
  }, this);

  this._eventHandler.listen(this._helpersCheckbox, 'change', this.onHelpersChange, false, this);

  this._cameraControllerEventHandler = new goog.events.EventHandler(this);

  this.show();
};
goog.inherits(feng.views.debug.Camera, feng.views.debug.DebugView);


feng.views.debug.Camera.prototype.show = function(){

  goog.base(this, 'show');
  goog.fx.anim.registerAnimation(this);
};


feng.views.debug.Camera.prototype.hide = function(){

  goog.base(this, 'hide');
  goog.fx.anim.unregisterAnimation(this);
};


feng.views.debug.Camera.prototype.setSelectedCamera = function(){

	var name = this._selectDom.value;
	this._controls = this._modeController.getModeControl( name );
	this._camera = this._controls.getCamera();

	this.updateVisibleButton();

	return this._camera;
};


feng.views.debug.Camera.prototype.updateVisibleButton = function(){
	
	var cameraHelper = this._cameraController.getCameraHelper( this._camera.name );

	if(cameraHelper.visible) {
		goog.dom.classes.remove(this._visibleButton, 'invisible');
	}else {
		goog.dom.classes.add(this._visibleButton, 'invisible');
	}
};


feng.views.debug.Camera.prototype.onView3DShow = function(view3d){

  goog.base(this, 'onView3DShow', view3d);

  this._cameraController = view3d.cameraController;
  this._modeController = view3d.modeController;

	var cameras = view3d.cameraController.getCameras();
	goog.object.forEach(cameras, function(camera) {
		this.onAddCamera({
			camera: camera
		});
	}, this);

	this._cameraControllerEventHandler.listen(this._cameraController, feng.events.EventType.ADD, this.onAddCamera, false, this);
	this._cameraControllerEventHandler.listen(this._cameraController, feng.events.EventType.REMOVE, this.onRemoveCamera, false, this);
	this._cameraControllerEventHandler.listen(this._cameraController, feng.events.EventType.CHANGE, this.onChangeCamera, false, this);
};


feng.views.debug.Camera.prototype.onView3DHide = function(view3d){

  goog.base(this, 'onView3DHide', view3d);

  this._cameraController = view3d.cameraController;

	var cameras = view3d.cameraController.getCameras();
	goog.object.forEach(cameras, function(camera) {
		this.onRemoveCamera({
			camera: camera
		});
	}, this);

  this._cameraControllerEventHandler.removeAll();
};


feng.views.debug.Camera.prototype.onAddCamera = function(e){

	var cameraName = e.camera.name;

	// add the camera option if not existed
	var optionDoms = goog.dom.query('option[value="'+cameraName+'"]', this._selectDom);
	if(optionDoms.length > 0) return;

	var optionDom = goog.dom.createDom('option', {
		'value': cameraName
	}, cameraName);

	this._selectDom.add( optionDom );

	this.setSelectedCamera();
};


feng.views.debug.Camera.prototype.onRemoveCamera = function(e){

	var cameraName = e.camera.name;

	// remove the camera option only if exists
	var optionDoms = goog.dom.query('option[value="'+cameraName+'"]', this._selectDom);
	if(optionDoms.length <= 0) return;

	var optionDom = optionDoms[0];

	this._selectDom.remove( optionDom );
};


feng.views.debug.Camera.prototype.onChangeCamera = function(e){

	this._selectDom.value = e.camera.name;
	this.setSelectedCamera();
};


feng.views.debug.Camera.prototype.onClick = function(e){

	goog.base(this, 'onClick', e);

	switch(e.currentTarget) {
		case this._useButton:
		this._cameraController.setCamera( this._selectDom.value );
		break;

		case this._visibleButton:
		var cameraHelper = this._cameraController.getCameraHelper( this._camera.name );
		cameraHelper.visible = !cameraHelper.visible;

		if(!this._helpersCheckbox.checked) {
			cameraHelper.visible = false;
		}

		this.updateVisibleButton();
		break;
	};
};


feng.views.debug.Camera.prototype.onFocus = function(e){

	this._isInputFocused = true;
};


feng.views.debug.Camera.prototype.onBlur = function(e){

	this._isInputFocused = false;
};


feng.views.debug.Camera.prototype.onHelpersChange = function(e){

	var visible = e.currentTarget.checked;

	goog.array.forEach(this._cameraController.cameraHelpers, function(cameraHelper) {
		cameraHelper.visible = cameraHelper.visible ? visible : false;
	});

	this.updateVisibleButton();
};


feng.views.debug.Camera.prototype.onInputChange = function(e){

	var fov = parseFloat( this._fovInput.value );
	this._controls.setFov( fov );

	var positionX = parseFloat( this._positionXInput.value );
	var positionY = parseFloat( this._positionYInput.value );
	var positionZ = parseFloat( this._positionZInput.value );

	this._controls.setPosition( positionX, positionY, positionZ );

	var inDegrees = this._degreesCheckbox.checked;
	var rotationX, rotationY, rotationZ;

	if(inDegrees) {

		rotationX = THREE.Math.degToRad( parseFloat( this._rotationXInput.value ) );
		rotationY = THREE.Math.degToRad( parseFloat( this._rotationYInput.value ) );
		rotationZ = THREE.Math.degToRad( parseFloat( this._rotationZInput.value ) );

	}else {

		rotationX = parseFloat( this._rotationXInput.value );
		rotationY = parseFloat( this._rotationYInput.value );
		rotationZ = parseFloat( this._rotationZInput.value );
	}

	this._controls.setRotation( rotationX, rotationY, rotationZ );
};


feng.views.debug.Camera.prototype.onAnimationFrame = function(now){

	if(!this._camera || this._isInputFocused) return;

	var position = this._controls.getPosition();
	var rotation = this._controls.getRotation();

	this._fovInput.value = this._camera.fov.toFixed(2);
  this._positionXInput.value = position.x.toFixed(2);
  this._positionYInput.value = position.y.toFixed(2);
  this._positionZInput.value = position.z.toFixed(2);

  var inDegrees = this._degreesCheckbox.checked;
  var rotationX = inDegrees ? goog.math.toDegrees( rotation.x ) : rotation.x;
  var rotationY = inDegrees ? goog.math.toDegrees( rotation.y ) : rotation.y;
  var rotationZ = inDegrees ? goog.math.toDegrees( rotation.z ) : rotation.z;

  this._rotationXInput.value = rotationX.toFixed(2);
  this._rotationYInput.value = rotationY.toFixed(2);
  this._rotationZInput.value = rotationZ.toFixed(2);
};// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing a numeric box.
 */


goog.provide('goog.math.Box');

goog.require('goog.math.Coordinate');



/**
 * Class for representing a box. A box is specified as a top, right, bottom,
 * and left. A box is useful for representing margins and padding.
 *
 * @param {number} top Top.
 * @param {number} right Right.
 * @param {number} bottom Bottom.
 * @param {number} left Left.
 * @constructor
 */
goog.math.Box = function(top, right, bottom, left) {
  /**
   * Top
   * @type {number}
   */
  this.top = top;

  /**
   * Right
   * @type {number}
   */
  this.right = right;

  /**
   * Bottom
   * @type {number}
   */
  this.bottom = bottom;

  /**
   * Left
   * @type {number}
   */
  this.left = left;
};


/**
 * Creates a Box by bounding a collection of goog.math.Coordinate objects
 * @param {...goog.math.Coordinate} var_args Coordinates to be included inside
 *     the box.
 * @return {!goog.math.Box} A Box containing all the specified Coordinates.
 */
goog.math.Box.boundingBox = function(var_args) {
  var box = new goog.math.Box(arguments[0].y, arguments[0].x,
                              arguments[0].y, arguments[0].x);
  for (var i = 1; i < arguments.length; i++) {
    var coord = arguments[i];
    box.top = Math.min(box.top, coord.y);
    box.right = Math.max(box.right, coord.x);
    box.bottom = Math.max(box.bottom, coord.y);
    box.left = Math.min(box.left, coord.x);
  }
  return box;
};


/**
 * Creates a copy of the box with the same dimensions.
 * @return {!goog.math.Box} A clone of this Box.
 */
goog.math.Box.prototype.clone = function() {
  return new goog.math.Box(this.top, this.right, this.bottom, this.left);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the box.
   * @return {string} In the form (50t, 73r, 24b, 13l).
   * @override
   */
  goog.math.Box.prototype.toString = function() {
    return '(' + this.top + 't, ' + this.right + 'r, ' + this.bottom + 'b, ' +
           this.left + 'l)';
  };
}


/**
 * Returns whether the box contains a coordinate or another box.
 *
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.prototype.contains = function(other) {
  return goog.math.Box.contains(this, other);
};


/**
 * Expands box with the given margins.
 *
 * @param {number|goog.math.Box} top Top margin or box with all margins.
 * @param {number=} opt_right Right margin.
 * @param {number=} opt_bottom Bottom margin.
 * @param {number=} opt_left Left margin.
 * @return {!goog.math.Box} A reference to this Box.
 */
goog.math.Box.prototype.expand = function(top, opt_right, opt_bottom,
    opt_left) {
  if (goog.isObject(top)) {
    this.top -= top.top;
    this.right += top.right;
    this.bottom += top.bottom;
    this.left -= top.left;
  } else {
    this.top -= top;
    this.right += opt_right;
    this.bottom += opt_bottom;
    this.left -= opt_left;
  }

  return this;
};


/**
 * Expand this box to include another box.
 * NOTE(user): This is used in code that needs to be very fast, please don't
 * add functionality to this function at the expense of speed (variable
 * arguments, accepting multiple argument types, etc).
 * @param {goog.math.Box} box The box to include in this one.
 */
goog.math.Box.prototype.expandToInclude = function(box) {
  this.left = Math.min(this.left, box.left);
  this.top = Math.min(this.top, box.top);
  this.right = Math.max(this.right, box.right);
  this.bottom = Math.max(this.bottom, box.bottom);
};


/**
 * Compares boxes for equality.
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A Box.
 * @return {boolean} True iff the boxes are equal, or if both are null.
 */
goog.math.Box.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.top == b.top && a.right == b.right &&
         a.bottom == b.bottom && a.left == b.left;
};


/**
 * Returns whether a box contains a coordinate or another box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.contains = function(box, other) {
  if (!box || !other) {
    return false;
  }

  if (other instanceof goog.math.Box) {
    return other.left >= box.left && other.right <= box.right &&
        other.top >= box.top && other.bottom <= box.bottom;
  }

  // other is a Coordinate.
  return other.x >= box.left && other.x <= box.right &&
         other.y >= box.top && other.y <= box.bottom;
};


/**
 * Returns the relative x position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The x position of {@code coord} relative to the nearest
 *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
 */
goog.math.Box.relativePositionX = function(box, coord) {
  if (coord.x < box.left) {
    return coord.x - box.left;
  } else if (coord.x > box.right) {
    return coord.x - box.right;
  }
  return 0;
};


/**
 * Returns the relative y position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The y position of {@code coord} relative to the nearest
 *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
 */
goog.math.Box.relativePositionY = function(box, coord) {
  if (coord.y < box.top) {
    return coord.y - box.top;
  } else if (coord.y > box.bottom) {
    return coord.y - box.bottom;
  }
  return 0;
};


/**
 * Returns the distance between a coordinate and the nearest corner/side of a
 * box. Returns zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The distance between {@code coord} and the nearest
 *     corner/side of {@code box}, or zero if {@code coord} is inside
 *     {@code box}.
 */
goog.math.Box.distance = function(box, coord) {
  var x = goog.math.Box.relativePositionX(box, coord);
  var y = goog.math.Box.relativePositionY(box, coord);
  return Math.sqrt(x * x + y * y);
};


/**
 * Returns whether two boxes intersect.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersects = function(a, b) {
  return (a.left <= b.right && b.left <= a.right &&
          a.top <= b.bottom && b.top <= a.bottom);
};


/**
 * Returns whether two boxes would intersect with additional padding.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @param {number} padding The additional padding.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersectsWithPadding = function(a, b, padding) {
  return (a.left <= b.right + padding && b.left <= a.right + padding &&
          a.top <= b.bottom + padding && b.top <= a.bottom + padding);
};


/**
 * Rounds the fields to the next larger integer values.
 *
 * @return {!goog.math.Box} This box with ceil'd fields.
 */
goog.math.Box.prototype.ceil = function() {
  this.top = Math.ceil(this.top);
  this.right = Math.ceil(this.right);
  this.bottom = Math.ceil(this.bottom);
  this.left = Math.ceil(this.left);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 *
 * @return {!goog.math.Box} This box with floored fields.
 */
goog.math.Box.prototype.floor = function() {
  this.top = Math.floor(this.top);
  this.right = Math.floor(this.right);
  this.bottom = Math.floor(this.bottom);
  this.left = Math.floor(this.left);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 *
 * @return {!goog.math.Box} This box with rounded fields.
 */
goog.math.Box.prototype.round = function() {
  this.top = Math.round(this.top);
  this.right = Math.round(this.right);
  this.bottom = Math.round(this.bottom);
  this.left = Math.round(this.left);
  return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the left and right values are translated by the coordinate's
 * x value and the top and bottom values are translated by the coordinate's y
 * value.  Otherwise, {@code tx} and {@code opt_ty} are used to translate the x
 * and y dimension values.
 *
 * @param {number|goog.math.Coordinate} tx The value to translate the x
 *     dimension values by or the the coordinate to translate this box by.
 * @param {number=} opt_ty The value to translate y dimension values by.
 * @return {!goog.math.Box} This box after translating.
 */
goog.math.Box.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.right += tx.x;
    this.top += tx.y;
    this.bottom += tx.y;
  } else {
    this.left += tx;
    this.right += tx;
    if (goog.isNumber(opt_ty)) {
      this.top += opt_ty;
      this.bottom += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y dimension
 * values are scaled by {@code sx} and {@code opt_sy} respectively.
 * If {@code opt_sy} is not given, then {@code sx} is used for both x and y.
 *
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Box} This box after scaling.
 */
goog.math.Box.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.left *= sx;
  this.right *= sx;
  this.top *= sy;
  this.bottom *= sy;
  return this;
};
goog.provide('feng.controllers.view3d.PathfindingController');

goog.require('goog.array');
goog.require('goog.events.EventTarget');
goog.require('goog.math.Box');

/**
 * @constructor
 */
feng.controllers.view3d.PathfindingController = function(){

  goog.base(this);

  // matrix pool
  this._matrixData = {
  	/*
	{
		matrix: matrix,
		gridWidth: gridWidth,
		gridHeight: gridHeight,
		gridMinX: Number,
		gridMaxX: Number,
		gridMinZ: Number,
		gridMaxZ: Number,
		tileSize: tileSize,
		numCols: numCols,
		numRows: numRows
	}
  	*/
  };

  // scene for capturing tiles
  this._scene = new THREE.Scene();

  this._camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);
  this._camera.rotation.x = - Math.PI / 2;

  this._boundaryBox = new THREE.Box3();

  this._zoom = 1;

  this._renderer = new THREE.CanvasRenderer();
  this._renderer.setClearColor( 0xff0000 );
};
goog.inherits(feng.controllers.view3d.PathfindingController, goog.events.EventTarget);
goog.addSingletonGetter(feng.controllers.view3d.PathfindingController);


feng.controllers.view3d.PathfindingController.prototype.getMatrixData = function( matrixId, objects ) {

	var matrixData = this._matrixData[ matrixId ];

	if(!matrixData) {
		matrixData = this.generateMatrix( matrixId, objects );
	}

	return matrixData;
};


feng.controllers.view3d.PathfindingController.prototype.generateMatrix = function( matrixId, objects ) {

	// draw scene from top view (WIP)
	// remove last children from rendering
	var obj, i, l = this._scene.children.length;

	for ( i = l - 1; i >= 0 ; i -- ) {

	    obj = this._scene.children[ i ];
			this._scene.remove( obj );
	}

	// add new children to rendering
	l = objects.length;

	for ( i = 0; i < l; i++ ) {

	    obj = objects[ i ];

	    if(obj.isCollidable() || obj.isFloor()) {
	    	var proxyMesh = obj.getTilemapProxy();
	    	this._scene.add( proxyMesh );
	    }
	}

	var box = this._boundaryBox.setFromObject( this._scene );
	var sceneSize = box.size();
	var sceneWidth = sceneSize.x;
	var sceneHeight = sceneSize.z;

	this._camera.left = sceneWidth / -2;
	this._camera.right = sceneWidth / 2;
	this._camera.top = sceneHeight / 2;
	this._camera.bottom = sceneHeight / -2;
	this._camera.position.copy( box.center() );
	this._camera.updateProjectionMatrix();

	this._renderer.setSize( sceneWidth * this._zoom, sceneHeight * this._zoom );
  this._renderer.render( this._scene, this._camera );

  // parse tiles from render
  var gridWidth = sceneWidth;
  var gridHeight = sceneHeight;

	var gridMinX = box.min.x;
	var gridMinZ = box.min.z;
	var gridMaxX = box.max.x;
	var gridMaxZ = box.max.z;

	var tileSize = 15;

	gridWidth = Math.floor(gridWidth / tileSize) * tileSize;
	gridHeight = Math.floor(gridHeight / tileSize) * tileSize;

	var numCols = gridWidth / tileSize;
	var numRows = gridHeight / tileSize;

	var matrix = [];
	var row = 0;
	var col = 0;
	var ctx = this._renderer.domElement.getContext('2d');
	var halfTileSize = tileSize / 2;

	var DPI = window.devicePixelRatio || 1;

	for(row = 0; row < numRows; ++row) {
		var rowData = [];

		for(col = 0; col < numCols; ++col) {

			var x = (col * tileSize + halfTileSize) * DPI;
			var y = (row * tileSize + halfTileSize) * DPI;

			var redCount = 0;

			if( ctx.getImageData(x, y, 1, 1).data[0] === 255 ) redCount++;
			if( ctx.getImageData(x + tileSize, y, 1, 1).data[0] === 255 ) redCount++;
			if( ctx.getImageData(x, y + tileSize, 1, 1).data[0] === 255 ) redCount++;
			if( ctx.getImageData(x + tileSize, y + tileSize, 1, 1).data[0] === 255 ) redCount++;

			var collided = (redCount >= 2);
			
			var type = collided ? 1 : 0;
			rowData.push( type );
		}

		matrix.push(rowData);
	}

	// cache the matrix by Id
	var matrixData = {
		matrix: matrix,
		gridWidth: gridWidth,
		gridHeight: gridHeight,
		gridMinX: gridMinX,
		gridMaxX: gridMaxX,
		gridMinZ: gridMinZ,
		gridMaxZ: gridMaxZ,
		tileSize: tileSize,
		numCols: numCols,
		numRows: numRows
	};

	this._matrixData[ matrixId ] = matrixData;
	
	return matrixData;
};


feng.controllers.view3d.PathfindingController.prototype.getTileByPosition = function( position, matrixData ) {

	var gridMaxX = matrixData.gridMaxX;
	var gridMaxZ = matrixData.gridMaxZ;
	var gridMinX = matrixData.gridMinX;
	var gridMinZ = matrixData.gridMinZ;
	var tileSize = matrixData.tileSize;
	var numCols = matrixData.numCols;
	var numRows = matrixData.numRows;

	var tileCol = goog.math.clamp( Math.round((position.x - gridMinX) / tileSize), 0, numCols-1 );
	var tileRow = goog.math.clamp( Math.round((position.z - gridMinZ) / tileSize), 0, numRows-1 );

	var tile = [ tileCol, tileRow ];

	return tile;
};


feng.controllers.view3d.PathfindingController.prototype.resolveMatrix = function( matrixData, start, end ) {

	var matrix = matrixData.matrix;
	var gridWidth = matrixData.gridWidth;
	var gridHeight = matrixData.gridHeight;
	var gridMinX = matrixData.gridMinX;
	var gridMaxX = matrixData.gridMaxX;
	var gridMinZ = matrixData.gridMinZ;
	var gridMaxZ = matrixData.gridMaxZ;
	var tileSize = matrixData.tileSize;
	var numCols = matrixData.numCols;
	var numRows = matrixData.numRows;

	var startTile = this.getTileByPosition( start, matrixData );
	var endTile = this.getTileByPosition( end, matrixData );
	
	// clamp the tile within bound
	startTile[0] = Math.min(startTile[0], numCols-1);
	startTile[1] = Math.min(startTile[1], numRows-1);

	endTile[0] = Math.min(endTile[0], numCols-1);
	endTile[1] = Math.min(endTile[1], numRows-1);

	var result = {
		matrix: matrix,
		gridMinX: gridMinX,
		gridMinZ: gridMinZ,
		gridWidth: gridWidth,
		gridHeight: gridHeight,
		numRows: numRows,
		numCols: numCols,
		tileSize: tileSize,
		startTile: startTile,
		endTile: endTile
	};

	return result;
};


feng.controllers.view3d.PathfindingController.prototype.isWalkablePosition = function( position, matrixData ) {

	var tile = this.getTileByPosition( position, matrixData );

	return this.isWalkableTile( tile, matrixData );
};


feng.controllers.view3d.PathfindingController.prototype.isWalkableTile = function( tile, matrixData ) {

	var matrix = matrixData.matrix;

	var tileType = matrix[ tile[1] ][ tile[0] ];

	return (tileType === 0);
};


feng.controllers.view3d.PathfindingController.prototype.getClosestWalkableTile = function( tile, matrixData ) {

	var matrix = matrixData.matrix;

	// return this tile if is walkable
	if(this.isWalkableTile( tile, matrixData )) {
		return tile;
	}

	// otherwise find the closest
	var shortestDistance = Number.MAX_VALUE;
	var closestWalkableTile = null;

	var row = 0;
	var col = 0;
	var numRows = matrixData.numRows;
	var numCols = matrixData.numCols;

	for(row = 0; row < numRows; ++row) {

		for(col = 0; col < numCols; ++col) {
			var type = matrix[row][col];

			if(type === 0) {

				var dx = col - tile[0];
				var dy = row - tile[1];
				var distance = Math.sqrt(dx * dx + dy * dy);

				if(distance < shortestDistance) {
					shortestDistance = distance;
					closestWalkableTile = [col, row];
				}
			}
		}
	}

	return closestWalkableTile;
};


feng.controllers.view3d.PathfindingController.prototype.getTilePosition = function( tile, matrixData ) {

	var gridMinX = matrixData.gridMinX;
	var gridMinZ = matrixData.gridMinZ;
	var tileSize = matrixData.tileSize;

	var x = tile[0] * tileSize + tileSize/2 + gridMinX;
	var y = 0;
	var z = tile[1] * tileSize + tileSize/2 + gridMinZ;

	return new THREE.Vector3(x, y, z);
};


feng.controllers.view3d.PathfindingController.prototype.getClosestWalkablePosition = function( position, matrixData ) {

	var tile = this.getTileByPosition( position, matrixData );
	tile = this.getClosestWalkableTile( tile, matrixData );

	return this.getTilePosition( tile, matrixData );
};


feng.controllers.view3d.PathfindingController.prototype.findPath = function( matrixId, start, end ) {

	// get matrix
	var matrixData = this.getMatrixData( matrixId );
	var matrixResult = this.resolveMatrix( matrixData, start, end );

	var matrix = matrixResult.matrix;
	var gridMinX = matrixResult.gridMinX;
	var gridMinZ = matrixResult.gridMinZ;
	var gridWidth = matrixResult.gridWidth;
	var gridHeight = matrixResult.gridHeight;
	var numCols = matrixResult.numCols;
	var numRows = matrixResult.numRows;
	var tileSize = matrixResult.tileSize;
	var startTile = matrixResult.startTile;
	var endTile = matrixResult.endTile;

	// get closest tile to the end tile if it's non-walkable
	endTile = this.getClosestWalkableTile( endTile, matrixData );

	if(endTile) {
		console.log( 'found closest walkable tile: ', endTile );
	}else {
		console.log( 'could not find closest walkable tile around: ', endTile);
		return null;
	}

	if(goog.array.equals(startTile, endTile)) {
		console.log( 'start tile is the same as end tile: ', startTile);
		return null;
	}

	// find path
	var grid = new PF.Grid(numCols, numRows, matrix);

	var finder = new PF.AStarFinder({
		'allowDiagonal': true,
		'heuristic': PF.Heuristic.chebyshev
	});

	var path = finder.findPath(startTile[0], startTile[1], endTile[0], endTile[1], grid);

	// extract points from grid
	var coordinates = goog.array.map(path, function(coordinate) {
		var x = coordinate[0] * tileSize + tileSize/2 + gridMinX;
		var y = 0;
		var z = coordinate[1] * tileSize + tileSize/2 + gridMinZ;
		return new THREE.Vector3(x, y, z);
	});

	coordinates[0] = start.clone().setY( 0 );

	// draw debug view
	this.dispatchEvent({
		type: feng.events.EventType.UPDATE,
		matrix: matrix,
		gridWidth: gridWidth,
		gridHeight: gridHeight,
		numCols: numCols,
		numRows: numRows,
		tileSize: tileSize,
		path: path,
		sourceCanvas: this._renderer.domElement
	});

	if(coordinates.length < 2) {

		return null;

	}else {

		// return smoothened coordinates
		var spline = new THREE.SplineCurve3( coordinates );
		var numPoints = Math.max(3, Math.floor( spline.getLength() / 100 ));
		var coordinates = spline.getSpacedPoints( numPoints );

		return coordinates;
	}
};goog.provide('feng.views.debug.Pathfinding');

goog.require('feng.controllers.view3d.PathfindingController');
goog.require('feng.views.debug.DebugView');
goog.require('feng.templates.debug');


/**
 * @constructor
 */
feng.views.debug.Pathfinding = function(){

  goog.base(this, feng.templates.debug.PathfindingDebugView);

	this._canvasContainerDom = goog.dom.getElementByClass('canvasContainer', this.domElement);
	
  this._debugScale = 1;

  this._colors = {};

  this.setColors({
  	walkable: '#CCFF99',
  	blocked: '#FF6666',
  	stroke: 'rgba(0, 0, 0, 0.1)',
  	start: '#00FF00',
  	end: '#33CCFF',
  	path: 'rgba(255, 255, 0, 0.6)'
  });

	var pathfindingController = feng.controllers.view3d.PathfindingController.getInstance();
	goog.events.listen( pathfindingController, feng.events.EventType.UPDATE, this.onPathfindingUpdate, false, this);

  this.hide();
};
goog.inherits(feng.views.debug.Pathfinding, feng.views.debug.DebugView);


feng.views.debug.Pathfinding.prototype.setColors = function(colors) {
	
	goog.object.forEach(colors, function(color, name) {
		this._colors[name] = color;
	}, this);
};


feng.views.debug.Pathfinding.prototype.update = function(matrix, gridWidth, gridHeight, numCols, numRows, cellSize, path, sourceCanvas) {

	var canvasWidth = gridWidth * this._debugScale;
	var canvasHeight = gridHeight * this._debugScale;

	var canvas = goog.dom.createDom('canvas', {
		'width': canvasWidth,
		'height': canvasHeight
	});

	var context = canvas.getContext('2d');

	var row = 0;
	var col = 0;
	var canvasCellSize = cellSize * this._debugScale;
	for(row = 0; row < numRows; ++row) {
		for(col = 0; col < numCols; ++col) {
			var cellX = col * canvasCellSize;
			var cellY = row * canvasCellSize;
			var type = matrix[row][col];
			var color = (type === 0) ? this._colors.walkable : this._colors.blocked;
			context.beginPath();
			context.rect(cellX, cellY, canvasCellSize, canvasCellSize);
			context.fillStyle = color;
			context.fill();
			context.lineWidth = 1;
			context.strokeStyle = this._colors.stroke;
			context.stroke();
		}
	}

	// draw path
	var i, l = path.length;
	for(i = 0; i < l; ++i) {
		var cellX = path[i][0] * canvasCellSize;
		var cellY = path[i][1] * canvasCellSize;
		var color = this._colors.path;
		if(i === 0) {
			color = this._colors.start;
		}else if(i === l - 1) {
			color = this._colors.end;
		}
		context.beginPath();
    	context.rect(cellX, cellY, canvasCellSize, canvasCellSize);
    	context.fillStyle = color;
    	context.fill();
	}

	goog.dom.removeChildren( this._canvasContainerDom );
	goog.dom.appendChild(this._canvasContainerDom, canvas);
	goog.dom.appendChild(this._canvasContainerDom, sourceCanvas);
};


feng.views.debug.Pathfinding.prototype.onPathfindingUpdate = function(e) {
	
	this.update(e.matrix, e.gridWidth, e.gridHeight, e.numCols, e.numRows, e.tileSize, e.path, e.sourceCanvas);
};goog.provide('feng.views.debug.Debugger');

goog.require('goog.dom');
goog.require('goog.dom.query');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');
goog.require('feng.models.achievements.Achievements');
goog.require('feng.views.debug.Achievements');
goog.require('feng.views.debug.Camera');
goog.require('feng.views.debug.Manipulate');
goog.require('feng.views.debug.Pathfinding');
goog.require('feng.views.debug.PathTrack');


/**
 * @constructor
 */
feng.views.debug.Debugger = function(){
  goog.base(this);

  this.domElement = goog.dom.getElement('debugger');
  this._bodyDom = goog.dom.query('ul', this.domElement)[0];
	this._displayButton = goog.dom.query('.button.display', this.domElement)[0];

  this._eventHandler = new goog.events.EventHandler(this);
	this._eventHandler.listen(this._displayButton, 'click', this.onClick, false, this);

	// optionally create debug views
	if(feng.views.debug.Debugger.Options.CAMERA) {
		this.cameraView = new feng.views.debug.Camera();
	}
	if(feng.views.debug.Debugger.Options.MANIPULATE) {
		this.manipulateView = new feng.views.debug.Manipulate();
	}
	if(feng.views.debug.Debugger.Options.PATHFINDING) {
		this.pathfindingView = new feng.views.debug.Pathfinding();
	}
	if(feng.views.debug.Debugger.Options.PATH_TRACK) {
		this.pathTrackView = new feng.views.debug.PathTrack();
	}

	feng.pubsub.subscribeOnce( feng.PubSub.Topic.MAIN_LOAD_COMPLETE, this.init, this );

	//
	this.hide();
};
goog.inherits(feng.views.debug.Debugger, goog.events.EventTarget);
goog.addSingletonGetter(feng.views.debug.Debugger);


feng.views.debug.Debugger.prototype.init = function( globalAssets ) {
	
	var tipsData = globalAssets['fengshui-data']['tips'];

	if(feng.views.debug.Debugger.Options.ACHIEVEMENTS) {
		this.achievementsView = new feng.views.debug.Achievements( tipsData );
	}
};


feng.views.debug.Debugger.prototype.show = function() {
	
	goog.dom.classes.remove(this._displayButton, 'invisible');
	goog.style.showElement(this._bodyDom, true);
};


feng.views.debug.Debugger.prototype.hide = function() {

	goog.dom.classes.add(this._displayButton, 'invisible');
	goog.style.showElement(this._bodyDom, false);
};


feng.views.debug.Debugger.prototype.onClick = function(e) {
	switch(e.currentTarget) {
		case this._displayButton:
		if(!goog.dom.classes.has(this._displayButton, 'invisible')) {
			this.hide();
		}else {
			this.show();
		}
		break;

		default:
		break;
	}
};


feng.views.debug.Debugger.Options = {
	CAMERA: true,
	MANIPULATE: true,
	PATHFINDING: true,
	ACHIEVEMENTS: true,
	PATH_TRACK: false
};// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing rectangles.
 */

goog.provide('goog.math.Rect');

goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');



/**
 * Class for representing rectangular regions.
 * @param {number} x Left.
 * @param {number} y Top.
 * @param {number} w Width.
 * @param {number} h Height.
 * @constructor
 */
goog.math.Rect = function(x, y, w, h) {
  /** @type {number} */
  this.left = x;

  /** @type {number} */
  this.top = y;

  /** @type {number} */
  this.width = w;

  /** @type {number} */
  this.height = h;
};


/**
 * @return {!goog.math.Rect} A new copy of this Rectangle.
 */
goog.math.Rect.prototype.clone = function() {
  return new goog.math.Rect(this.left, this.top, this.width, this.height);
};


/**
 * Returns a new Box object with the same position and dimensions as this
 * rectangle.
 * @return {!goog.math.Box} A new Box representation of this Rectangle.
 */
goog.math.Rect.prototype.toBox = function() {
  var right = this.left + this.width;
  var bottom = this.top + this.height;
  return new goog.math.Box(this.top,
                           right,
                           bottom,
                           this.left);
};


/**
 * Creates a new Rect object with the same position and dimensions as a given
 * Box.  Note that this is only the inverse of toBox if left/top are defined.
 * @param {goog.math.Box} box A box.
 * @return {!goog.math.Rect} A new Rect initialized with the box's position
 *     and size.
 */
goog.math.Rect.createFromBox = function(box) {
  return new goog.math.Rect(box.left, box.top,
      box.right - box.left, box.bottom - box.top);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size and dimensions of rectangle.
   * @return {string} In the form (50, 73 - 75w x 25h).
   * @override
   */
  goog.math.Rect.prototype.toString = function() {
    return '(' + this.left + ', ' + this.top + ' - ' + this.width + 'w x ' +
           this.height + 'h)';
  };
}


/**
 * Compares rectangles for equality.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {boolean} True iff the rectangles have the same left, top, width,
 *     and height, or if both are null.
 */
goog.math.Rect.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.left == b.left && a.width == b.width &&
         a.top == b.top && a.height == b.height;
};


/**
 * Computes the intersection of this rectangle and the rectangle parameter.  If
 * there is no intersection, returns false and leaves this rectangle as is.
 * @param {goog.math.Rect} rect A Rectangle.
 * @return {boolean} True iff this rectangle intersects with the parameter.
 */
goog.math.Rect.prototype.intersection = function(rect) {
  var x0 = Math.max(this.left, rect.left);
  var x1 = Math.min(this.left + this.width, rect.left + rect.width);

  if (x0 <= x1) {
    var y0 = Math.max(this.top, rect.top);
    var y1 = Math.min(this.top + this.height, rect.top + rect.height);

    if (y0 <= y1) {
      this.left = x0;
      this.top = y0;
      this.width = x1 - x0;
      this.height = y1 - y0;

      return true;
    }
  }
  return false;
};


/**
 * Returns the intersection of two rectangles. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {goog.math.Rect} A new intersection rect (even if width and height
 *     are 0), or null if there is no intersection.
 */
goog.math.Rect.intersection = function(a, b) {
  // There is no nice way to do intersection via a clone, because any such
  // clone might be unnecessary if this function returns null.  So, we duplicate
  // code from above.

  var x0 = Math.max(a.left, b.left);
  var x1 = Math.min(a.left + a.width, b.left + b.width);

  if (x0 <= x1) {
    var y0 = Math.max(a.top, b.top);
    var y1 = Math.min(a.top + a.height, b.top + b.height);

    if (y0 <= y1) {
      return new goog.math.Rect(x0, y0, x1 - x0, y1 - y0);
    }
  }
  return null;
};


/**
 * Returns whether two rectangles intersect. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {boolean} Whether a and b intersect.
 */
goog.math.Rect.intersects = function(a, b) {
  return (a.left <= b.left + b.width && b.left <= a.left + a.width &&
      a.top <= b.top + b.height && b.top <= a.top + a.height);
};


/**
 * Returns whether a rectangle intersects this rectangle.
 * @param {goog.math.Rect} rect A rectangle.
 * @return {boolean} Whether rect intersects this rectangle.
 */
goog.math.Rect.prototype.intersects = function(rect) {
  return goog.math.Rect.intersects(this, rect);
};


/**
 * Computes the difference regions between two rectangles. The return value is
 * an array of 0 to 4 rectangles defining the remaining regions of the first
 * rectangle after the second has been subtracted.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {!Array.<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.difference = function(a, b) {
  var intersection = goog.math.Rect.intersection(a, b);
  if (!intersection || !intersection.height || !intersection.width) {
    return [a.clone()];
  }

  var result = [];

  var top = a.top;
  var height = a.height;

  var ar = a.left + a.width;
  var ab = a.top + a.height;

  var br = b.left + b.width;
  var bb = b.top + b.height;

  // Subtract off any area on top where A extends past B
  if (b.top > a.top) {
    result.push(new goog.math.Rect(a.left, a.top, a.width, b.top - a.top));
    top = b.top;
    // If we're moving the top down, we also need to subtract the height diff.
    height -= b.top - a.top;
  }
  // Subtract off any area on bottom where A extends past B
  if (bb < ab) {
    result.push(new goog.math.Rect(a.left, bb, a.width, ab - bb));
    height = bb - top;
  }
  // Subtract any area on left where A extends past B
  if (b.left > a.left) {
    result.push(new goog.math.Rect(a.left, top, b.left - a.left, height));
  }
  // Subtract any area on right where A extends past B
  if (br < ar) {
    result.push(new goog.math.Rect(br, top, ar - br, height));
  }

  return result;
};


/**
 * Computes the difference regions between this rectangle and {@code rect}. The
 * return value is an array of 0 to 4 rectangles defining the remaining regions
 * of this rectangle after the other has been subtracted.
 * @param {goog.math.Rect} rect A Rectangle.
 * @return {!Array.<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.prototype.difference = function(rect) {
  return goog.math.Rect.difference(this, rect);
};


/**
 * Expand this rectangle to also include the area of the given rectangle.
 * @param {goog.math.Rect} rect The other rectangle.
 */
goog.math.Rect.prototype.boundingRect = function(rect) {
  // We compute right and bottom before we change left and top below.
  var right = Math.max(this.left + this.width, rect.left + rect.width);
  var bottom = Math.max(this.top + this.height, rect.top + rect.height);

  this.left = Math.min(this.left, rect.left);
  this.top = Math.min(this.top, rect.top);

  this.width = right - this.left;
  this.height = bottom - this.top;
};


/**
 * Returns a new rectangle which completely contains both input rectangles.
 * @param {goog.math.Rect} a A rectangle.
 * @param {goog.math.Rect} b A rectangle.
 * @return {goog.math.Rect} A new bounding rect, or null if either rect is
 *     null.
 */
goog.math.Rect.boundingRect = function(a, b) {
  if (!a || !b) {
    return null;
  }

  var clone = a.clone();
  clone.boundingRect(b);

  return clone;
};


/**
 * Tests whether this rectangle entirely contains another rectangle or
 * coordinate.
 *
 * @param {goog.math.Rect|goog.math.Coordinate} another The rectangle or
 *     coordinate to test for containment.
 * @return {boolean} Whether this rectangle contains given rectangle or
 *     coordinate.
 */
goog.math.Rect.prototype.contains = function(another) {
  if (another instanceof goog.math.Rect) {
    return this.left <= another.left &&
           this.left + this.width >= another.left + another.width &&
           this.top <= another.top &&
           this.top + this.height >= another.top + another.height;
  } else { // (another instanceof goog.math.Coordinate)
    return another.x >= this.left &&
           another.x <= this.left + this.width &&
           another.y >= this.top &&
           another.y <= this.top + this.height;
  }
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The squared distance between the point and the closest
 *     point inside the rectangle. Returns 0 if the point is inside the
 *     rectangle.
 */
goog.math.Rect.prototype.squaredDistance = function(point) {
  var dx = point.x < this.left ?
      this.left - point.x : Math.max(point.x - (this.left + this.width), 0);
  var dy = point.y < this.top ?
      this.top - point.y : Math.max(point.y - (this.top + this.height), 0);
  return dx * dx + dy * dy;
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The distance between the point and the closest point
 *     inside the rectangle. Returns 0 if the point is inside the rectangle.
 */
goog.math.Rect.prototype.distance = function(point) {
  return Math.sqrt(this.squaredDistance(point));
};


/**
 * @return {!goog.math.Size} The size of this rectangle.
 */
goog.math.Rect.prototype.getSize = function() {
  return new goog.math.Size(this.width, this.height);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the top-left corner of
 *     the rectangle.
 */
goog.math.Rect.prototype.getTopLeft = function() {
  return new goog.math.Coordinate(this.left, this.top);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the center of the
 *     rectangle.
 */
goog.math.Rect.prototype.getCenter = function() {
  return new goog.math.Coordinate(
      this.left + this.width / 2, this.top + this.height / 2);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the bottom-right corner
 *     of the rectangle.
 */
goog.math.Rect.prototype.getBottomRight = function() {
  return new goog.math.Coordinate(
      this.left + this.width, this.top + this.height);
};


/**
 * Rounds the fields to the next larger integer values.
 * @return {!goog.math.Rect} This rectangle with ceil'd fields.
 */
goog.math.Rect.prototype.ceil = function() {
  this.left = Math.ceil(this.left);
  this.top = Math.ceil(this.top);
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 * @return {!goog.math.Rect} This rectangle with floored fields.
 */
goog.math.Rect.prototype.floor = function() {
  this.left = Math.floor(this.left);
  this.top = Math.floor(this.top);
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 * @return {!goog.math.Rect} This rectangle with rounded fields.
 */
goog.math.Rect.prototype.round = function() {
  this.left = Math.round(this.left);
  this.top = Math.round(this.top);
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Translates this rectangle by the given offsets. If a
 * {@code goog.math.Coordinate} is given, then the left and top values are
 * translated by the coordinate's x and y values. Otherwise, top and left are
 * translated by {@code tx} and {@code opt_ty} respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate left by or the
 *     the coordinate to translate this rect by.
 * @param {number=} opt_ty The value to translate top by.
 * @return {!goog.math.Rect} This rectangle after translating.
 */
goog.math.Rect.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.top += tx.y;
  } else {
    this.left += tx;
    if (goog.isNumber(opt_ty)) {
      this.top += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this rectangle by the given scale factors. The left and width values
 * are scaled by {@code sx} and the top and height values are scaled by
 * {@code opt_sy}.  If {@code opt_sy} is not given, then all fields are scaled
 * by {@code sx}.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Rect} This rectangle after scaling.
 */
goog.math.Rect.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.left *= sx;
  this.width *= sx;
  this.top *= sy;
  this.height *= sy;
  return this;
};
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Vendor prefix getters.
 */

goog.provide('goog.dom.vendor');

goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Returns the JS vendor prefix used in CSS properties. Different vendors
 * use different methods of changing the case of the property names.
 *
 * @return {?string} The JS vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorJsPrefix = function() {
  if (goog.userAgent.WEBKIT) {
    return 'Webkit';
  } else if (goog.userAgent.GECKO) {
    return 'Moz';
  } else if (goog.userAgent.IE) {
    return 'ms';
  } else if (goog.userAgent.OPERA) {
    return 'O';
  }

  return null;
};


/**
 * Returns the vendor prefix used in CSS properties.
 *
 * @return {?string} The vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorPrefix = function() {
  if (goog.userAgent.WEBKIT) {
    return '-webkit';
  } else if (goog.userAgent.GECKO) {
    return '-moz';
  } else if (goog.userAgent.IE) {
    return '-ms';
  } else if (goog.userAgent.OPERA) {
    return '-o';
  }

  return null;
};


/**
 * @param {string} propertyName A property name.
 * @param {!Object=} opt_object If provided, we verify if the property exists in
 *     the object.
 * @return {?string} A vendor prefixed property name, or null if it does not
 *     exist.
 */
goog.dom.vendor.getPrefixedPropertyName = function(propertyName, opt_object) {
  // We first check for a non-prefixed property, if available.
  if (opt_object && propertyName in opt_object) {
    return propertyName;
  }
  var prefix = goog.dom.vendor.getVendorJsPrefix();
  if (prefix) {
    prefix = prefix.toLowerCase();
    var prefixedPropertyName = prefix + goog.string.toTitleCase(propertyName);
    return (!goog.isDef(opt_object) || prefixedPropertyName in opt_object) ?
        prefixedPropertyName : null;
  }
  return null;
};


/**
 * @param {string} eventType An event type.
 * @return {string} A lower-cased vendor prefixed event type.
 */
goog.dom.vendor.getPrefixedEventType = function(eventType) {
  var prefix = goog.dom.vendor.getVendorJsPrefix() || '';
  return (prefix + eventType).toLowerCase();
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for element styles.
 *
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 * @see ../demos/style_viewport.html
 */

goog.provide('goog.style');


goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.vendor');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that
 *     getBoundingClientRect() is present and bug-free on the browser.
 */
goog.define('goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS', false);


/**
 * Sets a style value on an element.
 *
 * This function is not indended to patch issues in the browser's style
 * handling, but to allow easy programmatic access to setting dash-separated
 * style properties.  An example is setting a batch of properties from a data
 * object without overwriting old styles.  When possible, use native APIs:
 * elem.style.propertyKey = 'value' or (if obliterating old styles is fine)
 * elem.style.cssText = 'property1: value1; property2: value2'.
 *
 * @param {Element} element The element to change.
 * @param {string|Object} style If a string, a style name. If an object, a hash
 *     of style names to style values.
 * @param {string|number|boolean=} opt_value If style was a string, then this
 *     should be the value.
 */
goog.style.setStyle = function(element, style, opt_value) {
  if (goog.isString(style)) {
    goog.style.setStyle_(element, opt_value, style);
  } else {
    goog.object.forEach(style, goog.partial(goog.style.setStyle_, element));
  }
};


/**
 * Sets a style value on an element, with parameters swapped to work with
 * {@code goog.object.forEach()}. Prepends a vendor-specific prefix when
 * necessary.
 * @param {Element} element The element to change.
 * @param {string|number|boolean|undefined} value Style value.
 * @param {string} style Style name.
 * @private
 */
goog.style.setStyle_ = function(element, value, style) {
  var propertyName = goog.style.getVendorJsStyleName_(element, style);

  if (propertyName) {
    element.style[propertyName] = value;
  }
};


/**
 * Returns the style property name in camel-case. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorJsStyleName_ = function(element, style) {
  var camelStyle = goog.string.toCamelCase(style);

  if (element.style[camelStyle] === undefined) {
    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
        goog.string.toTitleCase(style);

    if (element.style[prefixedStyle] !== undefined) {
      return prefixedStyle;
    }
  }

  return camelStyle;
};


/**
 * Returns the style property name in CSS notation. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorStyleName_ = function(element, style) {
  var camelStyle = goog.string.toCamelCase(style);

  if (element.style[camelStyle] === undefined) {
    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
        goog.string.toTitleCase(style);

    if (element.style[prefixedStyle] !== undefined) {
      return goog.dom.vendor.getVendorPrefix() + '-' + style;
    }
  }

  return style;
};


/**
 * Retrieves an explicitly-set style value of a node. This returns '' if there
 * isn't a style attribute on the element or if this style property has not been
 * explicitly set in script.
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get, css-style (if you have a camel-case
 * property, use element.style[style]).
 * @return {string} Style value.
 */
goog.style.getStyle = function(element, property) {
  // element.style is '' for well-known properties which are unset.
  // For for browser specific styles as 'filter' is undefined
  // so we need to return '' explicitly to make it consistent across
  // browsers.
  var styleValue = element.style[goog.string.toCamelCase(property)];

  // Using typeof here because of a bug in Safari 5.1, where this value
  // was undefined, but === undefined returned false.
  if (typeof(styleValue) !== 'undefined') {
    return styleValue;
  }

  return element.style[goog.style.getVendorJsStyleName_(element, property)] ||
      '';
};


/**
 * Retrieves a computed style value of a node. It returns empty string if the
 * value cannot be computed (which will be the case in Internet Explorer) or
 * "none" if the property requested is an SVG one and it has not been
 * explicitly set (firefox and webkit).
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getComputedStyle = function(element, property) {
  var doc = goog.dom.getOwnerDocument(element);
  if (doc.defaultView && doc.defaultView.getComputedStyle) {
    var styles = doc.defaultView.getComputedStyle(element, null);
    if (styles) {
      // element.style[..] is undefined for browser specific styles
      // as 'filter'.
      return styles[property] || styles.getPropertyValue(property) || '';
    }
  }

  return '';
};


/**
 * Gets the cascaded style value of a node, or null if the value cannot be
 * computed (only Internet Explorer can do this).
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getCascadedStyle = function(element, style) {
  // TODO(nicksantos): This should be documented to return null. #fixTypes
  return element.currentStyle ? element.currentStyle[style] : null;
};


/**
 * Cross-browser pseudo get computed style. It returns the computed style where
 * available. If not available it tries the cascaded style value (IE
 * currentStyle) and in worst case the inline style value.  It shouldn't be
 * called directly, see http://wiki/Main/ComputedStyleVsCascadedStyle for
 * discussion.
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (must be camelCase, not css-style.).
 * @return {string} Style value.
 * @private
 */
goog.style.getStyle_ = function(element, style) {
  return goog.style.getComputedStyle(element, style) ||
         goog.style.getCascadedStyle(element, style) ||
         (element.style && element.style[style]);
};


/**
 * Retrieves the computed value of the box-sizing CSS attribute.
 * Browser support: http://caniuse.com/css3-boxsizing.
 * @param {!Element} element The element whose box-sizing to get.
 * @return {?string} 'content-box', 'border-box' or 'padding-box'. null if
 *     box-sizing is not supported (IE7 and below).
 */
goog.style.getComputedBoxSizing = function(element) {
  return goog.style.getStyle_(element, 'boxSizing') ||
      goog.style.getStyle_(element, 'MozBoxSizing') ||
      goog.style.getStyle_(element, 'WebkitBoxSizing') || null;
};


/**
 * Retrieves the computed value of the position CSS attribute.
 * @param {Element} element The element to get the position of.
 * @return {string} Position value.
 */
goog.style.getComputedPosition = function(element) {
  return goog.style.getStyle_(element, 'position');
};


/**
 * Retrieves the computed background color string for a given element. The
 * string returned is suitable for assigning to another element's
 * background-color, but is not guaranteed to be in any particular string
 * format. Accessing the color in a numeric form may not be possible in all
 * browsers or with all input.
 *
 * If the background color for the element is defined as a hexadecimal value,
 * the resulting string can be parsed by goog.color.parse in all supported
 * browsers.
 *
 * Whether named colors like "red" or "lightblue" get translated into a
 * format which can be parsed is browser dependent. Calling this function on
 * transparent elements will return "transparent" in most browsers or
 * "rgba(0, 0, 0, 0)" in WebKit.
 * @param {Element} element The element to get the background color of.
 * @return {string} The computed string value of the background color.
 */
goog.style.getBackgroundColor = function(element) {
  return goog.style.getStyle_(element, 'backgroundColor');
};


/**
 * Retrieves the computed value of the overflow-x CSS attribute.
 * @param {Element} element The element to get the overflow-x of.
 * @return {string} The computed string value of the overflow-x attribute.
 */
goog.style.getComputedOverflowX = function(element) {
  return goog.style.getStyle_(element, 'overflowX');
};


/**
 * Retrieves the computed value of the overflow-y CSS attribute.
 * @param {Element} element The element to get the overflow-y of.
 * @return {string} The computed string value of the overflow-y attribute.
 */
goog.style.getComputedOverflowY = function(element) {
  return goog.style.getStyle_(element, 'overflowY');
};


/**
 * Retrieves the computed value of the z-index CSS attribute.
 * @param {Element} element The element to get the z-index of.
 * @return {string|number} The computed value of the z-index attribute.
 */
goog.style.getComputedZIndex = function(element) {
  return goog.style.getStyle_(element, 'zIndex');
};


/**
 * Retrieves the computed value of the text-align CSS attribute.
 * @param {Element} element The element to get the text-align of.
 * @return {string} The computed string value of the text-align attribute.
 */
goog.style.getComputedTextAlign = function(element) {
  return goog.style.getStyle_(element, 'textAlign');
};


/**
 * Retrieves the computed value of the cursor CSS attribute.
 * @param {Element} element The element to get the cursor of.
 * @return {string} The computed string value of the cursor attribute.
 */
goog.style.getComputedCursor = function(element) {
  return goog.style.getStyle_(element, 'cursor');
};


/**
 * Sets the top/left values of an element.  If no unit is specified in the
 * argument then it will add px. The second argument is required if the first
 * argument is a string or number and is ignored if the first argument
 * is a coordinate.
 * @param {Element} el Element to move.
 * @param {string|number|goog.math.Coordinate} arg1 Left position or coordinate.
 * @param {string|number=} opt_arg2 Top position.
 */
goog.style.setPosition = function(el, arg1, opt_arg2) {
  var x, y;
  var buggyGeckoSubPixelPos = goog.userAgent.GECKO &&
      (goog.userAgent.MAC || goog.userAgent.X11) &&
      goog.userAgent.isVersionOrHigher('1.9');

  if (arg1 instanceof goog.math.Coordinate) {
    x = arg1.x;
    y = arg1.y;
  } else {
    x = arg1;
    y = opt_arg2;
  }

  // Round to the nearest pixel for buggy sub-pixel support.
  el.style.left = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (x), buggyGeckoSubPixelPos);
  el.style.top = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (y), buggyGeckoSubPixelPos);
};


/**
 * Gets the offsetLeft and offsetTop properties of an element and returns them
 * in a Coordinate object
 * @param {Element} element Element.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getPosition = function(element) {
  return new goog.math.Coordinate(element.offsetLeft, element.offsetTop);
};


/**
 * Returns the viewport element for a particular document
 * @param {Node=} opt_node DOM node (Document is OK) to get the viewport element
 *     of.
 * @return {Element} document.documentElement or document.body.
 */
goog.style.getClientViewportElement = function(opt_node) {
  var doc;
  if (opt_node) {
    doc = goog.dom.getOwnerDocument(opt_node);
  } else {
    doc = goog.dom.getDocument();
  }

  // In old IE versions the document.body represented the viewport
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
      !goog.dom.getDomHelper(doc).isCss1CompatMode()) {
    return doc.body;
  }
  return doc.documentElement;
};


/**
 * Calculates the viewport coordinates relative to the page/document
 * containing the node. The viewport may be the browser viewport for
 * non-iframe document, or the iframe container for iframe'd document.
 * @param {!Document} doc The document to use as the reference point.
 * @return {!goog.math.Coordinate} The page offset of the viewport.
 */
goog.style.getViewportPageOffset = function(doc) {
  var body = doc.body;
  var documentElement = doc.documentElement;
  var scrollLeft = body.scrollLeft || documentElement.scrollLeft;
  var scrollTop = body.scrollTop || documentElement.scrollTop;
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Gets the client rectangle of the DOM element.
 *
 * getBoundingClientRect is part of a new CSS object model draft (with a
 * long-time presence in IE), replacing the error-prone parent offset
 * computation and the now-deprecated Gecko getBoxObjectFor.
 *
 * This utility patches common browser bugs in getBoundingClientRect. It
 * will fail if getBoundingClientRect is unsupported.
 *
 * If the element is not in the DOM, the result is undefined, and an error may
 * be thrown depending on user agent.
 *
 * @param {!Element} el The element whose bounding rectangle is being queried.
 * @return {Object} A native bounding rectangle with numerical left, top,
 *     right, and bottom.  Reported by Firefox to be of object type ClientRect.
 * @private
 */
goog.style.getBoundingClientRect_ = function(el) {
  var rect;
  try {
    rect = el.getBoundingClientRect();
  } catch (e) {
    // In IE < 9, calling getBoundingClientRect on an orphan element raises an
    // "Unspecified Error". All other browsers return zeros.
    return {'left': 0, 'top': 0, 'right': 0, 'bottom': 0};
  }

  // Patch the result in IE only, so that this function can be inlined if
  // compiled for non-IE.
  if (goog.userAgent.IE && el.ownerDocument.body) {

    // In IE, most of the time, 2 extra pixels are added to the top and left
    // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
    // IE6 standards mode, this border can be overridden by setting the
    // document element's border to zero -- thus, we cannot rely on the
    // offset always being 2 pixels.

    // In quirks mode, the offset can be determined by querying the body's
    // clientLeft/clientTop, but in standards mode, it is found by querying
    // the document element's clientLeft/clientTop.  Since we already called
    // getBoundingClientRect we have already forced a reflow, so it is not
    // too expensive just to query them all.

    // See: http://msdn.microsoft.com/en-us/library/ms536433(VS.85).aspx
    var doc = el.ownerDocument;
    rect.left -= doc.documentElement.clientLeft + doc.body.clientLeft;
    rect.top -= doc.documentElement.clientTop + doc.body.clientTop;
  }
  return /** @type {Object} */ (rect);
};


/**
 * Returns the first parent that could affect the position of a given element.
 * @param {Element} element The element to get the offset parent for.
 * @return {Element} The first offset parent or null if one cannot be found.
 */
goog.style.getOffsetParent = function(element) {
  // element.offsetParent does the right thing in IE7 and below.  In other
  // browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8)) {
    return element.offsetParent;
  }

  var doc = goog.dom.getOwnerDocument(element);
  var positionStyle = goog.style.getStyle_(element, 'position');
  var skipStatic = positionStyle == 'fixed' || positionStyle == 'absolute';
  for (var parent = element.parentNode; parent && parent != doc;
       parent = parent.parentNode) {
    positionStyle =
        goog.style.getStyle_(/** @type {!Element} */ (parent), 'position');
    skipStatic = skipStatic && positionStyle == 'static' &&
                 parent != doc.documentElement && parent != doc.body;
    if (!skipStatic && (parent.scrollWidth > parent.clientWidth ||
                        parent.scrollHeight > parent.clientHeight ||
                        positionStyle == 'fixed' ||
                        positionStyle == 'absolute' ||
                        positionStyle == 'relative')) {
      return /** @type {!Element} */ (parent);
    }
  }
  return null;
};


/**
 * Calculates and returns the visible rectangle for a given element. Returns a
 * box describing the visible portion of the nearest scrollable offset ancestor.
 * Coordinates are given relative to the document.
 *
 * @param {Element} element Element to get the visible rect for.
 * @return {goog.math.Box} Bounding elementBox describing the visible rect or
 *     null if scrollable ancestor isn't inside the visible viewport.
 */
goog.style.getVisibleRectForElement = function(element) {
  var visibleRect = new goog.math.Box(0, Infinity, Infinity, 0);
  var dom = goog.dom.getDomHelper(element);
  var body = dom.getDocument().body;
  var documentElement = dom.getDocument().documentElement;
  var scrollEl = dom.getDocumentScrollElement();

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  for (var el = element; el = goog.style.getOffsetParent(el); ) {
    // clientWidth is zero for inline block elements in IE.
    // on WEBKIT, body element can have clientHeight = 0 and scrollHeight > 0
    if ((!goog.userAgent.IE || el.clientWidth != 0) &&
        (!goog.userAgent.WEBKIT || el.clientHeight != 0 || el != body) &&
        // body may have overflow set on it, yet we still get the entire
        // viewport. In some browsers, el.offsetParent may be
        // document.documentElement, so check for that too.
        (el != body && el != documentElement &&
            goog.style.getStyle_(el, 'overflow') != 'visible')) {
      var pos = goog.style.getPageOffset(el);
      var client = goog.style.getClientLeftTop(el);
      pos.x += client.x;
      pos.y += client.y;

      visibleRect.top = Math.max(visibleRect.top, pos.y);
      visibleRect.right = Math.min(visibleRect.right,
                                   pos.x + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom,
                                    pos.y + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.x);
    }
  }

  // Clip by window's viewport.
  var scrollX = scrollEl.scrollLeft, scrollY = scrollEl.scrollTop;
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  var winSize = dom.getViewportSize();
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 &&
         visibleRect.bottom > visibleRect.top &&
         visibleRect.right > visibleRect.left ?
         visibleRect : null;
};


/**
 * Calculate the scroll position of {@code container} with the minimum amount so
 * that the content and the borders of the given {@code element} become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element} container The container to scroll.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 * @return {!goog.math.Coordinate} The new scroll position of the container,
 *     in form of goog.math.Coordinate(scrollLeft, scrollTop).
 */
goog.style.getContainerOffsetToScrollInto =
    function(element, container, opt_center) {
  // Absolute position of the element's border's top left corner.
  var elementPos = goog.style.getPageOffset(element);
  // Absolute position of the container's border's top left corner.
  var containerPos = goog.style.getPageOffset(container);
  var containerBorder = goog.style.getBorderBox(container);
  // Relative pos. of the element's border box to the container's content box.
  var relX = elementPos.x - containerPos.x - containerBorder.left;
  var relY = elementPos.y - containerPos.y - containerBorder.top;
  // How much the element can move in the container, i.e. the difference between
  // the element's bottom-right-most and top-left-most position where it's
  // fully visible.
  var spaceX = container.clientWidth - element.offsetWidth;
  var spaceY = container.clientHeight - element.offsetHeight;

  var scrollLeft = container.scrollLeft;
  var scrollTop = container.scrollTop;
  if (opt_center) {
    // All browsers round non-integer scroll positions down.
    scrollLeft += relX - spaceX / 2;
    scrollTop += relY - spaceY / 2;
  } else {
    // This formula was designed to give the correct scroll values in the
    // following cases:
    // - element is higher than container (spaceY < 0) => scroll down by relY
    // - element is not higher that container (spaceY >= 0):
    //   - it is above container (relY < 0) => scroll up by abs(relY)
    //   - it is below container (relY > spaceY) => scroll down by relY - spaceY
    //   - it is in the container => don't scroll
    scrollLeft += Math.min(relX, Math.max(relX - spaceX, 0));
    scrollTop += Math.min(relY, Math.max(relY - spaceY, 0));
  }
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Changes the scroll position of {@code container} with the minimum amount so
 * that the content and the borders of the given {@code element} become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element} container The container to scroll.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 */
goog.style.scrollIntoContainerView = function(element, container, opt_center) {
  var offset =
      goog.style.getContainerOffsetToScrollInto(element, container, opt_center);
  container.scrollLeft = offset.x;
  container.scrollTop = offset.y;
};


/**
 * Returns clientLeft (width of the left border and, if the directionality is
 * right to left, the vertical scrollbar) and clientTop as a coordinate object.
 *
 * @param {Element} el Element to get clientLeft for.
 * @return {!goog.math.Coordinate} Client left and top.
 */
goog.style.getClientLeftTop = function(el) {
  // NOTE(eae): Gecko prior to 1.9 doesn't support clientTop/Left, see
  // https://bugzilla.mozilla.org/show_bug.cgi?id=111207
  if (goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('1.9')) {
    var left = parseFloat(goog.style.getComputedStyle(el, 'borderLeftWidth'));
    if (goog.style.isRightToLeft(el)) {
      var scrollbarWidth = el.offsetWidth - el.clientWidth - left -
          parseFloat(goog.style.getComputedStyle(el, 'borderRightWidth'));
      left += scrollbarWidth;
    }
    return new goog.math.Coordinate(left,
        parseFloat(goog.style.getComputedStyle(el, 'borderTopWidth')));
  }

  return new goog.math.Coordinate(el.clientLeft, el.clientTop);
};


/**
 * Returns a Coordinate object relative to the top-left of the HTML document.
 * Implemented as a single function to save having to do two recursive loops in
 * opera and safari just to get both coordinates.  If you just want one value do
 * use goog.style.getPageOffsetLeft() and goog.style.getPageOffsetTop(), but
 * note if you call both those methods the tree will be analysed twice.
 *
 * @param {Element} el Element to get the page offset for.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getPageOffset = function(el) {
  var box, doc = goog.dom.getOwnerDocument(el);
  var positionStyle = goog.style.getStyle_(el, 'position');
  // TODO(gboyer): Update the jsdoc in a way that doesn't break the universe.
  goog.asserts.assertObject(el, 'Parameter is required');

  // NOTE(eae): Gecko pre 1.9 normally use getBoxObjectFor to calculate the
  // position. When invoked for an element with position absolute and a negative
  // position though it can be off by one. Therefor the recursive implementation
  // is used in those (relatively rare) cases.
  var BUGGY_GECKO_BOX_OBJECT =
      !goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS &&
      goog.userAgent.GECKO && doc.getBoxObjectFor &&
      !el.getBoundingClientRect && positionStyle == 'absolute' &&
      (box = doc.getBoxObjectFor(el)) && (box.screenX < 0 || box.screenY < 0);

  // NOTE(arv): If element is hidden (display none or disconnected or any the
  // ancestors are hidden) we get (0,0) by default but we still do the
  // accumulation of scroll position.

  // TODO(arv): Should we check if the node is disconnected and in that case
  //            return (0,0)?

  var pos = new goog.math.Coordinate(0, 0);
  var viewportElement = goog.style.getClientViewportElement(doc);
  if (el == viewportElement) {
    // viewport is always at 0,0 as that defined the coordinate system for this
    // function - this avoids special case checks in the code below
    return pos;
  }

  // IE, Gecko 1.9+, and most modern WebKit.
  if (goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS ||
      el.getBoundingClientRect) {
    box = goog.style.getBoundingClientRect_(el);
    // Must add the scroll coordinates in to get the absolute page offset
    // of element since getBoundingClientRect returns relative coordinates to
    // the viewport.
    var scrollCoord = goog.dom.getDomHelper(doc).getDocumentScroll();
    pos.x = box.left + scrollCoord.x;
    pos.y = box.top + scrollCoord.y;

  // Gecko prior to 1.9.
  } else if (doc.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) {
    // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
    // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

    box = doc.getBoxObjectFor(el);
    // TODO(user): Fix the off-by-one error when window is scrolled down
    // or right more than 1 pixel. The viewport offset does not move in lock
    // step with the window scroll; it moves in increments of 2px and at
    // somewhat random intervals.
    var vpBox = doc.getBoxObjectFor(viewportElement);
    pos.x = box.screenX - vpBox.screenX;
    pos.y = box.screenY - vpBox.screenY;

  // Safari, Opera and Camino up to 1.0.4.
  } else {
    var parent = el;
    do {
      pos.x += parent.offsetLeft;
      pos.y += parent.offsetTop;
      // For safari/chrome, we need to add parent's clientLeft/Top as well.
      if (parent != el) {
        pos.x += parent.clientLeft || 0;
        pos.y += parent.clientTop || 0;
      }
      // In Safari when hit a position fixed element the rest of the offsets
      // are not correct.
      if (goog.userAgent.WEBKIT &&
          goog.style.getComputedPosition(parent) == 'fixed') {
        pos.x += doc.body.scrollLeft;
        pos.y += doc.body.scrollTop;
        break;
      }
      parent = parent.offsetParent;
    } while (parent && parent != el);

    // Opera & (safari absolute) incorrectly account for body offsetTop.
    if (goog.userAgent.OPERA || (goog.userAgent.WEBKIT &&
        positionStyle == 'absolute')) {
      pos.y -= doc.body.offsetTop;
    }

    for (parent = el; (parent = goog.style.getOffsetParent(parent)) &&
        parent != doc.body && parent != viewportElement; ) {
      pos.x -= parent.scrollLeft;
      // Workaround for a bug in Opera 9.2 (and earlier) where table rows may
      // report an invalid scroll top value. The bug was fixed in Opera 9.5
      // however as that version supports getBoundingClientRect it won't
      // trigger this code path. https://bugs.opera.com/show_bug.cgi?id=249965
      if (!goog.userAgent.OPERA || parent.tagName != 'TR') {
        pos.y -= parent.scrollTop;
      }
    }
  }

  return pos;
};


/**
 * Returns the left coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The left coordinate.
 */
goog.style.getPageOffsetLeft = function(el) {
  return goog.style.getPageOffset(el).x;
};


/**
 * Returns the top coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The top coordinate.
 */
goog.style.getPageOffsetTop = function(el) {
  return goog.style.getPageOffset(el).y;
};


/**
 * Returns a Coordinate object relative to the top-left of an HTML document
 * in an ancestor frame of this element. Used for measuring the position of
 * an element inside a frame relative to a containing frame.
 *
 * @param {Element} el Element to get the page offset for.
 * @param {Window} relativeWin The window to measure relative to. If relativeWin
 *     is not in the ancestor frame chain of the element, we measure relative to
 *     the top-most window.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getFramedPageOffset = function(el, relativeWin) {
  var position = new goog.math.Coordinate(0, 0);

  // Iterate up the ancestor frame chain, keeping track of the current window
  // and the current element in that window.
  var currentWin = goog.dom.getWindow(goog.dom.getOwnerDocument(el));
  var currentEl = el;
  do {
    // if we're at the top window, we want to get the page offset.
    // if we're at an inner frame, we only want to get the window position
    // so that we can determine the actual page offset in the context of
    // the outer window.
    var offset = currentWin == relativeWin ?
        goog.style.getPageOffset(currentEl) :
        goog.style.getClientPositionForElement_(
            goog.asserts.assert(currentEl));

    position.x += offset.x;
    position.y += offset.y;
  } while (currentWin && currentWin != relativeWin &&
      (currentEl = currentWin.frameElement) &&
      (currentWin = currentWin.parent));

  return position;
};


/**
 * Translates the specified rect relative to origBase page, for newBase page.
 * If origBase and newBase are the same, this function does nothing.
 *
 * @param {goog.math.Rect} rect The source rectangle relative to origBase page,
 *     and it will have the translated result.
 * @param {goog.dom.DomHelper} origBase The DomHelper for the input rectangle.
 * @param {goog.dom.DomHelper} newBase The DomHelper for the resultant
 *     coordinate.  This must be a DOM for an ancestor frame of origBase
 *     or the same as origBase.
 */
goog.style.translateRectForAnotherFrame = function(rect, origBase, newBase) {
  if (origBase.getDocument() != newBase.getDocument()) {
    var body = origBase.getDocument().body;
    var pos = goog.style.getFramedPageOffset(body, newBase.getWindow());

    // Adjust Body's margin.
    pos = goog.math.Coordinate.difference(pos, goog.style.getPageOffset(body));

    if (goog.userAgent.IE && !origBase.isCss1CompatMode()) {
      pos = goog.math.Coordinate.difference(pos, origBase.getDocumentScroll());
    }

    rect.left += pos.x;
    rect.top += pos.y;
  }
};


/**
 * Returns the position of an element relative to another element in the
 * document.  A relative to B
 * @param {Element|Event|goog.events.Event} a Element or mouse event whose
 *     position we're calculating.
 * @param {Element|Event|goog.events.Event} b Element or mouse event position
 *     is relative to.
 * @return {!goog.math.Coordinate} The relative position.
 */
goog.style.getRelativePosition = function(a, b) {
  var ap = goog.style.getClientPosition(a);
  var bp = goog.style.getClientPosition(b);
  return new goog.math.Coordinate(ap.x - bp.x, ap.y - bp.y);
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport.
 * @param {!Element} el Element whose position to get.
 * @return {!goog.math.Coordinate} The position.
 * @private
 */
goog.style.getClientPositionForElement_ = function(el) {
  var pos;
  if (goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS ||
      el.getBoundingClientRect) {
    // IE, Gecko 1.9+, and most modern WebKit
    var box = goog.style.getBoundingClientRect_(el);
    pos = new goog.math.Coordinate(box.left, box.top);
  } else {
    var scrollCoord = goog.dom.getDomHelper(el).getDocumentScroll();
    var pageCoord = goog.style.getPageOffset(el);
    pos = new goog.math.Coordinate(
        pageCoord.x - scrollCoord.x,
        pageCoord.y - scrollCoord.y);
  }

  // Gecko below version 12 doesn't add CSS translation to the client position
  // (using either getBoundingClientRect or getBoxOffsetFor) so we need to do
  // so manually.
  if (goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher(12)) {
    return goog.math.Coordinate.sum(pos, goog.style.getCssTranslation(el));
  } else {
    return pos;
  }
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport.
 * @param {Element|Event|goog.events.Event} el Element or a mouse / touch event.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getClientPosition = function(el) {
  goog.asserts.assert(el);
  if (el.nodeType == goog.dom.NodeType.ELEMENT) {
    return goog.style.getClientPositionForElement_(
        /** @type {!Element} */ (el));
  } else {
    var isAbstractedEvent = goog.isFunction(el.getBrowserEvent);
    var be = /** @type {!goog.events.BrowserEvent} */ (el);
    var targetEvent = el;

    if (el.targetTouches) {
      targetEvent = el.targetTouches[0];
    } else if (isAbstractedEvent && be.getBrowserEvent().targetTouches) {
      targetEvent = be.getBrowserEvent().targetTouches[0];
    }

    return new goog.math.Coordinate(
        targetEvent.clientX,
        targetEvent.clientY);
  }
};


/**
 * Moves an element to the given coordinates relative to the client viewport.
 * @param {Element} el Absolutely positioned element to set page offset for.
 *     It must be in the document.
 * @param {number|goog.math.Coordinate} x Left position of the element's margin
 *     box or a coordinate object.
 * @param {number=} opt_y Top position of the element's margin box.
 */
goog.style.setPageOffset = function(el, x, opt_y) {
  // Get current pageoffset
  var cur = goog.style.getPageOffset(el);

  if (x instanceof goog.math.Coordinate) {
    opt_y = x.y;
    x = x.x;
  }

  // NOTE(arv): We cannot allow strings for x and y. We could but that would
  // require us to manually transform between different units

  // Work out deltas
  var dx = x - cur.x;
  var dy = opt_y - cur.y;

  // Set position to current left/top + delta
  goog.style.setPosition(el, el.offsetLeft + dx, el.offsetTop + dy);
};


/**
 * Sets the width/height values of an element.  If an argument is numeric,
 * or a goog.math.Size is passed, it is assumed to be pixels and will add
 * 'px' after converting it to an integer in string form. (This just sets the
 * CSS width and height properties so it might set content-box or border-box
 * size depending on the box model the browser is using.)
 *
 * @param {Element} element Element to set the size of.
 * @param {string|number|goog.math.Size} w Width of the element, or a
 *     size object.
 * @param {string|number=} opt_h Height of the element. Required if w is not a
 *     size object.
 */
goog.style.setSize = function(element, w, opt_h) {
  var h;
  if (w instanceof goog.math.Size) {
    h = w.height;
    w = w.width;
  } else {
    if (opt_h == undefined) {
      throw Error('missing height argument');
    }
    h = opt_h;
  }

  goog.style.setWidth(element, /** @type {string|number} */ (w));
  goog.style.setHeight(element, /** @type {string|number} */ (h));
};


/**
 * Helper function to create a string to be set into a pixel-value style
 * property of an element. Can round to the nearest integer value.
 *
 * @param {string|number} value The style value to be used. If a number,
 *     'px' will be appended, otherwise the value will be applied directly.
 * @param {boolean} round Whether to round the nearest integer (if property
 *     is a number).
 * @return {string} The string value for the property.
 * @private
 */
goog.style.getPixelStyleValue_ = function(value, round) {
  if (typeof value == 'number') {
    value = (round ? Math.round(value) : value) + 'px';
  }

  return value;
};


/**
 * Set the height of an element.  Sets the element's style property.
 * @param {Element} element Element to set the height of.
 * @param {string|number} height The height value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setHeight = function(element, height) {
  element.style.height = goog.style.getPixelStyleValue_(height, true);
};


/**
 * Set the width of an element.  Sets the element's style property.
 * @param {Element} element Element to set the width of.
 * @param {string|number} width The width value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setWidth = function(element, width) {
  element.style.width = goog.style.getPixelStyleValue_(width, true);
};


/**
 * Gets the height and width of an element, even if its display is none.
 *
 * Specifically, this returns the height and width of the border box,
 * irrespective of the box model in effect.
 *
 * Note that this function does not take CSS transforms into account. Please see
 * {@code goog.style.getTransformedSize}.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 */
goog.style.getSize = function(element) {
  return goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getSizeWithDisplay_, /** @type {!Element} */ (element));
};


/**
 * Call {@code fn} on {@code element} such that {@code element}'s dimensions are
 * accurate when it's passed to {@code fn}.
 * @param {function(!Element): T} fn Function to call with {@code element} as
 *     an argument after temporarily changing {@code element}'s display such
 *     that its dimensions are accurate.
 * @param {!Element} element Element (which may have display none) to use as
 *     argument to {@code fn}.
 * @return {T} Value returned by calling {@code fn} with {@code element}.
 * @template T
 * @private
 */
goog.style.evaluateWithTemporaryDisplay_ = function(fn, element) {
  if (goog.style.getStyle_(element, 'display') != 'none') {
    return fn(element);
  }

  var style = element.style;
  var originalDisplay = style.display;
  var originalVisibility = style.visibility;
  var originalPosition = style.position;

  style.visibility = 'hidden';
  style.position = 'absolute';
  style.display = 'inline';

  var retVal = fn(element);

  style.display = originalDisplay;
  style.position = originalPosition;
  style.visibility = originalVisibility;

  return retVal;
};


/**
 * Gets the height and width of an element when the display is not none.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 * @private
 */
goog.style.getSizeWithDisplay_ = function(element) {
  var offsetWidth = element.offsetWidth;
  var offsetHeight = element.offsetHeight;
  var webkitOffsetsZero =
      goog.userAgent.WEBKIT && !offsetWidth && !offsetHeight;
  if ((!goog.isDef(offsetWidth) || webkitOffsetsZero) &&
      element.getBoundingClientRect) {
    // Fall back to calling getBoundingClientRect when offsetWidth or
    // offsetHeight are not defined, or when they are zero in WebKit browsers.
    // This makes sure that we return for the correct size for SVG elements, but
    // will still return 0 on Webkit prior to 534.8, see
    // http://trac.webkit.org/changeset/67252.
    var clientRect = goog.style.getBoundingClientRect_(element);
    return new goog.math.Size(clientRect.right - clientRect.left,
        clientRect.bottom - clientRect.top);
  }
  return new goog.math.Size(offsetWidth, offsetHeight);
};


/**
 * Gets the height and width of an element, post transform, even if its display
 * is none.
 *
 * This is like {@code goog.style.getSize}, except:
 * <ol>
 * <li>Takes webkitTransforms such as rotate and scale into account.
 * <li>Will return null if {@code element} doesn't respond to
 *     {@code getBoundingClientRect}.
 * <li>Currently doesn't make sense on non-WebKit browsers which don't support
 *    webkitTransforms.
 * </ol>
 * @param {!Element} element Element to get size of.
 * @return {goog.math.Size} Object with width/height properties.
 */
goog.style.getTransformedSize = function(element) {
  if (!element.getBoundingClientRect) {
    return null;
  }

  var clientRect = goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getBoundingClientRect_, element);
  return new goog.math.Size(clientRect.right - clientRect.left,
      clientRect.bottom - clientRect.top);
};


/**
 * Returns a bounding rectangle for a given element in page space.
 * @param {Element} element Element to get bounds of. Must not be display none.
 * @return {!goog.math.Rect} Bounding rectangle for the element.
 */
goog.style.getBounds = function(element) {
  var o = goog.style.getPageOffset(element);
  var s = goog.style.getSize(element);
  return new goog.math.Rect(o.x, o.y, s.width, s.height);
};


/**
 * Converts a CSS selector in the form style-property to styleProperty.
 * @param {*} selector CSS Selector.
 * @return {string} Camel case selector.
 * @deprecated Use goog.string.toCamelCase instead.
 */
goog.style.toCamelCase = function(selector) {
  return goog.string.toCamelCase(String(selector));
};


/**
 * Converts a CSS selector in the form styleProperty to style-property.
 * @param {string} selector Camel case selector.
 * @return {string} Selector cased.
 * @deprecated Use goog.string.toSelectorCase instead.
 */
goog.style.toSelectorCase = function(selector) {
  return goog.string.toSelectorCase(selector);
};


/**
 * Gets the opacity of a node (x-browser). This gets the inline style opacity
 * of the node, and does not take into account the cascaded or the computed
 * style for this node.
 * @param {Element} el Element whose opacity has to be found.
 * @return {number|string} Opacity between 0 and 1 or an empty string {@code ''}
 *     if the opacity is not set.
 */
goog.style.getOpacity = function(el) {
  var style = el.style;
  var result = '';
  if ('opacity' in style) {
    result = style.opacity;
  } else if ('MozOpacity' in style) {
    result = style.MozOpacity;
  } else if ('filter' in style) {
    var match = style.filter.match(/alpha\(opacity=([\d.]+)\)/);
    if (match) {
      result = String(match[1] / 100);
    }
  }
  return result == '' ? result : Number(result);
};


/**
 * Sets the opacity of a node (x-browser).
 * @param {Element} el Elements whose opacity has to be set.
 * @param {number|string} alpha Opacity between 0 and 1 or an empty string
 *     {@code ''} to clear the opacity.
 */
goog.style.setOpacity = function(el, alpha) {
  var style = el.style;
  if ('opacity' in style) {
    style.opacity = alpha;
  } else if ('MozOpacity' in style) {
    style.MozOpacity = alpha;
  } else if ('filter' in style) {
    // TODO(arv): Overwriting the filter might have undesired side effects.
    if (alpha === '') {
      style.filter = '';
    } else {
      style.filter = 'alpha(opacity=' + alpha * 100 + ')';
    }
  }
};


/**
 * Sets the background of an element to a transparent image in a browser-
 * independent manner.
 *
 * This function does not support repeating backgrounds or alternate background
 * positions to match the behavior of Internet Explorer. It also does not
 * support sizingMethods other than crop since they cannot be replicated in
 * browsers other than Internet Explorer.
 *
 * @param {Element} el The element to set background on.
 * @param {string} src The image source URL.
 */
goog.style.setTransparentBackgroundImage = function(el, src) {
  var style = el.style;
  // It is safe to use the style.filter in IE only. In Safari 'filter' is in
  // style object but access to style.filter causes it to throw an exception.
  // Note: IE8 supports images with an alpha channel.
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    // See TODO in setOpacity.
    style.filter = 'progid:DXImageTransform.Microsoft.AlphaImageLoader(' +
        'src="' + src + '", sizingMethod="crop")';
  } else {
    // Set style properties individually instead of using background shorthand
    // to prevent overwriting a pre-existing background color.
    style.backgroundImage = 'url(' + src + ')';
    style.backgroundPosition = 'top left';
    style.backgroundRepeat = 'no-repeat';
  }
};


/**
 * Clears the background image of an element in a browser independent manner.
 * @param {Element} el The element to clear background image for.
 */
goog.style.clearTransparentBackgroundImage = function(el) {
  var style = el.style;
  if ('filter' in style) {
    // See TODO in setOpacity.
    style.filter = '';
  } else {
    // Set style properties individually instead of using background shorthand
    // to prevent overwriting a pre-existing background color.
    style.backgroundImage = 'none';
  }
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules.)
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * showElement(), effectively toggling the display between "none" and "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * showElement will clear that setting and defer to the inherited style in the
 * stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} display True to render the element in its default style,
 *     false to disable rendering the element.
 * @deprecated Use goog.style.setElementShown instead.
 */
goog.style.showElement = function(el, display) {
  goog.style.setElementShown(el, display);
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules).
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * setElementShown(), effectively toggling the display between "none" and
 * "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * setElementShown will clear that setting and defer to the inherited style in
 * the stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} isShown True to render the element in its default style,
 *     false to disable rendering the element.
 */
goog.style.setElementShown = function(el, isShown) {
  el.style.display = isShown ? '' : 'none';
};


/**
 * Test whether the given element has been shown or hidden via a call to
 * {@link #setElementShown}.
 *
 * Note this is strictly a companion method for a call
 * to {@link #setElementShown} and the same caveats apply; in particular, this
 * method does not guarantee that the return value will be consistent with
 * whether or not the element is actually visible.
 *
 * @param {Element} el The element to test.
 * @return {boolean} Whether the element has been shown.
 * @see #setElementShown
 */
goog.style.isElementShown = function(el) {
  return el.style.display != 'none';
};


/**
 * Installs the styles string into the window that contains opt_element.  If
 * opt_element is null, the main window is used.
 * @param {string} stylesString The style string to install.
 * @param {Node=} opt_node Node whose parent document should have the
 *     styles installed.
 * @return {Element|StyleSheet} The style element created.
 */
goog.style.installStyles = function(stylesString, opt_node) {
  var dh = goog.dom.getDomHelper(opt_node);
  var styleSheet = null;

  // IE < 11 requires createStyleSheet. Note that doc.createStyleSheet will be
  // undefined as of IE 11.
  var doc = dh.getDocument();
  if (goog.userAgent.IE && doc.createStyleSheet) {
    styleSheet = doc.createStyleSheet();
    goog.style.setStyles(styleSheet, stylesString);
  } else {
    var head = dh.getElementsByTagNameAndClass('head')[0];

    // In opera documents are not guaranteed to have a head element, thus we
    // have to make sure one exists before using it.
    if (!head) {
      var body = dh.getElementsByTagNameAndClass('body')[0];
      head = dh.createDom('head');
      body.parentNode.insertBefore(head, body);
    }
    styleSheet = dh.createDom('style');
    // NOTE(user): Setting styles after the style element has been appended
    // to the head results in a nasty Webkit bug in certain scenarios. Please
    // refer to https://bugs.webkit.org/show_bug.cgi?id=26307 for additional
    // details.
    goog.style.setStyles(styleSheet, stylesString);
    dh.appendChild(head, styleSheet);
  }
  return styleSheet;
};


/**
 * Removes the styles added by {@link #installStyles}.
 * @param {Element|StyleSheet} styleSheet The value returned by
 *     {@link #installStyles}.
 */
goog.style.uninstallStyles = function(styleSheet) {
  var node = styleSheet.ownerNode || styleSheet.owningElement ||
      /** @type {Element} */ (styleSheet);
  goog.dom.removeNode(node);
};


/**
 * Sets the content of a style element.  The style element can be any valid
 * style element.  This element will have its content completely replaced by
 * the new stylesString.
 * @param {Element|StyleSheet} element A stylesheet element as returned by
 *     installStyles.
 * @param {string} stylesString The new content of the stylesheet.
 */
goog.style.setStyles = function(element, stylesString) {
  if (goog.userAgent.IE && goog.isDef(element.cssText)) {
    // Adding the selectors individually caused the browser to hang if the
    // selector was invalid or there were CSS comments.  Setting the cssText of
    // the style node works fine and ignores CSS that IE doesn't understand.
    // However IE >= 11 doesn't support cssText any more, so we make sure that
    // cssText is a defined property and otherwise fall back to innerHTML.
    element.cssText = stylesString;
  } else {
    element.innerHTML = stylesString;
  }
};


/**
 * Sets 'white-space: pre-wrap' for a node (x-browser).
 *
 * There are as many ways of specifying pre-wrap as there are browsers.
 *
 * CSS3/IE8: white-space: pre-wrap;
 * Mozilla:  white-space: -moz-pre-wrap;
 * Opera:    white-space: -o-pre-wrap;
 * IE6/7:    white-space: pre; word-wrap: break-word;
 *
 * @param {Element} el Element to enable pre-wrap for.
 */
goog.style.setPreWrap = function(el) {
  var style = el.style;
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    style.whiteSpace = 'pre';
    style.wordWrap = 'break-word';
  } else if (goog.userAgent.GECKO) {
    style.whiteSpace = '-moz-pre-wrap';
  } else {
    style.whiteSpace = 'pre-wrap';
  }
};


/**
 * Sets 'display: inline-block' for an element (cross-browser).
 * @param {Element} el Element to which the inline-block display style is to be
 *    applied.
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 */
goog.style.setInlineBlock = function(el) {
  var style = el.style;
  // Without position:relative, weirdness ensues.  Just accept it and move on.
  style.position = 'relative';

  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    // IE8 supports inline-block so fall through to the else
    // Zoom:1 forces hasLayout, display:inline gives inline behavior.
    style.zoom = '1';
    style.display = 'inline';
  } else if (goog.userAgent.GECKO) {
    // Pre-Firefox 3, Gecko doesn't support inline-block, but -moz-inline-box
    // is close enough.
    style.display = goog.userAgent.isVersionOrHigher('1.9a') ? 'inline-block' :
        '-moz-inline-box';
  } else {
    // Opera, Webkit, and Safari seem to do OK with the standard inline-block
    // style.
    style.display = 'inline-block';
  }
};


/**
 * Returns true if the element is using right to left (rtl) direction.
 * @param {Element} el  The element to test.
 * @return {boolean} True for right to left, false for left to right.
 */
goog.style.isRightToLeft = function(el) {
  return 'rtl' == goog.style.getStyle_(el, 'direction');
};


/**
 * The CSS style property corresponding to an element being
 * unselectable on the current browser platform (null if none).
 * Opera and IE instead use a DOM attribute 'unselectable'.
 * @type {?string}
 * @private
 */
goog.style.unselectableStyle_ =
    goog.userAgent.GECKO ? 'MozUserSelect' :
    goog.userAgent.WEBKIT ? 'WebkitUserSelect' :
    null;


/**
 * Returns true if the element is set to be unselectable, false otherwise.
 * Note that on some platforms (e.g. Mozilla), even if an element isn't set
 * to be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  Element to check.
 * @return {boolean}  Whether the element is set to be unselectable.
 */
goog.style.isUnselectable = function(el) {
  if (goog.style.unselectableStyle_) {
    return el.style[goog.style.unselectableStyle_].toLowerCase() == 'none';
  } else if (goog.userAgent.IE || goog.userAgent.OPERA) {
    return el.getAttribute('unselectable') == 'on';
  }
  return false;
};


/**
 * Makes the element and its descendants selectable or unselectable.  Note
 * that on some platforms (e.g. Mozilla), even if an element isn't set to
 * be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  The element to alter.
 * @param {boolean} unselectable  Whether the element and its descendants
 *     should be made unselectable.
 * @param {boolean=} opt_noRecurse  Whether to only alter the element's own
 *     selectable state, and leave its descendants alone; defaults to false.
 */
goog.style.setUnselectable = function(el, unselectable, opt_noRecurse) {
  // TODO(attila): Do we need all of TR_DomUtil.makeUnselectable() in Closure?
  var descendants = !opt_noRecurse ? el.getElementsByTagName('*') : null;
  var name = goog.style.unselectableStyle_;
  if (name) {
    // Add/remove the appropriate CSS style to/from the element and its
    // descendants.
    var value = unselectable ? 'none' : '';
    el.style[name] = value;
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        descendant.style[name] = value;
      }
    }
  } else if (goog.userAgent.IE || goog.userAgent.OPERA) {
    // Toggle the 'unselectable' attribute on the element and its descendants.
    var value = unselectable ? 'on' : '';
    el.setAttribute('unselectable', value);
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        descendant.setAttribute('unselectable', value);
      }
    }
  }
};


/**
 * Gets the border box size for an element.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The border box size.
 */
goog.style.getBorderBoxSize = function(element) {
  return new goog.math.Size(element.offsetWidth, element.offsetHeight);
};


/**
 * Sets the border box size of an element. This is potentially expensive in IE
 * if the document is CSS1Compat mode
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setBorderBoxSize = function(element, size) {
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();

  if (goog.userAgent.IE &&
      (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
    var style = element.style;
    if (isCss1CompatMode) {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width - borderBox.left - paddingBox.left -
                         paddingBox.right - borderBox.right;
      style.pixelHeight = size.height - borderBox.top - paddingBox.top -
                          paddingBox.bottom - borderBox.bottom;
    } else {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'border-box');
  }
};


/**
 * Gets the content box size for an element.  This is potentially expensive in
 * all browsers.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The content box size.
 */
goog.style.getContentBoxSize = function(element) {
  var doc = goog.dom.getOwnerDocument(element);
  var ieCurrentStyle = goog.userAgent.IE && element.currentStyle;
  if (ieCurrentStyle &&
      goog.dom.getDomHelper(doc).isCss1CompatMode() &&
      ieCurrentStyle.width != 'auto' && ieCurrentStyle.height != 'auto' &&
      !ieCurrentStyle.boxSizing) {
    // If IE in CSS1Compat mode than just use the width and height.
    // If we have a boxSizing then fall back on measuring the borders etc.
    var width = goog.style.getIePixelValue_(element, ieCurrentStyle.width,
                                            'width', 'pixelWidth');
    var height = goog.style.getIePixelValue_(element, ieCurrentStyle.height,
                                             'height', 'pixelHeight');
    return new goog.math.Size(width, height);
  } else {
    var borderBoxSize = goog.style.getBorderBoxSize(element);
    var paddingBox = goog.style.getPaddingBox(element);
    var borderBox = goog.style.getBorderBox(element);
    return new goog.math.Size(borderBoxSize.width -
                              borderBox.left - paddingBox.left -
                              paddingBox.right - borderBox.right,
                              borderBoxSize.height -
                              borderBox.top - paddingBox.top -
                              paddingBox.bottom - borderBox.bottom);
  }
};


/**
 * Sets the content box size of an element. This is potentially expensive in IE
 * if the document is BackCompat mode.
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setContentBoxSize = function(element, size) {
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
  if (goog.userAgent.IE &&
      (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
    var style = element.style;
    if (isCss1CompatMode) {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    } else {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width + borderBox.left + paddingBox.left +
                         paddingBox.right + borderBox.right;
      style.pixelHeight = size.height + borderBox.top + paddingBox.top +
                          paddingBox.bottom + borderBox.bottom;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'content-box');
  }
};


/**
 * Helper function that sets the box sizing as well as the width and height
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size to set.
 * @param {string} boxSizing  The box-sizing value.
 * @private
 */
goog.style.setBoxSizingSize_ = function(element, size, boxSizing) {
  var style = element.style;
  if (goog.userAgent.GECKO) {
    style.MozBoxSizing = boxSizing;
  } else if (goog.userAgent.WEBKIT) {
    style.WebkitBoxSizing = boxSizing;
  } else {
    // Includes IE8 and Opera 9.50+
    style.boxSizing = boxSizing;
  }

  // Setting this to a negative value will throw an exception on IE
  // (and doesn't do anything different than setting it to 0).
  style.width = Math.max(size.width, 0) + 'px';
  style.height = Math.max(size.height, 0) + 'px';
};


/**
 * IE specific function that converts a non pixel unit to pixels.
 * @param {Element} element  The element to convert the value for.
 * @param {string} value  The current value as a string. The value must not be
 *     ''.
 * @param {string} name  The CSS property name to use for the converstion. This
 *     should be 'left', 'top', 'width' or 'height'.
 * @param {string} pixelName  The CSS pixel property name to use to get the
 *     value in pixels.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelValue_ = function(element, value, name, pixelName) {
  // Try if we already have a pixel value. IE does not do half pixels so we
  // only check if it matches a number followed by 'px'.
  if (/^\d+px?$/.test(value)) {
    return parseInt(value, 10);
  } else {
    var oldStyleValue = element.style[name];
    var oldRuntimeValue = element.runtimeStyle[name];
    // set runtime style to prevent changes
    element.runtimeStyle[name] = element.currentStyle[name];
    element.style[name] = value;
    var pixelValue = element.style[pixelName];
    // restore
    element.style[name] = oldStyleValue;
    element.runtimeStyle[name] = oldRuntimeValue;
    return pixelValue;
  }
};


/**
 * Helper function for getting the pixel padding or margin for IE.
 * @param {Element} element  The element to get the padding for.
 * @param {string} propName  The property name.
 * @return {number} The pixel padding.
 * @private
 */
goog.style.getIePixelDistance_ = function(element, propName) {
  var value = goog.style.getCascadedStyle(element, propName);
  return value ?
      goog.style.getIePixelValue_(element, value, 'left', 'pixelLeft') : 0;
};


/**
 * Gets the computed paddings or margins (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @param {string} stylePrefix  Pass 'padding' to retrieve the padding box,
 *     or 'margin' to retrieve the margin box.
 * @return {!goog.math.Box} The computed paddings or margins.
 * @private
 */
goog.style.getBox_ = function(element, stylePrefix) {
  if (goog.userAgent.IE) {
    var left = goog.style.getIePixelDistance_(element, stylePrefix + 'Left');
    var right = goog.style.getIePixelDistance_(element, stylePrefix + 'Right');
    var top = goog.style.getIePixelDistance_(element, stylePrefix + 'Top');
    var bottom = goog.style.getIePixelDistance_(
        element, stylePrefix + 'Bottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Left'));
    var right = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Right'));
    var top = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Top'));
    var bottom = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Bottom'));

    // NOTE(arv): Gecko can return floating point numbers for the computed
    // style values.
    return new goog.math.Box(parseFloat(top),
                             parseFloat(right),
                             parseFloat(bottom),
                             parseFloat(left));
  }
};


/**
 * Gets the computed paddings (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @return {!goog.math.Box} The computed paddings.
 */
goog.style.getPaddingBox = function(element) {
  return goog.style.getBox_(element, 'padding');
};


/**
 * Gets the computed margins (on all sides) in pixels.
 * @param {Element} element  The element to get the margins for.
 * @return {!goog.math.Box} The computed margins.
 */
goog.style.getMarginBox = function(element) {
  return goog.style.getBox_(element, 'margin');
};


/**
 * A map used to map the border width keywords to a pixel width.
 * @type {Object}
 * @private
 */
goog.style.ieBorderWidthKeywords_ = {
  'thin': 2,
  'medium': 4,
  'thick': 6
};


/**
 * Helper function for IE to get the pixel border.
 * @param {Element} element  The element to get the pixel border for.
 * @param {string} prop  The part of the property name.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelBorder_ = function(element, prop) {
  if (goog.style.getCascadedStyle(element, prop + 'Style') == 'none') {
    return 0;
  }
  var width = goog.style.getCascadedStyle(element, prop + 'Width');
  if (width in goog.style.ieBorderWidthKeywords_) {
    return goog.style.ieBorderWidthKeywords_[width];
  }
  return goog.style.getIePixelValue_(element, width, 'left', 'pixelLeft');
};


/**
 * Gets the computed border widths (on all sides) in pixels
 * @param {Element} element  The element to get the border widths for.
 * @return {!goog.math.Box} The computed border widths.
 */
goog.style.getBorderBox = function(element) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    var left = goog.style.getIePixelBorder_(element, 'borderLeft');
    var right = goog.style.getIePixelBorder_(element, 'borderRight');
    var top = goog.style.getIePixelBorder_(element, 'borderTop');
    var bottom = goog.style.getIePixelBorder_(element, 'borderBottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderLeftWidth'));
    var right = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderRightWidth'));
    var top = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderTopWidth'));
    var bottom = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderBottomWidth'));

    return new goog.math.Box(parseFloat(top),
                             parseFloat(right),
                             parseFloat(bottom),
                             parseFloat(left));
  }
};


/**
 * Returns the font face applied to a given node. Opera and IE should return
 * the font actually displayed. Firefox returns the author's most-preferred
 * font (whether the browser is capable of displaying it or not.)
 * @param {Element} el  The element whose font family is returned.
 * @return {string} The font family applied to el.
 */
goog.style.getFontFamily = function(el) {
  var doc = goog.dom.getOwnerDocument(el);
  var font = '';
  if (doc.body.createTextRange) {
    var range = doc.body.createTextRange();
    range.moveToElementText(el);
    /** @preserveTry */
    try {
      font = range.queryCommandValue('FontName');
    } catch (e) {
      // This is a workaround for a awkward exception.
      // On some IE, there is an exception coming from it.
      // The error description from this exception is:
      // This window has already been registered as a drop target
      // This is bogus description, likely due to a bug in ie.
      font = '';
    }
  }
  if (!font) {
    // Note if for some reason IE can't derive FontName with a TextRange, we
    // fallback to using currentStyle
    font = goog.style.getStyle_(el, 'fontFamily');
  }

  // Firefox returns the applied font-family string (author's list of
  // preferred fonts.) We want to return the most-preferred font, in lieu of
  // the *actually* applied font.
  var fontsArray = font.split(',');
  if (fontsArray.length > 1) font = fontsArray[0];

  // Sanitize for x-browser consistency:
  // Strip quotes because browsers aren't consistent with how they're
  // applied; Opera always encloses, Firefox sometimes, and IE never.
  return goog.string.stripQuotes(font, '"\'');
};


/**
 * Regular expression used for getLengthUnits.
 * @type {RegExp}
 * @private
 */
goog.style.lengthUnitRegex_ = /[^\d]+$/;


/**
 * Returns the units used for a CSS length measurement.
 * @param {string} value  A CSS length quantity.
 * @return {?string} The units of measurement.
 */
goog.style.getLengthUnits = function(value) {
  var units = value.match(goog.style.lengthUnitRegex_);
  return units && units[0] || null;
};


/**
 * Map of absolute CSS length units
 * @type {Object}
 * @private
 */
goog.style.ABSOLUTE_CSS_LENGTH_UNITS_ = {
  'cm' : 1,
  'in' : 1,
  'mm' : 1,
  'pc' : 1,
  'pt' : 1
};


/**
 * Map of relative CSS length units that can be accurately converted to px
 * font-size values using getIePixelValue_. Only units that are defined in
 * relation to a font size are convertible (%, small, etc. are not).
 * @type {Object}
 * @private
 */
goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_ = {
  'em' : 1,
  'ex' : 1
};


/**
 * Returns the font size, in pixels, of text in an element.
 * @param {Element} el  The element whose font size is returned.
 * @return {number} The font size (in pixels).
 */
goog.style.getFontSize = function(el) {
  var fontSize = goog.style.getStyle_(el, 'fontSize');
  var sizeUnits = goog.style.getLengthUnits(fontSize);
  if (fontSize && 'px' == sizeUnits) {
    // NOTE(user): This could be parseFloat instead, but IE doesn't return
    // decimal fractions in getStyle_ and Firefox reports the fractions, but
    // ignores them when rendering. Interestingly enough, when we force the
    // issue and size something to e.g., 50% of 25px, the browsers round in
    // opposite directions with Firefox reporting 12px and IE 13px. I punt.
    return parseInt(fontSize, 10);
  }

  // In IE, we can convert absolute length units to a px value using
  // goog.style.getIePixelValue_. Units defined in relation to a font size
  // (em, ex) are applied relative to the element's parentNode and can also
  // be converted.
  if (goog.userAgent.IE) {
    if (sizeUnits in goog.style.ABSOLUTE_CSS_LENGTH_UNITS_) {
      return goog.style.getIePixelValue_(el,
                                         fontSize,
                                         'left',
                                         'pixelLeft');
    } else if (el.parentNode &&
               el.parentNode.nodeType == goog.dom.NodeType.ELEMENT &&
               sizeUnits in goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_) {
      // Check the parent size - if it is the same it means the relative size
      // value is inherited and we therefore don't want to count it twice.  If
      // it is different, this element either has explicit style or has a CSS
      // rule applying to it.
      var parentElement = /** @type {Element} */ (el.parentNode);
      var parentSize = goog.style.getStyle_(parentElement, 'fontSize');
      return goog.style.getIePixelValue_(parentElement,
                                         fontSize == parentSize ?
                                             '1em' : fontSize,
                                         'left',
                                         'pixelLeft');
    }
  }

  // Sometimes we can't cleanly find the font size (some units relative to a
  // node's parent's font size are difficult: %, smaller et al), so we create
  // an invisible, absolutely-positioned span sized to be the height of an 'M'
  // rendered in its parent's (i.e., our target element's) font size. This is
  // the definition of CSS's font size attribute.
  var sizeElement = goog.dom.createDom(
      'span',
      {'style': 'visibility:hidden;position:absolute;' +
            'line-height:0;padding:0;margin:0;border:0;height:1em;'});
  goog.dom.appendChild(el, sizeElement);
  fontSize = sizeElement.offsetHeight;
  goog.dom.removeNode(sizeElement);

  return fontSize;
};


/**
 * Parses a style attribute value.  Converts CSS property names to camel case.
 * @param {string} value The style attribute value.
 * @return {!Object} Map of CSS properties to string values.
 */
goog.style.parseStyleAttribute = function(value) {
  var result = {};
  goog.array.forEach(value.split(/\s*;\s*/), function(pair) {
    var keyValue = pair.split(/\s*:\s*/);
    if (keyValue.length == 2) {
      result[goog.string.toCamelCase(keyValue[0].toLowerCase())] = keyValue[1];
    }
  });
  return result;
};


/**
 * Reverse of parseStyleAttribute; that is, takes a style object and returns the
 * corresponding attribute value.  Converts camel case property names to proper
 * CSS selector names.
 * @param {Object} obj Map of CSS properties to values.
 * @return {string} The style attribute value.
 */
goog.style.toStyleAttribute = function(obj) {
  var buffer = [];
  goog.object.forEach(obj, function(value, key) {
    buffer.push(goog.string.toSelectorCase(key), ':', value, ';');
  });
  return buffer.join('');
};


/**
 * Sets CSS float property on an element.
 * @param {Element} el The element to set float property on.
 * @param {string} value The value of float CSS property to set on this element.
 */
goog.style.setFloat = function(el, value) {
  el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] = value;
};


/**
 * Gets value of explicitly-set float CSS property on an element.
 * @param {Element} el The element to get float property of.
 * @return {string} The value of explicitly-set float CSS property on this
 *     element.
 */
goog.style.getFloat = function(el) {
  return el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] || '';
};


/**
 * Returns the scroll bar width (represents the width of both horizontal
 * and vertical scroll).
 *
 * @param {string=} opt_className An optional class name (or names) to apply
 *     to the invisible div created to measure the scrollbar. This is necessary
 *     if some scrollbars are styled differently than others.
 * @return {number} The scroll bar width in px.
 */
goog.style.getScrollbarWidth = function(opt_className) {
  // Add two hidden divs.  The child div is larger than the parent and
  // forces scrollbars to appear on it.
  // Using overflow:scroll does not work consistently with scrollbars that
  // are styled with ::-webkit-scrollbar.
  var outerDiv = goog.dom.createElement('div');
  if (opt_className) {
    outerDiv.className = opt_className;
  }
  outerDiv.style.cssText = 'overflow:auto;' +
      'position:absolute;top:0;width:100px;height:100px';
  var innerDiv = goog.dom.createElement('div');
  goog.style.setSize(innerDiv, '200px', '200px');
  outerDiv.appendChild(innerDiv);
  goog.dom.appendChild(goog.dom.getDocument().body, outerDiv);
  var width = outerDiv.offsetWidth - outerDiv.clientWidth;
  goog.dom.removeNode(outerDiv);
  return width;
};


/**
 * Regular expression to extract x and y translation components from a CSS
 * transform Matrix representation.
 *
 * @type {!RegExp}
 * @const
 * @private
 */
goog.style.MATRIX_TRANSLATION_REGEX_ =
    new RegExp('matrix\\([0-9\\.\\-]+, [0-9\\.\\-]+, ' +
               '[0-9\\.\\-]+, [0-9\\.\\-]+, ' +
               '([0-9\\.\\-]+)p?x?, ([0-9\\.\\-]+)p?x?\\)');


/**
 * Returns the x,y translation component of any CSS transforms applied to the
 * element, in pixels.
 *
 * @param {!Element} element The element to get the translation of.
 * @return {!goog.math.Coordinate} The CSS translation of the element in px.
 */
goog.style.getCssTranslation = function(element) {
  var property;
  if (goog.userAgent.IE) {
    property = '-ms-transform';
  } else if (goog.userAgent.WEBKIT) {
    property = '-webkit-transform';
  } else if (goog.userAgent.OPERA) {
    property = '-o-transform';
  } else if (goog.userAgent.GECKO) {
    property = '-moz-transform';
  }
  var transform;
  if (property) {
    transform = goog.style.getStyle_(element, property);
  }
  if (!transform) {
    transform = goog.style.getStyle_(element, 'transform');
  }
  if (!transform) {
    return new goog.math.Coordinate(0, 0);
  }
  var matches = transform.match(goog.style.MATRIX_TRANSLATION_REGEX_);
  if (!matches) {
    return new goog.math.Coordinate(0, 0);
  }
  return new goog.math.Coordinate(parseFloat(matches[1]),
                                  parseFloat(matches[2]));
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for window manipulation.
 */


goog.provide('goog.window');

goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Default height for popup windows
 * @type {number}
 */
goog.window.DEFAULT_POPUP_HEIGHT = 500;


/**
 * Default width for popup windows
 * @type {number}
 */
goog.window.DEFAULT_POPUP_WIDTH = 690;


/**
 * Default target for popup windows
 * @type {string}
 */
goog.window.DEFAULT_POPUP_TARGET = 'google_popup';


/**
 * Opens a new window.
 *
 * @param {string|Object} linkRef A string or an object that supports toString,
 *     for example goog.Uri.  If this is an object with a 'href' attribute, such
 *     as HTMLAnchorElement, it will be used instead.
 *
 * @param {Object=} opt_options supports the following options:
 *  'target': (string) target (window name). If null, linkRef.target will
 *          be used.
 *  'width': (number) window width.
 *  'height': (number) window height.
 *  'top': (number) distance from top of screen
 *  'left': (number) distance from left of screen
 *  'toolbar': (boolean) show toolbar
 *  'scrollbars': (boolean) show scrollbars
 *  'location': (boolean) show location
 *  'statusbar': (boolean) show statusbar
 *  'menubar': (boolean) show menubar
 *  'resizable': (boolean) resizable
 *  'noreferrer': (boolean) whether to attempt to remove the referrer header
 *      from the request headers. Does this by opening a blank window that
 *      then redirects to the target url, so users may see some flickering.
 *
 * @param {Window=} opt_parentWin Parent window that should be used to open the
 *                 new window.
 *
 * @return {Window} Returns the window object that was opened. This returns
 *                  null if a popup blocker prevented the window from being
 *                  opened.
 */
goog.window.open = function(linkRef, opt_options, opt_parentWin) {
  if (!opt_options) {
    opt_options = {};
  }
  var parentWin = opt_parentWin || window;

  // HTMLAnchorElement has a toString() method with the same behavior as
  // goog.Uri in all browsers except for Safari, which returns
  // '[object HTMLAnchorElement]'.  We check for the href first, then
  // assume that it's a goog.Uri or String otherwise.
  var href = typeof linkRef.href != 'undefined' ? linkRef.href :
      String(linkRef);
  var target = opt_options.target || linkRef.target;

  var sb = [];
  for (var option in opt_options) {
    switch (option) {
      case 'width':
      case 'height':
      case 'top':
      case 'left':
        sb.push(option + '=' + opt_options[option]);
        break;
      case 'target':
      case 'noreferrer':
        break;
      default:
        sb.push(option + '=' + (opt_options[option] ? 1 : 0));
    }
  }
  var optionString = sb.join(',');

  var newWin;
  if (opt_options['noreferrer']) {
    // Use a meta-refresh to stop the referrer from being included in the
    // request headers.
    newWin = parentWin.open('', target, optionString);
    if (newWin) {
      if (goog.userAgent.IE) {
        // IE has problems parsing the content attribute if the url contains
        // a semicolon. We can fix this by adding quotes around the url, but
        // then we can't parse quotes in the URL correctly. We take a
        // best-effort approach.
        //
        // If the URL has semicolons, wrap it in single quotes to protect
        // the semicolons.
        // If the URL has semicolons and single quotes, url-encode the single
        // quotes as well.
        //
        // This is imperfect. Notice that both ' and ; are reserved characters
        // in URIs, so this could do the wrong thing, but at least it will
        // do the wrong thing in only rare cases.
        // ugh.
        if (href.indexOf(';') != -1) {
          href = "'" + href.replace(/'/g, '%27') + "'";
        }
      }
      newWin.opener = null;
      href = goog.string.htmlEscape(href);
      newWin.document.write('<META HTTP-EQUIV="refresh" content="0; url=' +
                            href + '">');
      newWin.document.close();
    }
  } else {
    newWin = parentWin.open(href, target, optionString);
  }
  // newWin is null if a popup blocker prevented the window open.
  return newWin;
};


/**
 * Opens a new window without any real content in it.
 *
 * This can be used to get around popup blockers if you need to open a window
 * in response to a user event, but need to do asynchronous work to determine
 * the URL to open, and then set the URL later.
 *
 * Example usage:
 *
 * var newWin = goog.window.openBlank('Loading...');
 * setTimeout(
 *     function() {
 *       newWin.location.href = 'http://www.google.com';
 *     }, 100);
 *
 * @param {string=} opt_message String to show in the new window. This string
 *     will be HTML-escaped to avoid XSS issues.
 * @param {Object=} opt_options Options to open window with.
 *     {@see goog.window.open for exact option semantics}.
 * @param {Window=} opt_parentWin Parent window that should be used to open the
 *                 new window.
 * @return {Window} Returns the window object that was opened. This returns
 *                  null if a popup blocker prevented the window from being
 *                  opened.
 */
goog.window.openBlank = function(opt_message, opt_options, opt_parentWin) {

  // Open up a window with the loading message and nothing else.
  // This will be interpreted as HTML content type with a missing doctype
  // and html/body tags, but is otherwise acceptable.
  var loadingMessage = opt_message ? goog.string.htmlEscape(opt_message) : '';
  return /** @type {Window} */ (goog.window.open(
      'javascript:"' + encodeURI(loadingMessage) + '"',
      opt_options, opt_parentWin));
};


/**
 * Raise a help popup window, defaulting to "Google standard" size and name.
 *
 * (If your project is using GXPs, consider using {@link PopUpLink.gxp}.)
 *
 * @param {string|Object} linkRef if this is a string, it will be used as the
 * URL of the popped window; otherwise it's assumed to be an HTMLAnchorElement
 * (or some other object with "target" and "href" properties).
 *
 * @param {Object=} opt_options Options to open window with.
 *     {@see goog.window.open for exact option semantics}
 *     Additional wrinkles to the options:
 *     - if 'target' field is null, linkRef.target will be used. If *that's*
 *     null, the default is "google_popup".
 *     - if 'width' field is not specified, the default is 690.
 *     - if 'height' field is not specified, the default is 500.
 *
 * @return {boolean} true if the window was not popped up, false if it was.
 */
goog.window.popup = function(linkRef, opt_options) {
  if (!opt_options) {
    opt_options = {};
  }

  // set default properties
  opt_options['target'] = opt_options['target'] ||
      linkRef['target'] || goog.window.DEFAULT_POPUP_TARGET;
  opt_options['width'] = opt_options['width'] ||
      goog.window.DEFAULT_POPUP_WIDTH;
  opt_options['height'] = opt_options['height'] ||
      goog.window.DEFAULT_POPUP_HEIGHT;

  var newWin = goog.window.open(linkRef, opt_options);
  if (!newWin) {
    return true;
  }
  newWin.focus();

  return false;
};
goog.provide('feng.utils.Utils');

goog.require('goog.dom');
goog.require('goog.string');
goog.require('goog.style');
goog.require('goog.Uri');
goog.require('goog.window');


feng.utils.Utils.escapeConsole = function() {

  window.console = {};
  
  var methods = [
      'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
      'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
      'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
      'timeStamp', 'trace', 'warn'
    ];
  
  for(var i=0;i<methods.length;i++){
    console[methods[i]] = function(){};
  }
};


feng.utils.Utils.setValueByKeys = function(key, val, obj) {
	
  var ka = key.split(/\./);
  if (ka.length < 2) { 
    obj[ka[0]] = val;
  } else {
    if (!obj[ka[0]]) obj[ka[0]] = {};
    obj = obj[ka.shift()];
    feng.utils.Utils.setValueByKeys(ka.join("."),val,obj);
  }    
};


feng.utils.Utils.setCursor = function(cursor, element) {

  var el = element || document.body;
  goog.style.setStyle(el, 'cursor', cursor);
};


feng.utils.Utils.getQuery = function(key) {

  var uri = new goog.Uri( window.location.href );
  var queryData = uri.getQueryData();

  return queryData.get(key);
};


feng.utils.Utils.hasQuery = function(key, value) {

  var uri = new goog.Uri( window.location.href );
  var queryData = uri.getQueryData();

  return (goog.isString(value) ? (queryData.get(key) === value) : queryData.hasQuery(key));
};


feng.utils.Utils.centerAlign = function(alignEl, relativeElOrSize) {

  var relativeSize = (relativeElOrSize.width && relativeElOrSize.height) ? relativeElOrSize : null;

  if(!relativeSize) {
    relativeSize = goog.style.getSize( relativeElOrSize );
  }

  var alignElSize = goog.style.getSize( alignEl );
  var alignElX = Math.round( (relativeSize.width - alignElSize.width) / 2 );
  var alignElY = Math.round( (relativeSize.height - alignElSize.height) / 2 );

  goog.style.setPosition( alignEl, alignElX, alignElY );
};


feng.utils.Utils.createDomCollectionByAttributes = function( doms, attr ) {

  var result = {};

  goog.array.forEach(doms, function(dom) {
    result[ dom.getAttribute( attr ) ] = dom;
  });

  return result;
};


feng.utils.Utils.popUp = function(url) {

  var width, height;

  var isFacebook = goog.string.contains( url, 'facebook' );
  var isTwitter = goog.string.contains( url, 'twitter' );
  var isGoogle = goog.string.contains( url, 'google' );

  if(isFacebook) {

    width = 640;
    height = 275;

  }else if(isTwitter) {

    width = 575;
    height = 275;

  }else if(isGoogle) {

    width = 640;
    height = 470;
  }

  var viewportSize = goog.dom.getViewportSize();

  goog.window.open(url, {
    'width': width,
    'height': height,
    'left': (window.screenLeft || window.screenX) + (viewportSize.width - width)/2,
    'top': (window.screenTop || window.screenY) + (viewportSize.height - height)/2,
    'toolbar': false,
    'scrollbars': true,
    'statusbar': false,
    'menubar': false,
    'resizable': true
  });
};


feng.utils.Utils.supportWebGL = ( function () { try { var canvas = document.createElement( 'canvas' ); return !! window['WebGLRenderingContext'] && canvas.getContext( 'webgl' ); } catch( e ) { return false; } } )();goog.provide('feng.models.Preload');

goog.require('goog.object');
goog.require('feng.utils.Utils');


/**
 * @constructor
 */
feng.models.Preload = function(){

	this._assets = {
		'global': {
			'fengshui-data': 'json/fengshui.json',
			'loader-small-black': 'images/loader-small-black.gif',
			'scene-studio': 'images/scene-studio.jpg',
			'scene-house': 'images/scene-house.jpg',
			'circular-fill': 'images/circular-fill.png',
			'book': 'images/book.png',
			'cube-browse': 'images/cube-browse.png',
			'cube-design': 'images/cube-design.png',
			'leaf': {
				'green-1': 'images/texture/leaf/ji.png',
				'green-2': 'images/texture/leaf/yin.png',
				'yellow-1': 'images/texture/leaf/sha.png',
				'yellow-2': 'images/texture/leaf/yang.png'
			}
		},
		'home': {

		},
		'studio': {
			'global': {
				'character': {
					'ollie-data': 'json/character/ollie.json',
					'ollie': 'images/character/ollie.png',
					'ollie-open': 'images/character/ollie-open.png'
				}
			},
			'livingroom': {
				'scene-data': 'json/scene/studio-livingroom.json',
				'ground-shadow-texture': 'images/texture/studio/livingroom/ground-shadow.jpg',
				'floor-texture': 'images/texture/studio/livingroom/floor.jpg',
				'wall-texture': 'images/texture/studio/livingroom/wall.jpg',
				'wall-outer-texture': 'images/texture/studio/livingroom/wall-outer.jpg',
				'ceiling-texture': 'images/texture/studio/livingroom/ceiling.jpg',
				'ceiling-lamp-1-texture': 'images/texture/studio/livingroom/ceiling-lamp-1.jpg',
				'ceiling-lamp-2-texture': 'images/texture/studio/livingroom/ceiling-lamp-2.jpg',
				'studio-door-texture': 'images/texture/studio/livingroom/studio-door.jpg',
				'studio-door-handle-texture': 'images/texture/studio/livingroom/studio-door-handle.jpg',
				'studio-door-frame-texture': 'images/texture/studio/livingroom/studio-door-frame.jpg',
				'cactus-texture': 'images/texture/studio/livingroom/cactus.jpg',
				'bathroom-door-texture': 'images/texture/studio/livingroom/bathroom-door.jpg',
				'bed-texture': 'images/texture/studio/livingroom/bed.jpg',
				'shoestorage-texture': 'images/texture/studio/livingroom/shoestorage.jpg',
				'sofabed-cabinet-texture': 'images/texture/studio/livingroom/sofabed-cabinet.jpg',
				'kitchen-cabinets-texture': 'images/texture/studio/livingroom/kitchen-cabinets.jpg',
				'kitchen-storage-texture': 'images/texture/studio/livingroom/kitchen-storage.jpg',
				'microwave-texture': 'images/texture/studio/livingroom/microwave.jpg',
				'fruitplate-texture': 'images/texture/studio/livingroom/fruitplate.jpg',
				'glamour-photo-texture': 'images/texture/studio/livingroom/glamour-photo.jpg',
				'dining-table-texture': 'images/texture/studio/livingroom/dining-table.jpg',
				'dining-chair-texture': 'images/texture/studio/livingroom/dining-chair.jpg',
				'window-books-texture': 'images/texture/studio/livingroom/window-books.jpg',
				'clock-texture': 'images/texture/studio/livingroom/clock.jpg',
				'seasoning-texture': 'images/texture/studio/livingroom/seasoning.jpg',
				'bed-shelf-texture': 'images/texture/studio/livingroom/bed-shelf.jpg',
				'kitchen-ware-texture': 'images/texture/studio/livingroom/kitchen-ware.jpg',
				'linen-cabinet-texture': 'images/texture/studio/livingroom/linen-cabinet.jpg',
				'tv-texture': 'images/texture/studio/livingroom/tv.jpg',
				'tv-table-texture': 'images/texture/studio/livingroom/tv-table.jpg',
				'sofa-texture': 'images/texture/studio/livingroom/sofa.jpg',
				'sofabed-texture': 'images/texture/studio/livingroom/sofabed.jpg',
				'book-shelf-texture': 'images/texture/studio/livingroom/book-shelf.jpg',
				'nightstand-texture': 'images/texture/studio/livingroom/nightstand.jpg',
				'kitchen-shelf-texture': 'images/texture/studio/livingroom/kitchen-shelf.jpg',
				'sewingmachine-texture': 'images/texture/studio/livingroom/sewingmachine.jpg',
				'sewingmachine-cover-texture': 'images/texture/studio/livingroom/sewingmachine-cover.jpg',
				'coffee-pot-texture': 'images/texture/studio/livingroom/coffee-pot.jpg',
				'hood-texture': 'images/texture/studio/livingroom/hood.jpg',
				'round-lamp-texture': 'images/texture/studio/livingroom/round-lamp.jpg',
				'reading-lamp-texture': 'images/texture/studio/livingroom/reading-lamp.jpg',
				'boxes-texture': 'images/texture/studio/livingroom/boxes.jpg',
				'wardrobe-texture': 'images/texture/studio/livingroom/wardrobe.jpg',
				'pictures-texture': 'images/texture/studio/livingroom/pictures.jpg',
				'refrigerator-texture': 'images/texture/studio/livingroom/refrigerator.jpg',
				'refrigerator-stuff-texture': 'images/texture/studio/livingroom/refrigerator-stuff.jpg',
				'refrigerator-door-texture': 'images/texture/studio/livingroom/refrigerator-door.jpg',
				'carpet-texture': 'images/texture/studio/livingroom/carpet.jpg',
				'laptop-texture': 'images/texture/studio/livingroom/laptop.jpg',
				'apple-in-refrigerator-texture': 'images/texture/studio/livingroom/apple-in-refrigerator.jpg',
				'pineapple-in-refrigerator-texture': 'images/texture/studio/livingroom/pineapple-in-refrigerator.jpg',
				'orange-in-refrigerator-texture': 'images/texture/studio/livingroom/orange-in-refrigerator.jpg',
				'peach-in-refrigerator-texture': 'images/texture/studio/livingroom/peach-in-refrigerator.jpg',
				'apple-in-plate-texture': 'images/texture/studio/livingroom/apple-in-plate.jpg',
				'pineapple-in-plate-texture': 'images/texture/studio/livingroom/pineapple-in-plate.jpg',
				'orange-in-plate-texture': 'images/texture/studio/livingroom/orange-in-plate.jpg',
				'peach-in-plate-texture': 'images/texture/studio/livingroom/peach-in-plate.jpg',
				'window-left-texture': 'images/texture/studio/livingroom/window-left.jpg',
				'window-left-switch-texture': 'images/texture/studio/livingroom/window-left-switch.jpg',
				'window-right-texture': 'images/texture/studio/livingroom/window-right.jpg',
				'window-right-switch-texture': 'images/texture/studio/livingroom/window-right-switch.jpg',
				'pictures': {
					'birds': 'images/texture/studio/livingroom/pictures/birds.jpg',
					'fish': 'images/texture/studio/livingroom/pictures/fish.jpg',
					'leaves': 'images/texture/studio/livingroom/pictures/leaves.jpg'
				},
				'skybox': {
					'xpos': 'images/texture/studio/livingroom/skybox/pos-x.png',
					'xneg': 'images/texture/studio/livingroom/skybox/neg-x.png',
					'ypos': 'images/texture/studio/livingroom/skybox/pos-y.png',
					'yneg': 'images/texture/studio/livingroom/skybox/neg-y.png',
					'zpos': 'images/texture/studio/livingroom/skybox/pos-z.png',
					'zneg': 'images/texture/studio/livingroom/skybox/neg-z.png'
				}
			},
			'bathroom': {
				'scene-data': 'json/scene/studio-bathroom.json',
				'ground-shadow-texture': 'images/texture/studio/bathroom/ground-shadow.jpg',
				'floor-texture': 'images/texture/studio/bathroom/floor.jpg',
				'ceiling-texture': 'images/texture/studio/bathroom/ceiling.jpg',
				'wall-texture': 'images/texture/studio/bathroom/wall.jpg',
				'wall-outer-texture': 'images/texture/studio/bathroom/wall-outer.jpg',
				'bathroom-door-texture': 'images/texture/studio/bathroom/bathroom-door.jpg',
				'door-frame-texture': 'images/texture/studio/bathroom/door-frame.jpg',
				'ceiling-lamps-texture': 'images/texture/studio/bathroom/ceiling-lamps.jpg',
				'bathrobe-texture': 'images/texture/studio/bathroom/bathrobe.jpg',
				'bathtub-texture': 'images/texture/studio/bathroom/bathtub.jpg',
				'shower-curtain-texture': 'images/texture/studio/bathroom/shower-curtain.jpg',
				'lotus-texture': 'images/texture/studio/bathroom/lotus.jpg',
				'towel-texture': 'images/texture/studio/bathroom/towel.jpg',
				'showerhead-texture': 'images/texture/studio/bathroom/showerhead.jpg',
				'shower-handle-texture': 'images/texture/studio/bathroom/shower-handle.jpg',
				'shelf-texture': 'images/texture/studio/bathroom/shelf.jpg',
				'jar-1-texture': 'images/texture/studio/bathroom/jar-1.jpg',
				'jar-2-texture': 'images/texture/studio/bathroom/jar-2.jpg',
				'jar-3-texture': 'images/texture/studio/bathroom/jar-3.jpg',
				'jar-4-texture': 'images/texture/studio/bathroom/jar-4.jpg',
				'jar-5-texture': 'images/texture/studio/bathroom/jar-5.jpg',
				'jar-6-texture': 'images/texture/studio/bathroom/jar-6.jpg',
				'jar-7-texture': 'images/texture/studio/bathroom/jar-7.jpg',
				'jar-8-texture': 'images/texture/studio/bathroom/jar-8.jpg',
				'jar-9-texture': 'images/texture/studio/bathroom/jar-9.jpg',
				'jar-10-texture': 'images/texture/studio/bathroom/jar-10.jpg',
				'closet-texture': 'images/texture/studio/bathroom/closet.jpg',
				'closet-door-texture': 'images/texture/studio/bathroom/closet-door.jpg',
				'trashcan-texture': 'images/texture/studio/bathroom/trashcan.jpg',
				'plug-texture': 'images/texture/studio/bathroom/plug.jpg',
				'fragrance-texture': 'images/texture/studio/bathroom/fragrance.jpg',
				'carpets-texture': 'images/texture/studio/bathroom/carpets.jpg',
				'toilet-texture': 'images/texture/studio/bathroom/toilet.jpg',
				'toilet-paper-texture': 'images/texture/studio/bathroom/toilet-paper.jpg',
				'washbasin-texture': 'images/texture/studio/bathroom/washbasin.jpg',
				'lamps-texture': 'images/texture/studio/bathroom/lamps.jpg',
				'flipflop-texture': 'images/texture/studio/bathroom/flipflop.jpg',
				'bottles-texture': 'images/texture/studio/bathroom/bottles.jpg',
				'towel-roll-texture': 'images/texture/studio/bathroom/towel-roll.jpg',
				'cosmetic-bag-texture': 'images/texture/studio/bathroom/cosmetic-bag.jpg',
				'skybox': {
					'xpos': 'images/texture/studio/livingroom/skybox/pos-x.png',
					'xneg': 'images/texture/studio/livingroom/skybox/neg-x.png',
					'ypos': 'images/texture/studio/livingroom/skybox/pos-y.png',
					'yneg': 'images/texture/studio/livingroom/skybox/neg-y.png',
					'zpos': 'images/texture/studio/livingroom/skybox/pos-z.png',
					'zneg': 'images/texture/studio/livingroom/skybox/neg-z.png'
				}
			}
		},
		'house': {
			'global': {
				'character': {
					'joanna-data': 'json/character/joanna.json',
					'joanna': 'images/character/joanna.png',
					'scott-data': 'json/character/scott.json',
					'scott': 'images/character/scott.png',
					'nick-data': 'json/character/nick.json',
					'nick': 'images/character/nick.png',
					'joanna-open': 'images/character/joanna-open.png',
					'scott-open': 'images/character/scott-open.png',
					'nick-open': 'images/character/nick-open.png',
					'family-open': 'images/character/family-open.png'
				}
			},
			'livingroom': {
				'scene-data': 'json/scene/house-livingroom.json',
				'ground-shadow-texture': 'images/texture/house/livingroom/ground-shadow.jpg',
				'wall-texture': 'images/texture/house/livingroom/wall.jpg',
				'wall-outer-texture': 'images/texture/house/livingroom/wall-outer.jpg',
				'stairways-texture': 'images/texture/house/livingroom/stairways.jpg',
				'stairways-handrail-texture': 'images/texture/house/livingroom/stairways-handrail.jpg',
				'stairway-lamps-texture': 'images/texture/house/livingroom/stairway-lamps.jpg',
				'ceiling-texture': 'images/texture/house/livingroom/ceiling.jpg',
				'ceiling-lamp-1-texture': 'images/texture/house/livingroom/ceiling-lamp-1.jpg',
				'ceiling-lamp-2-texture': 'images/texture/house/livingroom/ceiling-lamp-2.jpg',
				'floor-texture': 'images/texture/house/livingroom/floor.jpg',
				'door-frame-texture': 'images/texture/house/livingroom/door-frame.jpg',
				'livingroom-door-texture': 'images/texture/house/livingroom/livingroom-door.jpg',
				'windows-texture': 'images/texture/house/livingroom/windows.jpg',
				'knife-on-cabinet-texture': 'images/texture/house/livingroom/knife-on-cabinet.jpg',
				'knife-in-drawer-texture': 'images/texture/house/livingroom/knife-in-drawer.jpg',
				'kitchen-top-texture': 'images/texture/house/livingroom/kitchen-top.jpg',
				'kitchen-bottom-texture': 'images/texture/house/livingroom/kitchen-bottom.jpg',
				'kitchen-stuff-texture': 'images/texture/house/livingroom/kitchen-stuff.jpg',
				'long-table-texture': 'images/texture/house/livingroom/long-table.jpg',
				'round-table-texture': 'images/texture/house/livingroom/round-table.jpg',
				'clock-texture': 'images/texture/house/livingroom/clock.jpg',
				'bookshelf-texture': 'images/texture/house/livingroom/bookshelf.jpg',
				'bookshelf-lamps-texture': 'images/texture/house/livingroom/bookshelf-lamps.jpg',
				'window-stand-texture': 'images/texture/house/livingroom/window-stand.jpg',
				'basin-texture': 'images/texture/house/livingroom/basin.jpg',
				'cooktop-texture': 'images/texture/house/livingroom/cooktop.jpg',
				'ladder-texture': 'images/texture/house/livingroom/ladder.jpg',
				'white-sofa-texture': 'images/texture/house/livingroom/white-sofa.jpg',
				'window-blinds-texture': 'images/texture/house/livingroom/window-blinds.jpg',
				'tv-stand-texture': 'images/texture/house/livingroom/tv-stand.jpg',
				'entrance-stuff-texture': 'images/texture/house/livingroom/entrance-stuff.jpg',
				'blue-sofa-texture': 'images/texture/house/livingroom/blue-sofa.jpg',
				'pads-texture': 'images/texture/house/livingroom/pads.jpg',
				'dining-table-texture': 'images/texture/house/livingroom/dining-table.jpg',
				'dining-chairs-texture': 'images/texture/house/livingroom/dining-chairs.jpg',
				'dining-lamps-texture': 'images/texture/house/livingroom/dining-lamps.jpg',
				'divider-texture': 'images/texture/house/livingroom/divider.jpg',
				'curtain-left-texture': 'images/texture/house/livingroom/curtain-left.jpg',
				'curtain-right-texture': 'images/texture/house/livingroom/curtain-right.jpg',
				'fruitplate-texture': 'images/texture/house/livingroom/fruitplate.jpg',
				'refrigerator-texture': 'images/texture/house/livingroom/refrigerator.jpg',
				'living-area-lamp-texture': 'images/texture/house/livingroom/living-area-lamp.jpg',
				'living-area-carpet-texture': 'images/texture/house/livingroom/living-area-carpet.jpg',
				'cupboard-texture': 'images/texture/house/livingroom/cupboard.jpg',
				'heater-texture': 'images/texture/house/livingroom/heater.jpg',
				'drawer-texture': 'images/texture/house/livingroom/drawer.jpg',
				'windowsill-stuff-texture': 'images/texture/house/livingroom/windowsill-stuff.jpg',
				'goldfish-texture': 'images/texture/house/livingroom/goldfish.jpg',
				'fish-bowl-texture': 'images/texture/house/livingroom/fish-bowl.jpg',
				'fish-bowl-stand-texture': 'images/texture/house/livingroom/fish-bowl-stand.jpg',
				'skybox': {
					'xpos': 'images/texture/house/boysroom/skybox/pos-x.jpg',
					'xneg': 'images/texture/house/boysroom/skybox/neg-x.jpg',
					'ypos': 'images/texture/house/boysroom/skybox/pos-y.jpg',
					'yneg': 'images/texture/house/boysroom/skybox/neg-y.jpg',
					'zpos': 'images/texture/house/boysroom/skybox/pos-z.jpg',
					'zneg': 'images/texture/house/boysroom/skybox/neg-z.jpg'
				},
			},
			'corridor': {
				'scene-data': 'json/scene/house-corridor.json',
				'ground-shadow-texture': 'images/texture/house/corridor/ground-shadow.jpg',
				'ceiling-texture': 'images/texture/house/corridor/ceiling.jpg',
				'ceiling-lamp-texture': 'images/texture/house/corridor/ceiling-lamp.jpg',
				'ceiling-lamps-texture': 'images/texture/house/corridor/ceiling-lamps.jpg',
				'floor-texture': 'images/texture/house/corridor/floor.jpg',
				'wall-texture': 'images/texture/house/corridor/wall.jpg',
				'wall-outer-texture': 'images/texture/house/corridor/wall-outer.jpg',
				'picture-wall-texture': 'images/texture/house/corridor/picture-wall.jpg',
				'door-frames-texture': 'images/texture/house/corridor/door-frames.jpg',
				'display-table-texture': 'images/texture/house/corridor/display-table.jpg',
				'cat-bed-texture': 'images/texture/house/corridor/cat-bed.jpg',
				'cat-texture': 'images/texture/house/corridor/cat.jpg',
				'corridor-window-texture': 'images/texture/house/corridor/corridor-window.jpg',
				'corridor-stuff-texture': 'images/texture/house/corridor/corridor-stuff.jpg',
				'nick-photo-texture': 'images/texture/house/corridor/nick-photo.jpg',
				'window-plant-texture': 'images/texture/house/corridor/window-plant.jpg',
				'homeoffice-door-texture': 'images/texture/house/corridor/homeoffice-door.jpg',
				'bedroom-door-texture': 'images/texture/house/corridor/bedroom-door.png',
				'boysroom-door-texture': 'images/texture/house/corridor/boysroom-door.jpg',
				'bathroom-door-texture': 'images/texture/house/corridor/bathroom-door.png',
				'skybox': {
					'xpos': 'images/texture/house/boysroom/skybox/pos-x.jpg',
					'xneg': 'images/texture/house/boysroom/skybox/neg-x.jpg',
					'ypos': 'images/texture/house/boysroom/skybox/pos-y.jpg',
					'yneg': 'images/texture/house/boysroom/skybox/neg-y.jpg',
					'zpos': 'images/texture/house/boysroom/skybox/pos-z.jpg',
					'zneg': 'images/texture/house/boysroom/skybox/neg-z.jpg'
				},
			},
			'boysroom': {
				'scene-data': 'json/scene/house-boysroom.json',
				'ground-shadow-texture': 'images/texture/house/boysroom/ground-shadow.jpg',
				'floor-texture': 'images/texture/house/boysroom/floor.jpg',
				'ceiling-texture': 'images/texture/house/boysroom/ceiling.jpg',
				'wall-texture': 'images/texture/house/boysroom/wall.jpg',
				'wall-outer-texture': 'images/texture/house/boysroom/wall-outer.jpg',
				'cabinet-texture': 'images/texture/house/boysroom/cabinet.jpg',
				'bed-texture': 'images/texture/house/boysroom/bed.jpg',
				'big-frame-texture': 'images/texture/house/boysroom/big-frame.jpg',
				'big-frame-picture-texture': 'images/texture/house/boysroom/pictures/shark.jpg',
				'decoration-pictures-texture': 'images/texture/house/boysroom/decoration-pictures.jpg',
				'ceiling-lamps-texture': 'images/texture/house/boysroom/ceiling-lamps.jpg',
				'stools-texture': 'images/texture/house/boysroom/stools.jpg',
				'football-texture': 'images/texture/house/boysroom/football.jpg',
				'bear-in-drawer-texture': 'images/texture/house/boysroom/bear-in-drawer.jpg',
				'bear-on-bed-texture': 'images/texture/house/boysroom/bear-on-bed.jpg',
				'moon-texture': 'images/texture/house/boysroom/moon.jpg',
				'carpet-texture': 'images/texture/house/boysroom/carpet.jpg',
				'shelf-stuff-1-texture': 'images/texture/house/boysroom/shelf-stuff-1.jpg',
				'shelf-stuff-2-texture': 'images/texture/house/boysroom/shelf-stuff-2.jpg',
				'shelf-stuff-3-texture': 'images/texture/house/boysroom/shelf-stuff-3.jpg',
				'shelf-stuff-4-texture': 'images/texture/house/boysroom/shelf-stuff-4.jpg',
				'shelf-stuff-5-texture': 'images/texture/house/boysroom/shelf-stuff-5.jpg',
				'shelf-stuff-6-texture': 'images/texture/house/boysroom/shelf-stuff-6.jpg',
				'toytrain-texture': 'images/texture/house/boysroom/toytrain.jpg',
				'sketchpad-texture': 'images/texture/house/boysroom/sketchpad.jpg',
				'nightstand-lamp-texture': 'images/texture/house/boysroom/nightstand-lamp.jpg',
				'yellow-reading-lamp-texture': 'images/texture/house/boysroom/yellow-reading-lamp.jpg',
				'blue-reading-lamp-texture': 'images/texture/house/boysroom/blue-reading-lamp.jpg',
				'bedding-texture': 'images/texture/house/boysroom/bedding.jpg',
				'chalkboard-texture': 'images/texture/house/boysroom/chalkboard.jpg',
				'slippers-texture': 'images/texture/house/boysroom/slippers.jpg',
				'table-books-texture': 'images/texture/house/boysroom/table-books.jpg',
				'computer-on-table-texture': 'images/texture/house/boysroom/computer-on-table.jpg',
				'computer-on-desk-texture': 'images/texture/house/boysroom/computer-on-desk.jpg',
				'table-texture': 'images/texture/house/boysroom/table.jpg',
				'table-stuff-texture': 'images/texture/house/boysroom/table-stuff.jpg',
				'desk-texture': 'images/texture/house/boysroom/desk.jpg',
				'swivel-chair-texture': 'images/texture/house/boysroom/swivel-chair.jpg',
				'shelf-left-texture': 'images/texture/house/boysroom/shelf-left.jpg',
				'shelf-right-texture': 'images/texture/house/boysroom/shelf-right.jpg',
				'pencil-vase-texture': 'images/texture/house/boysroom/pencil-vase.jpg',
				'nightstand-texture': 'images/texture/house/boysroom/nightstand.jpg',
				'drawer-texture': 'images/texture/house/boysroom/drawer.jpg',
				'handheld-nightstand-texture': 'images/texture/house/boysroom/handheld-nightstand.jpg',
				'window-texture': 'images/texture/house/boysroom/window.jpg',
				'window-frame-texture': 'images/texture/house/boysroom/window-frame.jpg',
				'boysroom-door-texture': 'images/texture/house/boysroom/boysroom-door.jpg',
				'door-frame-texture': 'images/texture/house/boysroom/door-frame.jpg',
				'pictures': {
					'family': 'images/texture/house/boysroom/pictures/1.jpg',
					'hug': 'images/texture/house/boysroom/pictures/2.jpg'
				},
				'skybox': {
					'xpos': 'images/texture/house/boysroom/skybox/pos-x.jpg',
					'xneg': 'images/texture/house/boysroom/skybox/neg-x.jpg',
					'ypos': 'images/texture/house/boysroom/skybox/pos-y.jpg',
					'yneg': 'images/texture/house/boysroom/skybox/neg-y.jpg',
					'zpos': 'images/texture/house/boysroom/skybox/pos-z.jpg',
					'zneg': 'images/texture/house/boysroom/skybox/neg-z.jpg'
				}
			},
			'homeoffice': {
				'scene-data': 'json/scene/house-homeoffice.json',
				'ground-shadow-texture': 'images/texture/house/homeoffice/ground-shadow.jpg',
				'floor-texture': 'images/texture/house/homeoffice/floor.jpg',
				'ceiling-texture': 'images/texture/house/homeoffice/ceiling.jpg',
				'wall-texture':	'images/texture/house/homeoffice/wall.jpg',
				'wall-outer-texture': 'images/texture/house/homeoffice/wall-outer.jpg',
				'swivel-chair-texture': 'images/texture/house/homeoffice/swivel-chair.jpg',
				'storage-texture': 'images/texture/house/homeoffice/storage.jpg',
				'setsquare-texture': 'images/texture/house/homeoffice/setsquare.jpg',
				'carpet-texture': 'images/texture/house/homeoffice/carpet.jpg',
				'door-frame-texture': 'images/texture/house/homeoffice/door-frame.jpg',
				'homeoffice-door-texture': 'images/texture/house/homeoffice/homeoffice-door.jpg',
				'display-shelf-lamp-texture': 'images/texture/house/homeoffice/display-shelf-lamp.jpg',
				'bookshelf-lamps-texture': 'images/texture/house/homeoffice/bookshelf-lamps.jpg',
				'picture-frame-1-texture': 'images/texture/house/homeoffice/picture-frame-1.jpg',
				'picture-frame-2-texture': 'images/texture/house/homeoffice/picture-frame-2.jpg',
				'picture-frame-3-texture': 'images/texture/house/homeoffice/picture-frame-3.jpg',
				'picture-frame-4-texture': 'images/texture/house/homeoffice/picture-frame-4.jpg',
				'block-shelf-1-texture': 'images/texture/house/homeoffice/block-shelf-1.jpg',
				'block-shelf-2-texture': 'images/texture/house/homeoffice/block-shelf-2.jpg',
				'block-stuff-1-texture': 'images/texture/house/homeoffice/block-stuff-1.jpg',
				'block-stuff-2-texture': 'images/texture/house/homeoffice/block-stuff-2.jpg',
				'books-1-texture': 'images/texture/house/homeoffice/books-1.jpg',
				'books-2-texture': 'images/texture/house/homeoffice/books-2.jpg',
				'round-lamp-texture': 'images/texture/house/homeoffice/round-lamp.jpg',
				'calendar-texture': 'images/texture/house/homeoffice/calendar.jpg',
				'magazine-texture': 'images/texture/house/homeoffice/magazine.jpg',
				'window-texture': 'images/texture/house/homeoffice/window.jpg',
				'armchair-texture': 'images/texture/house/homeoffice/armchair.jpg',
				'coffeecup-texture': 'images/texture/house/homeoffice/coffeecup.jpg',
				'writing-desk-texture': 'images/texture/house/homeoffice/writing-desk.jpg',
				'dracaena-fragrans-texture': 'images/texture/house/homeoffice/dracaena-fragrans.jpg',
				'handbag-texture': 'images/texture/house/homeoffice/handbag.jpg',
				'pen-vase-texture': 'images/texture/house/homeoffice/pen-vase.jpg',
				'rubberplant-texture': 'images/texture/house/homeoffice/rubberplant.jpg',
				'coffee-table-texture': 'images/texture/house/homeoffice/coffee-table.jpg',
				'floor-lamp-texture': 'images/texture/house/homeoffice/floor-lamp.jpg',
				'ceiling-lamp-texture': 'images/texture/house/homeoffice/ceiling-lamp.jpg',
				'cup-texture': 'images/texture/house/homeoffice/cup.jpg',
				'reading-lamp-1-texture': 'images/texture/house/homeoffice/reading-lamp-1.jpg',
				'reading-lamp-2-texture': 'images/texture/house/homeoffice/reading-lamp-2.jpg',
				'sofa-texture': 'images/texture/house/homeoffice/sofa.jpg',
				'trash-texture': 'images/texture/house/homeoffice/trash.jpg',
				'display-shelf-texture': 'images/texture/house/homeoffice/display-shelf.jpg',
				'computer-texture': 'images/texture/house/homeoffice/computer.jpg',
				'laptop-texture': 'images/texture/house/homeoffice/laptop.jpg',
				'curtain-texture': 'images/texture/house/homeoffice/curtain.jpg',
				'curtain-rod-texture': 'images/texture/house/homeoffice/curtain-rod.jpg',
				'telephone-texture': 'images/texture/house/homeoffice/telephone.jpg',
				'bookshelf-texture': 'images/texture/house/homeoffice/bookshelf.jpg',
				'bookshelf-stuff-texture': 'images/texture/house/homeoffice/bookshelf-stuff.jpg',
				'pictures': {
					'1': 'images/texture/house/homeoffice/pictures/1.jpg',
					'2': 'images/texture/house/homeoffice/pictures/2.jpg',
					'3': 'images/texture/house/homeoffice/pictures/3.jpg',
					'4': 'images/texture/house/homeoffice/pictures/4.jpg',
					'degree': 'images/texture/house/homeoffice/pictures/degree.jpg',
					'hug': 'images/texture/house/homeoffice/pictures/hug.jpg',
					'family': 'images/texture/house/homeoffice/pictures/family.jpg',
					'lecture': 'images/texture/house/homeoffice/pictures/lecture.jpg'
				},
				'skybox': {
					'xpos': 'images/texture/house/boysroom/skybox/pos-x.jpg',
					'xneg': 'images/texture/house/boysroom/skybox/neg-x.jpg',
					'ypos': 'images/texture/house/boysroom/skybox/pos-y.jpg',
					'yneg': 'images/texture/house/boysroom/skybox/neg-y.jpg',
					'zpos': 'images/texture/house/boysroom/skybox/pos-z.jpg',
					'zneg': 'images/texture/house/boysroom/skybox/neg-z.jpg'
				}
			}
		}
	};
};
goog.addSingletonGetter(feng.models.Preload);


feng.models.Preload.prototype.getDataByKeys = function( keys ) {

	//keys should be of the format 'key1.key2.key3..'

	var asset = this._assets;

	var keys = keys.split('.');
	var lastKey = keys[keys.length - 1];

	goog.array.forEach(keys, function(key) {
		asset = asset[key];
	});

	return asset;
};


feng.models.Preload.prototype.getManifest = function( keys ) {

	var asset = this.getDataByKeys( keys );

	var manifest = [];

	var parseLoadItem = function(obj) {

		if( goog.string.endsWith(obj.src, '.dds') ) {
			obj.type = createjs.LoadQueue.BINARY;
		}

		return obj;
	};

	var parseObject = function(key, asset) {

		goog.object.forEach(asset, function(obj, id) {

			if(goog.isString(obj)) {

				// if obj is an Url rather than result
				var loadItem = parseLoadItem( {id: key+'.'+id, src: obj} );
				manifest.push( loadItem );

			}else {
				
				// if obj is an Object contains keys, parse it again
				parseObject(key+'.'+id, obj);
			}
		});
	};

	if(goog.isString(asset)) {

		var loadItem = parseLoadItem( {id: keys, src: asset} );
		manifest.push( loadItem );

	}else {

		var key = keys;
		var object = asset;
		parseObject(key, object);
	}

	return manifest;
};


feng.models.Preload.prototype.getAsset = function( keys ) {

	var asset = this.getDataByKeys( keys );

	return goog.isString(asset) ? null : asset;
};


feng.models.Preload.prototype.setAsset = function( keys, result ) {

	feng.utils.Utils.setValueByKeys(keys, result, this._assets);
};goog.provide('feng.views.Preloader');

goog.require('goog.events.EventTarget');
goog.require('feng.models.Preload');
goog.require('feng.events');


/**
 * @constructor
 */
feng.views.Preloader = function(domElement, duration){

  goog.base(this);

  this.model = feng.models.Preload.getInstance();
  this.isCompleted = false;
  
  this._domElement = domElement;

  this._loader = new createjs.LoadQueue(true, feng.Config['assetsPath']);
  createjs.LoadQueue.loadTimeout = 100000;

  this._onLoadStart = goog.bind(this.onLoadStart, this);
  this._onFileLoad = goog.bind(this.onFileLoad, this);
  this._onComplete = goog.bind(this.onComplete, this);
  this._onError = goog.bind(this.onError, this);

  var fps = 30;
  this._ticker = new goog.Timer(1000/fps);
  goog.events.listen(this._ticker, goog.Timer.TICK, this.onTick, false, this);

  this._ticked = 0;
  this._progress = 0;
  this._duration = duration || 1000;
  this._durationPerTick = this._duration / (this._duration / (1000/fps));
};
goog.inherits(feng.views.Preloader, goog.events.EventTarget);


feng.views.Preloader.prototype.load = function( keys ){

	this.isCompleted = false;

	this._loader.removeAllEventListeners();

	this._loader.addEventListener("fileload", this._onFileLoad);
	this._loader.addEventListener("complete", this._onComplete);
	this._loader.addEventListener("error", this._onError);
	this._loader.setMaxConnections(5);

	var manifest = [];

	if(goog.isString(keys)) {

		manifest = manifest.concat( this.model.getManifest( keys ) );

	}else if(goog.isArray(keys)) {

		goog.array.forEach(keys, function(key) {
			manifest = manifest.concat( this.model.getManifest( key ) );
		}, this);
	}

	if(manifest.length > 0) {

		this._loader.loadManifest( manifest );
	}

	this.onLoadStart();

	this._ticked = 1;
	this._ticker.start();
};


feng.views.Preloader.prototype.onLoadStart = function(e){

	console.log('preloader loads start');
	
	this.dispatchEvent({
		type: feng.events.EventType.START
	});
};


feng.views.Preloader.prototype.onFileLoad = function(e){

	this.model.setAsset(e.item.id, e.result);

	this.dispatchEvent({
		type: feng.events.EventType.LOAD,
		id: e.item.id,
		result: e.result
	});
};


feng.views.Preloader.prototype.onComplete = function(e){

	if(this._loader.loaded && this._loader.hasEventListener("complete")) {

		console.log('preloader files load complete');

		this._loader.removeAllEventListeners();

		this.dispatchEvent({
			type: feng.events.EventType.LOAD_COMPLETE
		});
	}

	if(!this.isCompleted && this._progress === 1) {

		console.log('preloader animation progress complete');

		this._ticker.stop();

		this.isCompleted = true;

		this.dispatchEvent({
			type: feng.events.EventType.COMPLETE
		});
	}
};


feng.views.Preloader.prototype.onError = function(e){

	console.log('load error');

	this._loader.reset();

	this._ticker.stop();

	this.dispatchEvent({
		type: feng.events.EventType.ERROR
	});
};


feng.views.Preloader.prototype.onTick = function(e){

	var progress = this._durationPerTick * this._ticked / this._duration;
	progress = Math.min(progress, this._loader.progress, 1);

	if(progress === this._progress) {

		return;

	}else {

		this._progress = progress;
		this._ticked ++;

		this.dispatchEvent({
			type: feng.events.EventType.PROGRESS,
			progress: this._progress
		});

	}

	if(this._progress === 1) {

		this.onComplete();
	}
};// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a class useful for handling functions that must be
 * invoked after a delay, especially when that delay is frequently restarted.
 * Examples include delaying before displaying a tooltip, menu hysteresis,
 * idle timers, etc.
 * @author brenneman@google.com (Shawn Brenneman)
 * @see ../demos/timers.html
 */


goog.provide('goog.Delay');
goog.provide('goog.async.Delay');

goog.require('goog.Disposable');
goog.require('goog.Timer');



/**
 * A Delay object invokes the associated function after a specified delay. The
 * interval duration can be specified once in the constructor, or can be defined
 * each time the delay is started. Calling start on an active delay will reset
 * the timer.
 *
 * @param {Function} listener Function to call when the delay completes.
 * @param {number=} opt_interval The default length of the invocation delay (in
 *     milliseconds).
 * @param {Object=} opt_handler The object scope to invoke the function in.
 * @constructor
 * @extends {goog.Disposable}
 * @final
 */
goog.async.Delay = function(listener, opt_interval, opt_handler) {
  goog.Disposable.call(this);

  /**
   * The function that will be invoked after a delay.
   * @type {Function}
   * @private
   */
  this.listener_ = listener;

  /**
   * The default amount of time to delay before invoking the callback.
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 0;

  /**
   * The object context to invoke the callback in.
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;


  /**
   * Cached callback function invoked when the delay finishes.
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.Delay, goog.Disposable);



/**
 * A deprecated alias.
 * @deprecated Use goog.async.Delay instead.
 * @constructor
 * @final
 */
goog.Delay = goog.async.Delay;


/**
 * Identifier of the active delay timeout, or 0 when inactive.
 * @type {number}
 * @private
 */
goog.async.Delay.prototype.id_ = 0;


/**
 * Disposes of the object, cancelling the timeout if it is still outstanding and
 * removing all object references.
 * @override
 * @protected
 */
goog.async.Delay.prototype.disposeInternal = function() {
  goog.async.Delay.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.listener_;
  delete this.handler_;
};


/**
 * Starts the delay timer. The provided listener function will be called after
 * the specified interval. Calling start on an active timer will reset the
 * delay interval.
 * @param {number=} opt_interval If specified, overrides the object's default
 *     interval with this one (in milliseconds).
 */
goog.async.Delay.prototype.start = function(opt_interval) {
  this.stop();
  this.id_ = goog.Timer.callOnce(
      this.callback_,
      goog.isDef(opt_interval) ? opt_interval : this.interval_);
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.Delay.prototype.stop = function() {
  if (this.isActive()) {
    goog.Timer.clear(this.id_);
  }
  this.id_ = 0;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.Delay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.Delay.prototype.fireIfActive = function() {
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.Delay.prototype.isActive = function() {
  return this.id_ != 0;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.Delay.prototype.doAction_ = function() {
  this.id_ = 0;
  if (this.listener_) {
    this.listener_.call(this.handler_);
  }
};
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A delayed callback that pegs to the next animation frame
 * instead of a user-configurable timeout.
 *
 */

goog.provide('goog.async.AnimationDelay');

goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.functions');



// TODO(nicksantos): Should we factor out the common code between this and
// goog.async.Delay? I'm not sure if there's enough code for this to really
// make sense. Subclassing seems like the wrong approach for a variety of
// reasons. Maybe there should be a common interface?



/**
 * A delayed callback that pegs to the next animation frame
 * instead of a user configurable timeout. By design, this should have
 * the same interface as goog.async.Delay.
 *
 * Uses requestAnimationFrame and friends when available, but falls
 * back to a timeout of goog.async.AnimationDelay.TIMEOUT.
 *
 * For more on requestAnimationFrame and how you can use it to create smoother
 * animations, see:
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 *
 * @param {function(number)} listener Function to call when the delay completes.
 *     Will be passed the timestamp when it's called, in unix ms.
 * @param {Window=} opt_window The window object to execute the delay in.
 *     Defaults to the global object.
 * @param {Object=} opt_handler The object scope to invoke the function in.
 * @constructor
 * @extends {goog.Disposable}
 * @final
 */
goog.async.AnimationDelay = function(listener, opt_window, opt_handler) {
  goog.base(this);

  /**
   * The function that will be invoked after a delay.
   * @type {function(number)}
   * @private
   */
  this.listener_ = listener;

  /**
   * The object context to invoke the callback in.
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;

  /**
   * @type {Window}
   * @private
   */
  this.win_ = opt_window || window;

  /**
   * Cached callback function invoked when the delay finishes.
   * @type {function()}
   * @private
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.AnimationDelay, goog.Disposable);


/**
 * Identifier of the active delay timeout, or event listener,
 * or null when inactive.
 * @type {goog.events.Key|number|null}
 * @private
 */
goog.async.AnimationDelay.prototype.id_ = null;


/**
 * If we're using dom listeners.
 * @type {?boolean}
 * @private
 */
goog.async.AnimationDelay.prototype.usingListeners_ = false;


/**
 * Default wait timeout for animations (in milliseconds).  Only used for timed
 * animation, which uses a timer (setTimeout) to schedule animation.
 *
 * @type {number}
 * @const
 */
goog.async.AnimationDelay.TIMEOUT = 20;


/**
 * Name of event received from the requestAnimationFrame in Firefox.
 *
 * @type {string}
 * @const
 * @private
 */
goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_ = 'MozBeforePaint';


/**
 * Starts the delay timer. The provided listener function will be called
 * before the next animation frame.
 */
goog.async.AnimationDelay.prototype.start = function() {
  this.stop();
  this.usingListeners_ = false;

  var raf = this.getRaf_();
  var cancelRaf = this.getCancelRaf_();
  if (raf && !cancelRaf && this.win_.mozRequestAnimationFrame) {
    // Because Firefox (Gecko) runs animation in separate threads, it also saves
    // time by running the requestAnimationFrame callbacks in that same thread.
    // Sadly this breaks the assumption of implicit thread-safety in JS, and can
    // thus create thread-based inconsistencies on counters etc.
    //
    // Calling cycleAnimations_ using the MozBeforePaint event instead of as
    // callback fixes this.
    //
    // Trigger this condition only if the mozRequestAnimationFrame is available,
    // but not the W3C requestAnimationFrame function (as in draft) or the
    // equivalent cancel functions.
    this.id_ = goog.events.listen(
        this.win_,
        goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_,
        this.callback_);
    this.win_.mozRequestAnimationFrame(null);
    this.usingListeners_ = true;
  } else if (raf && cancelRaf) {
    this.id_ = raf.call(this.win_, this.callback_);
  } else {
    this.id_ = this.win_.setTimeout(
        // Prior to Firefox 13, Gecko passed a non-standard parameter
        // to the callback that we want to ignore.
        goog.functions.lock(this.callback_),
        goog.async.AnimationDelay.TIMEOUT);
  }
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.AnimationDelay.prototype.stop = function() {
  if (this.isActive()) {
    var raf = this.getRaf_();
    var cancelRaf = this.getCancelRaf_();
    if (raf && !cancelRaf && this.win_.mozRequestAnimationFrame) {
      goog.events.unlistenByKey(this.id_);
    } else if (raf && cancelRaf) {
      cancelRaf.call(this.win_, /** @type {number} */ (this.id_));
    } else {
      this.win_.clearTimeout(/** @type {number} */ (this.id_));
    }
  }
  this.id_ = null;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.AnimationDelay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.AnimationDelay.prototype.fireIfActive = function() {
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.AnimationDelay.prototype.isActive = function() {
  return this.id_ != null;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.AnimationDelay.prototype.doAction_ = function() {
  if (this.usingListeners_ && this.id_) {
    goog.events.unlistenByKey(this.id_);
  }
  this.id_ = null;

  // We are not using the timestamp returned by requestAnimationFrame
  // because it may be either a Date.now-style time or a
  // high-resolution time (depending on browser implementation). Using
  // goog.now() will ensure that the timestamp used is consistent and
  // compatible with goog.fx.Animation.
  this.listener_.call(this.handler_, goog.now());
};


/** @override */
goog.async.AnimationDelay.prototype.disposeInternal = function() {
  this.stop();
  goog.base(this, 'disposeInternal');
};


/**
 * @return {?function(function(number)): number} The requestAnimationFrame
 *     function, or null if not available on this browser.
 * @private
 */
goog.async.AnimationDelay.prototype.getRaf_ = function() {
  var win = this.win_;
  return win.requestAnimationFrame ||
      win.webkitRequestAnimationFrame ||
      win.mozRequestAnimationFrame ||
      win.oRequestAnimationFrame ||
      win.msRequestAnimationFrame ||
      null;
};


/**
 * @return {?function(number): number} The cancelAnimationFrame function,
 *     or null if not available on this browser.
 * @private
 */
goog.async.AnimationDelay.prototype.getCancelRaf_ = function() {
  var win = this.win_;
  return win.cancelRequestAnimationFrame ||
      win.webkitCancelRequestAnimationFrame ||
      win.mozCancelRequestAnimationFrame ||
      win.oCancelRequestAnimationFrame ||
      win.msCancelRequestAnimationFrame ||
      null;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Basic animation controls.
 *
 */
goog.provide('goog.fx.anim');
goog.provide('goog.fx.anim.Animated');

goog.require('goog.async.AnimationDelay');
goog.require('goog.async.Delay');
goog.require('goog.object');



/**
 * An interface for programatically animated objects. I.e. rendered in
 * javascript frame by frame.
 *
 * @interface
 */
goog.fx.anim.Animated = function() {};


/**
 * Function called when a frame is requested for the animation.
 *
 * @param {number} now Current time in milliseconds.
 */
goog.fx.anim.Animated.prototype.onAnimationFrame;


/**
 * Default wait timeout for animations (in milliseconds).  Only used for timed
 * animation, which uses a timer (setTimeout) to schedule animation.
 *
 * @type {number}
 * @const
 */
goog.fx.anim.TIMEOUT = goog.async.AnimationDelay.TIMEOUT;


/**
 * A map of animations which should be cycled on the global timer.
 *
 * @type {Object.<number, goog.fx.anim.Animated>}
 * @private
 */
goog.fx.anim.activeAnimations_ = {};


/**
 * An optional animation window.
 * @type {Window}
 * @private
 */
goog.fx.anim.animationWindow_ = null;


/**
 * An interval ID for the global timer or event handler uid.
 * @type {goog.async.Delay|goog.async.AnimationDelay}
 * @private
 */
goog.fx.anim.animationDelay_ = null;


/**
 * Registers an animation to be cycled on the global timer.
 * @param {goog.fx.anim.Animated} animation The animation to register.
 */
goog.fx.anim.registerAnimation = function(animation) {
  var uid = goog.getUid(animation);
  if (!(uid in goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.activeAnimations_[uid] = animation;
  }

  // If the timer is not already started, start it now.
  goog.fx.anim.requestAnimationFrame_();
};


/**
 * Removes an animation from the list of animations which are cycled on the
 * global timer.
 * @param {goog.fx.anim.Animated} animation The animation to unregister.
 */
goog.fx.anim.unregisterAnimation = function(animation) {
  var uid = goog.getUid(animation);
  delete goog.fx.anim.activeAnimations_[uid];

  // If a timer is running and we no longer have any active timers we stop the
  // timers.
  if (goog.object.isEmpty(goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.cancelAnimationFrame_();
  }
};


/**
 * Tears down this module. Useful for testing.
 */
// TODO(nicksantos): Wow, this api is pretty broken. This should be fixed.
goog.fx.anim.tearDown = function() {
  goog.fx.anim.animationWindow_ = null;
  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.activeAnimations_ = {};
};


/**
 * Registers an animation window. This allows usage of the timing control API
 * for animations. Note that this window must be visible, as non-visible
 * windows can potentially stop animating. This window does not necessarily
 * need to be the window inside which animation occurs, but must remain visible.
 * See: https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame.
 *
 * @param {Window} animationWindow The window in which to animate elements.
 */
goog.fx.anim.setAnimationWindow = function(animationWindow) {
  // If a timer is currently running, reset it and restart with new functions
  // after a timeout. This is to avoid mismatching timer UIDs if we change the
  // animation window during a running animation.
  //
  // In practice this cannot happen before some animation window and timer
  // control functions has already been set.
  var hasTimer =
      goog.fx.anim.animationDelay_ && goog.fx.anim.animationDelay_.isActive();

  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.animationWindow_ = animationWindow;

  // If the timer was running, start it again.
  if (hasTimer) {
    goog.fx.anim.requestAnimationFrame_();
  }
};


/**
 * Requests an animation frame based on the requestAnimationFrame and
 * cancelRequestAnimationFrame function pair.
 * @private
 */
goog.fx.anim.requestAnimationFrame_ = function() {
  if (!goog.fx.anim.animationDelay_) {
    // We cannot guarantee that the global window will be one that fires
    // requestAnimationFrame events (consider off-screen chrome extension
    // windows). Default to use goog.async.Delay, unless
    // the client has explicitly set an animation window.
    if (goog.fx.anim.animationWindow_) {
      // requestAnimationFrame will call cycleAnimations_ with the current
      // time in ms, as returned from goog.now().
      goog.fx.anim.animationDelay_ = new goog.async.AnimationDelay(
          function(now) {
            goog.fx.anim.cycleAnimations_(now);
          }, goog.fx.anim.animationWindow_);
    } else {
      goog.fx.anim.animationDelay_ = new goog.async.Delay(function() {
        goog.fx.anim.cycleAnimations_(goog.now());
      }, goog.fx.anim.TIMEOUT);
    }
  }

  var delay = goog.fx.anim.animationDelay_;
  if (!delay.isActive()) {
    delay.start();
  }
};


/**
 * Cancels an animation frame created by requestAnimationFrame_().
 * @private
 */
goog.fx.anim.cancelAnimationFrame_ = function() {
  if (goog.fx.anim.animationDelay_) {
    goog.fx.anim.animationDelay_.stop();
  }
};


/**
 * Cycles through all registered animations.
 * @param {number} now Current time in milliseconds.
 * @private
 */
goog.fx.anim.cycleAnimations_ = function(now) {
  goog.object.forEach(goog.fx.anim.activeAnimations_, function(anim) {
    anim.onAnimationFrame(now);
  });

  if (!goog.object.isEmpty(goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.requestAnimationFrame_();
  }
};
// This file was automatically generated from common.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.common');

goog.require('soy');
goog.require('soydata');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.Disc = function(opt_data, opt_ignored) {
  return '<div class="disc"><div class="outer"></div><div class="inner"><div class="content">' + opt_data.content + '</div></div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.PrimaryButton = function(opt_data, opt_ignored) {
  return (opt_data.href) ? '<a class="primary-button ' + opt_data.classname + '" href="' + opt_data.href + '" draggable="false">' + ((opt_data.icon) ? '<span class="icon ' + opt_data.icon + '"></span>' : '') + opt_data.text + '</a>' : '<button class="primary-button ' + opt_data.classname + '">' + ((opt_data.icon) ? '<span class="icon ' + opt_data.icon + '"></span>' : '') + opt_data.text + '</button>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.CloseButton = function(opt_data, opt_ignored) {
  return '<button class="icon icon-close close-button"></button>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.ScrollBar = function(opt_data, opt_ignored) {
  return '<div class="scrollbar"><button class="handle"></button></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.FengshuiLogo = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="fengshui-logo"><div class="symbol"><div class="needle"></div><div class="frame"></div></div>' + ((opt_data.noText != true) ? '<h1><div class="line1">FENGSHUI</div><div class="line2">REALTIME</div></h1>' : '') + '</div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.Popup = function(opt_data, opt_ignored) {
  return '<div class="popup ' + ((opt_data.classname) ? opt_data.classname : '') + '"><div class="content">' + opt_data.content + '</div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.TutorialPopup = function(opt_data, opt_ignored) {
  return feng.templates.common.Popup({classname: 'tutorial from-bottom', content: '<div class="subtitle"><p>WHAT TO DO</p><div class="line"></div></div><ul class="title"><li><h1>Explore<br>the environment</h1></li><li><h1>Discover<br>Feng Shui tips</h1></li><li><h1>Inquire<br>clues from your clients</h1></li></ul><div class="instructions"><button class="prev icon icon-prev" disabled></button><button class="next icon icon-next" disabled></button><ul class="steps"><li><video preload="metadata"><source src="' + opt_data.assetsPath + 'video/tutorial-1.mp4" type="video/mp4"><source src="' + opt_data.assetsPath + 'video/tutorial-1.ogv" type="video/ogg"></video></li><li><video preload="metadata"><source src="' + opt_data.assetsPath + 'video/tutorial-2.mp4" type="video/mp4"><source src="' + opt_data.assetsPath + 'video/tutorial-2.ogv" type="video/ogg"></video></li><li><video preload="metadata"><source src="' + opt_data.assetsPath + 'video/tutorial-3.mp4" type="video/mp4"><source src="' + opt_data.assetsPath + 'video/tutorial-3.ogv" type="video/ogg"></video></li></ul></div><div class="controls hidden"><div class="loader"><div class="bar"><div class="fill"></div></div><p class="counter">00</p></div>' + feng.templates.common.PrimaryButton({classname: 'skip', icon: 'icon-yes', text: 'OK'}) + '</div>'});
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.CreditsPopup = function(opt_data, opt_ignored) {
  return feng.templates.common.Popup({classname: 'credits from-bottom', content: '<h1>Credits and References</h1><div class="scroller"><div class="content"></div>' + feng.templates.common.ScrollBar(null) + '</div>' + feng.templates.common.PrimaryButton({classname: 'skip', icon: 'icon-yes', text: 'OK'})});
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.Helper = function(opt_data, opt_ignored) {
  return '<div class="helper ' + opt_data.classname + '"><div class="content">' + opt_data.content + '</div>' + feng.templates.common.CloseButton(null) + '</div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.common.Helpers = function(opt_data, opt_ignored) {
  return '<div class="helpers">' + feng.templates.common.Helper({classname: 'compass', content: '<p class="top">View from <b>top</b>.</p><p class="normal">Back to <b>normal view</b>.</p>'}) + feng.templates.common.Helper({classname: 'selector', content: '<p><b>Pressing down</b> the mouse button for<br><b>one second</b> to investigate this item.</p>'}) + feng.templates.common.Helper({classname: 'walk', content: '<p class="mousewheel">You can also <b>scroll</b> the mousewheel<br>to move forward or backward.</p><p class="click">You can also <b>click</b><br>to move around in the scene.</p>'}) + '</div>';
};
// This file was automatically generated from controls.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.controls');

goog.require('soy');
goog.require('soydata');
goog.require('feng.templates.common');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.RoundButton = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<button class="roundButton ' + ((opt_data.classname) ? opt_data.classname : '') + '"><div class="outline"></div><div class="circle"><div class="circle-content">' + ((opt_data.content) ? opt_data.content : '') + '</div></div></button>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.HomeButton = function(opt_data, opt_ignored) {
  return feng.templates.controls.RoundButton({classname: 'home-button', content: '<div class="icon"></div>'}) + '<div class="home-button-prompt"><h3>Are you sure you want to leave?</h3><div class="button-group">' + feng.templates.common.PrimaryButton({classname: 'small no', icon: 'icon-no', text: 'No'}) + feng.templates.common.PrimaryButton({classname: 'small yes', icon: 'icon-yes', text: 'Yes', href: opt_data.token.HOME}) + '</div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.Compass = function(opt_data, opt_ignored) {
  return '<div class="compass grab">' + feng.templates.controls.RoundButton({content: '<div class="cube"><div><div class="browse"></div><div class="design"></div></div></div>'}) + '</div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.Book = function(opt_data, opt_ignored) {
  return '<a class="book" href="' + opt_data.token.BOOK + '">' + feng.templates.controls.RoundButton({content: '<div class="icon"></div>'}) + '</a>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.Reminder = function(opt_data, opt_ignored) {
  var output = '<div class="reminder"><div class="character">' + feng.templates.controls.RoundButton({content: '<canvas></canvas>'}) + '</div><div class="dialogue hint"><div class="wrapper"><button class="prev icon icon-prev"></button><ul class="hints">';
  var tipList344 = opt_data.tips;
  var tipListLen344 = tipList344.length;
  for (var tipIndex344 = 0; tipIndex344 < tipListLen344; tipIndex344++) {
    var tipData344 = tipList344[tipIndex344];
    output += '<li data-tip-id="' + tipData344.id + '">' + tipData344.reminder + '</li>';
  }
  var keyList351 = soy.$$getMapKeys(opt_data.copy);
  var keyListLen351 = keyList351.length;
  for (var keyIndex351 = 0; keyIndex351 < keyListLen351; keyIndex351++) {
    var keyData351 = keyList351[keyIndex351];
    output += '<li data-view-id="' + keyData351 + '" class="resolved">' + opt_data.copy[keyData351] + '</li>';
  }
  output += '</ul><button class="next icon icon-next"></button></div></div></div>';
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.ObjectSelector = function(opt_data, opt_ignored) {
  return '<div class="objectSelector"><div class="fill"></div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.DropButton = function(opt_data, opt_ignored) {
  return '<div class="dropButton"><div class="circle"></div>' + feng.templates.common.PrimaryButton({icon: 'icon-yes', text: 'Drop'}) + '</div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.TipTooltip = function(opt_data, opt_ignored) {
  return '<a class="tooltip fadeOut tip locked" data-id="' + opt_data.object.id + '" data-tip-id="' + opt_data.object.tip.id + '" href="' + opt_data.goTipToken + '" draggable="false"><div class="bar"><div class="symbol"><div class="inner"><div class="icon icon-magnifier"></div><div class="icon icon-' + opt_data.object.tip.icon + '"></div></div></div><h6>' + opt_data.object.tip.name + '</h6></div></a>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.GatewayTooltip = function(opt_data, opt_ignored) {
  return '<a class="tooltip fadeOut gateway" data-id="' + opt_data.gateway.gatewayId + '" draggable="false"><div class="bar"><div class="symbol"><div class="inner"><div class="icon icon-magnifier"></div><div class="icon ' + ((opt_data.gateway.isStairs == true) ? 'icon-stairs' : 'icon-door') + '"></div></div></div><h6>To ' + opt_data.gateway.viewId + '</h6></div></a>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.controls.ProgressBar = function(opt_data, opt_ignored) {
  var output = '<div class="progressBar"><div class="inner"><div class="tips-wrapper">';
  var viewIdList393 = soy.$$getMapKeys(opt_data.tipsOfViews);
  var viewIdListLen393 = viewIdList393.length;
  for (var viewIdIndex393 = 0; viewIdIndex393 < viewIdListLen393; viewIdIndex393++) {
    var viewIdData393 = viewIdList393[viewIdIndex393];
    output += '<ul class="tips" data-view-id="' + viewIdData393 + '">';
    var tipList397 = opt_data.tipsOfViews[viewIdData393];
    var tipListLen397 = tipList397.length;
    for (var tipIndex397 = 0; tipIndex397 < tipListLen397; tipIndex397++) {
      var tipData397 = tipList397[tipIndex397];
      output += '<li class="tip" data-tip-id="' + tipData397.id + '" data-view-id="' + viewIdData393 + '"><div class="dot"><div class="outer"></div><div class="inner"></div></div><div class="dialog"><a class="content"><div class="icon icon-' + tipData397.icon + '" data-tip-id="' + tipData397.id + '" data-view-id="' + tipData397.viewId + '" data-section-id="' + tipData397.sectionId + '"></div></a></div></li>';
    }
    output += '</ul>';
  }
  output += '</div></div></div>';
  return output;
};
// This file was automatically generated from main.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.main');

goog.require('soy');
goog.require('soydata');
goog.require('feng.templates.common');
goog.require('feng.templates.controls');
goog.require('feng.templates.debug');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.main.EpisodeSection = function(opt_data, opt_ignored) {
  return '<div class="section episode" id="' + opt_data.id + '"><div class="hud"><div class="overlays"><div class="tutorial-overlay"></div><div class="credits-overlay"></div><div class="opening-overlay">' + feng.templates.common.Popup({classname: 'opening from-bottom', content: '<h1></h1><p></p>' + feng.templates.common.PrimaryButton({classname: 'ok', icon: 'icon-yes', text: 'Id be glad to help!'}) + '<div class="character"></div>'}) + '</div><div class="ending-overlay">' + feng.templates.common.Popup({classname: 'ending from-bottom', content: '<h1></h1><p></p>' + feng.templates.common.PrimaryButton({classname: 'stay', icon: 'icon-yes', text: 'Stay'}) + feng.templates.common.PrimaryButton({classname: 'next', icon: 'icon-yes', text: 'Next Location', href: opt_data.token.HOME}) + '<div class="character"></div>'}) + '</div><div class="finale-overlay">' + feng.templates.common.Popup({classname: 'finale from-bottom', content: '<h1></h1><p></p><h2>Share With Friends</h2><ul><li><a class="icon icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://fengshuirealtime.com/" target="_blank"></a></li><li><a class="icon icon-twitter" href="https://twitter.com/intent/tweet?original_referer=http://fengshuirealtime.com/" target="_blank"></a></li><li><a class="icon icon-google" href="https://plus.google.com/share?url=http://fengshuirealtime.com/" target="_blank"></a></li></ul>'}) + '</div><div class="loader-overlay"><div class="loader"><canvas class="spinner"></canvas><p class="progress"></p></div></div></div><div class="controls">' + feng.templates.controls.HomeButton(opt_data) + feng.templates.controls.Compass(null) + feng.templates.controls.Book(opt_data) + feng.templates.controls.ObjectSelector(null) + feng.templates.controls.DropButton(null) + feng.templates.controls.ProgressBar(opt_data) + feng.templates.controls.Reminder({tips: opt_data.tips, copy: opt_data.copy['dialog']['resolved'][opt_data.id]}) + '</div><div class="tooltips"></div><div class="captions"></div></div><div class="scene-container"></div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.main.EpisodeSelection = function(opt_data, opt_ignored) {
  return '<div class="episode-selection"><div class="scene studio"><div class="shade"></div><div class="prompt">' + feng.templates.common.Disc({content: '<div class="location"><p>LOCATION</p><div class="line"></div></div><h1>Ollie\'s Studio</h1><p>Ollie lives in a small, delicate studio in the crowded downtown. How could we improve its feng shui?</p>' + feng.templates.common.PrimaryButton({classname: 'studio', href: opt_data.token.STUDIO, icon: 'icon-yes', text: 'Start'})}) + '</div></div><div class="scene house"><div class="shade"></div><div class="prompt">' + feng.templates.common.Disc({content: '<div class="location"><p>LOCATION</p><div class="line"></div></div><h1>Scott\'s House</h1><p>Scott lives in a two story house, with his wife Joanna and son Nick. How could we improve its feng shui?</p>' + feng.templates.common.PrimaryButton({classname: 'house', href: opt_data.token.HOUSE, icon: 'icon-yes', text: 'Start'})}) + '</div></div><div class="prompt">' + feng.templates.common.Disc({content: '<div class="question">' + feng.templates.common.FengshuiLogo({noText: true}) + '<div><h1>Help your<br>feng shui<br>clients</h1><p>Please make some<br>improvements to their<br>home environments.</p><h2><div class="arrow left"></div><span>CHOOSE ONE</span><div class="arrow right"></div></h2></div></div>'}) + '</div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.main.Main = function(opt_data, opt_ignored) {
  return '<div id="main"><div class="section" id="home"><div class="inner"><section id="main-preloader"><div class="content"><h1>FengShui RealTime</h1><canvas class="house-logo"></canvas><p><span>A real-time experience to practice Feng shui.</span><span>Discovering tips for creating an optimal,</span><span>balanced home environment.</span></p></div></section><section id="main-episode-selection"></section></div></div><ul id="main-options"><li class="info"><div class="icon"></div><div class="slider"><div class="buttons"><button class="instructions">Instructions</button><button class="credits">Credits</button></div></div></li><li class="sound"><div class="icon"></div><div class="slider"><div class="buttons"><button class="on">On</button><button class="off">Off</button></div></div></li><li class="share"><div class="icon"></div><div class="slider"><div class="buttons"><a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://fengshuirealtime.com/" target="_blank"></a><a class="twitter" href="https://twitter.com/intent/tweet?original_referer=http://fengshuirealtime.com/" target="_blank"></a><a class="google" href="https://plus.google.com/share?url=http://fengshuirealtime.com/" target="_blank"></a></div></div></li></ul></div>' + ((opt_data.debug != false) ? feng.templates.debug.Debugger(null) : '');
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.main.Spline = function(opt_data, opt_ignored) {
  return '<div id="spline">' + feng.templates.debug.Debugger(null) + '<canvas></canvas></div>';
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview  Topic-based publish/subscribe channel implementation.
 *
 */

goog.provide('goog.pubsub.PubSub');

goog.require('goog.Disposable');
goog.require('goog.array');



/**
 * Topic-based publish/subscribe channel.  Maintains a map of topics to
 * subscriptions.  When a message is published to a topic, all functions
 * subscribed to that topic are invoked in the order they were added.
 * Uncaught errors abort publishing.
 *
 * Topics may be identified by any nonempty string, <strong>except</strong>
 * strings corresponding to native Object properties, e.g. "constructor",
 * "toString", "hasOwnProperty", etc.
 *
 * @constructor
 * @extends {goog.Disposable}
 */
goog.pubsub.PubSub = function() {
  goog.Disposable.call(this);
  this.subscriptions_ = [];
  this.topics_ = {};
};
goog.inherits(goog.pubsub.PubSub, goog.Disposable);


/**
 * Sparse array of subscriptions.  Each subscription is represented by a tuple
 * comprising a topic identifier, a function, and an optional context object.
 * Each tuple occupies three consecutive positions in the array, with the topic
 * identifier at index n, the function at index (n + 1), the context object at
 * index (n + 2), the next topic at index (n + 3), etc.  (This representation
 * minimizes the number of object allocations and has been shown to be faster
 * than an array of objects with three key-value pairs or three parallel arrays,
 * especially on IE.)  Once a subscription is removed via {@link #unsubscribe}
 * or {@link #unsubscribeByKey}, the three corresponding array elements are
 * deleted, and never reused.  This means the total number of subscriptions
 * during the lifetime of the pubsub channel is limited by the maximum length
 * of a JavaScript array to (2^32 - 1) / 3 = 1,431,655,765 subscriptions, which
 * should suffice for most applications.
 *
 * @type {!Array}
 * @private
 */
goog.pubsub.PubSub.prototype.subscriptions_;


/**
 * The next available subscription key.  Internally, this is an index into the
 * sparse array of subscriptions.
 *
 * @type {number}
 * @private
 */
goog.pubsub.PubSub.prototype.key_ = 1;


/**
 * Map of topics to arrays of subscription keys.
 *
 * @type {!Object.<!Array.<number>>}
 * @private
 */
goog.pubsub.PubSub.prototype.topics_;


/**
 * Array of subscription keys pending removal once publishing is done.
 *
 * @type {Array.<number>}
 * @private
 */
goog.pubsub.PubSub.prototype.pendingKeys_;


/**
 * Lock to prevent the removal of subscriptions during publishing.  Incremented
 * at the beginning of {@link #publish}, and decremented at the end.
 *
 * @type {number}
 * @private
 */
goog.pubsub.PubSub.prototype.publishDepth_ = 0;


/**
 * Subscribes a function to a topic.  The function is invoked as a method on
 * the given {@code opt_context} object, or in the global scope if no context
 * is specified.  Subscribing the same function to the same topic multiple
 * times will result in multiple function invocations while publishing.
 * Returns a subscription key that can be used to unsubscribe the function from
 * the topic via {@link #unsubscribeByKey}.
 *
 * @param {string} topic Topic to subscribe to.
 * @param {Function} fn Function to be invoked when a message is published to
 *     the given topic.
 * @param {Object=} opt_context Object in whose context the function is to be
 *     called (the global scope if none).
 * @return {number} Subscription key.
 */
goog.pubsub.PubSub.prototype.subscribe = function(topic, fn, opt_context) {
  var keys = this.topics_[topic];
  if (!keys) {
    // First subscription to this topic; initialize subscription key array.
    keys = this.topics_[topic] = [];
  }

  // Push the tuple representing the subscription onto the subscription array.
  var key = this.key_;
  this.subscriptions_[key] = topic;
  this.subscriptions_[key + 1] = fn;
  this.subscriptions_[key + 2] = opt_context;
  this.key_ = key + 3;

  // Push the subscription key onto the list of subscriptions for the topic.
  keys.push(key);

  // Return the subscription key.
  return key;
};


/**
 * Subscribes a single-use function to a topic.  The function is invoked as a
 * method on the given {@code opt_context} object, or in the global scope if
 * no context is specified, and is then unsubscribed.  Returns a subscription
 * key that can be used to unsubscribe the function from the topic via
 * {@link #unsubscribeByKey}.
 *
 * @param {string} topic Topic to subscribe to.
 * @param {Function} fn Function to be invoked once and then unsubscribed when
 *     a message is published to the given topic.
 * @param {Object=} opt_context Object in whose context the function is to be
 *     called (the global scope if none).
 * @return {number} Subscription key.
 */
goog.pubsub.PubSub.prototype.subscribeOnce = function(topic, fn, opt_context) {
  // Behold the power of lexical closures!
  var key = this.subscribe(topic, function(var_args) {
    fn.apply(opt_context, arguments);
    this.unsubscribeByKey(key);
  }, this);
  return key;
};


/**
 * Unsubscribes a function from a topic.  Only deletes the first match found.
 * Returns a Boolean indicating whether a subscription was removed.
 *
 * @param {string} topic Topic to unsubscribe from.
 * @param {Function} fn Function to unsubscribe.
 * @param {Object=} opt_context Object in whose context the function was to be
 *     called (the global scope if none).
 * @return {boolean} Whether a matching subscription was removed.
 */
goog.pubsub.PubSub.prototype.unsubscribe = function(topic, fn, opt_context) {
  var keys = this.topics_[topic];
  if (keys) {
    // Find the subscription key for the given combination of topic, function,
    // and context object.
    var subscriptions = this.subscriptions_;
    var key = goog.array.find(keys, function(k) {
      return subscriptions[k + 1] == fn && subscriptions[k + 2] == opt_context;
    });
    // Zero is not a valid key.
    if (key) {
      return this.unsubscribeByKey(/** @type {number} */ (key));
    }
  }

  return false;
};


/**
 * Removes a subscription based on the key returned by {@link #subscribe}.
 * No-op if no matching subscription is found.  Returns a Boolean indicating
 * whether a subscription was removed.
 *
 * @param {number} key Subscription key.
 * @return {boolean} Whether a matching subscription was removed.
 */
goog.pubsub.PubSub.prototype.unsubscribeByKey = function(key) {
  if (this.publishDepth_ != 0) {
    // Defer removal until after publishing is complete.
    if (!this.pendingKeys_) {
      this.pendingKeys_ = [];
    }
    this.pendingKeys_.push(key);
    return false;
  }

  var topic = this.subscriptions_[key];
  if (topic) {
    // Subscription tuple found.
    var keys = this.topics_[topic];
    if (keys) {
      goog.array.remove(keys, key);
    }
    delete this.subscriptions_[key];
    delete this.subscriptions_[key + 1];
    delete this.subscriptions_[key + 2];
  }

  return !!topic;
};


/**
 * Publishes a message to a topic.  Calls functions subscribed to the topic in
 * the order in which they were added, passing all arguments along.  If any of
 * the functions throws an uncaught error, publishing is aborted.
 *
 * @param {string} topic Topic to publish to.
 * @param {...*} var_args Arguments that are applied to each subscription
 *     function.
 * @return {boolean} Whether any subscriptions were called.
 */
goog.pubsub.PubSub.prototype.publish = function(topic, var_args) {
  var keys = this.topics_[topic];
  if (keys) {
    // We must lock subscriptions and remove them at the end, so we don't
    // adversely affect the performance of the common case by cloning the key
    // array.
    this.publishDepth_++;

    // For each key in the list of subscription keys for the topic, apply the
    // function to the arguments in the appropriate context.  The length of the
    // array mush be fixed during the iteration, since subscribers may add new
    // subscribers during publishing.
    var args = goog.array.slice(arguments, 1);
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      this.subscriptions_[key + 1].apply(this.subscriptions_[key + 2], args);
    }

    // Unlock subscriptions.
    this.publishDepth_--;

    if (this.pendingKeys_ && this.publishDepth_ == 0) {
      var pendingKey;
      while ((pendingKey = this.pendingKeys_.pop())) {
        this.unsubscribeByKey(pendingKey);
      }
    }

    // At least one subscriber was called.
    return i != 0;
  }

  // No subscribers were found.
  return false;
};


/**
 * Clears the subscription list for a topic, or all topics if unspecified.
 * @param {string=} opt_topic Topic to clear (all topics if unspecified).
 */
goog.pubsub.PubSub.prototype.clear = function(opt_topic) {
  if (opt_topic) {
    var keys = this.topics_[opt_topic];
    if (keys) {
      goog.array.forEach(keys, this.unsubscribeByKey, this);
      delete this.topics_[opt_topic];
    }
  } else {
    this.subscriptions_.length = 0;
    this.topics_ = {};
    // We don't reset key_ on purpose, because we want subscription keys to be
    // unique throughout the lifetime of the application.  Reusing subscription
    // keys could lead to subtle errors in client code.
  }
};


/**
 * Returns the number of subscriptions to the given topic (or all topics if
 * unspecified).
 * @param {string=} opt_topic The topic (all topics if unspecified).
 * @return {number} Number of subscriptions to the topic.
 */
goog.pubsub.PubSub.prototype.getCount = function(opt_topic) {
  if (opt_topic) {
    var keys = this.topics_[opt_topic];
    return keys ? keys.length : 0;
  }

  var count = 0;
  for (var topic in this.topics_) {
    count += this.getCount(topic);
  }

  return count;
};


/** @override */
goog.pubsub.PubSub.prototype.disposeInternal = function() {
  goog.pubsub.PubSub.superClass_.disposeInternal.call(this);
  delete this.subscriptions_;
  delete this.topics_;
  delete this.pendingKeys_;
};
goog.provide('feng.PubSub');

goog.require('goog.pubsub.PubSub');


feng.PubSub = function() {

	goog.base(this);

	this._shownWidgets = [];

	this.subscribe( feng.PubSub.Topic.SHOW_WIDGET, this.onShowWidget, this );
	this.subscribe( feng.PubSub.Topic.HIDE_WIDGET, this.onHideWidget, this );
};
goog.inherits( feng.PubSub, goog.pubsub.PubSub );
goog.addSingletonGetter( feng.PubSub );


feng.PubSub.prototype.getShownWidgets = function() {

	return this._shownWidgets;
};


feng.PubSub.prototype.isWidgetShown = function( widget ) {

	return goog.array.contains( this._shownWidgets, widget );
};


feng.PubSub.prototype.onShowWidget = function( widget ) {

	goog.array.insert( this._shownWidgets, widget );
};


feng.PubSub.prototype.onHideWidget = function( widget ) {

	goog.array.remove( this._shownWidgets, widget );
};


feng.PubSub.Topic = {
	SHOW_VIEW3D: 'show_view3d',
	HIDE_VIEW3D: 'hide_view3d',
	BUFFER_START: 'buffer_start',
	BUFFER_COMPLETE: 'buffer_complete',
	NAVIGATE: 'navigate',
	SOUND_ON: 'sound_on',
	SOUND_OFF: 'sound_off',
	MAIN_LOAD_COMPLETE: 'main_load_complete',
	SHOW_WIDGET: 'show_widget',
	HIDE_WIDGET: 'hide_widget',
	TRIGGER_COMPASS: 'trigger_compass',
	TRIGGER_SELECTOR: 'trigger_selector',
	TRIGGER_WALK: 'trigger_walk',
	UNTRIGGER_COMPASS: 'untrigger_compass',
	UNTRIGGER_SELECTOR: 'untrigger_selector',
	UNTRIGGER_WALK: 'untrigger_walk',
	COMPLETE_COMPASS: 'complete_compass',
	COMPLETE_SELECTOR: 'complete_selector',
	COMPLETE_WALK: 'complete_walk'
};goog.provide('feng.controllers.view3d.CameraController');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');
goog.require('feng.events');


/**
 * @constructor
 */
feng.controllers.view3d.CameraController = function(view3d){
  goog.base(this);

  this.activeCamera = null;

  this._view3d = view3d;
  this._scene = null;

  this.cameras = [];
  this.cameraHelpers = [];

  this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.controllers.view3d.CameraController, goog.events.EventTarget);


feng.controllers.view3d.CameraController.prototype.init = function( scene ){

  this._scene = scene;

  this.addCamera(feng.controllers.view3d.ModeController.Mode.BROWSE);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.CLOSE_UP);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.ENTRY);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.EXIT);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.DESIGN);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.WALK);
  this.addCamera(feng.controllers.view3d.ModeController.Mode.TRANSITION);

  this.setCamera(feng.controllers.view3d.ModeController.Mode.BROWSE);
};


feng.controllers.view3d.CameraController.prototype.addCamera = function( name, fov, near, far ){

  if(this.getCamera(name)) return;

  var fov = fov || 40;
  var aspect = this._view3d.getViewSize().aspectRatio();
  var near = near || 5;
  var far = far || 200000;

  var camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
  camera.name = name;
  this._scene.add(camera);
  this.cameras.push(camera);

  if(feng.debug) {

    var cameraHelper = new THREE.CameraHelper( camera );
    cameraHelper.name = name + '-helper';
    this._scene.add(cameraHelper);
    this.cameraHelpers.push(cameraHelper);
  }

  this.dispatchEvent({
    type: feng.events.EventType.ADD,
    camera: camera
  });

  return camera;
};


feng.controllers.view3d.CameraController.prototype.removeCamera = function( name ){

  var camera = this.getCamera(name);
  if(!camera) return;

  camera.parent.remove( camera );
  goog.array.remove(this.cameras, camera);

	var cameraHelper = this.getCameraHelper(name);

	cameraHelper.parent.remove( cameraHelper );
  goog.array.remove(this.cameraHelpers, cameraHelper);

  this.dispatchEvent({
    type: feng.events.EventType.REMOVE,
    camera: camera
  });
};


feng.controllers.view3d.CameraController.prototype.getCameras = function(){

  return this.cameras;
};


feng.controllers.view3d.CameraController.prototype.getCamera = function( name ){

  var camera = goog.array.find(this.cameras, function(camera) {
    return camera.name === name;
  });

  return camera;
};


feng.controllers.view3d.CameraController.prototype.getCameraHelper = function( name ){

  var cameraHelper = goog.array.find(this.cameraHelpers, function(cameraHelper) {
    return cameraHelper.name === (name + '-helper');
  });

  return cameraHelper;
};


feng.controllers.view3d.CameraController.prototype.setCamera = function( val ){

  this.activeCamera = goog.isString(val) ? this.getCamera( val ) : val;

  this.dispatchEvent({
    type: feng.events.EventType.CHANGE,
    camera: this.activeCamera
  });

  return this.activeCamera;
};


feng.controllers.view3d.CameraController.prototype.onResize = function(aspect){

  var cameras = this.getCameras();

  goog.array.forEach(cameras, function(camera) {
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
  }, this);
};goog.provide('feng.utils.ThreeUtils');

goog.require('goog.math');


/**
 * @constructor
 */
feng.utils.ThreeUtils.getObjectsBy2DPosition = function( clientX, clientY, objects, camera, viewSize, recursive ) {

	// get camera's world position
	camera.updateMatrixWorld();
	var position = camera.position.clone();
	position.applyMatrix4( camera.matrixWorld );

	var vector = new THREE.Vector3( ( clientX / viewSize.width ) * 2 - 1, - ( clientY / viewSize.height ) * 2 + 1, 0.5 );
	vector.unproject( camera );

	var raycaster = feng.utils.ThreeUtils.raycaster;
	raycaster.set( position, vector.sub( position ).normalize() );

	var intersects = raycaster.intersectObjects( objects, recursive );

	return intersects;
};


feng.utils.ThreeUtils.isFirstIntersectedObject = function( allObjects, object, proxyBox, raycaster ) {

	var _allObjects = allObjects.concat();

	goog.array.remove( _allObjects, object );

	if(proxyBox) {

		_allObjects.push( proxyBox );
	}

	var intersects = raycaster.intersectObjects( _allObjects );

	if(intersects.length > 0) {

		if(proxyBox) {

			return (intersects[0].object === proxyBox && proxyBox.view3dObject.object3d === object);

		}else {

			return (intersects[0].object === object);
		}

	}else {

		return false;
	}
};


feng.utils.ThreeUtils.getQuaternionByLookAt = function( vecFrom, vecTo, vecUp ) {

	var vecUp = vecUp || new THREE.Vector3(0, 1, 0);

	var mtx4 = new THREE.Matrix4();
	mtx4.lookAt( vecFrom, vecTo, vecUp );

	var elements = mtx4.elements;

	var m00 = elements[0], m10 = elements[1], m20 = elements[2],
	m01 = elements[4], m11 = elements[5], m21 = elements[6],
	m02 = elements[8], m12 = elements[9], m22 = elements[10];

	var t = m00 + m11 + m22,s,x,y,z,w;

	if (t > 0) { 
	  s =  Math.sqrt(t+1)*2; 
	  w = 0.25 * s;            
	  x = (m21 - m12) / s;
	  y = (m02 - m20) / s;
	  z = (m10 - m01) / s;
	} else if ((m00 > m11) && (m00 > m22)) {
	  s =  Math.sqrt(1.0 + m00 - m11 - m22)*2;
	  x = s * 0.25;
	  y = (m10 + m01) / s;
	  z = (m02 + m20) / s;
	  w = (m21 - m12) / s;
	} else if (m11 > m22) {
	  s =  Math.sqrt(1.0 + m11 - m00 - m22) *2; 
	  y = s * 0.25;
	  x = (m10 + m01) / s;
	  z = (m21 + m12) / s;
	  w = (m02 - m20) / s;
	} else {
	  s =  Math.sqrt(1.0 + m22 - m00 - m11) *2; 
	  z = s * 0.25;
	  x = (m02 + m20) / s;
	  y = (m21 + m12) / s;
	  w = (m10 - m01) / s;
	}

	var rotation = new THREE.Quaternion(x,y,z,w);
	rotation.normalize();
	return rotation;
};


feng.utils.ThreeUtils.get2DCoordinates = function( position, camera, renderElementSize ) {

	// this will give us position relative to the world
	// project will translate position to 2d
	var p = position.clone().project( camera );

	// translate our vector so that percX=0 represents
	// the left edge, percX=1 is the right edge,
	// percY=0 is the top edge, and percY=1 is the bottom edge.
	var percX = (p.x + 1) / 2;
	var percY = (-p.y + 1) / 2;

	// scale these values to our viewport size
	var x = percX * renderElementSize.width;
	var y = percY * renderElementSize.height;

	return {x: x, y: y};
};


feng.utils.ThreeUtils.getShortestRotation = function( from, to ) {
	// use shortest rotation, based on the TweenMax AS3 shortrotation...
	var calculate = function(fromVal, toVal) {
		var cap = Math.PI * 2;
		var diff = (toVal - fromVal) % cap;

		if (diff != diff % (cap / 2)) {
			diff = (diff < 0) ? diff + cap : diff - cap;
		}

		var shortest = fromVal + diff;

		return shortest;
	}

	if(from instanceof THREE.Euler && to instanceof THREE.Euler) {

		to.x = calculate(from.x, to.x);
		to.y = calculate(from.y, to.y);
		to.z = calculate(from.z, to.z);
		
	}else {

		to = calculate(from, to);
	}

	return to;
};


feng.utils.ThreeUtils.getLerpedEuler = function( a, b, x, opt_euler ) {

	var euler = opt_euler || a.clone();

	var qa = (new THREE.Quaternion()).setFromEuler( a );
	var qb = (new THREE.Quaternion()).setFromEuler( b );
	var qr = qa.slerp( qb, x );

	return euler.setFromQuaternion( qr );
};


feng.utils.ThreeUtils.getWorldPositionOfLocal = function( object, position, opt_pos ) {

	var localPos = opt_pos || new THREE.Vector3();
	localPos.copy( position );

	return object.localToWorld( localPos );
};


feng.utils.ThreeUtils.getLocalPositionOfWorld = function( object, position, opt_pos ) {

	var worldPos = opt_pos || new THREE.Vector3();
	worldPos.copy( position );

	return object.worldToLocal( worldPos );
};


feng.utils.ThreeUtils.getWorldRotationOfLocal = function( object, rotation, opt_rot ) {

  var localQuaternion = (new THREE.Quaternion()).setFromEuler( rotation );
  var objectQuaternion = (new THREE.Quaternion()).setFromEuler( object.rotation );

  var worldQuaternion = objectQuaternion.multiply( localQuaternion );
  var worldRotation = (opt_rot || new THREE.Euler()).setFromQuaternion( worldQuaternion );

  return worldRotation;
};


feng.utils.ThreeUtils.getLocalRotationOfWorld = function( object, rotation, opt_rot ) {

  var worldQuaternion = (new THREE.Quaternion()).setFromEuler( rotation );
  var objectQuaternion = (new THREE.Quaternion()).setFromEuler( object.rotation );

  var localQuaternion = worldQuaternion.multiply( objectQuaternion );
  var localRotation = (opt_rot || new THREE.Euler()).setFromQuaternion( localQuaternion );

  return localRotation;
};


feng.utils.ThreeUtils.projector = new THREE.Projector();
feng.utils.ThreeUtils.raycaster = new THREE.Raycaster();
feng.utils.ThreeUtils.loader = new THREE.ObjectLoader();
goog.provide('feng.models.View3D');


feng.models.View3D.Data = {

	'studio': {
		'livingroom': {
			'studio-door': {
				Class: "gateway",
				viewid: "livingroom",
				gatewayid: "studio-door",
				toHome: true,
				isEntry: true,
				inversed: true,
				openSound: 'entry-open',
				closeSound: 'entry-close',
				origin: {
					position: new THREE.Vector3(-240, 0, 30),
					rotation: new THREE.Euler(0, -Math.PI/2, 0)
				},
				texture: "studio.livingroom.studio-door-texture"
			},
			'ground': {
				texture: 'studio.livingroom.ground-shadow-texture'
			},
			'glamour-photo': {
				Class: 'pictures',
				captionClass: 'changepicture',
				tipKey: 'studio.livingroom.glamourphoto',
				texture: 'studio.livingroom.glamour-photo-texture',
				camera: {
					position: new THREE.Vector3(59, 80, 62),
					rotation: new THREE.Euler(0.13, -3.10, 0.00, 'YXZ'),
					fov: 40
				}
			},
			'studio-door-handle': {
				texture: "studio.livingroom.studio-door-handle-texture"
			},
			'studio-door-frame': {
				texture: "studio.livingroom.studio-door-frame-texture"
			},
			'bathroom-door': {
				Class: "gateway",
				viewid: "bathroom",
				gatewayid: "bathroom-door",
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(-176, 0, 20),
					rotation: new THREE.Euler(0, -Math.PI/2, 0)
				},
				texture: "studio.livingroom.bathroom-door-texture"
			},
			'wall':	{
				collidable: true,
				texture: "studio.livingroom.wall-texture"
			},
			'wall-outer':	{
				texture: "studio.livingroom.wall-outer-texture"
			},
			'ceiling':	{
				texture: "studio.livingroom.ceiling-texture"
			},
			'ceiling-lamp-1':	{
				texture: "studio.livingroom.ceiling-lamp-1-texture"
			},
			'ceiling-lamp-2':	{
				texture: "studio.livingroom.ceiling-lamp-2-texture"
			},
			'floor': {
				texture: "studio.livingroom.floor-texture"
			},
			'plant': {
				Class: "replaceable",
				tipKey: 'studio.livingroom.cactus',
				camera: {
					position: new THREE.Vector3(60, 64, -58.5),
					rotation: new THREE.Euler(-0.30, -1.50, 0.00, 'YXZ'),
					fov: 25
				},
				captionClass: 'changeobject',
				objects: [
					'lucky-bamboo',
					'rubberplant'
				]
			},
			'cactus': {
				texture: "studio.livingroom.cactus-texture"
			},
			'bed':	{
				collidable: true,
				texture: "studio.livingroom.bed-texture"
			},
			'kitchen-cabinets':	{
				collidable: true,
				texture: "studio.livingroom.kitchen-cabinets-texture"
			},
			'kitchen-ware':	{
				texture: "studio.livingroom.kitchen-ware-texture"
			},
			'linen-cabinet':	{
				collidable: true,
				texture: "studio.livingroom.linen-cabinet-texture"
			},
			'mirror':	{
				Class: "mirror"
			},
			'sofabed':	{
				collidable: true,
				texture: "studio.livingroom.sofabed-texture"
			},
			'sofabed-cabinet':	{
				collidable: true,
				texture: "studio.livingroom.sofabed-cabinet-texture"
			},
			'kitchen-storage':	{
				collidable: true,
				texture: "studio.livingroom.kitchen-storage-texture"
			},
			'coffee-pot':	{
				texture: "studio.livingroom.coffee-pot-texture"
			},
			'round-lamp':	{
				Class: 'lamp',
				tipKey: 'studio.livingroom.readinglamp',
				texture: "studio.livingroom.round-lamp-texture",
				captionClass: 'changecolor'
			},
			'reading-lamp':	{
				texture: "studio.livingroom.reading-lamp-texture"
			},
			'hood':	{
				texture: "studio.livingroom.hood-texture"
			},
			'microwave':	{
				texture: "studio.livingroom.microwave-texture"
			},
			'fruitplate':	{
				Class: 'fruitplate',
				camera: {
					position: new THREE.Vector3(-84, 80, -87),
					rotation: new THREE.Euler(-0.59, 2.02, 0.00, 'YXZ'),
					fov: 40
				},
				texture: "studio.livingroom.fruitplate-texture",
				tipKey: 'studio.livingroom.fruitplate',
				captionClass: 'dropfruits'
			},
			'dining-table':	{
				collidable: true,
				texture: "studio.livingroom.dining-table-texture"
			},
			'dining-chair':	{
				Class: "movable",
				texture: "studio.livingroom.dining-chair-texture",
				position: new THREE.Vector3(-47.69, 0, -54.87),
				rotation: new THREE.Euler(0, 0, 0),
				range: 140,
				tipKey: 'studio.livingroom.diningchair'
			},
			'window-books':	{
				texture: "studio.livingroom.window-books-texture"
			},
			'clock':	{
				Class: "tip",
				texture: "studio.livingroom.clock-texture",
				tipKey: 'studio.livingroom.clock'
			},
			'seasoning':	{
				texture: "studio.livingroom.seasoning-texture"
			},
			'bed-shelf':	{
				texture: "studio.livingroom.bed-shelf-texture"
			},
			'tv-table':	{
				collidable: true,
				texture: "studio.livingroom.tv-table-texture"
			},
			'tv':	{
				texture: "studio.livingroom.tv-texture"
			},
			'sofa':	{
				collidable: true,
				texture: "studio.livingroom.sofa-texture"
			},
			'book-shelf':	{
				collidable: true,
				texture: "studio.livingroom.book-shelf-texture"
			},
			'kitchen-shelf':	{
				texture: "studio.livingroom.kitchen-shelf-texture"
			},
			'nightstand':	{
				collidable: true,
				texture: "studio.livingroom.nightstand-texture"
			},
			'sewingmachine':	{
				Class: 'sewingmachine',
				camera: {
					position: new THREE.Vector3(-95, 54, 10),
					rotation: new THREE.Euler(-0.10, -0.80, 0.00, 'YXZ'),
					fov: 13
				},
				texture: "studio.livingroom.sewingmachine-texture",
				tipKey: 'studio.livingroom.sewingmachine'
			},
			'sewingmachine-cover':	{
				texture: "studio.livingroom.sewingmachine-cover-texture"
			},
			'pictures':	{
				texture: "studio.livingroom.pictures-texture"
			},
			'boxes':	{
				texture: "studio.livingroom.boxes-texture"
			},
			'shoestorage':	{
				collidable: true,
				texture: "studio.livingroom.shoestorage-texture"
			},
			'carpet':	{
				texture: "studio.livingroom.carpet-texture"
			},
			'crystal':	{
				Class: "tip",
				tipKey: 'studio.livingroom.crystal',
				glass: true
			},
			'laptop':	{
				texture: "studio.livingroom.laptop-texture"
			},
			'wardrobe':	{
				collidable: true,
				texture: "studio.livingroom.wardrobe-texture"
			},
			'window-left': {
				Class: "windows",
				tipKey: 'studio.livingroom.windows',
				texture: "studio.livingroom.window-left-texture",
				camera: {
					position: new THREE.Vector3(51.37, 80.49, -57.52),
					rotation: new THREE.Euler(-0.12, -1.52, 0.00, 'YXZ'),
					fov: 58
				}
			},
			'window-right': {
				Class: "windows",
				tipKey: 'studio.livingroom.windows',
				texture: "studio.livingroom.window-right-texture",
				camera: {
					position: new THREE.Vector3(-11.90, 80.00, 76.44),
					rotation: new THREE.Euler(-0.06, -1.67, 0.00, 'YXZ'),
					fov: 36
				}
			},
			'window-left-switch': {
				texture: "studio.livingroom.window-left-switch-texture"
			},
			'window-right-switch': {
				texture: "studio.livingroom.window-right-switch-texture"
			},
			'refrigerator':	{
				collidable: true,
				texture: "studio.livingroom.refrigerator-texture"
			},
			'refrigerator-stuff': {
				texture: "studio.livingroom.refrigerator-stuff-texture"
			},
			'refrigerator-door': {
				Class: "refrigerator",
				texture: "studio.livingroom.refrigerator-door-texture",
				camera: {
					position: new THREE.Vector3(-110, 80, -120),
					rotation: new THREE.Euler(-0.64, -1.57, 0.00, 'YXZ'),
					fov: 40
				},
				tipKey: 'studio.livingroom.refrigerator'
			},
			'apple': {
				Class: 'fruit',
				texture: "studio.livingroom.apple-in-refrigerator-texture"
			},
			'pineapple': {
				Class: 'fruit',
				texture: "studio.livingroom.pineapple-in-refrigerator-texture"
			},
			'orange': {
				Class: 'fruit',
				texture: "studio.livingroom.orange-in-refrigerator-texture"
			},
			'peach': {
				Class: 'fruit',
				texture: "studio.livingroom.peach-in-refrigerator-texture"
			}
		},
		'bathroom': {
			'floor': {
				texture: "studio.bathroom.floor-texture"
			},
			'ground': {
				texture: 'studio.bathroom.ground-shadow-texture'
			},
			'wall':	{
				texture: "studio.bathroom.wall-texture"
			},
			'wall-outer':	{
				texture: "studio.bathroom.wall-outer-texture"
			},
			'door-frame':	{
				texture: "studio.bathroom.door-frame-texture"
			},
			'ceiling':	{
				texture: "studio.bathroom.ceiling-texture"
			},
			'ceiling-lamps':	{
				texture: "studio.bathroom.ceiling-lamps-texture"
			},
			'lotus': {
				Class: 'tip',
				texture: "studio.bathroom.lotus-texture",
				tipKey: 'studio.bathroom.lotus'
			},
			'towel': {
				texture: "studio.bathroom.towel-texture"
			},
			'showerhead': {
				Class: 'showerhead',
				texture: "studio.bathroom.showerhead-texture",
				tipKey: 'studio.bathroom.showerhead',
				camera: {
					position: new THREE.Vector3(11.00, 84.00, 77.00),
					rotation: new THREE.Euler(0.16, -1.59, 0.00, 'YXZ'),
					fov: 46.00
				}
			},
			'waterdrop': {
				glass: true
			},
			'shower-handle': {
				texture: "studio.bathroom.shower-handle-texture"
			},
			'shelf': {
				collidable: true,
				texture: "studio.bathroom.shelf-texture"
			},
			'jar-1': {
				texture: "studio.bathroom.jar-1-texture"
			},
			'jar-2': {
				texture: "studio.bathroom.jar-2-texture"
			},
			'jar-3': {
				texture: "studio.bathroom.jar-3-texture"
			},
			'jar-4': {
				texture: "studio.bathroom.jar-4-texture"
			},
			'jar-5': {
				texture: "studio.bathroom.jar-5-texture"
			},
			'jar-6': {
				texture: "studio.bathroom.jar-6-texture"
			},
			'jar-7': {
				texture: "studio.bathroom.jar-7-texture"
			},
			'jar-8': {
				texture: "studio.bathroom.jar-8-texture"
			},
			'jar-9': {
				texture: "studio.bathroom.jar-9-texture"
			},
			'jar-10': {
				texture: "studio.bathroom.jar-10-texture"
			},
			'bottles': {
				texture: "studio.bathroom.bottles-texture"
			},
			'towel-roll': {
				texture: "studio.bathroom.towel-roll-texture"
			},
			'cosmetic-bag': {
				texture: "studio.bathroom.cosmetic-bag-texture"
			},
			'closet': {
				Class: "closet",
				camera: {
					position: new THREE.Vector3(27, 73, -52),
					rotation: new THREE.Euler(0.07, 1.57, 0.00, 'YXZ'),
					fov: 45
				},
				tipKey: 'studio.bathroom.closet',
				texture: "studio.bathroom.closet-texture"
			},
			'closet-door': {
				texture: "studio.bathroom.closet-door-texture"
			},
			'trashcan': {
				collidable: true,
				texture: "studio.bathroom.trashcan-texture"
			},
			'plug': {
				texture: "studio.bathroom.plug-texture"
			},
			'fragrance': {
				texture: "studio.bathroom.fragrance-texture"
			},
			'toilet-paper': {
				texture: "studio.bathroom.toilet-paper-texture"
			},
			'toilet': {
				collidable: true,
				texture: "studio.bathroom.toilet-texture"
			},
			'bathrobe': {
				texture: "studio.bathroom.bathrobe-texture"
			},
			'bathtub': {
				texture: "studio.bathroom.bathtub-texture"
			},
			'shower-curtain': {
				collidable: true,
				texture: "studio.bathroom.shower-curtain-texture"
			},
			'carpets': {
				texture: "studio.bathroom.carpets-texture"
			},
			'washbasin': {
				collidable: true,
				texture: "studio.bathroom.washbasin-texture"
			},
			'flipflop': {
				texture: "studio.bathroom.flipflop-texture"
			},
			'lamps': {
				collidable: true,
				texture: "studio.bathroom.lamps-texture"
			},
			'bathroom-door': {
				Class: "gateway",
				viewid: "livingroom",
				gatewayid: "bathroom-door",
				isEntry: true,
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(12, 0, -60),
					rotation: new THREE.Euler(0, Math.PI, 0)
				},
				texture: "studio.bathroom.bathroom-door-texture"
			}
		}
	},
	'house': {
		'livingroom': {
			'livingroom-door': {
				Class: "gateway",
				viewid: "livingroom",
				gatewayid: "livingroom-door",
				toHome: true,
				isEntry: true,
				openSound: 'entry-open',
				closeSound: 'entry-close',
				origin: {
					position: new THREE.Vector3(110, 0, 0),
					rotation: new THREE.Euler(0, Math.PI/2, 0)
				},
				texture: "house.livingroom.livingroom-door-texture"
			},
			'ground': {
				texture: "house.livingroom.ground-shadow-texture"
			},
			'stairways-door': {
				Class: "gateway",
				viewid: "corridor",
				gatewayid: "stairways-door",
				isStairs: true,
				openSound: null,
				closeSound: null,
				origin: {
					position: new THREE.Vector3(-125, 0, 50),
					rotation: new THREE.Euler(0, -Math.PI/2, 0)
				}
			},
			'stairways': {
				collidable: true,
				texture: "house.livingroom.stairways-texture"
			},
			'stairways-handrail': {
				texture: "house.livingroom.stairways-handrail-texture"
			},
			'door-frame': {
				texture: "house.livingroom.door-frame-texture"
			},
			'floor': {
				texture: "house.livingroom.floor-texture"
			},
			'wall':	{
				texture: "house.livingroom.wall-texture"
			},
			'wall-outer':	{
				texture: "house.livingroom.wall-outer-texture"
			},
			'ceiling':	{
				texture: "house.livingroom.ceiling-texture"
			},
			'ceiling-lamp-1':	{
				texture: "house.livingroom.ceiling-lamp-1-texture"
			},
			'ceiling-lamp-2':	{
				texture: "house.livingroom.ceiling-lamp-2-texture"
			},
			'mirror-holder':	{
				Class: "tip",
				camera: {
					position: new THREE.Vector3(-9, 75, -118),
					rotation: new THREE.Euler(-0.4, 0, 0, 'YXZ'),
					fov: 40
				},
				tipKey: 'house.livingroom.mirror'
			},
			'mirror':	{
				Class: "mirror"
			},
			'drawer': {
				Class: "drawer",
				texture: "house.livingroom.drawer-texture",
				camera: {
					position: new THREE.Vector3(-8, 97, -203),
					rotation: new THREE.Euler(-1.5, 0, 0, 'YXZ'),
					fov: 25
				},
				tipKey: 'house.livingroom.drawer'
			},
			'knife': {
				Class: "knife",
				texture: "house.livingroom.knife-on-cabinet-texture",
				position: new THREE.Vector3(-6.87, -2.21, 10.82),
				rotation: new THREE.Euler(0, 0, 0),
				range: 100,
				parent: 'drawer',
				tipKey: 'house.livingroom.knife'
			},
			'kitchen-top': {
				texture: "house.livingroom.kitchen-top-texture"
			},
			'kitchen-bottom': {
				collidable: true,
				texture: "house.livingroom.kitchen-bottom-texture"
			},
			'kitchen-stuff': {
				texture: "house.livingroom.kitchen-stuff-texture"
			},
			'windows': {
				texture: "house.livingroom.windows-texture"
			},
			'windowsill-stuff': {
				texture: "house.livingroom.windowsill-stuff-texture"
			},
			'basin': {
				texture: "house.livingroom.basin-texture"
			},
			'ladder': {
				texture: "house.livingroom.ladder-texture"
			},
			'cooktop': {
				texture: "house.livingroom.cooktop-texture"
			},
			'long-table': {
				collidable: true,
				texture: "house.livingroom.long-table-texture"
			},
			'clock': {
				texture: "house.livingroom.clock-texture"
			},
			'bookshelf': {
				Class: "tip",
				collidable: true,
				texture: "house.livingroom.bookshelf-texture",
				camera: {
					position: new THREE.Vector3(-22, 80, 0),
					rotation: new THREE.Euler(0.05, 1.58, 0, 'YXZ'),
					fov: 30
				},
				tipKey: 'house.livingroom.books'
			},
			'bookshelf-lamps': {
				texture: "house.livingroom.bookshelf-lamps-texture"
			},
			'round-table': {
				collidable: true,
				texture: "house.livingroom.round-table-texture"
			},
			'window-stand': {
				collidable: true,
				texture: "house.livingroom.window-stand-texture"
			},
			'entrance-stuff': {
				texture: "house.livingroom.entrance-stuff-texture"
			},
			'blue-sofa': {
				collidable: true,
				texture: "house.livingroom.blue-sofa-texture"
			},
			'pads': {
				texture: "house.livingroom.pads-texture"
			},
			'dining-table': {
				collidable: true,
				texture: "house.livingroom.dining-table-texture"
			},
			'dining-chairs': {
				collidable: true,
				texture: "house.livingroom.dining-chairs-texture"
			},
			'dining-lamps': {
				texture: "house.livingroom.dining-lamps-texture"
			},
			'divider': {
				collidable: true,
				texture: "house.livingroom.divider-texture"
			},
			'curtain-left': {
				collidable: true,
				texture: "house.livingroom.curtain-left-texture"
			},
			'curtain-right': {
				collidable: true,
				texture: "house.livingroom.curtain-right-texture"
			},
			'fruitplate': {
				texture: "house.livingroom.fruitplate-texture"
			},
			'refrigerator': {
				collidable: true,
				texture: "house.livingroom.refrigerator-texture"
			},
			'white-sofa': {
				collidable: true,
				texture: "house.livingroom.white-sofa-texture"
			},
			'goldfish': {
				texture: "house.livingroom.goldfish-texture"
			},
			'fish-bowl': {
				Class: 'glassbowl',
				tipKey: 'house.livingroom.glassbowl',
				texture: "house.livingroom.fish-bowl-texture",
				camera: {
					position: new THREE.Vector3(-11, 77, 56),
					rotation: new THREE.Euler(-1.06, 3.14, 0.00, 'YXZ'),
					fov: 22
				}
			},
			'fish-bowl-stand': {
				collidable: true,
				texture: "house.livingroom.fish-bowl-stand-texture"
			},
			'tv-stand': {
				collidable: true,
				texture: "house.livingroom.tv-stand-texture"
			},
			'glass-containers': {
				glass: true
			},
			'window-blinds': {
				texture: "house.livingroom.window-blinds-texture"
			},
			'cupboard': {
				collidable: true,
				texture: "house.livingroom.cupboard-texture"
			},
			'living-area-lamp': {
				collidable: true,
				texture: "house.livingroom.living-area-lamp-texture"
			},
			'living-area-carpet': {
				texture: "house.livingroom.living-area-carpet-texture"
			},
			'stairway-lamps': {
				texture: "house.livingroom.stairway-lamps-texture"
			},
			'heater': {
				texture: "house.livingroom.heater-texture"
			}
		},
		'corridor': {
			'ground': {
				texture: "house.corridor.ground-shadow-texture"
			},
			'floor': {
				texture: "house.corridor.floor-texture"
			},
			'floor-2': {
				collidable: true,
				texture: "house.livingroom.floor-texture"
			},
			'wall-2':	{
				texture: "house.livingroom.wall-texture"
			},
			'tv-stand': {
				texture: "house.livingroom.tv-stand-texture"
			},
			'clock': {
				texture: "house.livingroom.clock-texture"
			},
			'stairways': {
				texture: "house.livingroom.stairways-texture"
			},
			'stairways-handrail': {
				texture: "house.livingroom.stairways-handrail-texture"
			},
			'stairways-door': {
				Class: "gateway",
				viewid: "livingroom",
				gatewayid: "stairways-door",
				isEntry: true,
				isStairs: true,
				openSound: null,
				closeSound: null,
				origin: {
					position: new THREE.Vector3(50, 0, 225),
					rotation: new THREE.Euler(0, 0, 0)
				}
			},
			'round-table': {
				texture: "house.livingroom.round-table-texture"
			},
			'white-sofa': {
				texture: "house.livingroom.white-sofa-texture"
			},
			'ceiling-lamp': {
				texture: "house.corridor.ceiling-lamp-texture"
			},
			'ceiling-lamps': {
				texture: "house.corridor.ceiling-lamps-texture"
			},
			'stairway-lamps': {
				texture: "house.livingroom.stairway-lamps-texture"
			},
			'nick-photo': {
				texture: "house.corridor.nick-photo-texture"
			},
			'boysroom-door': {
				Class: "gateway",
				viewid: "boysroom",
				gatewayid: "boysroom-door",
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(60, 0, -170),
					rotation: new THREE.Euler(0, 0, 0)
				},
				texture: "house.corridor.boysroom-door-texture"
			},
			'homeoffice-door': {
				Class: "gateway",
				viewid: "homeoffice",
				gatewayid: "homeoffice-door",
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(20, 0, -50),
					rotation: new THREE.Euler(0, 0, 0)
				},
				texture: "house.corridor.homeoffice-door-texture"
			},
			'bathroom-door': {
				texture: "house.corridor.bathroom-door-texture"
			},
			'bedroom-door': {
				texture: "house.corridor.bedroom-door-texture"
			},
			'picture-wall': {
				texture: "house.corridor.picture-wall-texture"
			},
			'display-table': {
				collidable: true,
				texture: "house.corridor.display-table-texture"
			},
			'cat': {
				texture: "house.corridor.cat-texture"
			},
			'cat-bed': {
				Class: "cat",
				collidable: true,
				texture: "house.corridor.cat-bed-texture",
				tipKey: 'house.corridor.cat'
			},
			'wall':	{
				texture: "house.corridor.wall-texture"
			},
			'wall-outer':	{
				texture: "house.corridor.wall-outer-texture"
			},
			'door-frames':	{
				texture: "house.corridor.door-frames-texture"
			},
			'ceiling':	{
				texture: "house.corridor.ceiling-texture"
			},
			'corridor-window':	{
				texture: "house.corridor.corridor-window-texture"
			},
			'corridor-stuff':	{
				texture: "house.corridor.corridor-stuff-texture"
			},
			'window-plant':	{
				texture: "house.corridor.window-plant-texture"
			}
		},
		'boysroom': {
			'ground': {
				texture: 'house.boysroom.ground-shadow-texture'
			},
			'floor': {
				texture: "house.boysroom.floor-texture"
			},
			'wall':	{
				texture: "house.boysroom.wall-texture"
			},
			'wall-outer':	{
				texture: "house.boysroom.wall-outer-texture"
			},
			'ceiling':	{
				texture: "house.boysroom.ceiling-texture"
			},
			'cabinet':	{
				collidable: true,
				texture: "house.boysroom.cabinet-texture"
			},
			'bed': {
				collidable: true,
				texture: "house.boysroom.bed-texture"
			},
			'big-frame': {
				texture: "house.boysroom.big-frame-texture"
			},
			'big-frame-picture': {
				Class: 'pictures',
				captionClass: 'changepicture',
				tipKey: 'house.boysroom.poster',
				texture: "house.boysroom.big-frame-picture-texture",
				camera: {
					position: new THREE.Vector3(21.1, 80, -26.46),
					rotation: new THREE.Euler(-0.03, 1.55, 0.00, 'YXZ'),
					fov: 40
				}
			},
			'decoration-pictures': {
				texture: "house.boysroom.decoration-pictures-texture"
			},
			'carpet':	{
				texture: "house.boysroom.carpet-texture"
			},
			'stools': {
				texture: "house.boysroom.stools-texture"
			},
			'football': {
				collidable: true,
				texture: "house.boysroom.football-texture"
			},
			'moon': {
				texture: "house.boysroom.moon-texture"
			},
			'shelf-stuff-1': {
				texture: "house.boysroom.shelf-stuff-1-texture"
			},
			'shelf-stuff-2': {
				texture: "house.boysroom.shelf-stuff-2-texture"
			},
			'shelf-stuff-3': {
				texture: "house.boysroom.shelf-stuff-3-texture"
			},
			'shelf-stuff-4': {
				texture: "house.boysroom.shelf-stuff-4-texture"
			},
			'shelf-stuff-5': {
				texture: "house.boysroom.shelf-stuff-5-texture"
			},
			'shelf-stuff-6': {
				texture: "house.boysroom.shelf-stuff-6-texture"
			},
			'toytrain': {
				texture: "house.boysroom.toytrain-texture"
			},
			'computer': {
				Class: "computer",
				collidable: true,
				texture: "house.boysroom.computer-on-table-texture",
				position: new THREE.Vector3(63.04, 37.75, -97.24),
				rotation: new THREE.Euler(0, 3.14, 0),
				range: 100,
				parent: 'desk',
				tipKey: 'house.boysroom.computer'
			},
			'screen': {
			},
			'desk': {
				collidable: true,
				texture: "house.boysroom.desk-texture"
			},
			'table': {
				collidable: true,
				texture: "house.boysroom.table-texture"
			},
			'table-stuff': {
				texture: "house.boysroom.table-stuff-texture"
			},
			'swivel-chair': {
				collidable: true,
				texture: "house.boysroom.swivel-chair-texture"
			},
			'nightstand': {
				collidable: true,
				texture: "house.boysroom.nightstand-texture"
			},
			'pencil-vase': {
				texture: "house.boysroom.pencil-vase-texture"
			},
			'boysroom-door': {
				Class: "gateway",
				viewid: "corridor",
				gatewayid: "boysroom-door",
				isEntry: true,
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(78, 0, 33),
					rotation: new THREE.Euler(0, Math.PI/2, 0)
				},
				texture: "house.boysroom.boysroom-door-texture"
			},
			'sketchpad': {
				texture: "house.boysroom.sketchpad-texture"
			},
			'ceiling-lamps': {
				texture: "house.boysroom.ceiling-lamps-texture"
			},
			'nightstand-lamp': {
				texture: "house.boysroom.nightstand-lamp-texture"
			},
			'yellow-reading-lamp': {
				texture: "house.boysroom.yellow-reading-lamp-texture"
			},
			'blue-reading-lamp': {
				texture: "house.boysroom.blue-reading-lamp-texture"
			},
			'bedding': {
				texture: "house.boysroom.bedding-texture"
			},
			'chalkboard': {
				texture: "house.boysroom.chalkboard-texture"
			},
			'slippers': {
				texture: "house.boysroom.slippers-texture"
			},
			'table-books': {
				texture: "house.boysroom.table-books-texture"
			},
			'shelf-left': {
				collidable: true,
				texture: "house.boysroom.shelf-left-texture"
			},
			'shelf-right': {
				collidable: true,
				texture: "house.boysroom.shelf-right-texture"
			},
			'drawer': {
				texture: "house.boysroom.drawer-texture"
			},
			'bear': {
				Class: "bear",
				texture: "house.boysroom.bear-in-drawer-texture",
				position: new THREE.Vector3(-50.04, 33.70, -27.77),
				rotation: new THREE.Euler(0, -1.57, 0),
				range: 100,
				parent: 'bed',
				tipKey: 'house.boysroom.bear'
			},
			'handheld': {
				Class: "movable",
				texture: "house.boysroom.handheld-nightstand-texture",
				tipKey: 'house.boysroom.handheld',
				position: new THREE.Vector3(-43.73, 69.26, -100.78),
				rotation: new THREE.Euler(0, 1.57, 0),
				range: 100,
				parent: 'shelf-left'
			},
			'window': {
				texture: "house.boysroom.window-texture"
			},
			'window-frame': {
				texture: "house.boysroom.window-frame-texture"
			},
			'door-frame': {
				texture: "house.boysroom.door-frame-texture"
			}
		},
		'homeoffice': {
			'ground': {
				texture: "house.homeoffice.ground-shadow-texture"
			},
			'floor': {
				texture: "house.homeoffice.floor-texture"
			},
			'ceiling': {
				texture: "house.homeoffice.ceiling-texture"
			},
			'wall':	{
				texture: "house.homeoffice.wall-texture"
			},
			'wall-outer':	{
				texture: "house.homeoffice.wall-outer-texture"
			},
			'homeoffice-door': {
				Class: "gateway",
				viewid: "corridor",
				gatewayid: "homeoffice-door",
				isEntry: true,
				openSound: 'door-open',
				closeSound: 'door-close',
				origin: {
					position: new THREE.Vector3(68, 0, -53),
					rotation: new THREE.Euler(0, Math.PI/2, 0)
				},
				texture: "house.homeoffice.homeoffice-door-texture"
			},
			'swivel-chair': {
				Class: "movable",
				collidable: true,
				texture: "house.homeoffice.swivel-chair-texture",
				position: new THREE.Vector3(-40, 0, 9),
				rotation: new THREE.Euler(0, 0, 0),
				range: 200,
				tipKey: 'house.homeoffice.deskchair'
			},
			'storage': {
				collidable: true,
				texture: "house.homeoffice.storage-texture"
			},
			'setsquare': {
				Class: "movable",
				collidable: true,
				texture: "house.homeoffice.setsquare-texture",
				tipKey: 'house.homeoffice.setsquare',
				position: new THREE.Vector3(-36.95, 107.05, 137.10),
				rotation: new THREE.Euler(0, 1.57, 0.18),
				range: 140,
				parent: 'block-shelf-1'
			},
			'carpet': {
				texture: "house.homeoffice.carpet-texture"
			},
			'door-frame': {
				texture: "house.homeoffice.door-frame-texture"
			},
			'display-shelf-lamp': {
				texture: "house.homeoffice.display-shelf-lamp-texture"
			},
			'bookshelf-lamps': {
				texture: "house.homeoffice.bookshelf-lamps-texture"
			},
			'picture-frame-1': {
				texture: "house.homeoffice.picture-frame-1-texture"
			},
			'picture-frame-2': {
				texture: "house.homeoffice.picture-frame-2-texture"
			},
			'picture-frame-3': {
				texture: "house.homeoffice.picture-frame-3-texture"
			},
			'picture-frame-4': {
				texture: "house.homeoffice.picture-frame-4-texture"
			},
			'picture-1': {
				texture: "house.homeoffice.pictures.1"
			},
			'picture-2': {
				texture: "house.homeoffice.pictures.2"
			},
			'picture-3': {
				texture: "house.homeoffice.pictures.3"
			},
			'picture-4': {
				texture: "house.homeoffice.pictures.4"
			},
			'block-shelf-1':	{
				texture: "house.homeoffice.block-shelf-1-texture"
			},
			'block-shelf-2':	{
				texture: "house.homeoffice.block-shelf-2-texture"
			},
			'block-stuff-1':	{
				texture: "house.homeoffice.block-stuff-1-texture"
			},
			'block-stuff-2':	{
				texture: "house.homeoffice.block-stuff-2-texture"
			},
			'books-1':	{
				texture: "house.homeoffice.books-1-texture"
			},
			'books-2':	{
				texture: "house.homeoffice.books-2-texture"
			},
			'round-lamp':	{
				collidable: true,
				texture: "house.homeoffice.round-lamp-texture"
			},
			'calendar':	{
				texture: "house.homeoffice.calendar-texture"
			},
			'magazine':	{
				texture: "house.homeoffice.magazine-texture"
			},
			'window':	{
				texture: "house.homeoffice.window-texture"
			},
			'armchair':	{
				texture: "house.homeoffice.armchair-texture"
			},
			'writing-desk':	{
				collidable: true,
				texture: "house.homeoffice.writing-desk-texture"
			},
			'dracaena-fragrans': {
				collidable: true,
				texture: "house.homeoffice.dracaena-fragrans-texture"
			},
			'handbag': {
				texture: "house.homeoffice.handbag-texture"
			},
			'pen-vase': {
				texture: "house.homeoffice.pen-vase-texture"
			},
			'rubberplant': {
				Class: "tip",
				texture: "house.homeoffice.rubberplant-texture",
				tipKey: 'house.homeoffice.officeplant'
			},
			'coffee-table':	{
				collidable: true,
				texture: "house.homeoffice.coffee-table-texture"
			},
			'coffeecup': {
				texture: "house.homeoffice.coffeecup-texture"
			},
			'floor-lamp': {
				collidable: true,
				texture: "house.homeoffice.floor-lamp-texture"
			},
			'ceiling-lamp': {
				texture: "house.homeoffice.ceiling-lamp-texture"
			},
			'cup': {
				texture: "house.homeoffice.cup-texture"
			},
			'reading-lamp-1': {
				texture: "house.homeoffice.reading-lamp-1-texture"
			},
			'reading-lamp-2': {
				texture: "house.homeoffice.reading-lamp-2-texture"
			},
			'sofa': {
				collidable: true,
				texture: "house.homeoffice.sofa-texture"
			},
			'trash': {
				texture: "house.homeoffice.trash-texture"
			},
			'display-shelf': {
				Class: 'pictures',
				collidable: true,
				captionClass: 'changepicture',
				tipKey: 'house.homeoffice.photodisplay',
				texture: "house.homeoffice.display-shelf-texture",
				camera: {
					position: new THREE.Vector3(23, 80, -60),
					rotation: new THREE.Euler(0.01, 0.07, 0.00, 'YXZ'),
					fov: 40
				}
			},
			'computer':	{
				texture: "house.homeoffice.computer-texture"
			},
			'screen': {
				Class: 'wallpaper',
				tipKey: 'house.homeoffice.desktopwallpaper'
			},
			'laptop':	{
				texture: "house.homeoffice.laptop-texture"
			},
			'curtain':	{
				texture: "house.homeoffice.curtain-texture"
			},
			'curtain-rod':	{
				texture: "house.homeoffice.curtain-rod-texture"
			},
			'telephone':	{
				texture: "house.homeoffice.telephone-texture"
			},
			'bookshelf':	{
				collidable: true,
				texture: "house.homeoffice.bookshelf-texture"
			},
			'bookshelf-stuff':	{
				texture: "house.homeoffice.bookshelf-stuff-texture"
			}
		}
	}
};


feng.models.View3D.getData = function(keyString) {

	var keys = keyString.split('.');
	var data = feng.models.View3D.Data;
	goog.array.forEach(keys, function(key) {
		data = data[key];
	});

	return data || {};
};goog.provide('feng.views.view3dobject.View3DObject');

goog.require('goog.events.EventTarget');
goog.require('goog.math.Box');
goog.require('feng.models.Preload');
goog.require('feng.models.View3D');

/**
 * @constructor
 * A 3d object in view3d
 */
feng.views.view3dobject.View3DObject = function( object3d, data, view3d ){

  goog.base(this);

  this.object3d = object3d;
  this.object3d.userData = data;
  this.object3d.view3dObject = this;

  this.name = object3d.name;
  this.id = object3d.name + '-' + object3d.uuid;
  this.data = data;

  this._view3d = view3d;
  this._boundingBox = new THREE.Box3();
  this._boundingSphere = new THREE.Sphere();
  this._center = new THREE.Vector3();

  this._tilemapProxy = null;

  this._proxyBox = new THREE.Mesh( new THREE.BoxGeometry(1,1,1) );
  this._proxyBox.view3dObject = this;

  this._canRender = this.object3d.visible;
  
  this.isRenderEnabled = this._canRender;
  this.isTextureCreated = false;

  this._isGlass = this.data.glass;

  //
  this.registerToView3D();
};
goog.inherits(feng.views.view3dobject.View3DObject, goog.events.EventTarget);


feng.views.view3dobject.View3DObject.prototype.registerToView3D = function(){

  this._view3d.view3dObjects[ this.name ] = this;
};


feng.views.view3dobject.View3DObject.prototype.init = function(){

  if(this._isGlass) {

    var shader = THREE.FresnelShader;
    var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

    uniforms[ "tCube" ].value = this._view3d.createCubeMap( this.getCenter(), feng.renderSettings.renderSize/2 );

    this.object3d.material = new THREE.ShaderMaterial({
      'fragmentShader': shader.fragmentShader,
      'vertexShader': shader.vertexShader,
      'uniforms': uniforms,
      'shading': THREE.FlatShading
    });

  }else if(this.object3d.material) {

    this.object3d.material.shading = THREE.FlatShading;
    this.object3d.material.fog = this.data.fog || false;
  }
};


feng.views.view3dobject.View3DObject.prototype.createTextures = function(){

  if(this.isTextureCreated) {

    return false;

  }else {

    this.isTextureCreated = true;
  }

  var preloadModel = feng.models.Preload.getInstance();
  var sectionId = this._view3d.sectionId;
  var viewId = this._view3d.id;

  this.object3d.traverse(function(object) {

    var data = feng.models.View3D.getData(sectionId+'.'+viewId+'.'+object.name);

    if(object instanceof THREE.Object3D) {

      var textureData = data.texture;

      if(goog.isString(textureData) && !object.material.map) {

          var textureAsset = preloadModel.getAsset( textureData );
          var texture;

          if(textureAsset.src) {

            texture = new THREE.Texture( textureAsset );
            texture.needsUpdate = true;

          }else {
            /*
            var ddsLoader = new THREE.DDSLoader();           
            var dds = ddsLoader.parse( textureAsset );

            texture = new THREE.CompressedTexture();
            texture.image = [];
            texture.flipY = false;
            texture.generateMipmaps = false;
            texture.image.width = dds.width;
            texture.image.height = dds.height;
            texture.mipmaps = dds.mipmaps;
            texture.format = dds.format;
            texture.needsUpdate = true;
            */
          }

          object.material.shading = THREE.FlatShading;
          object.material.fog = false;
          object.material.map = texture;
          object.material.needsUpdate = true;
      }
    }
  });

  return true;
};


feng.views.view3dobject.View3DObject.prototype.disposeTextures = function(){

  if(!this.isTextureCreated) {

    return false;

  }else {

    this.isTextureCreated = false;
  }

  this.object3d.traverse(function(object) {

    if(object instanceof THREE.Mesh) {

      if(object.material.map) {

        object.material.map.dispose();
        object.material.map = null;
        object.material.needsUpdate = true;
      }
    }
  });

  return true;
};


feng.views.view3dobject.View3DObject.prototype.isCollidable = function(){

  return (this.data.collidable === true);
};


feng.views.view3dobject.View3DObject.prototype.isFloor = function(){

  return (goog.string.startsWith(this.name, 'floor'));
};


feng.views.view3dobject.View3DObject.prototype.getProxyBox = function(){

  var boundingBox = this.getBoundingBox();

  boundingBox.size( this._proxyBox.scale );
  boundingBox.center( this._proxyBox.position );
  this._proxyBox.updateMatrixWorld();

  return this._proxyBox;
};


feng.views.view3dobject.View3DObject.prototype.getBoundingBox = function(){

  this._boundingBox.setFromObject( this.object3d );
  return this._boundingBox;
};


feng.views.view3dobject.View3DObject.prototype.getBoundingSphere = function(){

  this.getBoundingBox().getBoundingSphere( this._boundingSphere );
  return this._boundingSphere;
};


feng.views.view3dobject.View3DObject.prototype.getBox = function(){

  var box3 = this.getBoundingBox();
  var minX = box3.min.x;
  var minZ = box3.min.z;
  var maxX = box3.max.x;
  var maxZ = box3.max.z;

  var box2 = new goog.math.Box(minZ, maxX, maxZ, minX);

  return box2;
};


feng.views.view3dobject.View3DObject.prototype.getCenter = function(){

  var box3 = this.getBoundingBox();
  return box3.center();
};


feng.views.view3dobject.View3DObject.prototype.getBoundingBoxParameters = function(){

  var box3 = this.getBoundingBox();
  
  return {
    width: Math.abs(box3.max.x - box3.min.x),
    height: Math.abs(box3.max.y - box3.min.y),
    length: Math.abs(box3.max.z - box3.min.z)
  };
};


feng.views.view3dobject.View3DObject.prototype.getHeight = function(){

  return this.getBoundingBoxParameters().height;
};


feng.views.view3dobject.View3DObject.prototype.getTilemapProxy = function(){

  var clone = this._tilemapProxy;

  if(!clone) {

    clone = new THREE.Mesh( this.object3d.geometry );
    this._tilemapProxy = clone;
  }

  if(this.isCollidable()) {

    clone.material = feng.views.view3dobject.View3DObject.ProxyMaterial.RED;

  }else {

    clone.material = feng.views.view3dobject.View3DObject.ProxyMaterial.GREEN;
  }
  
  clone.material.overdraw = 8;

  clone.position.copy( this.object3d.position );
  clone.rotation.copy( this.object3d.rotation );

  return clone;
};


feng.views.view3dobject.View3DObject.prototype.addToScene = function( parent ){

  var parent = parent || this._view3d.scene;
  parent.add( this.object3d );
};


feng.views.view3dobject.View3DObject.prototype.removeFromScene = function(){

  if(this.object3d.parent) {
    this.object3d.parent.remove( this.object3d );
  }
};


feng.views.view3dobject.View3DObject.prototype.isInScene = function(){

  return goog.isDefAndNotNull( this.object3d.parent );
};


feng.views.view3dobject.View3DObject.prototype.enableRender = function(){

  if(!this._canRender) return;

  if(this.isRenderEnabled) return;
  else this.isRenderEnabled = true;

  // itself, its parent and its children should be renderable
  this.object3d.visible = true;

  var parent = this.object3d.parent;
  var scene = this._view3d.scene;

  while(parent && !(parent === scene)) {

    if(parent.view3dObject) parent.view3dObject.enableRender();
    else parent.visible = true;

    parent = parent.parent;
  }

  this.object3d.traverse(function(child) {

    if(child.view3dObject) child.view3dObject.enableRender();
    else child.visible = true;
  });

  //console.log("SHOW:", this.object3d.name);
};


feng.views.view3dobject.View3DObject.prototype.disableRender = function(){

  if(!this.isRenderEnabled) return;
  else this.isRenderEnabled = false;

  // itself and its children should not be renderable
  this.object3d.visible = false;

  //console.log("HIDE:", this.object3d.name);
};


feng.views.view3dobject.View3DObject.ProxyMaterial = {
  RED: new THREE.MeshBasicMaterial( {color: 0xff0000} ),
  GREEN: new THREE.MeshBasicMaterial( {color: 0x00ff00} )
};goog.provide('feng.views.view3dobject.InteractiveObject');

goog.require('goog.async.Delay');
goog.require('goog.events.EventHandler');
goog.require('feng.views.view3dobject.View3DObject');

/**
 * @constructor
 * A 3d object that can be interacted in view3d
 */
feng.views.view3dobject.InteractiveObject = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this.object3d.interactiveObject = this;

  this.isSpecialCameraEnabled = data.camera ? true : false;
  this.specialCameraSettings = data.camera || {};

  this._interactionHandler = new goog.events.EventHandler(this);

  this.cameraInDuration = 1000;
  this._onCameraAnimatedInDelay = new goog.async.Delay(this.onCameraAnimatedIn, 0, this);
};
goog.inherits(feng.views.view3dobject.InteractiveObject, feng.views.view3dobject.View3DObject);


feng.views.view3dobject.InteractiveObject.prototype.registerToView3D = function(){

  goog.base(this, 'registerToView3D');
  
  this._view3d.interactiveObjects[ this.name ] = this;
};


feng.views.view3dobject.InteractiveObject.prototype.activate = function(){

};


feng.views.view3dobject.InteractiveObject.prototype.deactivate = function(){

};


feng.views.view3dobject.InteractiveObject.prototype.startInteraction = function(){

  this.dispatchEvent( feng.events.EventType.START );
};


feng.views.view3dobject.InteractiveObject.prototype.stopInteraction = function(){

  this._interactionHandler.removeAll();

  this.dispatchEvent( feng.events.EventType.END );
};


feng.views.view3dobject.InteractiveObject.prototype.enableSpecialCamera = function( position, rotation, fov ){

  this.isSpecialCameraEnabled = position ? true : false;

  if(this.isSpecialCameraEnabled) {

    this.specialCameraSettings.position = position;
    this.specialCameraSettings.rotation = rotation;
    this.specialCameraSettings.fov = fov;
  }
};


feng.views.view3dobject.InteractiveObject.prototype.onCameraIn = function(){

  console.log('on camera in: ' + this.name);

  this._onCameraAnimatedInDelay.start( this.cameraInDuration );
};


feng.views.view3dobject.InteractiveObject.prototype.onCameraOut = function(){

  console.log('on camera out: ' + this.name);

  this._onCameraAnimatedInDelay.stop();
};


feng.views.view3dobject.InteractiveObject.prototype.onCameraAnimatedIn = function(){

  this.dispatchEvent( feng.events.EventType.ANIMATED_IN );
};goog.provide('feng.views.view3dobject.TipObject');

goog.require('feng.models.achievements.Achievements');
goog.require('feng.views.view3dobject.InteractiveObject');

/**
 * @constructor
 * An interactive object that shall be solved as a feng-shui tip
 */
feng.views.view3dobject.TipObject = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  // get tip model and listen to unlock event
  var tipKeys = data.tipKey.split('.');
  var tipId = tipKeys[2];
  var viewId = tipKeys[1];
  var sectionId = tipKeys[0];
  this.tip = feng.models.achievements.Achievements.getInstance().getTip(tipId, viewId, sectionId);

  goog.events.listenOnce(this.tip, feng.events.EventType.UNLOCK, this.onUnlock, false, this);

  // get tip caption id if specified
  this.captionClass = data.captionClass || null;
};
goog.inherits(feng.views.view3dobject.TipObject, feng.views.view3dobject.InteractiveObject);


feng.views.view3dobject.TipObject.prototype.registerToView3D = function(){

  goog.base(this, 'registerToView3D');
  
  this._view3d.tipObjects[ this.name ] = this;
};


feng.views.view3dobject.TipObject.prototype.isUnlocked = function(){

  return this.tip.unlocked;
};


feng.views.view3dobject.TipObject.prototype.unlock = function(e){

  this.tip.unlock();
};


feng.views.view3dobject.TipObject.prototype.onUnlock = function(e){

  this.dispatchEvent( feng.events.EventType.UNLOCK );

  console.log("UNLOCK: ", this);
};goog.provide('feng.views.view3dobject.MovableObject');

goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * A tip object that can be resolved by moving to a new position
 */
feng.views.view3dobject.MovableObject = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this.dropParent = null;
  this.range = this.data.range;

  this.hasPicked = false;
  this.hasDropped = false;

  this._pickDelay = new goog.async.Delay(this.pick, 1000, this);
};
goog.inherits(feng.views.view3dobject.MovableObject, feng.views.view3dobject.TipObject);


feng.views.view3dobject.MovableObject.prototype.init = function(){

  goog.base(this, 'init');

  var dropParentObject = this._view3d.getView3dObject( this.data.parent );
  this.dropParent = dropParentObject ? dropParentObject.object3d : this._view3d.scene;
};


feng.views.view3dobject.MovableObject.prototype.getBoundingBox = function(){

  if(!this.hasPicked) {

    return goog.base(this, 'getBoundingBox');

  }else {

    // calculate bounding box of original orientation
    this.object3d.geometry.computeBoundingBox();
    var boundingBox = this.object3d.geometry.boundingBox;

    var size = boundingBox.size();
    var center = this.data.position.clone();
    center.y += size.y/2;

    this._boundingBox.setFromCenterAndSize( center, size );
    return this._boundingBox;
  }
};


feng.views.view3dobject.MovableObject.prototype.getDestination = function(){

  return this.dropParent.localToWorld( this.data.position.clone() );
};


feng.views.view3dobject.MovableObject.prototype.getCloseUpObjectWhenDropped = function(){

  return this;
};


feng.views.view3dobject.MovableObject.prototype.pick = function(){

  var arms = this._view3d.arms;
  var endOrientation = arms.getWorldOrientation( this.name );
  var endPosition = endOrientation.position;
  var endRotation = endOrientation.rotation;
  var startPosition = this.object3d.position;
  var startRotation = this.object3d.rotation;

  var prop = {
    t: 0
  };

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();

  TweenMax.to( prop, 2, {
    t: 1,
    'ease': Sine.easeIn,
    'onUpdate': function() {
      
      position = position.copy(startPosition).lerp(endPosition, prop.t);
      this.object3d.position.copy( position );

      rotation = feng.utils.ThreeUtils.getLerpedEuler( startRotation, endRotation, prop.t, rotation );
      this.object3d.rotation.copy( rotation );
    },
    'onUpdateScope': this,
    'onComplete': this.onPicked,
    'onCompleteScope': this
  });
};


feng.views.view3dobject.MovableObject.prototype.drop = function(){

  var arms = this._view3d.arms;
  arms.removeItem( this );

  this.dropParent.add( this.object3d );

  //
  var startOrientation = arms.getWorldOrientation( this.name );
  var worldPosition = startOrientation.position;
  var worldRotation = startOrientation.rotation;

  var startPosition = feng.utils.ThreeUtils.getLocalPositionOfWorld( this.dropParent, worldPosition );
  var startRotation = feng.utils.ThreeUtils.getLocalRotationOfWorld( this.dropParent, worldRotation );

  var endPosition = this.data.position.clone().setY( this.data.position.y + 10 );
  var endRotation = this.data.rotation;

  var prop = {
    t: 0
  };

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();

  TweenMax.to( prop, 1, {
    t: 1,
    'immediateRender': true,
    'ease': Sine.easeInOut,
    'onUpdate': function() {
      
      position = position.copy(startPosition).lerp(endPosition, prop.t);
      this.object3d.position.copy( position );

      rotation = feng.utils.ThreeUtils.getLerpedEuler( startRotation, endRotation, prop.t, rotation );
      this.object3d.rotation.copy( rotation );
    },
    'onUpdateScope': this
  });

  TweenMax.to( this.object3d.position, 1, {
    'y': this.data.position.y,
    'delay': 1.5,
    'ease': Bounce.easeOut,
    'onComplete': this.onDropped,
    'onCompleteScope': this
  });
};


feng.views.view3dobject.MovableObject.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  this._pickDelay.start();
};


feng.views.view3dobject.MovableObject.prototype.stopInteraction = function(){

  goog.base(this, 'stopInteraction');

  this._pickDelay.stop();
};


feng.views.view3dobject.MovableObject.prototype.onPicked = function(){

  this.hasPicked = true;

  this.stopInteraction();
  
  var arms = this._view3d.arms;
  arms.addItem( this );
};


feng.views.view3dobject.MovableObject.prototype.onDropped = function(){

  this.hasDropped = true;

  this.unlock();
};


feng.views.view3dobject.MovableObject.prototype.onCameraIn = function(){

  if(this.hasDropped) {

    this.cameraInDuration = 1000;

  }else if(!this.hasPicked) {

    this.cameraInDuration = 1000;

  }else if(this.hasPicked && !this.hasDropped) {

    this.cameraInDuration = 3000;

    this.drop();
  }

  goog.base(this, 'onCameraIn');
};goog.provide('feng.views.view3dobject.entities.Fruit');

goog.require('feng.views.view3dobject.View3DObject');


/**
 * @constructor
 * The generic fruit class
 */
feng.views.view3dobject.entities.Fruit = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._inPlateTexture = null;
};
goog.inherits(feng.views.view3dobject.entities.Fruit, feng.views.view3dobject.View3DObject);


feng.views.view3dobject.entities.Fruit.prototype.createTextures = function(){

  var shouldCreate = goog.base(this, 'createTextures');

  if(!shouldCreate) return;

  var preload = feng.models.Preload.getInstance();
  var inPlateImg = preload.getAsset(this._view3d.sectionId + '.' + this._view3d.id + '.' + this.name +'-in-plate-texture');
  this._inPlateTexture = new THREE.Texture( inPlateImg );
  this._inPlateTexture.needsUpdate = true;

  if(this.object3d.parent.name !== 'refrigerator') {
    this.object3d.material.map = this._inPlateTexture;
  }
};


feng.views.view3dobject.entities.Fruit.prototype.disposeTextures = function(){

  var shouldDispose = goog.base(this, 'disposeTextures');

  if(!shouldDispose) return;

  this._inPlateTexture.dispose();
  this._inPlateTexture = null;
};


feng.views.view3dobject.entities.Fruit.prototype.onPick = function(){

  this.object3d.material.map = this._inPlateTexture;
  this.object3d.material.needsUpdate = true;
};// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bidi utility functions.
 *
 */

goog.provide('goog.style.bidi');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('goog.userAgent');


/**
 * Returns the normalized scrollLeft position for a scrolled element.
 * @param {Element} element The scrolled element.
 * @return {number} The number of pixels the element is scrolled. 0 indicates
 *     that the element is not scrolled at all (which, in general, is the
 *     left-most position in ltr and the right-most position in rtl).
 */
goog.style.bidi.getScrollLeft = function(element) {
  var isRtl = goog.style.isRightToLeft(element);
  if (isRtl && goog.userAgent.GECKO) {
    // ScrollLeft starts at 0 and then goes negative as the element is scrolled
    // towards the left.
    return -element.scrollLeft;
  } else if (isRtl &&
             !(goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8'))) {
    // ScrollLeft starts at the maximum positive value and decreases towards
    // 0 as the element is scrolled towards the left. However, for overflow
    // visible, there is no scrollLeft and the value always stays correctly at 0
    var overflowX = goog.style.getComputedOverflowX(element);
    if (overflowX == 'visible') {
      return element.scrollLeft;
    } else {
      return element.scrollWidth - element.clientWidth - element.scrollLeft;
    }
  }
  // ScrollLeft behavior is identical in rtl and ltr, it starts at 0 and
  // increases as the element is scrolled away from the start.
  return element.scrollLeft;
};


/**
 * Returns the "offsetStart" of an element, analagous to offsetLeft but
 * normalized for right-to-left environments and various browser
 * inconsistencies. This value returned can always be passed to setScrollOffset
 * to scroll to an element's left edge in a left-to-right offsetParent or
 * right edge in a right-to-left offsetParent.
 *
 * For example, here offsetStart is 10px in an LTR environment and 5px in RTL:
 *
 * <pre>
 * |          xxxxxxxxxx     |
 *  ^^^^^^^^^^   ^^^^   ^^^^^
 *     10px      elem    5px
 * </pre>
 *
 * If an element is positioned before the start of its offsetParent, the
 * startOffset may be negative.  This can be used with setScrollOffset to
 * reliably scroll to an element:
 *
 * <pre>
 * var scrollOffset = goog.style.bidi.getOffsetStart(element);
 * goog.style.bidi.setScrollOffset(element.offsetParent, scrollOffset);
 * </pre>
 *
 * @see setScrollOffset
 *
 * @param {Element} element The element for which we need to determine the
 *     offsetStart position.
 * @return {number} The offsetStart for that element.
 */
goog.style.bidi.getOffsetStart = function(element) {
  var offsetLeftForReal = element.offsetLeft;

  // The element might not have an offsetParent.
  // For example, the node might not be attached to the DOM tree,
  // and position:fixed children do not have an offset parent.
  // Just try to do the best we can with what we have.
  var bestParent = element.offsetParent;

  if (!bestParent && goog.style.getComputedPosition(element) == 'fixed') {
    bestParent = goog.dom.getOwnerDocument(element).documentElement;
  }

  // Just give up in this case.
  if (!bestParent) {
    return offsetLeftForReal;
  }

  if (goog.userAgent.GECKO) {
    // When calculating an element's offsetLeft, Firefox erroneously subtracts
    // the border width from the actual distance.  So we need to add it back.
    var borderWidths = goog.style.getBorderBox(bestParent);
    offsetLeftForReal += borderWidths.left;
  } else if (goog.userAgent.isDocumentModeOrHigher(8)) {
    // When calculating an element's offsetLeft, IE8-Standards Mode erroneously
    // adds the border width to the actual distance.  So we need to subtract it.
    var borderWidths = goog.style.getBorderBox(bestParent);
    offsetLeftForReal -= borderWidths.left;
  }

  if (goog.style.isRightToLeft(bestParent)) {
    // Right edge of the element relative to the left edge of its parent.
    var elementRightOffset = offsetLeftForReal + element.offsetWidth;

    // Distance from the parent's right edge to the element's right edge.
    return bestParent.clientWidth - elementRightOffset;
  }

  return offsetLeftForReal;
};


/**
 * Sets the element's scrollLeft attribute so it is correctly scrolled by
 * offsetStart pixels.  This takes into account whether the element is RTL and
 * the nuances of different browsers.  To scroll to the "beginning" of an
 * element use getOffsetStart to obtain the element's offsetStart value and then
 * pass the value to setScrollOffset.
 * @see getOffsetStart
 * @param {Element} element The element to set scrollLeft on.
 * @param {number} offsetStart The number of pixels to scroll the element.
 *     If this value is < 0, 0 is used.
 */
goog.style.bidi.setScrollOffset = function(element, offsetStart) {
  offsetStart = Math.max(offsetStart, 0);
  // In LTR and in "mirrored" browser RTL (such as IE), we set scrollLeft to
  // the number of pixels to scroll.
  // Otherwise, in RTL, we need to account for different browser behavior.
  if (!goog.style.isRightToLeft(element)) {
    element.scrollLeft = offsetStart;
  } else if (goog.userAgent.GECKO) {
    // Negative scroll-left positions in RTL.
    element.scrollLeft = -offsetStart;
  } else if (!(goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8'))) {
    // Take the current scrollLeft value and move to the right by the
    // offsetStart to get to the left edge of the element, and then by
    // the clientWidth of the element to get to the right edge.
    element.scrollLeft =
        element.scrollWidth - offsetStart - element.clientWidth;
  } else {
    element.scrollLeft = offsetStart;
  }
};


/**
 * Sets the element's left style attribute in LTR or right style attribute in
 * RTL.  Also clears the left attribute in RTL and the right attribute in LTR.
 * @param {Element} elem The element to position.
 * @param {number} left The left position in LTR; will be set as right in RTL.
 * @param {?number} top The top position.  If null only the left/right is set.
 * @param {boolean} isRtl Whether we are in RTL mode.
 */
goog.style.bidi.setPosition = function(elem, left, top, isRtl) {
  if (!goog.isNull(top)) {
    elem.style.top = top + 'px';
  }
  if (isRtl) {
    elem.style.right = left + 'px';
    elem.style.left = '';
  } else {
    elem.style.left = left + 'px';
    elem.style.right = '';
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Drag Utilities.
 *
 * Provides extensible functionality for drag & drop behaviour.
 *
 * @see ../demos/drag.html
 * @see ../demos/dragger.html
 */


goog.provide('goog.fx.DragEvent');
goog.provide('goog.fx.Dragger');
goog.provide('goog.fx.Dragger.EventType');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.style');
goog.require('goog.style.bidi');
goog.require('goog.userAgent');



/**
 * A class that allows mouse or touch-based dragging (moving) of an element
 *
 * @param {Element} target The element that will be dragged.
 * @param {Element=} opt_handle An optional handle to control the drag, if null
 *     the target is used.
 * @param {goog.math.Rect=} opt_limits Object containing left, top, width,
 *     and height.
 *
 * @extends {goog.events.EventTarget}
 * @constructor
 */
goog.fx.Dragger = function(target, opt_handle, opt_limits) {
  goog.events.EventTarget.call(this);
  this.target = target;
  this.handle = opt_handle || target;
  this.limits = opt_limits || new goog.math.Rect(NaN, NaN, NaN, NaN);

  this.document_ = goog.dom.getOwnerDocument(target);
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  // Add listener. Do not use the event handler here since the event handler is
  // used for listeners added and removed during the drag operation.
  goog.events.listen(this.handle,
      [goog.events.EventType.TOUCHSTART, goog.events.EventType.MOUSEDOWN],
      this.startDrag, false, this);
};
goog.inherits(goog.fx.Dragger, goog.events.EventTarget);


/**
 * Whether setCapture is supported by the browser.
 * @type {boolean}
 * @private
 */
goog.fx.Dragger.HAS_SET_CAPTURE_ =
    // IE and Gecko after 1.9.3 has setCapture
    // WebKit does not yet: https://bugs.webkit.org/show_bug.cgi?id=27330
    goog.userAgent.IE ||
    goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.3');


/**
 * Creates copy of node being dragged.  This is a utility function to be used
 * wherever it is inappropriate for the original source to follow the mouse
 * cursor itself.
 *
 * @param {Element} sourceEl Element to copy.
 * @return {Element} The clone of {@code sourceEl}.
 */
goog.fx.Dragger.cloneNode = function(sourceEl) {
  var clonedEl = /** @type {Element} */ (sourceEl.cloneNode(true)),
      origTexts = sourceEl.getElementsByTagName('textarea'),
      dragTexts = clonedEl.getElementsByTagName('textarea');
  // Cloning does not copy the current value of textarea elements, so correct
  // this manually.
  for (var i = 0; i < origTexts.length; i++) {
    dragTexts[i].value = origTexts[i].value;
  }
  switch (sourceEl.tagName.toLowerCase()) {
    case 'tr':
      return goog.dom.createDom(
          'table', null, goog.dom.createDom('tbody', null, clonedEl));
    case 'td':
    case 'th':
      return goog.dom.createDom(
          'table', null, goog.dom.createDom('tbody', null, goog.dom.createDom(
          'tr', null, clonedEl)));
    case 'textarea':
      clonedEl.value = sourceEl.value;
    default:
      return clonedEl;
  }
};


/**
 * Constants for event names.
 * @enum {string}
 */
goog.fx.Dragger.EventType = {
  // The drag action was canceled before the START event. Possible reasons:
  // disabled dragger, dragging with the right mouse button or releasing the
  // button before reaching the hysteresis distance.
  EARLY_CANCEL: 'earlycancel',
  START: 'start',
  BEFOREDRAG: 'beforedrag',
  DRAG: 'drag',
  END: 'end'
};


/**
 * Reference to drag target element.
 * @type {Element}
 */
goog.fx.Dragger.prototype.target;


/**
 * Reference to the handler that initiates the drag.
 * @type {Element}
 */
goog.fx.Dragger.prototype.handle;


/**
 * Object representing the limits of the drag region.
 * @type {goog.math.Rect}
 */
goog.fx.Dragger.prototype.limits;


/**
 * Whether the element is rendered right-to-left. We initialize this lazily.
 * @type {boolean|undefined}}
 * @private
 */
goog.fx.Dragger.prototype.rightToLeft_;


/**
 * Current x position of mouse or touch relative to viewport.
 * @type {number}
 */
goog.fx.Dragger.prototype.clientX = 0;


/**
 * Current y position of mouse or touch relative to viewport.
 * @type {number}
 */
goog.fx.Dragger.prototype.clientY = 0;


/**
 * Current x position of mouse or touch relative to screen. Deprecated because
 * it doesn't take into affect zoom level or pixel density.
 * @type {number}
 * @deprecated Consider switching to clientX instead.
 */
goog.fx.Dragger.prototype.screenX = 0;


/**
 * Current y position of mouse or touch relative to screen. Deprecated because
 * it doesn't take into affect zoom level or pixel density.
 * @type {number}
 * @deprecated Consider switching to clientY instead.
 */
goog.fx.Dragger.prototype.screenY = 0;


/**
 * The x position where the first mousedown or touchstart occurred.
 * @type {number}
 */
goog.fx.Dragger.prototype.startX = 0;


/**
 * The y position where the first mousedown or touchstart occurred.
 * @type {number}
 */
goog.fx.Dragger.prototype.startY = 0;


/**
 * Current x position of drag relative to target's parent.
 * @type {number}
 */
goog.fx.Dragger.prototype.deltaX = 0;


/**
 * Current y position of drag relative to target's parent.
 * @type {number}
 */
goog.fx.Dragger.prototype.deltaY = 0;


/**
 * The current page scroll value.
 * @type {goog.math.Coordinate}
 */
goog.fx.Dragger.prototype.pageScroll;


/**
 * Whether dragging is currently enabled.
 * @type {boolean}
 * @private
 */
goog.fx.Dragger.prototype.enabled_ = true;


/**
 * Whether object is currently being dragged.
 * @type {boolean}
 * @private
 */
goog.fx.Dragger.prototype.dragging_ = false;


/**
 * The amount of distance, in pixels, after which a mousedown or touchstart is
 * considered a drag.
 * @type {number}
 * @private
 */
goog.fx.Dragger.prototype.hysteresisDistanceSquared_ = 0;


/**
 * Timestamp of when the mousedown or touchstart occurred.
 * @type {number}
 * @private
 */
goog.fx.Dragger.prototype.mouseDownTime_ = 0;


/**
 * Reference to a document object to use for the events.
 * @type {Document}
 * @private
 */
goog.fx.Dragger.prototype.document_;


/**
 * The SCROLL event target used to make drag element follow scrolling.
 * @type {EventTarget}
 * @private
 */
goog.fx.Dragger.prototype.scrollTarget_;


/**
 * Whether IE drag events cancelling is on.
 * @type {boolean}
 * @private
 */
goog.fx.Dragger.prototype.ieDragStartCancellingOn_ = false;


/**
 * Whether the dragger implements the changes described in http://b/6324964,
 * making it truly RTL.  This is a temporary flag to allow clients to transition
 * to the new behavior at their convenience.  At some point it will be the
 * default.
 * @type {boolean}
 * @private
 */
goog.fx.Dragger.prototype.useRightPositioningForRtl_ = false;


/**
 * Turns on/off true RTL behavior.  This should be called immediately after
 * construction.  This is a temporary flag to allow clients to transition
 * to the new component at their convenience.  At some point true will be the
 * default.
 * @param {boolean} useRightPositioningForRtl True if "right" should be used for
 *     positioning, false if "left" should be used for positioning.
 */
goog.fx.Dragger.prototype.enableRightPositioningForRtl =
    function(useRightPositioningForRtl) {
  this.useRightPositioningForRtl_ = useRightPositioningForRtl;
};


/**
 * Returns the event handler, intended for subclass use.
 * @return {goog.events.EventHandler.<T>} The event handler.
 * @this T
 * @template T
 */
goog.fx.Dragger.prototype.getHandler = function() {
  return this.eventHandler_;
};


/**
 * Sets (or reset) the Drag limits after a Dragger is created.
 * @param {goog.math.Rect?} limits Object containing left, top, width,
 *     height for new Dragger limits. If target is right-to-left and
 *     enableRightPositioningForRtl(true) is called, then rect is interpreted as
 *     right, top, width, and height.
 */
goog.fx.Dragger.prototype.setLimits = function(limits) {
  this.limits = limits || new goog.math.Rect(NaN, NaN, NaN, NaN);
};


/**
 * Sets the distance the user has to drag the element before a drag operation is
 * started.
 * @param {number} distance The number of pixels after which a mousedown and
 *     move is considered a drag.
 */
goog.fx.Dragger.prototype.setHysteresis = function(distance) {
  this.hysteresisDistanceSquared_ = Math.pow(distance, 2);
};


/**
 * Gets the distance the user has to drag the element before a drag operation is
 * started.
 * @return {number} distance The number of pixels after which a mousedown and
 *     move is considered a drag.
 */
goog.fx.Dragger.prototype.getHysteresis = function() {
  return Math.sqrt(this.hysteresisDistanceSquared_);
};


/**
 * Sets the SCROLL event target to make drag element follow scrolling.
 *
 * @param {EventTarget} scrollTarget The event target that dispatches SCROLL
 *     events.
 */
goog.fx.Dragger.prototype.setScrollTarget = function(scrollTarget) {
  this.scrollTarget_ = scrollTarget;
};


/**
 * Enables cancelling of built-in IE drag events.
 * @param {boolean} cancelIeDragStart Whether to enable cancelling of IE
 *     dragstart event.
 */
goog.fx.Dragger.prototype.setCancelIeDragStart = function(cancelIeDragStart) {
  this.ieDragStartCancellingOn_ = cancelIeDragStart;
};


/**
 * @return {boolean} Whether the dragger is enabled.
 */
goog.fx.Dragger.prototype.getEnabled = function() {
  return this.enabled_;
};


/**
 * Set whether dragger is enabled
 * @param {boolean} enabled Whether dragger is enabled.
 */
goog.fx.Dragger.prototype.setEnabled = function(enabled) {
  this.enabled_ = enabled;
};


/** @override */
goog.fx.Dragger.prototype.disposeInternal = function() {
  goog.fx.Dragger.superClass_.disposeInternal.call(this);
  goog.events.unlisten(this.handle,
      [goog.events.EventType.TOUCHSTART, goog.events.EventType.MOUSEDOWN],
      this.startDrag, false, this);
  this.cleanUpAfterDragging_();

  this.target = null;
  this.handle = null;
};


/**
 * Whether the DOM element being manipulated is rendered right-to-left.
 * @return {boolean} True if the DOM element is rendered right-to-left, false
 *     otherwise.
 * @private
 */
goog.fx.Dragger.prototype.isRightToLeft_ = function() {
  if (!goog.isDef(this.rightToLeft_)) {
    this.rightToLeft_ = goog.style.isRightToLeft(this.target);
  }
  return this.rightToLeft_;
};


/**
 * Event handler that is used to start the drag
 * @param {goog.events.BrowserEvent} e Event object.
 */
goog.fx.Dragger.prototype.startDrag = function(e) {
  var isMouseDown = e.type == goog.events.EventType.MOUSEDOWN;

  // Dragger.startDrag() can be called by AbstractDragDrop with a mousemove
  // event and IE does not report pressed mouse buttons on mousemove. Also,
  // it does not make sense to check for the button if the user is already
  // dragging.

  if (this.enabled_ && !this.dragging_ &&
      (!isMouseDown || e.isMouseActionButton())) {
    this.maybeReinitTouchEvent_(e);
    if (this.hysteresisDistanceSquared_ == 0) {
      if (this.fireDragStart_(e)) {
        this.dragging_ = true;
        e.preventDefault();
      } else {
        // If the start drag is cancelled, don't setup for a drag.
        return;
      }
    } else {
      // Need to preventDefault for hysteresis to prevent page getting selected.
      e.preventDefault();
    }
    this.setupDragHandlers();

    this.clientX = this.startX = e.clientX;
    this.clientY = this.startY = e.clientY;
    this.screenX = e.screenX;
    this.screenY = e.screenY;
    this.computeInitialPosition();
    this.pageScroll = goog.dom.getDomHelper(this.document_).getDocumentScroll();

    this.mouseDownTime_ = goog.now();
  } else {
    this.dispatchEvent(goog.fx.Dragger.EventType.EARLY_CANCEL);
  }
};


/**
 * Sets up event handlers when dragging starts.
 * @protected
 */
goog.fx.Dragger.prototype.setupDragHandlers = function() {
  var doc = this.document_;
  var docEl = doc.documentElement;
  // Use bubbling when we have setCapture since we got reports that IE has
  // problems with the capturing events in combination with setCapture.
  var useCapture = !goog.fx.Dragger.HAS_SET_CAPTURE_;

  this.eventHandler_.listen(doc,
      [goog.events.EventType.TOUCHMOVE, goog.events.EventType.MOUSEMOVE],
      this.handleMove_, useCapture);
  this.eventHandler_.listen(doc,
      [goog.events.EventType.TOUCHEND, goog.events.EventType.MOUSEUP],
      this.endDrag, useCapture);

  if (goog.fx.Dragger.HAS_SET_CAPTURE_) {
    docEl.setCapture(false);
    this.eventHandler_.listen(docEl,
                              goog.events.EventType.LOSECAPTURE,
                              this.endDrag);
  } else {
    // Make sure we stop the dragging if the window loses focus.
    // Don't use capture in this listener because we only want to end the drag
    // if the actual window loses focus. Since blur events do not bubble we use
    // a bubbling listener on the window.
    this.eventHandler_.listen(goog.dom.getWindow(doc),
                              goog.events.EventType.BLUR,
                              this.endDrag);
  }

  if (goog.userAgent.IE && this.ieDragStartCancellingOn_) {
    // Cancel IE's 'ondragstart' event.
    this.eventHandler_.listen(doc, goog.events.EventType.DRAGSTART,
                              goog.events.Event.preventDefault);
  }

  if (this.scrollTarget_) {
    this.eventHandler_.listen(this.scrollTarget_, goog.events.EventType.SCROLL,
                              this.onScroll_, useCapture);
  }
};


/**
 * Fires a goog.fx.Dragger.EventType.START event.
 * @param {goog.events.BrowserEvent} e Browser event that triggered the drag.
 * @return {boolean} False iff preventDefault was called on the DragEvent.
 * @private
 */
goog.fx.Dragger.prototype.fireDragStart_ = function(e) {
  return this.dispatchEvent(new goog.fx.DragEvent(
      goog.fx.Dragger.EventType.START, this, e.clientX, e.clientY, e));
};


/**
 * Unregisters the event handlers that are only active during dragging, and
 * releases mouse capture.
 * @private
 */
goog.fx.Dragger.prototype.cleanUpAfterDragging_ = function() {
  this.eventHandler_.removeAll();
  if (goog.fx.Dragger.HAS_SET_CAPTURE_) {
    this.document_.releaseCapture();
  }
};


/**
 * Event handler that is used to end the drag.
 * @param {goog.events.BrowserEvent} e Event object.
 * @param {boolean=} opt_dragCanceled Whether the drag has been canceled.
 */
goog.fx.Dragger.prototype.endDrag = function(e, opt_dragCanceled) {
  this.cleanUpAfterDragging_();

  if (this.dragging_) {
    this.maybeReinitTouchEvent_(e);
    this.dragging_ = false;

    var x = this.limitX(this.deltaX);
    var y = this.limitY(this.deltaY);
    var dragCanceled = opt_dragCanceled ||
        e.type == goog.events.EventType.TOUCHCANCEL;
    this.dispatchEvent(new goog.fx.DragEvent(
        goog.fx.Dragger.EventType.END, this, e.clientX, e.clientY, e, x, y,
        dragCanceled));
  } else {
    this.dispatchEvent(goog.fx.Dragger.EventType.EARLY_CANCEL);
  }
};


/**
 * Event handler that is used to end the drag by cancelling it.
 * @param {goog.events.BrowserEvent} e Event object.
 */
goog.fx.Dragger.prototype.endDragCancel = function(e) {
  this.endDrag(e, true);
};


/**
 * Re-initializes the event with the first target touch event or, in the case
 * of a stop event, the last changed touch.
 * @param {goog.events.BrowserEvent} e A TOUCH... event.
 * @private
 */
goog.fx.Dragger.prototype.maybeReinitTouchEvent_ = function(e) {
  var type = e.type;

  if (type == goog.events.EventType.TOUCHSTART ||
      type == goog.events.EventType.TOUCHMOVE) {
    e.init(e.getBrowserEvent().targetTouches[0], e.currentTarget);
  } else if (type == goog.events.EventType.TOUCHEND ||
             type == goog.events.EventType.TOUCHCANCEL) {
    e.init(e.getBrowserEvent().changedTouches[0], e.currentTarget);
  }
};


/**
 * Event handler that is used on mouse / touch move to update the drag
 * @param {goog.events.BrowserEvent} e Event object.
 * @private
 */
goog.fx.Dragger.prototype.handleMove_ = function(e) {
  if (this.enabled_) {
    this.maybeReinitTouchEvent_(e);
    // dx in right-to-left cases is relative to the right.
    var sign = this.useRightPositioningForRtl_ &&
        this.isRightToLeft_() ? -1 : 1;
    var dx = sign * (e.clientX - this.clientX);
    var dy = e.clientY - this.clientY;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.screenX = e.screenX;
    this.screenY = e.screenY;

    if (!this.dragging_) {
      var diffX = this.startX - this.clientX;
      var diffY = this.startY - this.clientY;
      var distance = diffX * diffX + diffY * diffY;
      if (distance > this.hysteresisDistanceSquared_) {
        if (this.fireDragStart_(e)) {
          this.dragging_ = true;
        } else {
          // DragListGroup disposes of the dragger if BEFOREDRAGSTART is
          // canceled.
          if (!this.isDisposed()) {
            this.endDrag(e);
          }
          return;
        }
      }
    }

    var pos = this.calculatePosition_(dx, dy);
    var x = pos.x;
    var y = pos.y;

    if (this.dragging_) {

      var rv = this.dispatchEvent(new goog.fx.DragEvent(
          goog.fx.Dragger.EventType.BEFOREDRAG, this, e.clientX, e.clientY,
          e, x, y));

      // Only do the defaultAction and dispatch drag event if predrag didn't
      // prevent default
      if (rv) {
        this.doDrag(e, x, y, false);
        e.preventDefault();
      }
    }
  }
};


/**
 * Calculates the drag position.
 *
 * @param {number} dx The horizontal movement delta.
 * @param {number} dy The vertical movement delta.
 * @return {goog.math.Coordinate} The newly calculated drag element position.
 * @private
 */
goog.fx.Dragger.prototype.calculatePosition_ = function(dx, dy) {
  // Update the position for any change in body scrolling
  var pageScroll = goog.dom.getDomHelper(this.document_).getDocumentScroll();
  dx += pageScroll.x - this.pageScroll.x;
  dy += pageScroll.y - this.pageScroll.y;
  this.pageScroll = pageScroll;

  this.deltaX += dx;
  this.deltaY += dy;

  var x = this.limitX(this.deltaX);
  var y = this.limitY(this.deltaY);
  return new goog.math.Coordinate(x, y);
};


/**
 * Event handler for scroll target scrolling.
 * @param {goog.events.BrowserEvent} e The event.
 * @private
 */
goog.fx.Dragger.prototype.onScroll_ = function(e) {
  var pos = this.calculatePosition_(0, 0);
  e.clientX = this.clientX;
  e.clientY = this.clientY;
  this.doDrag(e, pos.x, pos.y, true);
};


/**
 * @param {goog.events.BrowserEvent} e The closure object
 *     representing the browser event that caused a drag event.
 * @param {number} x The new horizontal position for the drag element.
 * @param {number} y The new vertical position for the drag element.
 * @param {boolean} dragFromScroll Whether dragging was caused by scrolling
 *     the associated scroll target.
 * @protected
 */
goog.fx.Dragger.prototype.doDrag = function(e, x, y, dragFromScroll) {
  this.defaultAction(x, y);
  this.dispatchEvent(new goog.fx.DragEvent(
      goog.fx.Dragger.EventType.DRAG, this, e.clientX, e.clientY, e, x, y));
};


/**
 * Returns the 'real' x after limits are applied (allows for some
 * limits to be undefined).
 * @param {number} x X-coordinate to limit.
 * @return {number} The 'real' X-coordinate after limits are applied.
 */
goog.fx.Dragger.prototype.limitX = function(x) {
  var rect = this.limits;
  var left = !isNaN(rect.left) ? rect.left : null;
  var width = !isNaN(rect.width) ? rect.width : 0;
  var maxX = left != null ? left + width : Infinity;
  var minX = left != null ? left : -Infinity;
  return Math.min(maxX, Math.max(minX, x));
};


/**
 * Returns the 'real' y after limits are applied (allows for some
 * limits to be undefined).
 * @param {number} y Y-coordinate to limit.
 * @return {number} The 'real' Y-coordinate after limits are applied.
 */
goog.fx.Dragger.prototype.limitY = function(y) {
  var rect = this.limits;
  var top = !isNaN(rect.top) ? rect.top : null;
  var height = !isNaN(rect.height) ? rect.height : 0;
  var maxY = top != null ? top + height : Infinity;
  var minY = top != null ? top : -Infinity;
  return Math.min(maxY, Math.max(minY, y));
};


/**
 * Overridable function for computing the initial position of the target
 * before dragging begins.
 * @protected
 */
goog.fx.Dragger.prototype.computeInitialPosition = function() {
  this.deltaX = this.useRightPositioningForRtl_ ?
      goog.style.bidi.getOffsetStart(this.target) : this.target.offsetLeft;
  this.deltaY = this.target.offsetTop;
};


/**
 * Overridable function for handling the default action of the drag behaviour.
 * Normally this is simply moving the element to x,y though in some cases it
 * might be used to resize the layer.  This is basically a shortcut to
 * implementing a default ondrag event handler.
 * @param {number} x X-coordinate for target element. In right-to-left, x this
 *     is the number of pixels the target should be moved to from the right.
 * @param {number} y Y-coordinate for target element.
 */
goog.fx.Dragger.prototype.defaultAction = function(x, y) {
  if (this.useRightPositioningForRtl_ && this.isRightToLeft_()) {
    this.target.style.right = x + 'px';
  } else {
    this.target.style.left = x + 'px';
  }
  this.target.style.top = y + 'px';
};


/**
 * @return {boolean} Whether the dragger is currently in the midst of a drag.
 */
goog.fx.Dragger.prototype.isDragging = function() {
  return this.dragging_;
};



/**
 * Object representing a drag event
 * @param {string} type Event type.
 * @param {goog.fx.Dragger} dragobj Drag object initiating event.
 * @param {number} clientX X-coordinate relative to the viewport.
 * @param {number} clientY Y-coordinate relative to the viewport.
 * @param {goog.events.BrowserEvent} browserEvent The closure object
 *   representing the browser event that caused this drag event.
 * @param {number=} opt_actX Optional actual x for drag if it has been limited.
 * @param {number=} opt_actY Optional actual y for drag if it has been limited.
 * @param {boolean=} opt_dragCanceled Whether the drag has been canceled.
 * @constructor
 * @extends {goog.events.Event}
 */
goog.fx.DragEvent = function(type, dragobj, clientX, clientY, browserEvent,
                             opt_actX, opt_actY, opt_dragCanceled) {
  goog.events.Event.call(this, type);

  /**
   * X-coordinate relative to the viewport
   * @type {number}
   */
  this.clientX = clientX;

  /**
   * Y-coordinate relative to the viewport
   * @type {number}
   */
  this.clientY = clientY;

  /**
   * The closure object representing the browser event that caused this drag
   * event.
   * @type {goog.events.BrowserEvent}
   */
  this.browserEvent = browserEvent;

  /**
   * The real x-position of the drag if it has been limited
   * @type {number}
   */
  this.left = goog.isDef(opt_actX) ? opt_actX : dragobj.deltaX;

  /**
   * The real y-position of the drag if it has been limited
   * @type {number}
   */
  this.top = goog.isDef(opt_actY) ? opt_actY : dragobj.deltaY;

  /**
   * Reference to the drag object for this event
   * @type {goog.fx.Dragger}
   */
  this.dragger = dragobj;

  /**
   * Whether drag was canceled with this event. Used to differentiate between
   * a legitimate drag END that can result in an action and a drag END which is
   * a result of a drag cancelation. For now it can happen 1) with drag END
   * event on FireFox when user drags the mouse out of the window, 2) with
   * drag END event on IE7 which is generated on MOUSEMOVE event when user
   * moves the mouse into the document after the mouse button has been
   * released, 3) when TOUCHCANCEL is raised instead of TOUCHEND (on touch
   * events).
   * @type {boolean}
   */
  this.dragCanceled = !!opt_dragCanceled;
};
goog.inherits(goog.fx.DragEvent, goog.events.Event);
// This file was automatically generated from book.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.book');

goog.require('soy');
goog.require('soydata');
goog.require('feng.templates.common');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.book.Book = function(opt_data, opt_ignored) {
  var output = '<div id="book">' + feng.templates.common.CloseButton(null) + '<h2>Feng Shui Tips Collected <span class="tip-counter"></span></h2><div class="scroller-wrapper"><div class="scroller"><div class="inner"><ul>';
  var tipList6 = opt_data.tips;
  var tipListLen6 = tipList6.length;
  for (var tipIndex6 = 0; tipIndex6 < tipListLen6; tipIndex6++) {
    var tipData6 = tipList6[tipIndex6];
    output += '<li class="tip-module" data-tip-id="' + tipData6.id + '"><div class="card"><div class="curtain"><div class="wrapper unlocked"><div class="icon icon-' + tipData6.icon + '"></div><h1>' + tipData6.name + '</h1><h2><span>Located at</span>' + tipData6.sectionId + '</h2></div><div class="wrapper locked"><div class="icon icon-lock"></div><h1>Unknown Tip</h1><h2><span>Unlock in</span>' + tipData6.sectionId + '</h2></div></div><div class="detail"><div class="screen" data-src="' + tipData6.shareImageUrl + '"><div class="loader"></div></div><div class="advice"><h3>' + tipData6.name + '</h3><div class="scroller"><div class="content"><p>' + ((tipData6.problem) ? tipData6.problem + '<br>' : '') + ((tipData6.advice) ? tipData6.advice + '<br>' : '');
    if (tipData6.details['descriptions']) {
      var keyList32 = soy.$$getMapKeys(tipData6.details['descriptions']);
      var keyListLen32 = keyList32.length;
      for (var keyIndex32 = 0; keyIndex32 < keyListLen32; keyIndex32++) {
        var keyData32 = keyList32[keyIndex32];
        output += tipData6.details['descriptions'][keyData32] + '</br>';
      }
    }
    output += '</p></div>' + feng.templates.common.ScrollBar(null) + '</div><ul class="share"><li><a href="https://www.facebook.com/sharer/sharer.php?u=http://fengshuirealtime.com/assets/html/share/' + tipData6.id + '.html" target="_blank" class="icon icon-facebook"></a></li><li><a href="https://twitter.com/intent/tweet?original_referer=http://fengshuirealtime.com/assets/html/share/' + tipData6.id + '.html" target="_blank" class="icon icon-twitter"></a></li><li><a href="https://plus.google.com/share?url=http://fengshuirealtime.com/assets/html/share/' + tipData6.id + '.html" target="_blank" class="icon icon-google"></a></li></ul></div></div></div></li>';
  }
  output += '</ul></div></div></div><div class="scrubber"><button class="handle"></button></div></div>';
  return output;
};
goog.provide('feng.fx.ScrollBar');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.fx.Dragger');


/**
 * @constructor
 */
feng.fx.ScrollBar = function(domElement, scrollerEl){

	goog.base(this);

	this.domElement = domElement;
	this._handleEl = goog.dom.getElementByClass('handle', this.domElement);

	this._scrollerEl = scrollerEl;

	this._eventHandler = new goog.events.EventHandler(this);

	this.isHoveringScroller = false;

	this._scrollerContentHeight = 0;
	this._hasScrollBar = false;

	this._draggerLimits = new goog.math.Rect(0, 0, 0, 0);
	this._dragger = new goog.fx.Dragger(this._handleEl, null, this._draggerLimits);
	this._dragger.defaultAction = goog.bind(this.onDragHandle, this);
};
goog.inherits(feng.fx.ScrollBar, goog.events.EventTarget);


feng.fx.ScrollBar.prototype.activate = function() {

	this._eventHandler.listen( this._scrollerEl, 'scroll', this.onScrollerScroll, false, this );
	this._eventHandler.listen( this._scrollerEl, 'mouseover', this.onMouseOverScroller, false, this );
	this._eventHandler.listen( this._scrollerEl, 'mouseout', this.onMouseOutScroller, false, this );

	goog.style.setStyle( this._scrollerEl, 'overflow', 'auto' );

	this.resize();
};


feng.fx.ScrollBar.prototype.deactivate = function() {

	this._eventHandler.removeAll();

	goog.style.setStyle( this._scrollerEl, 'overflow', 'hidden' );
};


feng.fx.ScrollBar.prototype.resize = function() {

	// update scroller size
	this._scrollerContentHeight = goog.style.getSize(this._scrollerEl).height;
	var scrollerRatio = this._scrollerContentHeight / this._scrollerEl.scrollHeight;
	var handlePer = Math.round(scrollerRatio * 100);
	goog.style.setStyle( this._handleEl, 'height', handlePer + '%' );

	this._hasScrollBar = !(handlePer >= 100 || handlePer <= 0);
	goog.style.showElement( this.domElement, this._hasScrollBar );

	// update dragger
	var scrollBarPosition = goog.style.getPosition(this.domElement);
	var scrollBarHeight = goog.style.getSize(this.domElement).height;
	this._draggerLimits.height = scrollBarHeight - (scrollBarHeight * scrollerRatio);
	this._dragger.setLimits( this._draggerLimits );
};


feng.fx.ScrollBar.prototype.scrollTo = function( y ) {

	this._scrollerEl.scrollTop = y;
	this.onScrollerScroll();
};


feng.fx.ScrollBar.prototype.onDragHandle = function(x, y) {

	goog.style.setPosition( this._handleEl, x, y );

	var ratio = y / this._draggerLimits.height;
	var distanceToScroll = this._scrollerEl.scrollHeight - this._scrollerContentHeight;
	this._scrollerEl.scrollTop = distanceToScroll * ratio;
};


feng.fx.ScrollBar.prototype.onScrollerScroll = function(e) {

	var handleRatio = Math.round(this._scrollerEl.scrollTop / this._scrollerEl.scrollHeight * 100);

	goog.style.setStyle( this._handleEl, 'top', handleRatio + '%' );
};


feng.fx.ScrollBar.prototype.onMouseOverScroller = function(e) {

	this.isHoveringScroller = this._hasScrollBar;
};


feng.fx.ScrollBar.prototype.onMouseOutScroller = function(e) {

	if(e.relatedTarget) {
		this.isHoveringScroller = false;
		return;
	}

	if( e.relatedTarget && !goog.dom.contains(e.currentTarget, e.relatedTarget) ) {
		this.isHoveringScroller = false;
	}
};goog.provide('feng.views.book.TipModule');

goog.require('goog.dom');
goog.require('goog.events.EventHandler');
goog.require('goog.math.Size');
goog.require('feng.events');
goog.require('feng.utils.Utils');
goog.require('feng.fx.ScrollBar');


feng.views.book.TipModule = function( domElement, index, widthChangeCallback ) {

	goog.base(this);
	
	this.domElement = domElement;
	this._cardEl = goog.dom.getElementByClass('card', this.domElement);

	var scrollerEl = goog.dom.getElementByClass('scroller', this.domElement);
	var scrollerContentEl = goog.dom.getElementByClass('content', scrollerEl);
	var scrollBarEl = goog.dom.getElementByClass('scrollbar', scrollerEl);

	this._scrollBar = new feng.fx.ScrollBar( scrollBarEl, scrollerContentEl );

	this._shareButtons = goog.dom.query('.share a', this.domElement);

	this.id = this.domElement.getAttribute('data-tip-id');

	this.index = index;
	
	this._widthChangeCallback = widthChangeCallback;

	this.x = 0;
	this.size = new goog.math.Size();

	this._minSize = feng.views.book.TipModule.MIN_SIZE;
	this._aspectRatio = this._minSize.aspectRatio();

	this._ratioOfWidth = feng.views.book.TipModule.RATIO_OF_WIDTH;
	this._ratioOfMargin = feng.views.book.TipModule.RATIO_OF_MARGIN;

	this._margin = 0;
	this._coverWidth = 0;

	this._imageLoaded = false;

	this._isUnlocked = false;

	this._outerEventHandler = new goog.events.EventHandler(this);
	this._innerEventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.views.book.TipModule, goog.events.EventTarget);


feng.views.book.TipModule.prototype.activate = function() {

	this._outerEventHandler.listen( this.domElement, 'click', this.onClick, false, this );
};


feng.views.book.TipModule.prototype.deactivate = function() {

	this._outerEventHandler.removeAll();
	this._innerEventHandler.removeAll();
};


feng.views.book.TipModule.prototype.getFinalWidth = function() {

	return this._coverWidth + this._margin * 2;
};


feng.views.book.TipModule.prototype.setActive = function( isActive ) {

	if(isActive && this._isUnlocked) {

		goog.dom.classlist.add(this.domElement, 'active');

		if(!this._imageLoaded) {
			
			var screenEl = goog.dom.getElementByClass('screen', this.domElement);

			var img = new Image();
			img.src = screenEl.getAttribute('data-src');

			goog.events.listenOnce(img, 'load', function() {
				goog.style.setStyle(screenEl, 'background-image', 'url(' + img.src + ')');
				goog.dom.classlist.enable( screenEl, 'loaded', true );
			});
		}

		// activate inner events
		this._scrollBar.activate();

		goog.array.forEach(this._shareButtons, function(shareButton) {
			this._innerEventHandler.listen( shareButton, 'click', this.onClickShareButton, false, this );
		}, this);

	}else {

		goog.dom.classlist.remove(this.domElement, 'active');

		this._scrollBar.deactivate();

		// deactivate inner events
		this._innerEventHandler.removeAll();
	}
};


feng.views.book.TipModule.prototype.setX = function( x ) {

	this.x = x;
	goog.style.setStyle( this.domElement, 'transform', 'translateX(' + x + 'px)' );
};


feng.views.book.TipModule.prototype.setSize = function( viewportSize ) {

	// update element size
	this._coverWidth = viewportSize.width * this._ratioOfWidth;
	this._coverWidth = Math.max(this._minSize.width, this._coverWidth);

	var maxHeight = Math.max(450, viewportSize.height * .6);
	var height = Math.min(maxHeight, this._coverWidth / this._aspectRatio);

	this._coverWidth = height * this._aspectRatio;

	this._margin = viewportSize.width * this._ratioOfMargin;
	var widthIncludeMargins = this._coverWidth + this._margin * 2;

	this.size.width = widthIncludeMargins;
	this.size.height = height;

	goog.style.setSize( this._cardEl, this._coverWidth, height );
	goog.style.setSize( this.domElement, this.size );

	// update scroller size
	this._scrollBar.resize();

	//
	return this.size;
};


feng.views.book.TipModule.prototype.isHoveringScroller = function() {

	return this._scrollBar.isHoveringScroller;
};


feng.views.book.TipModule.prototype.updateWidth = function() {

	goog.style.setSize( this.domElement, this.size );

	this._widthChangeCallback( this.index, this.size.width );
};


feng.views.book.TipModule.prototype.unlock = function() {

	this._isUnlocked = true;

	goog.dom.classlist.enable( this.domElement, 'unlocked', true );
};


feng.views.book.TipModule.prototype.onClick = function(e) {

	this.dispatchEvent( feng.events.EventType.CHANGE );
};


feng.views.book.TipModule.prototype.onClickShareButton = function(e) {

  e.preventDefault();

  feng.utils.Utils.popUp( e.currentTarget.href );
};


feng.views.book.TipModule.RATIO_OF_WIDTH = 0.35;
feng.views.book.TipModule.RATIO_OF_MARGIN = 0.025;
feng.views.book.TipModule.MIN_SIZE = new goog.math.Size(300, 440);// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview This event wrapper will dispatch an event when the user uses
 * the mouse wheel to scroll an element. You can get the direction by checking
 * the deltaX and deltaY properties of the event.
 *
 * This class aims to smooth out inconsistencies between browser platforms with
 * regards to mousewheel events, but we do not cover every possible
 * software/hardware combination out there, some of which occasionally produce
 * very large deltas in mousewheel events. If your application wants to guard
 * against extremely large deltas, use the setMaxDeltaX and setMaxDeltaY APIs
 * to set maximum values that make sense for your application.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @see ../demos/mousewheelhandler.html
 */

goog.provide('goog.events.MouseWheelEvent');
goog.provide('goog.events.MouseWheelHandler');
goog.provide('goog.events.MouseWheelHandler.EventType');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.EventTarget');
goog.require('goog.math');
goog.require('goog.style');
goog.require('goog.userAgent');



/**
 * This event handler allows you to catch mouse wheel events in a consistent
 * manner.
 * @param {Element|Document} element The element to listen to the mouse wheel
 *     event on.
 * @param {boolean=} opt_capture Whether to handle the mouse wheel event in
 *     capture phase.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.events.MouseWheelHandler = function(element, opt_capture) {
  goog.events.EventTarget.call(this);

  /**
   * This is the element that we will listen to the real mouse wheel events on.
   * @type {Element|Document}
   * @private
   */
  this.element_ = element;

  var rtlElement = goog.dom.isElement(this.element_) ?
      /** @type {Element} */ (this.element_) :
      (this.element_ ? /** @type {Document} */ (this.element_).body : null);

  /**
   * True if the element exists and is RTL, false otherwise.
   * @type {boolean}
   * @private
   */
  this.isRtl_ = !!rtlElement && goog.style.isRightToLeft(rtlElement);

  var type = goog.userAgent.GECKO ? 'DOMMouseScroll' : 'mousewheel';

  /**
   * The key returned from the goog.events.listen.
   * @type {goog.events.Key}
   * @private
   */
  this.listenKey_ = goog.events.listen(this.element_, type, this, opt_capture);
};
goog.inherits(goog.events.MouseWheelHandler, goog.events.EventTarget);


/**
 * Enum type for the events fired by the mouse wheel handler.
 * @enum {string}
 */
goog.events.MouseWheelHandler.EventType = {
  MOUSEWHEEL: 'mousewheel'
};


/**
 * Optional maximum magnitude for x delta on each mousewheel event.
 * @type {number|undefined}
 * @private
 */
goog.events.MouseWheelHandler.prototype.maxDeltaX_;


/**
 * Optional maximum magnitude for y delta on each mousewheel event.
 * @type {number|undefined}
 * @private
 */
goog.events.MouseWheelHandler.prototype.maxDeltaY_;


/**
 * @param {number} maxDeltaX Maximum magnitude for x delta on each mousewheel
 *     event. Should be non-negative.
 */
goog.events.MouseWheelHandler.prototype.setMaxDeltaX = function(maxDeltaX) {
  this.maxDeltaX_ = maxDeltaX;
};


/**
 * @param {number} maxDeltaY Maximum magnitude for y delta on each mousewheel
 *     event. Should be non-negative.
 */
goog.events.MouseWheelHandler.prototype.setMaxDeltaY = function(maxDeltaY) {
  this.maxDeltaY_ = maxDeltaY;
};


/**
 * Handles the events on the element.
 * @param {goog.events.BrowserEvent} e The underlying browser event.
 */
goog.events.MouseWheelHandler.prototype.handleEvent = function(e) {
  var deltaX = 0;
  var deltaY = 0;
  var detail = 0;
  var be = e.getBrowserEvent();
  if (be.type == 'mousewheel') {
    var wheelDeltaScaleFactor = 1;
    if (goog.userAgent.IE ||
        goog.userAgent.WEBKIT &&
        (goog.userAgent.WINDOWS || goog.userAgent.isVersionOrHigher('532.0'))) {
      // In IE we get a multiple of 120; we adjust to a multiple of 3 to
      // represent number of lines scrolled (like Gecko).
      // Newer versions of Webkit match IE behavior, and WebKit on
      // Windows also matches IE behavior.
      // See bug https://bugs.webkit.org/show_bug.cgi?id=24368
      wheelDeltaScaleFactor = 40;
    }

    detail = goog.events.MouseWheelHandler.smartScale_(
        -be.wheelDelta, wheelDeltaScaleFactor);
    if (goog.isDef(be.wheelDeltaX)) {
      // Webkit has two properties to indicate directional scroll, and
      // can scroll both directions at once.
      deltaX = goog.events.MouseWheelHandler.smartScale_(
          -be.wheelDeltaX, wheelDeltaScaleFactor);
      deltaY = goog.events.MouseWheelHandler.smartScale_(
          -be.wheelDeltaY, wheelDeltaScaleFactor);
    } else {
      deltaY = detail;
    }

    // Historical note: Opera (pre 9.5) used to negate the detail value.
  } else { // Gecko
    // Gecko returns multiple of 3 (representing the number of lines scrolled)
    detail = be.detail;

    // Gecko sometimes returns really big values if the user changes settings to
    // scroll a whole page per scroll
    if (detail > 100) {
      detail = 3;
    } else if (detail < -100) {
      detail = -3;
    }

    // Firefox 3.1 adds an axis field to the event to indicate direction of
    // scroll.  See https://developer.mozilla.org/en/Gecko-Specific_DOM_Events
    if (goog.isDef(be.axis) && be.axis === be.HORIZONTAL_AXIS) {
      deltaX = detail;
    } else {
      deltaY = detail;
    }
  }

  if (goog.isNumber(this.maxDeltaX_)) {
    deltaX = goog.math.clamp(deltaX, -this.maxDeltaX_, this.maxDeltaX_);
  }
  if (goog.isNumber(this.maxDeltaY_)) {
    deltaY = goog.math.clamp(deltaY, -this.maxDeltaY_, this.maxDeltaY_);
  }
  // Don't clamp 'detail', since it could be ambiguous which axis it refers to
  // and because it's informally deprecated anyways.

  // For horizontal scrolling we need to flip the value for RTL grids.
  if (this.isRtl_) {
    deltaX = -deltaX;
  }
  var newEvent = new goog.events.MouseWheelEvent(detail, be, deltaX, deltaY);
  this.dispatchEvent(newEvent);
};


/**
 * Helper for scaling down a mousewheel delta by a scale factor, if appropriate.
 * @param {number} mouseWheelDelta Delta from a mouse wheel event. Expected to
 *     be an integer.
 * @param {number} scaleFactor Factor to scale the delta down by. Expected to
 *     be an integer.
 * @return {number} Scaled-down delta value, or the original delta if the
 *     scaleFactor does not appear to be applicable.
 * @private
 */
goog.events.MouseWheelHandler.smartScale_ = function(mouseWheelDelta,
    scaleFactor) {
  // The basic problem here is that in Webkit on Mac and Linux, we can get two
  // very different types of mousewheel events: from continuous devices
  // (touchpads, Mighty Mouse) or non-continuous devices (normal wheel mice).
  //
  // Non-continuous devices in Webkit get their wheel deltas scaled up to
  // behave like IE. Continuous devices return much smaller unscaled values
  // (which most of the time will not be cleanly divisible by the IE scale
  // factor), so we should not try to normalize them down.
  //
  // Detailed discussion:
  //   https://bugs.webkit.org/show_bug.cgi?id=29601
  //   http://trac.webkit.org/browser/trunk/WebKit/chromium/src/mac/WebInputEventFactory.mm#L1063
  if (goog.userAgent.WEBKIT &&
      (goog.userAgent.MAC || goog.userAgent.LINUX) &&
      (mouseWheelDelta % scaleFactor) != 0) {
    return mouseWheelDelta;
  } else {
    return mouseWheelDelta / scaleFactor;
  }
};


/** @override */
goog.events.MouseWheelHandler.prototype.disposeInternal = function() {
  goog.events.MouseWheelHandler.superClass_.disposeInternal.call(this);
  goog.events.unlistenByKey(this.listenKey_);
  this.listenKey_ = null;
};



/**
 * A base class for mouse wheel events. This is used with the
 * MouseWheelHandler.
 *
 * @param {number} detail The number of rows the user scrolled.
 * @param {Event} browserEvent Browser event object.
 * @param {number} deltaX The number of rows the user scrolled in the X
 *     direction.
 * @param {number} deltaY The number of rows the user scrolled in the Y
 *     direction.
 * @constructor
 * @extends {goog.events.BrowserEvent}
 * @final
 */
goog.events.MouseWheelEvent = function(detail, browserEvent, deltaX, deltaY) {
  goog.events.BrowserEvent.call(this, browserEvent);

  this.type = goog.events.MouseWheelHandler.EventType.MOUSEWHEEL;

  /**
   * The number of lines the user scrolled
   * @type {number}
   * NOTE: Informally deprecated. Use deltaX and deltaY instead, they provide
   * more information.
   */
  this.detail = detail;

  /**
   * The number of "lines" scrolled in the X direction.
   *
   * Note that not all browsers provide enough information to distinguish
   * horizontal and vertical scroll events, so for these unsupported browsers,
   * we will always have a deltaX of 0, even if the user scrolled their mouse
   * wheel or trackpad sideways.
   *
   * Currently supported browsers are Webkit and Firefox 3.1 or later.
   *
   * @type {number}
   */
  this.deltaX = deltaX;

  /**
   * The number of lines scrolled in the Y direction.
   * @type {number}
   */
  this.deltaY = deltaY;
};
goog.inherits(goog.events.MouseWheelEvent, goog.events.BrowserEvent);
goog.provide('feng.views.book.Book');

goog.require('goog.dom');
goog.require('goog.events.EventHandler');
goog.require('goog.events.MouseWheelHandler');
goog.require('goog.fx.Dragger');
goog.require('goog.math.Rect');
goog.require('goog.object');
goog.require('feng.events');
goog.require('feng.models.achievements.Achievements');
goog.require('feng.templates.book');
goog.require('feng.views.book.TipModule');


feng.views.book.Book = function() {

	goog.base(this);
	
	// retrieve final tips
	var tips = feng.models.achievements.Achievements.getInstance().getAllTips();

	this._tips = goog.array.filter(tips, function(tip) {

		if( tip.isFinal ) {
			tip.listen( feng.events.EventType.UNLOCK, this.onTipUnlock, false, this );
		}

		return tip.isFinal;
	}, this);

	this.domElement = soy.renderAsFragment(feng.templates.book.Book, {
		tips: this._tips
	});

	goog.dom.appendChild(goog.dom.getElement('main'), this.domElement);

	this._closeButton = goog.dom.getElementByClass('close-button', this.domElement);

	this._tipCounterEl = goog.dom.getElementByClass('tip-counter', this.domElement);

	this._scrollerEl = goog.dom.getElementByClass('scroller', this.domElement);
	this._scrollerInnerEl = goog.dom.getElementByClass('inner', this._scrollerEl);

	this._scrubberEl = goog.dom.getElementByClass('scrubber', this.domElement);
	this._handleEl = goog.dom.getElementByClass('handle', this._scrubberEl);

	this._scrubberWidth = 0;
	this._handleWidth = 0;

	this._dragger = new goog.fx.Dragger(this._handleEl);
	this._dragger.setHysteresis( 10 );
	this._draggerLimits = new goog.math.Rect(0, 0, 0, 0);

	var tipModuleEls = goog.dom.getElementsByClass('tip-module', this.domElement);
	var widthChangeCallback = goog.bind(this.updateFromTipModuleIndex, this);

	this._tipModules = goog.array.map( tipModuleEls, function(tipModuleEl, index) {

		var tipModule = new feng.views.book.TipModule( tipModuleEl, index, widthChangeCallback );
		tipModule.setParentEventTarget( this );
		return tipModule;
	}, this);

	this._tipModulesDic = {};

	goog.array.forEach(this._tipModules, function(tipModule) {
		this._tipModulesDic[ tipModule.id ] = tipModule;
	}, this);

	this._tipModuleWidths = [];
	this._openedTipModule = null;
	this._activeTipModule = null;
	this._activeTipIndex = 0;

	this._viewportSize = null;
	this._scrollX = 0;
	this._targetScrollX = 0;
	this._sumFunc = function(r, v, i, arr) {return r + v;}

	this._scrollTweener = null;

	this._animateInTweener = new TimelineMax();

	//
	this._animateOut = goog.bind( this.animateOut, this );
	this._prevTipModule = goog.bind( this.prevTipModule, this );
	this._nextTipModule = goog.bind( this.nextTipModule, this );

	this._enterKeyId = null;
	this._leftKeyId = null;
	this._rightKeyId = null;

	//
	this._mouseWheelHandler = new goog.events.MouseWheelHandler( this.domElement );
	this._maxDelta = 30;
	this._mouseWheelHandler.setMaxDeltaX( this._maxDelta );
	this._mouseWheelHandler.setMaxDeltaY( this._maxDelta );

	this._eventHandler = new goog.events.EventHandler( this );

	goog.events.listen( feng.navigationController, feng.events.EventType.CHANGE, this.onNavigationChange, false, this );

	this.animateOut( true );

	this.updateTips();
};
goog.inherits(feng.views.book.Book, goog.events.EventTarget);
goog.addSingletonGetter(feng.views.book.Book);


feng.views.book.Book.prototype.activate = function() {

	this._eventHandler.listen( window, 'resize', this.onResize, false, this );
	this._eventHandler.listen( this._closeButton, 'click', this.animateOut, false, this );
	this._eventHandler.listen( this, feng.events.EventType.CHANGE, this.onTipModuleChange, false, this );
	this._eventHandler.listen( this, feng.events.EventType.CLOSE, this.onTipModuleClose, false, this );
	this._eventHandler.listen( this._mouseWheelHandler, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.onMouseWheel, false, this );
	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.DRAG, this.onDrag, false, this );
	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.START, this.onDragStart, false, this );
	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.END, this.onDragEnd, false, this );

	this._enterKeyId = feng.keyboardController.bind( this._animateOut, feng.keyboardController.key.ESC, true );
	this._leftKeyId = feng.keyboardController.bind( this._prevTipModule, feng.keyboardController.key.LEFT );
	this._rightKeyId = feng.keyboardController.bind( this._nextTipModule, feng.keyboardController.key.RIGHT );

	goog.array.forEach( this._tipModules, function(tipModule) {
		tipModule.activate();
	});
};


feng.views.book.Book.prototype.deactivate = function() {

	this._eventHandler.removeAll();

	feng.keyboardController.unbind( this._enterKeyId );
	feng.keyboardController.unbind( this._leftKeyId );
	feng.keyboardController.unbind( this._rightKeyId );

	goog.array.forEach( this._tipModules, function(tipModule) {
		tipModule.deactivate();
	});
};


feng.views.book.Book.prototype.resize = function() {

	this._viewportSize = feng.viewportSize;

	this._tipModuleWidths = goog.array.map(this._tipModules, function(tipModule) {
		return tipModule.setSize( this._viewportSize ).width;
	}, this);

	goog.style.setStyle(this._scrollerEl, 'height', this._tipModules[0].size.height + 'px');

	// rearrange tip module positions after resizing
	goog.array.forEach(this._tipModules, function(tipModule, index) {

		var widths = this._tipModuleWidths.slice(0, index);
		var x = goog.array.reduce(widths, this._sumFunc, 0); 

		tipModule.setX( x );

	}, this);

	// set scrubber limits
	var tipModuleTotalWidth = goog.array.reduce(this._tipModuleWidths, this._sumFunc, 0); 
	this._scrubberWidth = goog.style.getSize(this._scrubberEl).width;
	this._handleWidth = this._viewportSize.width / tipModuleTotalWidth * this._scrubberWidth;
	goog.style.setStyle(this._handleEl, 'width', this._handleWidth + 'px');
	this._draggerLimits.width = this._scrubberWidth - this._handleWidth;
	this._dragger.setLimits( this._draggerLimits );
};


feng.views.book.Book.prototype.updateFromTipModuleIndex = function( tipModuleIndex, tipModuleWidth ) {

	this._tipModuleWidths[ tipModuleIndex ] = tipModuleWidth;

	// rearrange tip module positions when any tip module width change
	goog.array.forEach(this._tipModules, function(tipModule, index) {

		var widths = this._tipModuleWidths.slice(0, index);
		var x = goog.array.reduce(widths, this._sumFunc, 0); 

		tipModule.setX( x );

	}, this);
};


feng.views.book.Book.prototype.animateIn = function( tipId ) {

	goog.style.showElement(this.domElement, true);

	this.activate();

	this.resize();

	// lock to tip if id supplied
	var tipModuleIndex = 0;

	if(tipId) {

		tipModuleIndex = goog.array.findIndex(this._tipModules, function(tipModule) {
			var el = tipModule.domElement;
			return (el.getAttribute('data-tip-id') === tipId);
		});
	}

	this.scrollToTipModule( tipModuleIndex, true );

	this.dispatchEvent( feng.events.EventType.ANIMATE_IN );

	// animate in
	this._animateInTweener.clear();

	var tipTweeners = [];

	var i = Math.max(0, tipModuleIndex - 2);
	var l = Math.min(tipModuleIndex + 2, this._tipModules.length);

	for( i = i; i <= l; i ++ ) {

		var tipModule = this._tipModules[i];
		var el = tipModule.domElement;

		TweenMax.set( el, {
			'x': tipModule.x + this._viewportSize.width
		});

		var tweener = TweenMax.to( el, 1.2, {
			'x': tipModule.x,
			'ease': Strong.easeOut
		});

		tipTweeners.push( tweener );
	}

	this._animateInTweener.add( tipTweeners, '+=0', 'start', .10 );
	this._animateInTweener.play();

	feng.soundController.playSfx('confirm');
};


feng.views.book.Book.prototype.animateOut = function( instant ) {

	goog.style.showElement(this.domElement, false);

	this.deactivate();

	feng.navigationController.replaceToken('');

	feng.soundController.playSfx('close');

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );
};


feng.views.book.Book.prototype.getScrollInfo = function() {

	// pre-calculate X considering tip modules who have post-update widths
	var finalTipModuleWidths = goog.array.map( this._tipModules, function(tipModule) {
		return tipModule.getFinalWidth();
	}, this);

	var scrollWidth = goog.array.reduce(finalTipModuleWidths, this._sumFunc, 0);

	var firstSectionWidth = finalTipModuleWidths[0];
	var lastSectionWidth = finalTipModuleWidths[finalTipModuleWidths.length - 1];

	var leftX = -(this._viewportSize.width - firstSectionWidth) / 2;
	var rightX = (scrollWidth - lastSectionWidth) - (this._viewportSize.width - lastSectionWidth) / 2;

	var info = {
		widths: finalTipModuleWidths,
		scrollWidth: scrollWidth,
		leftX: leftX,
		rightX: rightX
	};

	return info;
};


feng.views.book.Book.prototype.getTipModuleIndexByX = function( x ) {

	var scrollInfo = this.getScrollInfo();
	var finalTipModuleWidths = scrollInfo.widths;
	var leftX = scrollInfo.leftX;
	var rightX = scrollInfo.rightX;

	var i, l = finalTipModuleWidths.length;
	var currentX = leftX;

	for(i = 0; i < l - 1; i ++) {

		var nextX = currentX + finalTipModuleWidths[i];

		if(x >= currentX && x < nextX) {
			return i;
			break;
		}

		currentX = nextX;
	}

	return (l-1);
};


feng.views.book.Book.prototype.scrollToTipModule = function( index, instant ) {

	TweenMax.ticker.removeEventListener("tick", this.update, this);

	if(this._activeTipModule) {
		this._activeTipModule.setActive(false);
	}

	this._activeTipIndex = index;
	this._activeTipModule = this._tipModules[ index ];

	this._activeTipModule.setActive(true);

	var scrollInfo = this.getScrollInfo();
	var finalTipModuleWidths = scrollInfo.widths;
	var leftX = scrollInfo.leftX;

	var widths = finalTipModuleWidths.slice(0, index);
	var tipModuleWidth = finalTipModuleWidths[ index ];
	var tipModuleX = goog.array.reduce(widths, this._sumFunc, 0);

	var scrollX = tipModuleX - (this._viewportSize.width - tipModuleWidth) / 2;

	var duration = instant ? 0 : .65;

	this._scrollTweener = TweenMax.to(this, duration, {
		_scrollX: scrollX,
		_targetScrollX: scrollX,
		'ease': Strong.easeOut,
		'onUpdate': this.applyScrollX,
		'onUpdateScope': this
	});
};


feng.views.book.Book.prototype.prevTipModule = function() {

	if(this._scrollTweener && this._scrollTweener.isActive()) {
		return;
	}

	var index = Math.max(0, this._activeTipIndex - 1);
	this.scrollToTipModule( index );
};


feng.views.book.Book.prototype.nextTipModule = function() {

	if(this._scrollTweener && this._scrollTweener.isActive()) {
		return;
	}

	var index = Math.min(this._tipModules.length - 1, this._activeTipIndex + 1);
	this.scrollToTipModule( index );
};


feng.views.book.Book.prototype.applyScrollX = function() {

	goog.style.setStyle( this._scrollerInnerEl, 'transform', 'translateX(' + (-this._scrollX) + 'px)' );

	if(!this._dragger.isDragging()) {

		var scrollInfo = this.getScrollInfo();
		var leftX = scrollInfo.leftX;
		var rightX = scrollInfo.rightX;
		var scrollWidth = scrollInfo.scrollWidth;
		var ratio = (this._scrollX - leftX) / (rightX - leftX);
		var handleX = (this._scrubberWidth - this._handleWidth) * ratio;
		goog.style.setPosition( this._handleEl, handleX, 0 );
	}
};


feng.views.book.Book.prototype.updateTips = function() {

	var numUnlocked = 0;

	goog.array.forEach(this._tips, function(tip) {

		if(tip.unlocked) {

			numUnlocked ++;
			this._tipModulesDic[ tip.id ].unlock();
		}
	}, this);

	this._tipCounterEl.innerHTML = numUnlocked + '/' + this._tips.length;
};


feng.views.book.Book.prototype.onDrag = function( e ) {

	var ratio = Math.max(0, Math.min(1, this._dragger.deltaX / this._draggerLimits.width));
	var scrollInfo = this.getScrollInfo();
	var leftX = scrollInfo.leftX;
	var rightX = scrollInfo.rightX;

	this._targetScrollX = goog.math.lerp( leftX, rightX, ratio );
};


feng.views.book.Book.prototype.onDragStart = function( e ) {

	TweenMax.ticker.addEventListener("tick", this.update, this);

	if(this._scrollTweener && this._scrollTweener.isActive()) {
		this._scrollTweener.kill();
	}

	goog.dom.classlist.addRemove(this._scrollerEl, 'zoom-in', 'zoom-out');
};


feng.views.book.Book.prototype.onDragEnd = function( e ) {

	goog.dom.classlist.addRemove(this._scrollerEl, 'zoom-out', 'zoom-in');
};


feng.views.book.Book.prototype.onTipModuleChange = function(e) {
 
	this.scrollToTipModule( e.target.index );
};


feng.views.book.Book.prototype.onTipModuleClose = function(e) {
 
 	this.animateOut();
};


feng.views.book.Book.prototype.onMouseWheel = function( e ) {

	// skip mousewheel if hovering on a tip module scroller
	var hoveringScroller = goog.array.find(this._tipModules, function(tipModule) {
		return (tipModule.isHoveringScroller() === true);
	});

	if(hoveringScroller) {
		return false;
	}

	//
	var delta = e.deltaX || e.deltaY;
	var scrollDist = goog.math.lerp( 0, this._viewportSize.width/4, delta/this._maxDelta );

	this._targetScrollX += scrollDist;

	var scrollInfo = this.getScrollInfo();
	var leftX = scrollInfo.leftX;
	var rightX = scrollInfo.rightX;

	this._targetScrollX = Math.max( Math.min( rightX, this._targetScrollX ), leftX );

	TweenMax.ticker.addEventListener("tick", this.update, this);

	if(this._scrollTweener && this._scrollTweener.isActive()) {
		this._scrollTweener.kill();
	}
};


feng.views.book.Book.prototype.update = function() {

	this._scrollX += (this._targetScrollX - this._scrollX) * .1;
	this.applyScrollX();

	// if reached the target scroll x, stop animating and lock to the nearest tip module
	if( goog.math.nearlyEquals(this._scrollX, this._targetScrollX, 1) && !this._dragger.isDragging()) {

		TweenMax.ticker.removeEventListener("tick", this.update, this);

		this._scrollX = this._targetScrollX;

		var tipModuleIndex = this.getTipModuleIndexByX( this._scrollX );
		this.scrollToTipModule( tipModuleIndex );
	}
};


feng.views.book.Book.prototype.onNavigationChange = function( e ) {

	var navController = e.target;

	var shouldOpenBook = navController.testToken( e.tokenArray, feng.controllers.NavigationController.Token.BOOK );
	var tipToken = navController.testToken( e.tokenArray, feng.controllers.NavigationController.Token.READ_TIP );
	
	var tipId = tipToken ? tipToken['tipId'] : null;

	if(tipId) {
		shouldOpenBook = true;
	}

	if(shouldOpenBook) {
		this.animateIn( tipId );
	}
};


feng.views.book.Book.prototype.onTipUnlock = function( e ) {

	this.updateTips();
};


feng.views.book.Book.prototype.onResize = function( e ) {

	this.resize();

	// lock to module
	this.scrollToTipModule( (this._activeTipIndex || 0) );
};goog.provide('feng.views.view3dobject.entities.SewingMachine');

goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * The sewing machine with a cover
 */
feng.views.view3dobject.entities.SewingMachine = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._isCovered = false;

  this._cover = null;
};
goog.inherits(feng.views.view3dobject.entities.SewingMachine, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.SewingMachine.prototype.init = function(){

  goog.base(this, 'init');

  this._cover = this._view3d.getView3dObject('sewingmachine-cover');
  this._cover.removeFromScene();
};


feng.views.view3dobject.entities.SewingMachine.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  if(!this._isCovered) {

  	this._cover.addToScene( this.object3d );

  	TweenMax.fromTo(this._cover.object3d.position, 2, {
  		'y': this._cover.object3d.position.y + 30
  	}, {
  		'y': this._cover.object3d.position.y,
      'immediateRender': true,
  		'ease': Strong.easeInOut,
  		'onComplete': this.onCovered,
  		'onCompleteScope': this
  	});
  }
};


feng.views.view3dobject.entities.SewingMachine.prototype.onCovered = function(){

  this.unlock();
  this.stopInteraction();

  this._isCovered = true;
};goog.provide('feng.views.view3dobject.entities.Bear');

goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * The bear in boy's room
 */
feng.views.view3dobject.entities.Bear = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._onBedTexture = null;
};
goog.inherits(feng.views.view3dobject.entities.Bear, feng.views.view3dobject.MovableObject);


feng.views.view3dobject.entities.Bear.prototype.createTextures = function(){

  goog.base(this, 'createTextures');

  var preload = feng.models.Preload.getInstance();
  var onBedImg = preload.getAsset(this._view3d.sectionId + '.' + this._view3d.id + '.bear-on-bed-texture');
  this._onBedTexture = new THREE.Texture( onBedImg );
  this._onBedTexture.needsUpdate = true;

  if(this.hasPicked) {
    this.object3d.material.map = this._onBedTexture;
  }
};


feng.views.view3dobject.entities.Bear.prototype.disposeTextures = function(){

  this._onBedTexture.dispose();
  this._onBedTexture = null;

  this.object3d.material.map = null;

  goog.base(this, 'disposeTextures');
};


feng.views.view3dobject.entities.Bear.prototype.pick = function(){

  goog.base(this, 'pick');

  this.object3d.material.map = this._onBedTexture;
  this.object3d.material.needsUpdate = true;

  var drawer = this._view3d.getView3dObject( 'drawer' );

  TweenMax.to( drawer.object3d.position, 1, {
    'delay': 2,
    'z': -11
  });
};goog.provide('feng.views.view3dobject.entities.Pictures');

goog.require('goog.string');
goog.require('feng.models.Preload');
goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * A tip object that contains pictures
 */
feng.views.view3dobject.entities.Pictures = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  // parse and store pictures data
  this._pictureTextures = null;

  // get all picture object 3ds
  var pictureObject3ds = [];

  this.object3d.traverse(function(obj) {
    if((obj instanceof THREE.Mesh) && (obj.geometry.vertices.length === 4)) {
      pictureObject3ds.push( obj );
    }
  });

  this._pictureObject3ds = (pictureObject3ds.length > 0) ? pictureObject3ds : [this.object3d];

  //
  this._activePicture = null;

  this._resolvedPictures = {};
};
goog.inherits(feng.views.view3dobject.entities.Pictures, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Pictures.prototype.createTextures = function(){

  var shouldCreate = goog.base(this, 'createTextures');

  if(!shouldCreate) return;

  // parse and store pictures data
  var pictures = this.tip.details['pictures'];

  var preload = feng.models.Preload.getInstance();

  this._pictureTextures = goog.object.map(pictures, function(val, key) {

    var img = preload.getAsset( this._view3d.sectionId + '.' + this._view3d.id + '.pictures.' + key );

    var texture = new THREE.Texture( img );
    texture.needsUpdate = true;

    return texture;
  }, this);

  // restore texture from picture id
  var pictureTextures = this._pictureTextures;

  this.object3d.traverse(function(object) {
    if(object.userData.id) {
      object.material.map = pictureTextures[ object.userData.id ];
    }
  });
};


feng.views.view3dobject.entities.Pictures.prototype.disposeTextures = function(){

  var shouldDispose = goog.base(this, 'disposeTextures');

  if(!shouldDispose) return;

  goog.object.forEach(this._pictureTextures, function(texture) {
    texture.dispose();
  });

  this._pictureTextures = null;
};


feng.views.view3dobject.entities.Pictures.prototype.startInteraction = function() {

  goog.base(this, 'startInteraction');

  // disable free picture selection for now...
  //this._interactionHandler.listen(this._view3d.domElement, 'click', this.onClick, false, this);

  this.setActivePicture( this._pictureObject3ds[0] );
};


feng.views.view3dobject.entities.Pictures.prototype.stopInteraction = function() {

  goog.base(this, 'stopInteraction');

  this.setActivePicture( null );
};


feng.views.view3dobject.entities.Pictures.prototype.nextPicture = function() {

  var pictureIndex = goog.array.indexOf(this._pictureObject3ds, this._activePicture) + 1;
  pictureIndex = Math.min( pictureIndex, this._pictureObject3ds.length - 1 );

  this.setActivePicture( this._pictureObject3ds[pictureIndex] );
};


feng.views.view3dobject.entities.Pictures.prototype.setActivePicture = function( picture ) {

  this._activePicture = picture;

  goog.array.forEach( this._pictureObject3ds, function(obj) {

    var color;

    if(obj === picture || !picture) {
      color = 0xffffff;
    }else {
      color = 0x6E6E6E;
    }

    var prop = {
      t: 0,
      fromColor: obj.material.color.clone(),
      toColor: new THREE.Color( color )
    };

    TweenMax.to(prop, .25, {
      t: 1,
      'onUpdate': function() {
        obj.material.color.copy( prop.fromColor ).lerp( prop.toColor, prop.t );
        obj.material.needsUpdate = true;
      }
    });
  });
};


feng.views.view3dobject.entities.Pictures.prototype.setPicture = function( id ){

  var texture = this._pictureTextures[ id ];
  
  this._activePicture.material.map = texture;
  this._activePicture.material.needsUpdate = true;
  this._activePicture.userData.id = id;

  // fit picture texture in UV
  var u, v, offsetU, offsetV;
  var imgRatio = texture.image.width / texture.image.height;

  this._activePicture.geometry.computeBoundingBox();
  var size = this._activePicture.geometry.boundingBox;

  var diffX = size.max.x - size.min.x;
  var diffZ = size.max.z - size.min.z;
  var diffY = size.max.y - size.min.y;
  var meshWidth = (diffX > diffZ) ? diffX : diffZ;
  var meshHeight = diffY;
  var meshRatio = meshWidth / meshHeight;

  var actualWidth;
  var actualHeight;

  if(imgRatio > meshRatio) {

    u = 1 / (imgRatio / meshRatio);
    v = 1;

    actualWidth = meshHeight * imgRatio;
    actualHeight = meshHeight;

    offsetU = (actualWidth - meshWidth) / 2 / actualWidth;
    offsetV = 0;

  }else {

    u = 1;
    v = 1 * (imgRatio / meshRatio);

    actualWidth = meshWidth;
    actualHeight = meshWidth / imgRatio;

    offsetU = 0;
    offsetV = (actualHeight - meshHeight) / 2 / actualHeight;
  }

  texture.repeat.set( u, v );
  texture.offset.set( offsetU, offsetV );

  // check if resolved all
  this._resolvedPictures[ this._activePicture.name ] = true;

  var resolvedAllPictures = (goog.object.getCount( this._resolvedPictures ) === this._pictureObject3ds.length);

  if(resolvedAllPictures) {

    this.unlock();
  }
};

/*
feng.views.view3dobject.entities.Pictures.prototype.onClick = function(e){

  var camera = this._view3d.cameraController.activeCamera;
  var viewSize = this._view3d.viewSize;
  var clickedObjects = feng.utils.ThreeUtils.getObjectsBy2DPosition( e.clientX, e.clientY, this._pictureObject3ds, camera, viewSize );

  if(clickedObjects.length > 0) {
    var picture = clickedObjects[0].object;
    this.setActivePicture( picture );
  }
};
*/goog.provide('feng.fx.View3DSize');

goog.require('goog.events.EventTarget');
goog.require('goog.math.Size');

/**
 * @constructor
 */
feng.fx.View3DSize = function(width, height){

	goog.base(this);

	this._size = new goog.math.Size( width, height );
	
	this.ratioX = 1;
	this.ratioY = 1;

	this.width = this._size.width;
	this.height = this._size.height;

	goog.events.listen( window, goog.events.EventType.RESIZE, this.onResize, false, this );
};
goog.inherits(feng.fx.View3DSize, goog.events.EventTarget);


feng.fx.View3DSize.prototype.set = function(width, height){

	this._size.width = goog.isNumber(width) ? width : this._size.width;
	this._size.height = goog.isNumber(height) ? height : this._size.height;

	this.width = this._size.width;
	this.height = this._size.height;

	this.dispatchEvent({
		type: goog.events.EventType.RESIZE,
		width: this._size.width,
		height: this._size.height
	});
};


feng.fx.View3DSize.prototype.isEmpty = function(){

	return this._size.isEmpty();
};


feng.fx.View3DSize.prototype.reset = function(){

	this.update(1, 1);
};


feng.fx.View3DSize.prototype.aspectRatio = function(){

	return this._size.aspectRatio();
};


feng.fx.View3DSize.prototype.update = function( ratioX, ratioY ){

	this.ratioX = goog.isNumber(ratioX) ? ratioX : this.ratioX;
	this.ratioY = goog.isNumber(ratioY) ? ratioY : this.ratioY;

	var width = feng.viewportSize.width * this.ratioX;
	var height = feng.viewportSize.height * this.ratioY;

	this.set( width, height );

	return this;
};


feng.fx.View3DSize.prototype.onResize = function(e){

	this.update();
};goog.provide('feng.views.view3dobject.ReplaceableObject');

goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');

/**
 * @constructor
 * A holder to replace its content (mesh)
 */
feng.views.view3dobject.ReplaceableObject = function( object3d, data, view3d ){

	goog.base(this, object3d, data, view3d);

	// create assets loader
	this._loader = new createjs.LoadQueue(true);
  	createjs.LoadQueue.loadTimeout = 100000;

	this._onLoadComplete = goog.bind(this.onLoadComplete, this);
	this._onLoadError = goog.bind(this.onLoadError, this);

	// object storage
	this._object = this.object3d.children[0];

	this.objects = {};

	goog.array.forEach( data.objects, function(objectKey) {
		this.objects[ objectKey ] = null;
	}, this);

	//
	this._idToLoad = null;
};
goog.inherits(feng.views.view3dobject.ReplaceableObject, feng.views.view3dobject.TipObject);


feng.views.view3dobject.ReplaceableObject.prototype.change = function( objectId ){

	if(this.objects[objectId]) {

		this.updateObject( this.objects[objectId] );
		return;
	}

	this._idToLoad = objectId;

	this._loader.removeAll();
	this._loader.removeAllEventListeners();

	this._loader.addEventListener("complete", this._onLoadComplete);
	this._loader.addEventListener("error", this._onLoadError);

	this._loader.loadManifest([
		{
			'src': feng.Config['assetsPath'] + 'json/replaceable/' + objectId + '.json',
			'id': 'data'
		},
		{
			'src': feng.Config['assetsPath'] + 'images/texture/replaceable/' + objectId + '.jpg',
			'id': 'texture'
		}
	]);

	this.dispatchEvent({
		type: feng.events.EventType.LOAD,
		id: this._idToLoad
	});

	//
};


feng.views.view3dobject.ReplaceableObject.prototype.updateObject = function( view3dObject ){

	var currentObject = this.object3d.children[0];

	if(currentObject) {

		this.object3d.remove( currentObject );
		delete this._view3d.view3dObjects[ currentObject.name ];
	}

	this._view3d.view3dObjects[ view3dObject.name ] = view3dObject;

	this._object = view3dObject.object3d;

	this.object3d.add( this._object );

	TweenMax.fromTo( this._object.scale, 1, {
		'y': 1.05
	},{
		'y': 1,
		'ease': Elastic.easeOut
	});

	TweenMax.fromTo( this._object.position, .5, {
		'y': 1.5
	},{
		'y': 0,
		'ease': Bounce.easeOut
	});
};


feng.views.view3dobject.ReplaceableObject.prototype.onLoadComplete = function( e ){

	var json = this._loader.getResult('data');
	var img = this._loader.getResult('texture');

	var mesh = feng.utils.ThreeUtils.loader.parse( json );

	var texture = new THREE.Texture( img );
	texture.needsUpdate = true;

	mesh.material.map = texture;
	mesh.material.needsUpdate = true;

	var view3dObject = new feng.views.view3dobject.View3DObject( mesh, {}, this._view3d );
	view3dObject.init();
	
	this.objects[ this._idToLoad ] = view3dObject;

	this.updateObject( view3dObject );

	this.unlock();

	this.dispatchEvent({
		type: feng.events.EventType.LOAD_COMPLETE,
		id: this._idToLoad
	});
};


feng.views.view3dobject.ReplaceableObject.prototype.onLoadError = function( e ){


};goog.provide('feng.views.view3dobject.Skybox');

goog.require('feng.views.view3dobject.View3DObject');

/**
 * @constructor
 * An infinite plane in design mode
 */
feng.views.view3dobject.Skybox = function( assets, view3d ){

  this._assets = assets;

  var materials = [];

  for (var i = 0; i < 6; i++) {

    var material = new THREE.MeshBasicMaterial({
      'transparent': true,
      'side': THREE.BackSide
    });
    material.shading = THREE.FlatShading;
    material.fog = false;

    materials.push( material );
  }

  var skyGeometry = new THREE.BoxGeometry( 100000, 100000, 100000 );

  this._material = new THREE.MeshFaceMaterial( materials );
  this._material.shading = THREE.FlatShading;
  this._material.fog = false;

  var skybox = new THREE.Mesh( skyGeometry, this._material );
  skybox.position.y = -8000;
  skybox.name = 'skybox';

  goog.base( this, skybox, {}, view3d );

  this.opacity = 1;

  this.addToScene();
};
goog.inherits(feng.views.view3dobject.Skybox, feng.views.view3dobject.View3DObject);


feng.views.view3dobject.Skybox.prototype.createTextures = function(){

  var shouldCreate = goog.base(this, 'createTextures');

  if(!shouldCreate) return;

  var directions = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];

  goog.array.forEach(this._material.materials, function(material, i) {

    var asset = this._assets[ directions[i] ];

    var texture = new THREE.Texture( asset );
    texture.needsUpdate = true;

    material.map = texture;
    material.needsUpdate = true;

  }, this);
};


feng.views.view3dobject.Skybox.prototype.disposeTextures = function(){

  var shouldDispose = goog.base(this, 'disposeTextures');

  if(!shouldDispose) return;

  goog.array.forEach(this._material.materials, function(material, i) {

    material.map.dispose();
    material.map = null;
    material.needsUpdate = true;

  }, this);
};


feng.views.view3dobject.Skybox.prototype.updateOpacity = function( opt_opacity ){

  this.opacity = goog.isNumber(opt_opacity) ? opt_opacity : this.opacity;

  goog.array.forEach(this._material.materials, function(material) {
    material.opacity = this.opacity;
  }, this);
};goog.provide('feng.views.view3dobject.Mirror');

goog.require('feng.views.view3dobject.View3DObject');

/**
 * @constructor
 * A mirror
 */
feng.views.view3dobject.Mirror = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

};
goog.inherits(feng.views.view3dobject.Mirror, feng.views.view3dobject.View3DObject);


feng.views.view3dobject.Mirror.prototype.init = function() {

  goog.base(this, 'init');

  var material = this.object3d.material;
  material.needsUpdate = true;
  material.envMap = this._view3d.createCubeMap( this.getCenter() );
};goog.provide('feng.fx.TextureAnimator');

goog.require('goog.events.EventTarget');


/**
 * @constructor
 */
feng.fx.TextureAnimator = function ( texture, tilesHoriz, tilesVert, numTiles, tileDispDuration ) {

	this._tilesHorizontal = tilesHoriz;
  this._tilesVertical = tilesVert;
  this._numberOfTiles = numTiles;

	this.texture = texture;
  this.texture.needsUpdate = true;
	this.texture.wrapS = this.texture.wrapT = THREE.RepeatWrapping;
  this.texture.repeat.set(1 / this._tilesHorizontal, 1 / this._tilesVertical);

  this._tileDisplayDuration = tileDispDuration;
  this._currentDisplayTime = 0;
  this._currentTile = 0;

  this._clock = new THREE.Clock( false );
};
goog.inherits(feng.fx.TextureAnimator, goog.events.EventTarget);


feng.fx.TextureAnimator.prototype.start = function() {

	this._clock.start();
	goog.fx.anim.registerAnimation( this );
};


feng.fx.TextureAnimator.prototype.stop = function() {

	this._clock.stop();
	goog.fx.anim.unregisterAnimation( this );
};


feng.fx.TextureAnimator.prototype.onAnimationFrame = function( now ) {

	var currentColumn, currentRow;

  this._currentDisplayTime += 1000 * this._clock.getDelta();

  while (this._currentDisplayTime > this._tileDisplayDuration) {

    this._currentDisplayTime -= this._tileDisplayDuration;
    this._currentTile++;

    if (this._currentTile === this._numberOfTiles) {
      this._currentTile = 0;
    }

    currentColumn = this._currentTile % this._tilesHorizontal;
    this.texture.offset.x = currentColumn / this._tilesHorizontal;

    currentRow = Math.floor(this._currentTile / this._tilesHorizontal);
    this.texture.offset.y = currentRow / this._tilesVertical;
  }
};goog.provide('feng.views.view3dobject.entities.Windows');

goog.require('goog.fx.Dragger');
goog.require('feng.fx.TextureAnimator');
goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * Two windows in ollie's studio to be be lifted up or pulled down
 */
feng.views.view3dobject.entities.Windows = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._window = null;
  this._switch = null;

  this._windowLeft = null;
  this._windowRight = null;
  this._windowLeftSwitch = null;
  this._windowRightSwitch = null;

  this._switchTopY = 30;
  this._switchBottomY = 0;
  this._switchStartY = 0;

  this._startFov = 0;

  this._canDrag = false;

  this._cameraTransitionTweener = null;
  this._cameraZoomTweener = null;

  this._hasDoneWindowLeft = false;
  this._hasDoneWindowRight = false;

  // dragger to drag the windows
  this._dragger = new goog.fx.Dragger( this._view3d.domElement );
  this._dragger.setHysteresis( 5 );
  this._dragger.defaultAction = goog.nullFunction;
};
goog.inherits(feng.views.view3dobject.entities.Windows, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Windows.prototype.init = function(){

	goog.base(this, 'init');
	
  this._windowLeft = this._view3d.getView3dObject('window-left');
  this._windowRight = this._view3d.getView3dObject('window-right');

  this._windowLeftSwitch = this._view3d.getView3dObject( 'window-left-switch' );
  this._windowRightSwitch = this._view3d.getView3dObject( 'window-right-switch' );
};


feng.views.view3dobject.entities.Windows.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  this.enableWindowDragging( this );
};


feng.views.view3dobject.entities.Windows.prototype.stopInteraction = function(){

  goog.base(this, 'stopInteraction');
};


feng.views.view3dobject.entities.Windows.prototype.transitionToWindow = function( opt_window ){

	this._interactionHandler.removeAll();

	this._window = opt_window;

	var toCameraSettings = opt_window.specialCameraSettings;

  var control = this._view3d.modeController.control;

  var prop = {
    t: 0,
    startPosition: control.getPosition().clone(),
    endPosition: toCameraSettings.position,
    startRotation: control.getRotation().clone(),
    endRotation: toCameraSettings.rotation,
    startFov: control.getFov(),
    endFov: toCameraSettings.fov
  }

  this._cameraTransitionTweener = TweenMax.to( prop, 1, {
    t: 1,
    'ease': Sine.easeInOut,
    'onUpdate': this.onCameraTransitionUpdate,
    'onUpdateParams': [prop],
    'onUpdateScope': this,
    'onComplete': this.onCameraTransitionComplete,
    'onCompleteScope': this
  });
};


feng.views.view3dobject.entities.Windows.prototype.enableWindowDragging = function( opt_window ){

  this._window = (opt_window === this._windowLeft) ? this._windowLeft : this._windowRight;
  this._switch = (this._window === this._windowLeft) ? this._windowLeftSwitch : this._windowRightSwitch;

  this._startFov = this._view3d.modeController.control.getFov();
  
  this._interactionHandler.listen( this._view3d.domElement, feng.events.EventType.INPUT_DOWN, this.onDown, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.START, this.onDragStart, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.DRAG, this.onDrag, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.END, this.onDragEnd, false, this);
};


feng.views.view3dobject.entities.Windows.prototype.onDown = function(e){

	var camera = this._view3d.cameraController.activeCamera;
  var viewSize = this._view3d.viewSize;
  var objects = [this._window.getProxyBox()];
  var clickedObjects = feng.utils.ThreeUtils.getObjectsBy2DPosition( e.clientX, e.clientY, objects, camera, viewSize );

  this._canDrag = (clickedObjects.length > 0);
};


feng.views.view3dobject.entities.Windows.prototype.onDragStart = function(e){

	if(!this._canDrag) return;

	this._switchStartY = this._switch.object3d.position.y;

	var control = this._view3d.modeController.control;

	var prop = {
    fov: control.getFov()
  };

  this._cameraZoomTweener = TweenMax.to(prop, 1, {
    fov: this._startFov - 5,
    'ease': Strong.easeOut,
    'onUpdate': this.onCameraZoomUpdate,
    'onUpdateParams': [prop],
    'onUpdateScope': this
  });
};


feng.views.view3dobject.entities.Windows.prototype.onDrag = function(e){

	if(!this._canDrag) return;

	var dist = (this._switchTopY - this._switchBottomY) * (this._dragger.deltaY / feng.viewportSize.height);
	var switchY = this._switchStartY - dist;

	this._switch.object3d.position.y = goog.math.clamp( switchY, this._switchBottomY, this._switchTopY );
};


feng.views.view3dobject.entities.Windows.prototype.onDragEnd = function(e){

	if(!this._canDrag) return;

	this._hasDoneWindowLeft = (this._windowLeftSwitch.object3d.position.y === this._switchTopY);
	this._hasDoneWindowRight = (this._windowRightSwitch.object3d.position.y === this._switchBottomY);

	var justDoneWindowLeft = (this._window === this._windowLeft && this._hasDoneWindowLeft);
	var justDoneWindowRight = (this._window === this._windowRight && this._hasDoneWindowRight);

	if(justDoneWindowLeft || justDoneWindowRight) {

		var control = this._view3d.modeController.control;

		var prop = {
	    fov: control.getFov()
	  };

	  this._cameraZoomTweener = TweenMax.to(prop, 1, {
	    fov: this._startFov,
	    'onUpdate': this.onCameraZoomUpdate,
	    'onUpdateParams': [prop],
	    'onUpdateScope': this,
	    'onComplete': this.onCameraZoomOutComplete,
	    'onCompleteScope': this
	  });
	}
};


feng.views.view3dobject.entities.Windows.prototype.onCameraTransitionUpdate = function(prop){

  var startPosition = prop.startPosition;
  var endPosition = prop.endPosition;
  var startRotation = prop.startRotation;
  var endRotation = prop.endRotation;
  var startFov = prop.startFov;
  var endFov = prop.endFov;
  var t = prop.t;

  var control = this._view3d.modeController.control;

  control.lerp( startPosition, endPosition, startRotation, endRotation, startFov, endFov, t );
};


feng.views.view3dobject.entities.Windows.prototype.onCameraTransitionComplete = function(){

  this.enableWindowDragging( this._window );
};


feng.views.view3dobject.entities.Windows.prototype.onCameraZoomUpdate = function(prop){

  var control = this._view3d.modeController.control;

  control.setFov( prop.fov );
};


feng.views.view3dobject.entities.Windows.prototype.onCameraZoomOutComplete = function(){

	if(this._hasDoneWindowLeft && this._hasDoneWindowRight) {

    this.unlock();
    this.stopInteraction();

	}else if(this._hasDoneWindowLeft) {

		this.transitionToWindow( this._windowRight );

	}else if(this._hasDoneWindowRight) {

		this.transitionToWindow( this._windowLeft );
	}
};goog.provide('feng.views.view3dobject.entities.Cat');

goog.require('feng.views.view3dobject.TipObject');

/**
 * @constructor
 * The cat sleeping in house corridor
 */
feng.views.view3dobject.entities.Cat = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._cat = this.object3d.getObjectByName('cat');

  this._sleepTweener = TweenMax.to(this._cat.scale, 4, {
    'y': 1.04,
    'repeat': -1,
    'repeatDelay': 0.5,
    'yoyo': true,
    'paused': true,
    'ease': Sine.easeInOut
  });
};
goog.inherits(feng.views.view3dobject.entities.Cat, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Cat.prototype.onCameraIn = function(){

  goog.base(this, 'onCameraIn');

  this._sleepTweener.play();

  //feng.soundController.playSfx('refrigerator-open');
};


feng.views.view3dobject.entities.Cat.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  this._sleepTweener.pause();

  /*
  TweenMax.delayedCall(.8, function() {
    //feng.soundController.playSfx('refrigerator-close');
  }, [], this);
	*/
};goog.provide('feng.controllers.controls.Controls');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');


/**
 * @constructor
 * A custom camera control, wrapped the camera with pitch and yaw object
 */
feng.controllers.controls.Controls = function(camera, view3d, domElement){
	
  goog.base(this);

  this._camera = camera;
  this._view3d = view3d;
  this._scene = this._view3d.scene;

  this._eventHandler = new goog.events.EventHandler(this);

  this.isEnabled = false;
  this.isPaused = false;

  this._pauseProps = {
  	fov: 0,
  	oFov: 0,
  	z: 0,
  	oZ: 0
  };

  this._rotation = new THREE.Euler(0, 0, 0, 'YXZ'); //YXZ is to overcome gimbal lock

  this._originalPosition = this._camera.position.clone();
  this._originalRotation = this._camera.rotation.clone();

	this._pitchObject = new THREE.Object3D();
	this._pitchObject.add( this._camera );

	this._yawObject = new THREE.Object3D();
	this._yawObject.add( this._pitchObject );

	this._mainEl = goog.dom.getElement('main');
	this._domElement = domElement;

	this._scene.add( this.getObject() );

	this.reset();
};
goog.inherits(feng.controllers.controls.Controls, goog.events.EventTarget);


feng.controllers.controls.Controls.prototype.getObject = function () {

	return this._yawObject;
};


feng.controllers.controls.Controls.prototype.getCamera = function () {

	return this._camera;
};


feng.controllers.controls.Controls.prototype.getPosition = function () {

	return this.getObject().position;
};


feng.controllers.controls.Controls.prototype.getRotation = function () {

	this._rotation.x = this.getPitch();
	this._rotation.y = this.getYaw();
	return this._rotation;
};


feng.controllers.controls.Controls.prototype.getPitch = function () {

	return this._pitchObject.rotation.x;
};


feng.controllers.controls.Controls.prototype.getYaw = function () {

	return this._yawObject.rotation.y;
};


feng.controllers.controls.Controls.prototype.getFov = function () {

	return this._camera.fov;
};


feng.controllers.controls.Controls.prototype.getForwardVector = function (dontForceZeroY) {

	var forward = new THREE.Vector3(0, 0, -1);
	forward.applyEuler(this._pitchObject.rotation, this._pitchObject.rotation.order);
	forward.applyEuler(this._yawObject.rotation, this._yawObject.rotation.order);
	forward.normalize();

	if(!dontForceZeroY) {
		forward.setY(0);
	}

	return forward;
};


feng.controllers.controls.Controls.prototype.getTarget = function () {

	var raycaster = new THREE.Raycaster(this.getPosition(), this.getForwardVector(true));
	var intersects = raycaster.intersectObject( this._view3d.skybox.object3d );
	var intersectPosition = intersects.length > 0 ? intersects[0].point : this._view3d.scene.position;

	return intersectPosition;
};


feng.controllers.controls.Controls.prototype.setPosition = function (x, y, z) {

	if(x instanceof THREE.Vector3) {
		var position = x;
		this._yawObject.position.copy( position );
	}else {
		this._yawObject.position.set(x, y, z);
	}
};


feng.controllers.controls.Controls.prototype.setRotation = function (x, y) {

	if(x instanceof THREE.Euler) {
		var rotation = x;
		this._rotation.x = rotation.x;
		this._rotation.y = rotation.y;
	}else {
		this._rotation.x = x;
		this._rotation.y = y;
	}

	this._pitchObject.rotation.x = this._rotation.x;
	this._yawObject.rotation.y = this._rotation.y;
};


feng.controllers.controls.Controls.prototype.setPitch = function (pitch) {

	this._pitchObject.rotation.x = pitch;
};


feng.controllers.controls.Controls.prototype.setYaw = function (yaw) {

	this._yawObject.rotation.y = yaw;
};


feng.controllers.controls.Controls.prototype.setFov = function (fov) {

	this._camera.fov = fov;
	this._camera.updateProjectionMatrix();
};


feng.controllers.controls.Controls.prototype.reset = function () {

	this._camera.position.set( 0, 0, 0 );
	this._camera.rotation.set( 0, 0, 0 );

	this._pitchObject.position.set(0, 0, 0);
	this._pitchObject.rotation.set(0, 0, 0);
	
	this._yawObject.position.copy( this._originalPosition );
	this._yawObject.rotation.copy( this._originalRotation );
};


feng.controllers.controls.Controls.prototype.lerp = function( startPosition, endPosition, startRotation, endRotation, startFov, endFov, t ) {

	var position = this.getPosition();
	var rotation = this.getRotation();

	var lerpPosition = position.copy( startPosition ).lerp( endPosition, t );
	var lerpRotation = feng.utils.ThreeUtils.getLerpedEuler( startRotation, endRotation, t, rotation );
	var lerpFov = goog.math.lerp( startFov, endFov, t );

	this.setPosition( lerpPosition );
	this.setRotation( lerpRotation );
	this.setFov( lerpFov );
};


feng.controllers.controls.Controls.prototype.activate = function() {

	this._eventHandler.listen(this._domElement, 'click', this.onClick, false, this);
	this._eventHandler.listen(this._domElement, feng.events.EventType.INPUT_DOWN, this.onInputDown, false, this);

	TweenMax.ticker.addEventListener("tick", this.update, this);

	goog.dom.classlist.add(this._view3d.domElement, 'grab');
};


feng.controllers.controls.Controls.prototype.deactivate = function() {

	this._eventHandler.removeAll();

	TweenMax.ticker.removeEventListener("tick", this.update, this);

	goog.dom.classlist.remove(this._view3d.domElement, 'grab');
	goog.dom.classlist.remove(this._mainEl, 'grabbing');
};


feng.controllers.controls.Controls.prototype.enable = function( enable ) {

	if(this.isEnabled === enable) {

		return false;
	}
	
	this.isEnabled = enable;

	if(this.isEnabled) {

		this.activate();

	}else {

		this.deactivate();
	}

	return true;
};


feng.controllers.controls.Controls.prototype.pause = function( pause ) {

	if(this.isPaused === pause || !this.isEnabled) return;
	
	this.isPaused = pause;

	if(this.isPaused) {

		this._pauseProps.oFov = this._pauseProps.fov = this.getFov();
		this._pauseProps.oZ = this._pauseProps.z = 0;

		TweenMax.to( this._pauseProps, .8, {
			fov: this._pauseProps.oFov + 8,
			z: 5,
			'ease': Quad.easeInOut,
			'onUpdate': this.onPauseAnimate,
			'onUpdateScope': this,
			'onStart': this.onPauseStart,
			'onStartScope': this
		});

	}else {

		TweenMax.to( this._pauseProps, .8, {
			fov: this._pauseProps.oFov,
			z: this._pauseProps.oZ,
			'ease': Quad.easeInOut,
			'onUpdate': this.onPauseAnimate,
			'onUpdateScope': this,
			'onComplete': this.onPauseResumed,
			'onCompleteScope': this
		});
	}

	return this.isPaused;
};


feng.controllers.controls.Controls.prototype.update = function() {

};


feng.controllers.controls.Controls.prototype.getDirection = function() {

	// assumes the camera itself is not rotated
	var direction = new THREE.Vector3( 0, 0, -1 );
	var rotation = new THREE.Euler( 0, 0, 0, 'YXZ' );

	var v = this._yawObject.position.clone();
	rotation.set( this._pitchObject.rotation.x, this._yawObject.rotation.y, 0 );
	v.copy( direction ).applyEuler( rotation );

	return v;
};


feng.controllers.controls.Controls.prototype.onPauseStart = function() {

	this.deactivate();
};


feng.controllers.controls.Controls.prototype.onPauseAnimate = function() {

	var camera = this.getCamera();

	camera.position.z = this._pauseProps.z;

	this.setFov( this._pauseProps.fov );
};


feng.controllers.controls.Controls.prototype.onPauseResumed = function() {

	this.activate();
};


feng.controllers.controls.Controls.prototype.onClick = function ( e ) {

};


feng.controllers.controls.Controls.prototype.onInputDown = function ( e ) {

	e.preventDefault();
	
	this._eventHandler.listen(this._domElement, feng.events.EventType.INPUT_MOVE, this.onInputMove, false, this);
	this._eventHandler.listen(document, feng.events.EventType.INPUT_UP, this.onInputUp, false, this);
};


feng.controllers.controls.Controls.prototype.onInputUp = function ( e ) {

	e.preventDefault();

	this._eventHandler.unlisten(this._domElement, feng.events.EventType.INPUT_MOVE, this.onInputMove, false, this);
	this._eventHandler.unlisten(document, feng.events.EventType.INPUT_UP, this.onInputUp, false, this);

	goog.dom.classlist.remove(this._mainEl, 'grabbing');
};


feng.controllers.controls.Controls.prototype.onInputMove = function ( e ) {

	e.preventDefault();

	goog.dom.classlist.add(this._mainEl, 'grabbing');
};


feng.controllers.controls.Controls.Default = {
	STANCE_HEIGHT: (170 - 10) / 2, // eyes height (10cm) of 170cm..
	ARM_HEIGHT: (170 - 10 - 30) / 2,
	FOV: 40
};goog.provide('feng.controllers.controls.ExitControls');

goog.require('feng.controllers.controls.Controls');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * to move in front of and face the gateway, then load the next view
 */
feng.controllers.controls.ExitControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

  this._gateway = null;
};
goog.inherits(feng.controllers.controls.ExitControls, feng.controllers.controls.Controls);


feng.controllers.controls.ExitControls.prototype.setCamera = function( gateway ) {

	this._gateway = gateway;
	
	var position = this._gateway.origin.position;
	this.setPosition( position );

	var rotation = new THREE.Euler(0, 0, 0, 'YXZ');
  	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(position, gateway.getCenter());
  	rotation.setFromQuaternion( quaternion );
	this.setRotation( rotation );

	var fov = feng.controllers.controls.Controls.Default.FOV;
	this.setFov( fov );
};


feng.controllers.controls.ExitControls.prototype.activate = function () {

	goog.base(this, 'activate');

	if(this._gateway.shouldGoHome()) {

		feng.navigationController.setToken( feng.controllers.NavigationController.Token.HOME );

	}else {

		// start to load the go-to view3d of this episode
		var viewId = this._gateway.viewId;
		this._view3d.episode.load( viewId );

		// listen to episode load complete event to resume after load
		this._eventHandler.listenOnce( this._view3d.episode, feng.events.EventType.COMPLETE, this.onLoadComplete, false, this);
	}
};


feng.controllers.controls.ExitControls.prototype.onLoadComplete = function () {
	
	feng.pubsub.subscribeOnce( feng.PubSub.Topic.BUFFER_COMPLETE, this.onBufferComplete, this );
};


feng.controllers.controls.ExitControls.prototype.onBufferComplete = function () {

	this._gateway.playOpenSound();

	goog.Timer.callOnce(function() {
		this._gateway.playCloseSound();
	}, 2500, this);

	this._view3d.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		sectionId: this._view3d.sectionId,
		viewId: this._gateway.viewId,
		gatewayId: this._gateway.gatewayId
	});
};goog.provide('feng.controllers.controls.EntryControls');

goog.require('feng.controllers.controls.Controls');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * a series of movements before entering the door first-time
 */
feng.controllers.controls.EntryControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

  this._cameraPosition = new THREE.Vector3(0, 0, 0);
  this._cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');

  this._timeline = new TimelineMax();

  this._footstepsSound = null;

  this._entry = this._view3d.getEntry();
};
goog.inherits(feng.controllers.controls.EntryControls, feng.controllers.controls.Controls);


feng.controllers.controls.EntryControls.prototype.start = function () {

	var entry = this._entry;
	var entryPosition = entry.getCenter();
	var entryOriginPosition = entry.origin.position;
	var entryOriginRotation = entry.origin.rotation;
	var entryDirection = (new THREE.Vector3()).subVectors(entryOriginPosition, entryPosition).setY(0).normalize().negate();

	var endPosition = entryOriginPosition.clone().setY( feng.controllers.controls.Controls.Default.STANCE_HEIGHT );
	var startPosition = entryPosition.clone().setY( feng.controllers.controls.Controls.Default.STANCE_HEIGHT ).add( entryDirection.clone().multiplyScalar(150) );
	var stepInPosition = startPosition.clone().add( entryDirection.clone().multiplyScalar(-80) );

	var endRotation = entryOriginRotation.clone();
	var startRotation = new THREE.Euler(0, 0, 0, 'YXZ');
	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(startPosition, entryPosition);
	startRotation.setFromQuaternion( quaternion );

	var endFov = feng.controllers.controls.Controls.Default.FOV;
	var startFov = endFov + 20;

	this.setPosition( startPosition );
	this.setRotation( startRotation );
	this.setFov( startFov );

	var designPlane = this._view3d.designPlane;
	designPlane.addToScene();

	var prop = {
		t: 0,
		startPosition: startPosition,
		endPosition: stepInPosition
	};

	var stepCloseTweener = TweenMax.to(prop, 3, {
		t: 1,
		'ease': Sine.easeInOut,
		'onUpdate': this.onStepCloseUpdate,
		'onUpdateParams': [prop],
		'onUpdateScope': this,
		'onComplete': this.onStepCloseComplete,
		'onCompleteScope': this
	});

	var prop = {
		t: 0,
		startPosition: stepInPosition,
		endPosition: endPosition,
		startRotation: startRotation,
		endRotation: endRotation,
		startFov: startFov,
		endFov: endFov
	};

	var arriveInTweener = TweenMax.to(prop, 3, {
		t: 1,
		'delay': 1,
		'ease': Quad.easeInOut,
		'onStart': this.onArriveInStart,
		'onStartScope': this,
		'onUpdate': this.onArriveInUpdate,
		'onUpdateParams': [prop],
		'onUpdateScope': this,
		'onComplete': this.onArriveInComplete,
		'onCompleteParams': [prop],
		'onCompleteScope': this
	});

	this._timeline.add( stepCloseTweener );
	this._timeline.add( arriveInTweener );
};


feng.controllers.controls.EntryControls.prototype.openDoor = function () {

	var skipPause = true;
	this._entry.open( skipPause );

	var designPlane = this._view3d.designPlane;
	designPlane.removeFromScene();

	this._timeline.play();

	this._entry.playOpenSound();
};


feng.controllers.controls.EntryControls.prototype.onStepCloseUpdate = function (prop) {

	var t = prop.t;
	var startPosition = prop.startPosition;
	var endPosition = prop.endPosition;

	var position = this._cameraPosition.copy( startPosition ).lerp( endPosition, t );
	this.setPosition( position );
};


feng.controllers.controls.EntryControls.prototype.onStepCloseComplete = function () {

	this._timeline.pause();

	var hud = this._view3d.hud;
	var viewId = this._view3d.id;
	var sectionId = this._view3d.sectionId;

	hud.openingOverlay.updateContent( sectionId, viewId );
	hud.openingOverlay.animateIn();

	goog.events.listenOnce( hud.openingOverlay, feng.events.EventType.HIDE, this.openDoor, false, this );
};


feng.controllers.controls.EntryControls.prototype.onArriveInStart = function () {
	
	this._footstepsSound = feng.soundController.playSfx('footsteps');
};


feng.controllers.controls.EntryControls.prototype.onArriveInUpdate = function (prop) {

	var t = prop.t;

	var startPosition = prop.startPosition;
	var endPosition = prop.endPosition;

	var position = this._cameraPosition.copy( startPosition ).lerp( endPosition, t );
	this.setPosition( position );

	var startRotation = prop.startRotation;
	var endRotation = prop.endRotation;

	var rx = goog.math.lerp(startRotation.x, endRotation.x, t);
	var ry = goog.math.lerp(startRotation.y, endRotation.y, t);
	var rz = goog.math.lerp(startRotation.z, endRotation.z, t);
	
	this._cameraRotation.set( rx, ry, rz, 'YXZ' );

	this.setRotation( this._cameraRotation );

	var startFov = prop.startFov;
	var endFov = prop.endFov;
	var fov = goog.math.lerp( startFov, endFov, t );

	this.setFov( fov );
};


feng.controllers.controls.EntryControls.prototype.onArriveInComplete = function (prop) {

	this._footstepsSound.pause();

	this._entry.playCloseSound();

	this._entry.close();

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.BROWSE,
		toPosition: prop.endPosition,
		toRotation: prop.endRotation,
		toFov: prop.endFov
	});
};goog.provide('feng.views.sections.controls.Controls');

goog.require('goog.style');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');


/**
 * @constructor
 */
feng.views.sections.controls.Controls = function(domElement){

  goog.base(this);

  this.domElement = domElement;

  this._view3d = null;
  this._cameraController = null;
  this._viewSize = null;
  this._renderEl = null;

  this._isActivated = false;

  this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.views.sections.controls.Controls, goog.events.EventTarget);


feng.views.sections.controls.Controls.prototype.init = function(){
  
};


feng.views.sections.controls.Controls.prototype.setView3D = function( view3d ){

  if(this._view3d) {
    this._view3d.modeController.unlisten( feng.events.EventType.CHANGE, this.onModeChange, false, this );
  }

	this._view3d = view3d;
  this._cameraController = view3d.cameraController;
  this._viewSize = view3d.viewSize;
  this._renderEl = view3d.domElement;

  this._view3d.modeController.listen( feng.events.EventType.CHANGE, this.onModeChange, false, this );
};


feng.views.sections.controls.Controls.prototype.activate = function(){

  if(this._isActivated) return false;
  else this._isActivated = true;

  if(this._view3d) {
    this._view3d.modeController.listen( feng.events.EventType.CHANGE, this.onModeChange, false, this );
  }

	this._eventHandler.listen(window, 'resize', this.onResize, false, this);

	this.onResize();

  return true;
};


feng.views.sections.controls.Controls.prototype.deactivate = function(){

  if(!this._isActivated) return false;
  else this._isActivated = false;
  
  this._eventHandler.removeAll();
  
  return true;
};


feng.views.sections.controls.Controls.prototype.show = function( shouldShow ){

  var shouldShow = goog.isBoolean(shouldShow) ? shouldShow : true;

  goog.dom.classlist.enable( this.domElement, 'hidden', !shouldShow );

  if(shouldShow) {
    
    this.onResize();
  }
};


feng.views.sections.controls.Controls.prototype.onModeChange = function(e){

};


feng.views.sections.controls.Controls.prototype.onResize = function(e){

};goog.provide('feng.views.sections.controls.ZoomSlider');

goog.require('goog.dom');
goog.require('goog.math');
goog.require('goog.events.MouseWheelHandler');
goog.require('feng.events');
goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.ZoomSlider = function(domElement, mousewheelElement, onUpdateCallback){
	
  goog.base(this, domElement);

  this.fovRange = {
  	min: 10,
  	max: 30
  };

  this._zoomSteps = 10;
  this._zoomStep = this._zoomSteps / 2; // mid of min and max

  this._fov = this.calculateFov();
  this._currentFov = this._fov;

  this._mouseWheelHandler = new goog.events.MouseWheelHandler( mousewheelElement );

  this._onUpdateCallback = onUpdateCallback || goog.nullFunction;
};
goog.inherits(feng.views.sections.controls.ZoomSlider, feng.views.sections.controls.Controls);


feng.views.sections.controls.ZoomSlider.prototype.getCurrentFov = function(){

	return this._currentFov;
};


feng.views.sections.controls.ZoomSlider.prototype.calculateFov = function( zoomRatio ){

	this._zoomStep = goog.isNumber(zoomRatio) ? Math.round(goog.math.lerp(0, this._zoomSteps, zoomRatio)) : this._zoomStep;

	this._fov = goog.math.lerp(this.fovRange.min, this.fovRange.max, this._zoomStep/this._zoomSteps);
	
	return this._fov;
};


feng.views.sections.controls.ZoomSlider.prototype.reset = function( zoomRatio ){

	this._fov = this.calculateFov( zoomRatio );
	this._currentFov = this._fov;
};


feng.views.sections.controls.ZoomSlider.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;
  
	this._eventHandler.listen(this._mouseWheelHandler, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.onMouseWheel, false, this);
};


feng.views.sections.controls.ZoomSlider.prototype.onMouseWheel = function(e){

	this._zoomStep = (e.deltaY > 0) ? (this._zoomStep + 1) : (this._zoomStep - 1);
	this._zoomStep = Math.max(0, Math.min(this._zoomStep, this._zoomSteps));

	this._fov = this.calculateFov();

	goog.fx.anim.registerAnimation(this);
};


feng.views.sections.controls.ZoomSlider.prototype.onAnimationFrame = function(now){

	this._currentFov += (this._fov - this._currentFov) * .1;

	this._onUpdateCallback( this.getCurrentFov() );

	if( goog.math.nearlyEquals(this._currentFov, this._fov, 0.01) ) {
		goog.fx.anim.unregisterAnimation(this);
	}
};goog.provide('feng.controllers.controls.DesignControls');

goog.require('goog.fx.Dragger');
goog.require('feng.controllers.controls.Controls');
goog.require('feng.utils.ThreeUtils');
goog.require('feng.views.sections.controls.ZoomSlider');


/**
 * @constructor
 * a combination of trackball controls and transform controls
 */
feng.controllers.controls.DesignControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

  this._activeObject = null;

  this._focus = new THREE.Vector3();

  this._distance = 900;

  // detect bounding box on floors for camera to move around
  this._boundingBox = new THREE.Box3();

	var floorObjects = goog.array.filter(this._view3d.scene.children, function(obj) {
		if(goog.string.startsWith(obj.name, 'floor') && obj.name.length <= 7) {
			return true;
		}
	})

  goog.array.forEach(floorObjects, function(floorObject) {

  	var floorBox = (new THREE.Box3()).setFromObject( floorObject );
  	this._boundingBox = this._boundingBox.union( floorBox );

  }, this);

  // dragger to drag the view
  this._dragger = new goog.fx.Dragger( this._view3d.domElement );
  this._dragger.setHysteresis( 10 );
  this._dragger.defaultAction = goog.nullFunction;
  this._dragger.setEnabled( false );

  this._dragOrigin = new THREE.Vector3();
  this._dragToPosition = new THREE.Vector3();
  this._dragCamera = new THREE.PerspectiveCamera();

	this._tracker = new THREE.Mesh( new THREE.BoxGeometry( 20, 20, 20 ), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, wireframeLinewidth: 2 }) );
	this._tracker.material.fog = false;

	if(feng.debug) {
		this._view3d.scene.add( this._tracker );
	}

  var zoomSliderDom = goog.dom.createDom('div');
  var zoomCallback = goog.bind(this.setFov, this);
  this._zoomSlider = new feng.views.sections.controls.ZoomSlider( zoomSliderDom, this._view3d.domElement, zoomCallback );

  this._dragProps = {
  	'x': 0,
  	'y': 0,
  	startX: 0,
  	startY: 0
  };

  this._startDragRotationX = 0;

  this._cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
};
goog.inherits(feng.controllers.controls.DesignControls, feng.controllers.controls.Controls);


feng.controllers.controls.DesignControls.prototype.setCamera = function( forward, object ) {

	// set focus to center of scene
	this._focus.copy( this._view3d.scene.position );

	// set position / rotation based on focus
	this.setFocus( this._focus.x, this._focus.z, forward );
	
	this.setFov( this._zoomSlider.calculateFov( .6 ) );

	// calculate start rotation for dragging
	var position = this.getPosition();
	var startDeg = goog.math.angle(position.x, position.z, this._focus.x, this._focus.z) + 90;
	this._startDragRotationX = goog.math.toRadians( startDeg );

	// reset drag props
	this._dragProps['x'] = 0;
	this._dragProps.startX = 0;

	this._dragProps['y'] = 1;
	this._dragProps.startY = 1;

	this._zoomSlider.reset();

	this._activeObject = object;
};


feng.controllers.controls.DesignControls.prototype.setFocus = function( x, z, forward ) {

	this._focus.set( x, 0, z );

	// calculate camera position from inversed forward vector
	var vector = forward.negate().multiplyScalar( this._distance );

/*
	var deg = goog.math.angle(vector.x, vector.z, 0, 0);
	var rad = THREE.Math.degToRad(deg);
	var posX = this._distance * Math.cos( rad ) - this._distance * Math.sin( rad );
	var posZ = this._distance * Math.sin( rad ) + this._distance * Math.cos( rad );

	var cameraX = posX;
	var cameraZ = posZ;
*/
	var cameraX = vector.x;
	var cameraZ = vector.z;

	var cameraY = this._distance;

	// apply position
	this.setPosition( cameraX, cameraY, cameraZ );

	// recalculate rotation
	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(this.getPosition(), this._focus);
	this._cameraRotation.setFromQuaternion( quaternion );

	this.setRotation( this._cameraRotation );

	// update tracker position
	this._tracker.position.copy( this._focus );
};


feng.controllers.controls.DesignControls.prototype.getZoomFraction = function() {

	var fov = this._zoomSlider.getCurrentFov();
	var range = this._zoomSlider.fovRange;
	
	return (fov - range.min) / (range.max - range.min);
};


feng.controllers.controls.DesignControls.prototype.isDragging = function() {

	return this._dragger.isDragging();
};


feng.controllers.controls.DesignControls.prototype.enable = function( enable ) {

	var shouldDo = goog.base(this, 'enable', enable);

	if(!shouldDo) return false;
	
	if(this.isEnabled) {

		this._zoomSlider.show(true);

		this.update();

	}else  {

		this._zoomSlider.show(false);
	}

	this._dragger.setEnabled( this.isEnabled );
};


feng.controllers.controls.DesignControls.prototype.activate = function () {

	goog.base(this, 'activate');

	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.START, this.onDragStart, false, this);
	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.DRAG, this.onDrag, false, this);
	this._eventHandler.listen( this._dragger, goog.fx.Dragger.EventType.END, this.onDragEnd, false, this);

	this._eventHandler.listen( feng.navigationController, feng.events.EventType.CHANGE, this.onNavigationChange, false, this );

	this._eventHandler.listen( this._view3d.hud, feng.events.EventType.UPDATE, this.onUpdateHud, false, this);
	this._eventHandler.listen( this._view3d.hud.compass, feng.events.EventType.CLICK_COMPASS, this.onClickCompass, false, this );
	this._eventHandler.listen( this._view3d.hud.tooltips, feng.events.EventType.CLICK_GATEWAY, this.onClickGateway, false, this );

	this._zoomSlider.activate();
};


feng.controllers.controls.DesignControls.prototype.deactivate = function () {

	goog.base(this, 'deactivate');

	this._zoomSlider.deactivate();
};


feng.controllers.controls.DesignControls.prototype.update = function () {

	goog.base(this, 'update');

	var position = this.getPosition();
	var rotationY = goog.math.angle(position.x, position.z, this._focus.x, this._focus.z) + 90;
	rotationY = goog.math.modulo( goog.math.toRadians(rotationY), 2 * Math.PI );

	//
	this.dispatchEvent({
		type: feng.events.EventType.UPDATE,
		rotationY: rotationY
	});
};


feng.controllers.controls.DesignControls.prototype.applyDragRotation = function( rad, distanceFactor ){

	var posX = this._distance * distanceFactor * Math.sin( - rad ) + this._focus.x;
	var posZ = this._distance * distanceFactor * Math.cos( - rad ) + this._focus.z;
	var posY = this._distance;

	this.setPosition( posX, posY, posZ );

	// look at
	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(this.getPosition(), this._focus);
	this._cameraRotation.setFromQuaternion( quaternion );

	this.setRotation( this._cameraRotation );
};


feng.controllers.controls.DesignControls.prototype.thrustDown = function( onComplete, onCompleteParams ){

	var lookDirection = this._focus.clone().sub( this.getPosition() ).normalize();

	var endPosition = this.getPosition().clone().add( lookDirection.multiplyScalar( 600 ) );

  var prop = {
    t: 0,
    startPosition: this.getPosition().clone(),
    endPosition: endPosition,
    startRotation: this.getRotation(),
    endRotation: this.getRotation(),
    startFov: this.getFov(),
    endFov: this.getFov()
  }

	TweenMax.to( prop, 1, {
	  t: 1,
	  'ease': Expo.easeOut,
	  'onStart': this.onCameraTransitionStart,
	  'onStartScope': this,
	  'onUpdate': this.onCameraTransitionUpdate,
	  'onUpdateParams': [prop],
	  'onUpdateScope': this,
	  'onComplete': onComplete,
	  'onCompleteParams': onCompleteParams,
	  'onCompleteScope': this
	});
};


feng.controllers.controls.DesignControls.prototype.onDragStart = function(e){

	this._dragProps.startX = this._dragProps['x'];
	this._dragProps.startY = this._dragProps['y'];

	TweenLite.killTweensOf( this._dragProps );
	ThrowPropsPlugin.untrack( this._dragProps );

	ThrowPropsPlugin.track( this._dragProps, 'x,y' );
};


feng.controllers.controls.DesignControls.prototype.onDrag = function(e){

	var deltaX = this._dragger.deltaX;
	this._dragProps['x'] = this._dragProps.startX + deltaX / this._view3d.viewSize.width / 2;

	var deltaY = this._dragger.deltaY;
	var deltaFraction = deltaY / (this._view3d.viewSize.height/2);
	this._dragProps['y'] = goog.math.clamp( this._dragProps.startY - deltaFraction, 0.05, 1 );

	this.onDragUpdate();
};


feng.controllers.controls.DesignControls.prototype.onDragEnd = function(e){

	ThrowPropsPlugin.to(this._dragProps, {
		'throwProps': {
			'x': 'auto',
			'y': 'auto',
			'resistance': 100
		},
		'onUpdate': this.onDragUpdate,
		'onUpdateScope': this
	}, 4, .5);
};


feng.controllers.controls.DesignControls.prototype.onDragUpdate = function(){

	var deg = this._dragProps['x'] * 360;
	var rad = THREE.Math.degToRad( deg );

	var distanceFactor = goog.math.clamp( this._dragProps['y'], 0.05, 1 );

	this.applyDragRotation( this._startDragRotationX + rad, distanceFactor );
};


feng.controllers.controls.DesignControls.prototype.onClickGateway = function(e) {

	this.thrustDown( this.onCameraTransitionToGatewayComplete, [e.gateway] );
};


feng.controllers.controls.DesignControls.prototype.onClickCompass = function(e) {

	if(e.mode === 'browse') {

		this.thrustDown( this.onCameraTransitionToBrowseModeComplete, [] );
	}
};


feng.controllers.controls.DesignControls.prototype.onNavigationChange = function(e) {

	var navController = e.target;

	var goTipResult = navController.testToken( e.tokenArray, feng.controllers.NavigationController.Token.GO_TIP );

	if(!goTipResult) {

		return;
	}

	this.thrustDown( this.onCameraTransitionToTipComplete, [goTipResult] );
};


feng.controllers.controls.DesignControls.prototype.onCameraTransitionStart = function(){

	this._view3d.hud.tooltips.deactivate();
	this.deactivate();

	feng.soundController.playSfx('thrust-down');
};


feng.controllers.controls.DesignControls.prototype.onCameraTransitionUpdate = function(prop){

  var startPosition = prop.startPosition;
  var endPosition = prop.endPosition;
  var startRotation = prop.startRotation;
  var endRotation = prop.endRotation;
  var startFov = prop.startFov;
  var endFov = prop.endFov;
  var t = prop.t;

  this.lerp( startPosition, endPosition, startRotation, endRotation, startFov, endFov, t );

  this._view3d.renderController.globalBrightness = - t;
};


feng.controllers.controls.DesignControls.prototype.onCameraTransitionToGatewayComplete = function( gateway ){

	var gatewayPosition = gateway.getCenter();
	var gatewayOriginPosition = gateway.origin.position;
	var gatewayOriginRotation = gateway.origin.rotation;
	var gatewayDirection = (new THREE.Vector3()).subVectors(gatewayOriginPosition, gatewayPosition).setY(0).normalize();

	var fromPosition = gatewayOriginPosition.clone().add( gatewayDirection.clone().multiplyScalar(50) ).setY( feng.controllers.controls.Controls.Default.STANCE_HEIGHT );

	var fromRotation = new THREE.Euler(0, 0, 0, 'YXZ');
	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(fromPosition, gatewayPosition);
	fromRotation.setFromQuaternion( quaternion );

	var fromFov = feng.controllers.controls.Controls.Default.FOV;

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
	  mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
	  nextMode: feng.controllers.view3d.ModeController.Mode.EXIT,
	  fromPosition: fromPosition,
		fromRotation: fromRotation,
		fromFov: fromFov,
	  gateway: gateway
	});
};


feng.controllers.controls.DesignControls.prototype.onCameraTransitionToTipComplete = function( goTipResult ){

	var object = this._view3d.getView3dObjectById( goTipResult['objectId'] );
	var tip = object.tip;

	// calculate camera position/rotation/fov before transition
	var browseControls = this._view3d.modeController.getModeControl(feng.controllers.view3d.ModeController.Mode.BROWSE);
	var direction = new THREE.Vector3().subVectors( browseControls.getPosition(), object.getCenter() ).normalize();
	var fromPosition = object.getCenter().clone().add( direction.multiplyScalar(100) );
	
	var matrixData = feng.pathfinder.getMatrixData( this._view3d.getMatrixId() );
	fromPosition = feng.pathfinder.getClosestWalkablePosition( fromPosition, matrixData ).setY( feng.controllers.controls.Controls.Default.STANCE_HEIGHT );

	var fromRotation = new THREE.Euler(0, 0, 0, 'YXZ');
  var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(fromPosition, object.getCenter());
  fromRotation.setFromQuaternion( quaternion );

  var fromFov = feng.controllers.controls.Controls.Default.FOV;

  browseControls.setPosition( fromPosition );
  browseControls.setRotation( fromRotation );

	//
	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
		nextMode: feng.controllers.view3d.ModeController.Mode.CLOSE_UP,
		fromPosition: fromPosition,
		fromRotation: fromRotation,
		fromFov: fromFov,
		object: object
	});
};


feng.controllers.controls.DesignControls.prototype.onCameraTransitionToBrowseModeComplete = function(){

	var browseControls = this._view3d.modeController.getModeControl(feng.controllers.view3d.ModeController.Mode.BROWSE);

	var fromPosition = browseControls.getPosition();

	var fromRotation = browseControls.getRotation().clone();
	fromRotation.x = Math.PI / 4;

	var fromFov = feng.controllers.controls.Controls.Default.FOV;

  this.setPosition( fromPosition );
  this.setRotation( fromRotation );
  this.setFov( fromFov );

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
		nextMode: feng.controllers.view3d.ModeController.Mode.BROWSE
	});
};goog.provide('feng.controllers.controls.CloseUpControls');

goog.require('goog.events');
goog.require('goog.math');
goog.require('feng.controllers.controls.Controls');


/**
 * @constructor
 */
feng.controllers.controls.CloseUpControls = function(camera, view3d, domElement) {

  goog.base(this, camera, view3d, domElement);

  this._activeObject = null;

  this._backUpRotation = new THREE.Euler(0, 0, 0, 'YXZ');

  this._raycaster = feng.utils.ThreeUtils.raycaster;

  this.distanceToObject = 0;
};
goog.inherits(feng.controllers.controls.CloseUpControls, feng.controllers.controls.Controls);


feng.controllers.controls.CloseUpControls.prototype.setCamera = function( object ) {
	
	// from
	var browseControls = this._view3d.modeController.getModeControl(feng.controllers.view3d.ModeController.Mode.BROWSE);
	var position = browseControls.getPosition();
	var rotation = browseControls.getRotation();
	var fov = browseControls.getFov();

	// get special camera settings from object
	var cameraSettings = object.isSpecialCameraEnabled ? object.specialCameraSettings : null;
	console.log( 'set close up by special camera settings: ', cameraSettings );

	// otherwise focus on the center of object's proxy box
	if(!cameraSettings) {

		var proxyBox = object.getProxyBox();
		var boundingBox = (new THREE.Box3()).setFromObject( proxyBox );

		var toRotation = new THREE.Euler(0, 0, 0, 'YXZ');
		var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt(position, boundingBox.center());
		toRotation.setFromQuaternion( quaternion );

		var direction = proxyBox.position.clone().sub( position ).normalize();
		this._raycaster.set( position, direction );

		var intersects = this._raycaster.intersectObject( proxyBox, true );
		this.distanceToObject = intersects[0].distance;

		var height = boundingBox.size().y;
		var fitFov = 2 * Math.atan( height / ( 2 * this.distanceToObject ) ) * ( 180 / Math.PI );
		var toFov = fitFov + 10;

		cameraSettings = {
			position: position,
			rotation: toRotation,
			fov: toFov
		};
	}

	// clear camera offset
	this.getCamera().position.set( 0, 0, 0 );

	// set camera
	this.setPosition( cameraSettings.position );
	this.setRotation( cameraSettings.rotation );
	this.setFov( cameraSettings.fov );

	//
	this._activeObject = object;

	// pre-calculate backed up rotation, in case the object might be later picked up
	var browseControls = this._view3d.modeController.getModeControl( feng.controllers.view3d.ModeController.Mode.BROWSE );

	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt( browseControls.getPosition(), this._activeObject.getCenter() );
	this._backUpRotation.setFromQuaternion( quaternion );
};


feng.controllers.controls.CloseUpControls.prototype.enable = function( enable, object ) {
	
	this._activeObject = object || this._activeObject;

	var shouldDo = goog.base(this, 'enable', enable);

	if(!shouldDo) return false;

	if(this.isEnabled) {

		this.distanceToObject = this.getPosition().distanceTo( this._activeObject.object3d.position );

		this._activeObject.onCameraIn();

		var caption = this._view3d.hud.getCaption( this._activeObject, this );
		caption.setParentEventTarget(this);
		caption.show();

		// todo
		if(this._activeObject.tip.unlocked) {

			this._view3d.fx.greenLeaves.animateIn( this._activeObject );
			this._view3d.fx.yellowLeaves.animateOut();

		}else {

			this._view3d.fx.yellowLeaves.animateIn( this._activeObject );
			this._view3d.fx.greenLeaves.animateOut();
		}

	}else  {
		
		var caption = this._view3d.hud.getCaption( this._activeObject, this );
		caption.hide();

		this._view3d.fx.greenLeaves.animateOut( 4 );
		this._view3d.fx.yellowLeaves.animateOut( 4 );
	}
};


feng.controllers.controls.CloseUpControls.prototype.activate = function () {

	goog.base(this, 'activate');

	this._eventHandler.listen(this, feng.events.EventType.CLOSE, this.close, false, this);

	// animate out object select effect
	this._view3d.fx.selectEffect.animateOut();
};


feng.controllers.controls.CloseUpControls.prototype.close = function ( e ) {

	this._activeObject.onCameraOut();

	// set the only object to unlock next
	var providedTip = this._activeObject.tip.getProvidedTip();

	if(providedTip) {

		this._view3d.onlyObjectToUnlock = providedTip.unlocked ? null : this._view3d.getObjectByTip( providedTip );

	}else {

		this._view3d.onlyObjectToUnlock = (this._activeObject.hasPicked && !this._activeObject.hasDropped) ? this._activeObject : null;
	}

	//
	feng.navigationController.replaceToken("");

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
		nextMode: feng.controllers.view3d.ModeController.Mode.BROWSE,
		toRotation: this._backUpRotation,
		eventToTrigger: e ? e.eventToTrigger : null
	});
};goog.provide('feng.controllers.controls.BrowseControls');

goog.require('goog.events');
goog.require('goog.events.MouseWheelHandler');
goog.require('goog.math.Box');
goog.require('feng.controllers.controls.Controls');
goog.require('feng.utils.ThreeUtils');

/**
 * @constructor
 * a mod of PointerLockControls...
 */
feng.controllers.controls.BrowseControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

	this._shouldIgnoreClick = false;

	this._objectSelectorCallbacks = {
		'onStart': goog.bind(this.onObjectSelectStart, this),
		'onCancel': goog.bind(this.onObjectSelectCancel, this),
		'onComplete': goog.bind(this.onObjectSelectComplete, this)
	};

	this._objectSelector = this._view3d.hud.objectSelector;
	this._progressBar = this._view3d.hud.progressBar;

	this._detectorDistance = 300/2;
	
	this._detectorSphere = new THREE.Sphere();

	this._detectorRay = new THREE.Raycaster();
	this._detectorRay.far = this._detectorDistance;

	this._maxMouseWheelDeltaY = 50;
	this._mouseWheelHandler = new goog.events.MouseWheelHandler( domElement );
	this._mouseWheelHandler.setMaxDeltaY( this._maxMouseWheelDeltaY );

	this._lastMouseX = 0;
	this._lastMouseY = 0;
	this._targetRotationX = 0;
	this._targetRotationY = 0;

	this._maxRotationX = THREE.Math.degToRad(40);
	this._minRotationX = THREE.Math.degToRad(-60);
};
goog.inherits(feng.controllers.controls.BrowseControls, feng.controllers.controls.Controls);


feng.controllers.controls.BrowseControls.prototype.setCamera = function( toRotation ) {

	this.setRotation( toRotation );
};


feng.controllers.controls.BrowseControls.prototype.enable = function( enable, mouseEventToTrigger ) {

	var shouldDo = goog.base(this, 'enable', enable);

	if(!shouldDo) return false;

	if(this.isEnabled) {

		if(mouseEventToTrigger) {
			this.onInputDown( mouseEventToTrigger );
		}

		this._targetRotationY = this._yawObject.rotation.y;
		this._targetRotationX = this._pitchObject.rotation.x;

		// update sphere to limit the reach of tip objects
		var cameraPosition = this.getPosition();
		this._detectorSphere.set( cameraPosition, this._detectorDistance );

		// update selectable objects only locked within sphere
		var selectableObjects = [];

		var solidObjects = this._view3d.getSolidObjects();
		var object3ds = goog.array.map(solidObjects, function(object) {
			return object.object3d;
		});

		goog.object.forEach(this._view3d.tipObjects, function(tipObject) {

			var locked = !tipObject.tip.unlocked;
			
			var isUnlockedRequiredTip = (tipObject.tip.getProvidedTip() && !locked);
			if(isUnlockedRequiredTip) return;

			var withinRange = this._detectorSphere.intersectsSphere( tipObject.getBoundingSphere() );

			var inArms = this._view3d.arms.containsObject( tipObject );

			//console.log(tipObject.name + ' withinRange: ' + withinRange + ', locked: ' + locked);

			if(locked && withinRange && !inArms) {
				selectableObjects.push( tipObject );
			}
		}, this);

		//
		var nearbyObjects = selectableObjects.concat();
		
		this._objectSelector.setSelectableObjects( selectableObjects );
		this._progressBar.setNearbyObjects( nearbyObjects );
	}
};


feng.controllers.controls.BrowseControls.prototype.activate = function () {

	goog.base(this, 'activate');

	this._eventHandler.listen( this._view3d.hud, feng.events.EventType.UPDATE, this.onUpdateHud, false, this );
	this._eventHandler.listen( this._view3d.hud.compass, feng.events.EventType.CLICK_COMPASS, this.onClickCompass, false, this );
	this._eventHandler.listen( this._view3d.hud.tooltips, feng.events.EventType.CLICK_GATEWAY, this.onClickGateway, false, this );
	
	this._eventHandler.listen( this._mouseWheelHandler, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.onMouseWheel, false, this );
	this._eventHandler.listen( feng.navigationController, feng.events.EventType.CHANGE, this.onNavigationChange, false, this );

	this._objectSelector.activate( this._objectSelectorCallbacks );
};


feng.controllers.controls.BrowseControls.prototype.deactivate = function () {

	goog.base(this, 'deactivate');

	this._objectSelector.deactivate();
};


feng.controllers.controls.BrowseControls.prototype.getClickableObjects = function () {

	var clickableObjects = [];

	goog.object.forEach(this._view3d.view3dObjects, function(object) {

		clickableObjects.push( object.object3d );
	});

	return clickableObjects;
};


feng.controllers.controls.BrowseControls.prototype.update = function () {

	goog.base(this, 'update');

	var PI_2 = Math.PI / 2;

	this._yawObject.rotation.y += (this._targetRotationY - this._yawObject.rotation.y) * .1;
	this._pitchObject.rotation.x += (this._targetRotationX - this._pitchObject.rotation.x) * .1;
	this._pitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, this._pitchObject.rotation.x ) );

	var fov = this.getFov();
	var defaultFov = feng.controllers.controls.Controls.Default.FOV;

	if(fov !== defaultFov) {

		fov += (defaultFov - fov) * .05;
		this.setFov( fov );

		if(goog.math.nearlyEquals(fov, defaultFov, .1)) {
			this.setFov( defaultFov );
		}
	}
	
	//
	this.dispatchEvent({
		type: feng.events.EventType.UPDATE,
		rotationY: this.getYaw()
	});
};


feng.controllers.controls.BrowseControls.prototype.onClick = function ( e ) {
	
	goog.base(this, 'onClick', e);

	if ( this._shouldIgnoreClick ) return;

	var clickableObjects = this.getClickableObjects();

	goog.array.remove( clickableObjects, this._view3d.designPlane.object3d );
	goog.array.remove( clickableObjects, this._view3d.skybox.object3d );

	var intersects = feng.utils.ThreeUtils.getObjectsBy2DPosition( e.clientX, e.clientY, clickableObjects, this._camera, this._view3d.getViewSize() );

	if ( intersects.length > 0 ) {

		// walk to the object
		var toPosition = intersects[0].point;

		this.dispatchEvent({
			type: feng.events.EventType.CHANGE,
			mode: feng.controllers.view3d.ModeController.Mode.WALK,
			nextMode: feng.controllers.view3d.ModeController.Mode.BROWSE,
			toPosition: toPosition
		});

		feng.pubsub.publish( feng.PubSub.Topic.TRIGGER_WALK, 'click' );

		// play click effect
		var normal = intersects[0].face.normal;
		this._view3d.fx.clickEffect.play( toPosition, normal );
	}
};


feng.controllers.controls.BrowseControls.prototype.onInputDown = function ( e ) {

	goog.base(this, 'onInputDown', e);

	this._shouldIgnoreClick = false;

	this._lastMouseX = e.clientX;
	this._lastMouseY = e.clientY;
};


feng.controllers.controls.BrowseControls.prototype.onInputMove = function ( e ) {

	goog.base(this, 'onInputMove', e);

	this._shouldIgnoreClick = true;

	var movementX = e.clientX - this._lastMouseX;
	var movementY = e.clientY - this._lastMouseY;

	this._lastMouseX = e.clientX;
	this._lastMouseY = e.clientY;

	this._targetRotationY = this._yawObject.rotation.y + movementX * 0.009;
	this._targetRotationX = this._pitchObject.rotation.x + movementY * 0.009;

	// limit vertical rotation
	this._targetRotationX = Math.max(Math.min(this._maxRotationX, this._targetRotationX), this._minRotationX);
};


feng.controllers.controls.BrowseControls.prototype.onMouseWheel = function ( e ) {

	e.preventDefault();

	var distance = goog.math.lerp( 100, 400, Math.abs(e.deltaY) / this._maxMouseWheelDeltaY );
	distance *= - e.deltaY / Math.abs(e.deltaY);

	var forward = this.getForwardVector();
	var toPosition = (new THREE.Vector3()).addVectors( this.getPosition(), forward.multiplyScalar( distance ) );
	toPosition.y = this.getPosition().y;

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.WALK,
		nextMode: feng.controllers.view3d.ModeController.Mode.BROWSE,
		toPosition: toPosition,
		mousewheel: true
	});

	feng.pubsub.publish( feng.PubSub.Topic.TRIGGER_WALK, 'mousewheel' );
};


feng.controllers.controls.BrowseControls.prototype.onObjectSelectCancel = function () {


};


feng.controllers.controls.BrowseControls.prototype.onObjectSelectStart = function ( object ) {

	
};


feng.controllers.controls.BrowseControls.prototype.onObjectSelectComplete = function ( object ) {

	console.log('Object selected: ' + object.object3d.name);

	//
	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
		nextMode: feng.controllers.view3d.ModeController.Mode.CLOSE_UP,
		object: object
	});	
};


feng.controllers.controls.BrowseControls.prototype.onUpdateHud = function(e){

	if(e.target instanceof feng.views.sections.controls.Compass) {
		this.setYaw( e.rotation );
		this._targetRotationY = e.rotation;
	}
};


feng.controllers.controls.BrowseControls.prototype.onClickCompass = function(e) {

	if(e.mode === 'design') {

  		this.dispatchEvent({
  			type: feng.events.EventType.CHANGE,
			mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
			nextMode: feng.controllers.view3d.ModeController.Mode.DESIGN
		});
	}
};


feng.controllers.controls.BrowseControls.prototype.onClickGateway = function(e) {

  this.dispatchEvent({
  	type: feng.events.EventType.CHANGE,
    mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
    nextMode: feng.controllers.view3d.ModeController.Mode.EXIT,
    gateway: e.gateway
  });
};


feng.controllers.controls.BrowseControls.prototype.onNavigationChange = function(e) {

	var navController = e.target;

	var goTipResult = navController.testToken( e.tokenArray, feng.controllers.NavigationController.Token.GO_TIP );
	
	if(goTipResult) {

		var object = this._view3d.getView3dObjectById( goTipResult['objectId'] );
		var tip = object.tip;

		this.dispatchEvent({
			type: feng.events.EventType.CHANGE,
			mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
			nextMode: feng.controllers.view3d.ModeController.Mode.CLOSE_UP,
			object: object
		});
	}
};// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview PseudoRandom provides a mechanism for generating deterministic
 * psuedo random numbers based on a seed. Based on the Park-Miller algorithm.
 * See http://dx.doi.org/10.1145%2F63039.63042 for details.
 *
 */

goog.provide('goog.testing.PseudoRandom');

goog.require('goog.Disposable');



/**
 * Class for unit testing code that uses Math.random. Generates deterministic
 * random numbers.
 *
 * @param {number=} opt_seed The seed to use.
 * @param {boolean=} opt_install Whether to install the PseudoRandom at
 *     construction time.
 * @extends {goog.Disposable}
 * @constructor
 * @final
 */
goog.testing.PseudoRandom = function(opt_seed, opt_install) {
  goog.Disposable.call(this);

  if (!goog.isDef(opt_seed)) {
    opt_seed = goog.testing.PseudoRandom.seedUniquifier_++ + goog.now();
  }
  this.seed(opt_seed);

  if (opt_install) {
    this.install();
  }
};
goog.inherits(goog.testing.PseudoRandom, goog.Disposable);


/**
 * Helps create a unique seed.
 * @type {number}
 * @private
 */
goog.testing.PseudoRandom.seedUniquifier_ = 0;


/**
 * Constant used as part of the algorithm.
 * @type {number}
 */
goog.testing.PseudoRandom.A = 48271;


/**
 * Constant used as part of the algorithm. 2^31 - 1.
 * @type {number}
 */
goog.testing.PseudoRandom.M = 2147483647;


/**
 * Constant used as part of the algorithm. It is equal to M / A.
 * @type {number}
 */
goog.testing.PseudoRandom.Q = 44488;


/**
 * Constant used as part of the algorithm. It is equal to M % A.
 * @type {number}
 */
goog.testing.PseudoRandom.R = 3399;


/**
 * Constant used as part of the algorithm to get values from range [0, 1).
 * @type {number}
 */
goog.testing.PseudoRandom.ONE_OVER_M_MINUS_ONE =
    1.0 / (goog.testing.PseudoRandom.M - 1);


/**
 * The seed of the random sequence and also the next returned value (before
 * normalization). Must be between 1 and M - 1 (inclusive).
 * @type {number}
 * @private
 */
goog.testing.PseudoRandom.prototype.seed_ = 1;


/**
 * Whether this PseudoRandom has been installed.
 * @type {boolean}
 * @private
 */
goog.testing.PseudoRandom.prototype.installed_;


/**
 * The original Math.random function.
 * @type {function(): number}
 * @private
 */
goog.testing.PseudoRandom.prototype.mathRandom_;


/**
 * Installs this PseudoRandom as the system number generator.
 */
goog.testing.PseudoRandom.prototype.install = function() {
  if (!this.installed_) {
    this.mathRandom_ = Math.random;
    Math.random = goog.bind(this.random, this);
    this.installed_ = true;
  }
};


/** @override */
goog.testing.PseudoRandom.prototype.disposeInternal = function() {
  goog.testing.PseudoRandom.superClass_.disposeInternal.call(this);
  this.uninstall();
};


/**
 * Uninstalls the PseudoRandom.
 */
goog.testing.PseudoRandom.prototype.uninstall = function() {
  if (this.installed_) {
    Math.random = this.mathRandom_;
    this.installed_ = false;
  }
};


/**
 * Seed the generator.
 *
 * @param {number=} seed The seed to use.
 */
goog.testing.PseudoRandom.prototype.seed = function(seed) {
  this.seed_ = seed % (goog.testing.PseudoRandom.M - 1);
  if (this.seed_ <= 0) {
    this.seed_ += goog.testing.PseudoRandom.M - 1;
  }
};


/**
 * @return {number} The next number in the sequence.
 */
goog.testing.PseudoRandom.prototype.random = function() {
  var hi = Math.floor(this.seed_ / goog.testing.PseudoRandom.Q);
  var lo = this.seed_ % goog.testing.PseudoRandom.Q;
  var test = goog.testing.PseudoRandom.A * lo -
             goog.testing.PseudoRandom.R * hi;
  if (test > 0) {
    this.seed_ = test;
  } else {
    this.seed_ = test + goog.testing.PseudoRandom.M;
  }
  return (this.seed_ - 1) * goog.testing.PseudoRandom.ONE_OVER_M_MINUS_ONE;
};
goog.provide('feng.utils.Randomizer');

goog.require('goog.math');
goog.require('goog.testing.PseudoRandom');


/**
 * @constructor
 */
feng.utils.Randomizer = function(){

};


/**
 * Static Method, return seeded randomized number
 */
feng.utils.Randomizer.getRandomNumber = function(seed){

	var random = new goog.testing.PseudoRandom(seed);
	return random.random();
};


/**
 * Static Method, return seeded randomized numbers
 */
feng.utils.Randomizer.getRandomNumbers = function(seed, amount){

	var random = new goog.testing.PseudoRandom(seed);
	var randomNumbers = [];

	for(var i = 0; i < amount; ++i) {
		randomNumbers.push( random.random() );
	}

	return randomNumbers;
};goog.provide('feng.fx.PathTrack');

goog.require('feng.utils.Randomizer');

/**
 * @constructor
 * Based on http://mrdoob.github.io/three.js/examples/webgl_geometry_extrude_splines.html
 */
feng.fx.PathTrack = function(controlPoints, offset, isClosed, color){

  goog.base(this);

  this.controlPoints = null;
  this.isClosed = false;
  this.spline = null;

  this.tubeGeometry = null;
  this.segments = null;

  this._material = new THREE.MeshBasicMaterial({
	opacity: 0.4,
	transparent: true,
	wireframe: true
  });

  // a dummy camera for calculating the position/rotation on spline
  this._pathCamera = new THREE.PerspectiveCamera();
  this._binormal = new THREE.Vector3();
  this._normal = new THREE.Vector3();
  this._up = new THREE.Vector3(0, 1, 0);
  this._offset = 0;

  this._debugObject = new THREE.Object3D();
  this.add( this._debugObject );

  this.create( controlPoints, offset, isClosed, color );
};
goog.inherits(feng.fx.PathTrack, THREE.Object3D);


feng.fx.PathTrack.prototype.create = function(controlPoints, offset, isClosed, color){

  this.controlPoints = controlPoints;
  this.isClosed = isClosed;
  this.spline = !this.isClosed ? new THREE.SplineCurve3(controlPoints) : new THREE.ClosedSplineCurve3(controlPoints);

  this._material.color = color || '#000000';

  this._offset = goog.isNumber(offset) ? offset : -15;

  this.updateTrack();
};


feng.fx.PathTrack.prototype.dispose = function(){

	this.tubeGeometry.dispose();
	this.tubeGeometry = null;

	this._material.dispose();
	this._material = null;
};


feng.fx.PathTrack.prototype.getControlMeshes = function(){

	var meshes = [];

	goog.array.forEach(this._debugObject.children, function(child) {
		if(child.geometry instanceof THREE.BoxGeometry) {
			meshes.push(child);
		}
	});

	return meshes;
};


feng.fx.PathTrack.prototype.getControlCubeByName = function(name){

	return this._debugObject.getObjectByName( name );
};


feng.fx.PathTrack.prototype.getSpacedPoints = function(){

	return this.spline.getSpacedPoints( this.segments );
};


feng.fx.PathTrack.prototype.getEstimatedDistanceBetweenU = function(u1, u2){

	var lengths = this.spline.getLengths();
	var d1 = lengths[ Math.floor( (lengths.length - 1) * u1 ) ];
	var d2 = lengths[ Math.floor( (lengths.length - 1) * u2 ) ];
	var d = d2 - d1;

	return d;
};


feng.fx.PathTrack.prototype.getCameraAt = function(u){

	var tube = this.tubeGeometry;
	var pos = this.spline.getPointAt( u );

	// interpolation
	var segments = tube.tangents.length;
	var picku = u * segments;
	var pick = Math.floor( picku );
	var pickNext = ( pick + 1 ) % segments;

	if(picku <= segments - 1) {

		var binormal = this._binormal;
		binormal.subVectors( tube.binormals[ pickNext ], tube.binormals[ pick ] );
		binormal.multiplyScalar( picku - pick ).add( tube.binormals[ pick ] );

		var dir = this.spline.getTangentAt( u );

		var normal = this._normal;
		normal.copy( binormal ).cross( dir );

		// We move on a offset on its binormal
		pos.add( normal.clone().multiplyScalar( this._offset ) );

		this._pathCamera.position.copy( pos );

		var lookAt = this.spline.getPointAt( ( u + 30 / this.spline.getLength() ) % 1 );
		lookAt.copy( pos ).add( dir );

		this._pathCamera.matrix.lookAt(pos, lookAt, this._up);
		this._pathCamera.rotation.setFromRotationMatrix( this._pathCamera.matrix, this._pathCamera.rotation.order );

		var euler = new THREE.Euler(0, 0, 0, 'YXZ').setFromQuaternion( this._pathCamera.quaternion );
		this._pathCamera.rotation.copy( euler );

	}else {

		// make sure to reach the last position when u = 1
		this._pathCamera.position.copy( this.spline.getPointAt(1) );
	}

	return this._pathCamera;
};


feng.fx.PathTrack.prototype.addControlPoint = function(val){

	var id;

	if(val instanceof THREE.Mesh) {
		id = val.userData.id;
	}else if(val instanceof THREE.Vector3) {
		id = goog.array.indexOf(this.controlPoints, val);
	}else if(goog.isNumber(val)) {
		id = val;
	}else {
		id = this.controlPoints.length - 1;
	}

	var startControlPoint = this.controlPoints[id];
	var endControlPoint = this.controlPoints[Math.min(this.controlPoints.length-1, id+1)];

	var newControlPoint;

	if(startControlPoint === endControlPoint) {
		newControlPoint = startControlPoint.clone().add( startControlPoint );
	}else {
		newControlPoint = startControlPoint.clone().lerp(endControlPoint, .5);
	}

	goog.array.insertAt(this.controlPoints, newControlPoint, id+1);

	this.updateTrack();

	return this.getControlCubeByName('cube'+(id+1));
};


feng.fx.PathTrack.prototype.removeControlPoint = function(val){

	var id;

	if(val instanceof THREE.Mesh) {
		id = val.userData.id;
	}else if(val instanceof THREE.Vector3) {
		id = goog.array.indexOf(this.controlPoints, val);
	}else if(goog.isNumber(val)) {
		id = val;
	}else {
		id = this.controlPoints.length - 1;
	}

	goog.array.removeAt(this.controlPoints, id);

	this.updateTrack();
};


feng.fx.PathTrack.prototype.updateTrack = function(){

	this.spline.updateArcLengths();

	// remove debug object children
	goog.array.forEachRight(this._debugObject.children, function(child) {
		this._debugObject.remove(child);
	}, this);

	// create new segments
	var segmentLength = 5;
	this.segments = Math.floor(this.spline.getLength() / segmentLength);

  this.tubeGeometry = new THREE.TubeGeometry(this.spline, this.segments, .5, 4, this.isClosed);
  var tubeMesh = new THREE.Mesh( this.tubeGeometry, this._material );
  this._debugObject.add(tubeMesh);
  
  // create cubes for dragging
  goog.array.forEach(this.controlPoints, function(coordinate, index) {
  	var geometry = new THREE.BoxGeometry(6, 6, 6);
  	var cube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
  		transparent: true,
  		opacity: .2,
      color: feng.utils.Randomizer.getRandomNumber(index*100) * 0xffffff
    }));
    cube.name = 'cube'+index;
    cube.userData.id = index;
    cube.userData.position = coordinate;
    cube.position.copy( coordinate );
    this._debugObject.add(cube);
  }, this);
};goog.provide('feng.controllers.controls.WalkControls');

goog.require('goog.events');
goog.require('goog.math');
goog.require('feng.controllers.controls.Controls');
goog.require('feng.fx.PathTrack');
goog.require('feng.utils.ThreeUtils');

/**
 * @constructor
 */
feng.controllers.controls.WalkControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

	this._tweener = null;
	this._pathTrack = null;

	this._cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
	this._startRotation = new THREE.Euler(0, 0, 0, 'YXZ');
	this._endRotation = new THREE.Euler(0, 0, 0, 'YXZ');

	this._footstepsSound = null;
};
goog.inherits(feng.controllers.controls.WalkControls, feng.controllers.controls.Controls);


feng.controllers.controls.WalkControls.prototype.pause = function ( pause ) {

	var shouldPause = goog.base(this, 'pause', pause);

	if(shouldPause && this._tweener) {

		this._tweener.pause();

	}else {

		this._tweener.resume();
	}
};


feng.controllers.controls.WalkControls.prototype.start = function ( ev ) {

	var fromPosition = ev.fromPosition;
	var toPosition = ev.toPosition;
	var nextMode = ev.nextMode;

	//
	var pathfinder = feng.pathfinder;

	var matrixId = this._view3d.getMatrixId();
	var start = fromPosition;
	var end = toPosition;
	
	var coordinates = pathfinder.findPath( matrixId, start, end );

	if(!coordinates) {
		
		var matrixData = feng.pathfinder.getMatrixData( this._view3d.getMatrixId() );
		this.bounceBack( nextMode );
		return;
	}

	// dispose last path track
	if(this._pathTrack) {

		if(feng.debug) {
			this._scene.remove( this._pathTrack );
		}

		this._pathTrack.dispose();
	}

	// create path track
	this._pathTrack = new feng.fx.PathTrack( coordinates, 0, false, null, feng.debug );

	if(feng.debug) {
		this._scene.add( this._pathTrack );
	}

	// calculate end rotation based on last position
	var viewDistance = 25;
	var splineLength = this._pathTrack.spline.getLength();
	var actualDistance = splineLength - viewDistance;
	var endU = actualDistance / splineLength;

	if(endU <= 0) {

		this.bounceBack( nextMode );
		return;
	}

	var actualEndPosition = this._pathTrack.spline.getPointAt( endU ).setY( feng.controllers.controls.Controls.Default.STANCE_HEIGHT );

	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt( actualEndPosition, toPosition );
	this._endRotation.setFromQuaternion( quaternion );
	this._endRotation.x = Math.max(this._endRotation.x, THREE.Math.degToRad(-40));
	
	this._startRotation.copy( ev.fromRotation );
	
	// adult walking speed is 1.564 meter per second
	var speed = 1.000 * 100;
	var duration = Math.max(1, actualDistance / (speed / 2));

	var footstepLength = 20;
	var footsteps = Math.floor(actualDistance / footstepLength);

	var prop = {
		t: 0,
		endU: endU,
		footstep: 0,
		mousewheel: ev.mousewheel
	};

  this._tweener = TweenMax.to(prop, duration, {
    t: 1,
    footstep: Math.PI * footsteps,
    'ease': Linear.easeNone,
    'onStart': this.onPathStart,
    'onStartScope': this,
    'onUpdate': this.onPathProgress,
    'onUpdateParams': [prop],
    'onUpdateScope': this,
    'onComplete': this.onPathComplete,
    'onCompleteParams': [nextMode],
    'onCompleteScope': this
  });
};


feng.controllers.controls.WalkControls.prototype.bounceBack = function ( nextMode ) {

	var prop = {
		fov: this.getFov()
	};

	TweenMax.to(prop, .3, {
		fov: 35,
		'yoyo': true,
		'repeat': 1,
		'ease': Quad.easeInOut,
		'onUpdate': function(prop) {
			this.setFov( prop.fov );
		},
		'onUpdateParams': [prop],
		'onUpdateScope': this,
		'onComplete': this.onPathComplete,
		'onCompleteParams': [nextMode],
		'onCompleteScope': this
	});
};


feng.controllers.controls.WalkControls.prototype.onPathStart = function () {

	this._footstepsSound = feng.soundController.playSfx('footsteps');
};


feng.controllers.controls.WalkControls.prototype.onPathProgress = function ( prop ) {

  var t = prop.t;
  
  var smoothT = THREE.Math.smoothstep(t, 0, 1);

  var pathTrack = this._pathTrack;

  // update position
  var pathCamera = pathTrack.getCameraAt( smoothT * prop.endU );
  var cameraPosition = pathCamera.position;

  var footstepHeight = Math.sin(prop.footstep) * .5;
  var defaultHeight = feng.controllers.controls.Controls.Default.STANCE_HEIGHT;
  var cameraY = defaultHeight + footstepHeight;

  this.setPosition( cameraPosition.x, cameraY, cameraPosition.z );

  if(!prop.mousewheel) {
  	// update rotation
  	this._cameraRotation = feng.utils.ThreeUtils.getLerpedEuler( this._startRotation, this._endRotation, smoothT, this._cameraRotation );
  	this.setRotation( this._cameraRotation.x, this._cameraRotation.y );
  }
};


feng.controllers.controls.WalkControls.prototype.onPathComplete = function ( nextMode ) {

	if(this._footstepsSound) {
		this._footstepsSound.pause();
	}

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: nextMode
	});
};


feng.controllers.controls.WalkControls.prototype.onInputDown = function ( e ) {

	goog.base(this, 'onInputDown', e);

	if(this._tweener) {
		this._tweener.kill();
	}

	if(this._footstepsSound) {
		this._footstepsSound.pause();
	}
	
	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		mode: feng.controllers.view3d.ModeController.Mode.BROWSE,
		eventToTrigger: e
	});
};goog.provide('feng.controllers.controls.TransitionControls');

goog.require('goog.events');
goog.require('goog.math');
goog.require('feng.controllers.controls.Controls');


/**
 * @constructor
 */
feng.controllers.controls.TransitionControls = function(camera, view3d, domElement){

  goog.base(this, camera, view3d, domElement);

  this._tweener = null;

  this._cameraPosition = new THREE.Vector3(0 ,0, 0);
  this._cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
};
goog.inherits(feng.controllers.controls.TransitionControls, feng.controllers.controls.Controls);


feng.controllers.controls.TransitionControls.prototype.start = function ( ev ) {

	var fromPosition = ev.fromPosition || this.getPosition();
	var toPosition = ev.toPosition;

	var prop = {
		t: 0,
		fromPosition: fromPosition,
		toPosition: toPosition,
		fromFov: ev.fromFov || this.getFov(),
		toFov: ev.toFov || this.getFov(),
		fromTarget: ev.fromTarget || this.getTarget(),
		toTarget: ev.toTarget,
		nextMode: ev.nextMode
	};

	var nextMode = ev.nextMode;
	var nextModeIsDesign = (nextMode === feng.controllers.view3d.ModeController.Mode.DESIGN);

	var dur = goog.math.clamp( 1, 2, goog.math.lerp( 1, 2, fromPosition.distanceTo( toPosition ) / 100 ));
	dur = nextModeIsDesign ? 1.5 : dur;

	this._tweener = TweenMax.to( prop, dur, {
		t: 1,
		'ease': Sine.easeInOut,
		'onUpdate': this.onTransitionUpdate,
		'onUpdateParams': [prop],
		'onUpdateScope': this,
		'onComplete': this.onTransitionComplete,
		'onCompleteParams': [prop],
		'onCompleteScope': this
	});

	// toggle ground plane
	var designPlane = this._view3d.designPlane;
	var skybox = this._view3d.skybox;

	if(nextModeIsDesign) {

		skybox.updateOpacity(1);
		skybox.addToScene();

		TweenMax.to(skybox, dur, {
			opacity: 0,
			'onUpdate': skybox.updateOpacity,
			'onUpdateScope': skybox,
			'onComplete': skybox.removeFromScene,
			'onCompleteScope': skybox
		});

		designPlane.updateOpacity(0);
		designPlane.addToScene();

		TweenMax.to(designPlane, dur, {
			opacity: 1,
			'onUpdate': designPlane.updateOpacity,
			'onUpdateScope': designPlane
		});

		feng.soundController.playSfx('thrust-up');

	}else {

		if(!skybox.isInScene()) {

			skybox.updateOpacity( 1 );
			skybox.addToScene();

			designPlane.updateOpacity( 0 );
			designPlane.removeFromScene();
		}
	}

	//
	TweenMax.to(this._view3d.renderController, dur, {
		globalBrightness: 0,
		'ease': Expo.easeOut
	});

	// toggle sound loops
	if(nextMode === feng.controllers.view3d.ModeController.Mode.CLOSE_UP) {

		feng.soundController.stopMix( this._view3d.sectionId, 1 );
		feng.soundController.fadeLoop( 'closeup', 0, 1, 2, false );

	}else {

		feng.soundController.playMix( this._view3d.sectionId, 6 );
		feng.soundController.fadeLoop( 'closeup', null, 0, 3, true, true );
	}

	//
	this.dispatchEvent({
		type: feng.events.EventType.UPDATE,
		mode: nextMode
	});
};


feng.controllers.controls.TransitionControls.prototype.pause = function ( pause ) {

	var shouldPause = goog.base(this, 'pause', pause);

	if(shouldPause) {

		this._tweener.pause();

	}else {

		this._tweener.resume();
	}
};


feng.controllers.controls.TransitionControls.prototype.onTransitionUpdate = function ( prop ) {

	var t = prop.t;

	var fromPosition = prop.fromPosition;
	var toPosition = prop.toPosition;
	this._cameraPosition = this._cameraPosition.copy( fromPosition ).lerp( toPosition, t );
	this.setPosition( this._cameraPosition );

	var fromTarget = prop.fromTarget;
	var toTarget = prop.toTarget;

	var targetPosition = fromTarget.clone().lerp( toTarget, t );

  	var quaternion = feng.utils.ThreeUtils.getQuaternionByLookAt( this._cameraPosition, targetPosition );
	this._cameraRotation.setFromQuaternion( quaternion );

	this.setRotation( this._cameraRotation.x, this._cameraRotation.y );

	var fov = goog.math.lerp( prop.fromFov, prop.toFov, t );
	this.setFov( fov );
};


feng.controllers.controls.TransitionControls.prototype.onTransitionComplete = function ( prop ) {

	var ev = {
		type: feng.events.EventType.CHANGE,
		mode: prop.nextMode
	};

	this.dispatchEvent( ev );
};goog.provide('feng.controllers.view3d.ModeController');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');
goog.require('goog.object');
goog.require('feng.events');
goog.require('feng.controllers.controls.BrowseControls');
goog.require('feng.controllers.controls.CloseUpControls');
goog.require('feng.controllers.controls.EntryControls');
goog.require('feng.controllers.controls.ExitControls');
goog.require('feng.controllers.controls.DesignControls');
goog.require('feng.controllers.controls.WalkControls');
goog.require('feng.controllers.controls.TransitionControls');


/**
 * @constructor
 */
feng.controllers.view3d.ModeController = function( view3d ){

  goog.base(this);

  this._eventHandler = new goog.events.EventHandler(this);

  this.control = null;

  this._view3d = view3d;
  this._cameraController = this._view3d.cameraController;
  this._renderController = this._view3d.renderController;

  this._browseControls = null;
  this._designControls = null;
  this._walkControls = null;
  this._climbControls = null;
  this._transitionControls = null;

  this._mode = null;

  this._modeControls = {};
};
goog.inherits(feng.controllers.view3d.ModeController, goog.events.EventTarget);


feng.controllers.view3d.ModeController.prototype.init = function(){

	// create mode controls
	this._browseControls = this.createControls( feng.controllers.view3d.ModeController.Mode.BROWSE );
	this._closeUpControls = this.createControls( feng.controllers.view3d.ModeController.Mode.CLOSE_UP );
	this._designControls = this.createControls( feng.controllers.view3d.ModeController.Mode.DESIGN );
	this._entryControls = this.createControls( feng.controllers.view3d.ModeController.Mode.ENTRY );
	this._exitControls = this.createControls( feng.controllers.view3d.ModeController.Mode.EXIT );
	this._walkControls = this.createControls( feng.controllers.view3d.ModeController.Mode.WALK );
	this._transitionControls = this.createControls( feng.controllers.view3d.ModeController.Mode.TRANSITION );

	//
	this.control = this._entryControls;
};


feng.controllers.view3d.ModeController.prototype.activate = function(){

	this._eventHandler.listen( this, feng.events.EventType.CHANGE, this.onModeChange, false, this );

	this.control = (this.control === this._exitControls) ? this._browseControls : this.control;
	
	if(this.control) {
		this.control.enable( true );
	}
};


feng.controllers.view3d.ModeController.prototype.deactivate = function(){

	this._eventHandler.removeAll();

	if(this.control) {
		this.control.enable( false );
	}
};


feng.controllers.view3d.ModeController.prototype.getModeControl = function( mode ){

	return this._modeControls[ mode ];
};


feng.controllers.view3d.ModeController.prototype.getMode = function(){

	return this._mode;
};


feng.controllers.view3d.ModeController.prototype.setMode = function( modeData ){

	var eventData = {
		type: feng.events.EventType.CHANGE
	};

	goog.object.extend( eventData, modeData );

	this.dispatchEvent( eventData );
};


feng.controllers.view3d.ModeController.prototype.createControls = function( mode ){

	var uiElement = this._view3d.hud.domElement;
	var renderElement = this._view3d.domElement;
	var camera = this._cameraController.getCamera( mode );

	var ControlClass;

	switch(mode) {

		case feng.controllers.view3d.ModeController.Mode.BROWSE:
		ControlClass = feng.controllers.controls.BrowseControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.CLOSE_UP:
		ControlClass = feng.controllers.controls.CloseUpControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.DESIGN:
		ControlClass = feng.controllers.controls.DesignControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.ENTRY:
		ControlClass = feng.controllers.controls.EntryControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.EXIT:
		ControlClass = feng.controllers.controls.ExitControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.WALK:
		ControlClass = feng.controllers.controls.WalkControls;
		break;

		case feng.controllers.view3d.ModeController.Mode.TRANSITION:
		ControlClass = feng.controllers.controls.TransitionControls;
		break;
	}

	var controls = new ControlClass( camera, this._view3d, renderElement, uiElement );
	controls.setParentEventTarget( this );

	// register mode controls
	this._modeControls[ mode ] = controls;

	return controls;
};


feng.controllers.view3d.ModeController.prototype.onModeChange = function(e) {
	
	var oldMode = this._mode;
	var newMode = e.mode;
	var nextMode = e.nextMode;

	this._mode = newMode;

	console.log('view3D mode changed from ' + oldMode + ' to ' + newMode);
	
	var oldControl = this.control;
	var newControl = this.getModeControl( this._mode );
	var nextControl = this.getModeControl( nextMode );

	// handle old control
	if(oldControl) {
		oldControl.enable( false );
	}

	// set new control
	this.control = newControl;

	var fromPosition = e.fromPosition || oldControl.getPosition();
	var fromRotation = e.fromRotation || oldControl.getRotation();
	var fromFov = e.fromFov || oldControl.getFov();

	var toPosition = e.toPosition || (nextControl ? nextControl.getPosition() : newControl.getPosition());
	var toRotation = e.toRotation || (nextControl ? nextControl.getRotation() : newControl.getRotation());
	var toFov = e.toFov || (nextControl ? nextControl.getFov() : newControl.getFov());

	this.control.setPosition( fromPosition );
	this.control.setRotation( fromRotation );
	this.control.setFov( fromFov );

	e.fromPosition = fromPosition;
	e.fromRotation = fromRotation;
	e.fromFov = fromFov;
	e.toPosition = toPosition;
	e.toRotation = toRotation;
	e.toFov = toFov;

	switch(this.control) {
		case this._browseControls:
		this.control.enable( true, e.eventToTrigger );
		break;

		case this._closeUpControls:
		this.control.enable( true, e.object );
		break;	

		default:
		this.control.enable( true );
		break;
	}

	this._cameraController.setCamera( this.control.getCamera() );

	// if next mode is set,
	// set and get the next mode controls start values and use that for current controls' end value
	if(nextControl) {

		var shouldUpdateToPosition = false;
		var shouldUpdateToRotation = false;
		var shouldUpdateToFov = false;
		var shouldUpdateToTarget = false;

		switch(nextControl) {
			
			case this._browseControls:
			if(oldControl === this._designControls || oldControl === this._closeUpControls) {
				this._browseControls.setCamera( toRotation );
				shouldUpdateToRotation = true;
				shouldUpdateToTarget = true;
			}
			break;

			case this._exitControls:
			this._exitControls.setCamera( e.gateway );
			shouldUpdateToPosition = true;
			shouldUpdateToRotation = true;
			shouldUpdateToFov = true;
			shouldUpdateToTarget = true;
			break;

			case this._closeUpControls:
			this._closeUpControls.setCamera( e.object );
			shouldUpdateToPosition = true;
			shouldUpdateToRotation = true;
			shouldUpdateToFov = true;
			shouldUpdateToTarget = true;
			break;

			case this._designControls:
			this._designControls.setCamera( this.control.getForwardVector(), e.object );
			shouldUpdateToPosition = true;
			shouldUpdateToRotation = true;
			shouldUpdateToFov = true;
			shouldUpdateToTarget = true;
			break;
		};

		e.toPosition = shouldUpdateToPosition ? nextControl.getPosition() : e.toPosition;
		e.toRotation = shouldUpdateToRotation ? feng.utils.ThreeUtils.getShortestRotation(fromRotation, nextControl.getRotation()) : e.toRotation;
		e.toFov = shouldUpdateToFov ? nextControl.getFov() : e.toFov;
		e.toTarget = shouldUpdateToTarget ? nextControl.getTarget() : e.toTarget;
	}

	switch(this._mode) {
		case feng.controllers.view3d.ModeController.Mode.ENTRY:
			this.control.start();
			break;

		case feng.controllers.view3d.ModeController.Mode.WALK:
		case feng.controllers.view3d.ModeController.Mode.TRANSITION:
			this.control.start( e );
			break;

		default:
			break;
	}

	// update renderer
	this._renderController.updateByMode(this._mode, e.nextMode);
};


feng.controllers.view3d.ModeController.Mode = {
	BROWSE: 'browse', //look around
	CLOSE_UP: 'close_up', //a locked perspective viewing a specific object
	DESIGN: 'design', // isometrix view for ease of positioning/rotating control
	ENTRY: 'entry', //first-time enter a residence
	EXIT: 'exit', //head out of the current view
	WALK: 'walk',	// walk along a path
	TRANSITION: 'transition' // transition between different cameras for the above mode
};goog.provide('feng.views.view3dobject.entities.Refrigerator');

goog.require('feng.models.Preload');
goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * A refrigerator from where the fruits can be collected
 */
feng.views.view3dobject.entities.Refrigerator = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._door = this.object3d;

  this.cameraInDuration = 3000;

  this._cameraZoomTweener = null;
};
goog.inherits(feng.views.view3dobject.entities.Refrigerator, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Refrigerator.prototype.getFruits = function(){

  var fruits = [];

  goog.array.forEach( ['peach', 'pineapple', 'orange', 'apple'], function(name) {

    fruits.push( this._view3d.getView3dObject(name) );
  }, this );

  return fruits;
};


feng.views.view3dobject.entities.Refrigerator.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  // zoom in camera a bit to start picking fruits
  var prop = {
    fov: this.data.camera.fov
  };
  
  this._cameraZoomTweener = TweenMax.to(prop, 1, {
    fov: prop.fov - 20,
    'ease': Quad.easeInOut,
    'onUpdate': this.onCameraZoomUpdate,
    'onUpdateParams': [prop],
    'onUpdateScope': this,
    'onComplete': this.onCameraZoomIn,
    'onCompleteScope': this,
    'onReverseComplete': this.onCameraZoomOut,
    'onReverseCompleteScope': this
  });
};


feng.views.view3dobject.entities.Refrigerator.prototype.onCameraZoomUpdate = function(prop){

  var control = this._view3d.modeController.control;

  control.setFov( prop.fov );
};


feng.views.view3dobject.entities.Refrigerator.prototype.onCameraZoomIn = function(){

  var fruits = this.getFruits();
  
  var arms = this._view3d.arms;

  // animate picking up fruits
  var timeline = new TimelineMax({
    'onComplete': this.onPickedLastFruit,
    'onCompleteScope': this
  });

  goog.array.forEach(fruits, function(fruit) {

    var endOrientation = arms.getWorldOrientation( fruit.name );
    var endPosition = endOrientation.position;
    var endRotation = endOrientation.rotation;
    var startPosition = fruit.object3d.position;
    var startRotation = fruit.object3d.rotation;

    var prop = {
      t: 0
    };

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();

    var tweener = TweenMax.to( prop, 1, {
      t: 1,
      'ease': Sine.easeIn,
      'onUpdate': function() {
        
        position = position.copy(startPosition).lerp(endPosition, prop.t);
        fruit.object3d.position.copy( position );

        rotation = feng.utils.ThreeUtils.getLerpedEuler( startRotation, endRotation, prop.t, rotation );
        fruit.object3d.rotation.copy( rotation );
      },
      'onComplete': this.onPickedFruit,
      'onCompleteParams': [fruit],
      'onCompleteScope': this
    });

    timeline.add( tweener );

  }, this);
};


feng.views.view3dobject.entities.Refrigerator.prototype.onCameraZoomOut = function(){

  this.unlock();
  this.stopInteraction();
};


feng.views.view3dobject.entities.Refrigerator.prototype.onCameraIn = function(){

  goog.base(this, 'onCameraIn');

  TweenMax.to(this._door.rotation, 2, {
    'y': 2.8,
    'ease': Quad.easeInOut
  });

  feng.soundController.playSfx('refrigerator-open');
};


feng.views.view3dobject.entities.Refrigerator.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  TweenMax.to(this._door.rotation, 1, {
    'y': 0,
    'ease': Quad.easeInOut
  });

  TweenMax.delayedCall(.8, function() {
    feng.soundController.playSfx('refrigerator-close');
  });
};


feng.views.view3dobject.entities.Refrigerator.prototype.onPickedFruit = function(fruit){

  var arms = this._view3d.arms;

  arms.addItem( fruit );

  fruit.onPick();
};


feng.views.view3dobject.entities.Refrigerator.prototype.onPickedLastFruit = function(){

  this._cameraZoomTweener.reverse();
};goog.provide('feng.views.view3dobject.DesignPlane');

goog.require('feng.views.view3dobject.View3DObject');

/**
 * @constructor
 * An infinite plane in design mode
 */
feng.views.view3dobject.DesignPlane = function( view3d ){

  var planeGeometry = new THREE.PlaneBufferGeometry( 100000, 100000, 1, 1 );
  var planeMaterial = new THREE.MeshBasicMaterial({
    transparent: true
  });

  this._plane = new THREE.Mesh( planeGeometry, planeMaterial );
  this._plane.name = 'design-plane';
  this._plane.rotation.x = -Math.PI/2;
  this._plane.position.y = -10;

  var data = {
    fog: true
  };

  var object3d = new THREE.Object3D();
  object3d.add( this._plane );

  goog.base( this, object3d, data, view3d );

  this.opacity = 1;
};
goog.inherits(feng.views.view3dobject.DesignPlane, feng.views.view3dobject.View3DObject);


feng.views.view3dobject.DesignPlane.prototype.init = function(){

  goog.base(this, 'init');

  var ground = this._view3d.getView3dObject( 'ground' );

  if(ground) {
    this.object3d.add( ground.object3d );
  }
};


feng.views.view3dobject.DesignPlane.prototype.createTextures = function(){

  var shouldCreate = goog.base(this, 'createTextures');

  if(!shouldCreate) return;

  var size = 128;
  var canvas = goog.dom.createDom('canvas');
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  ctx.fillStyle = "#e7e7e7";
  ctx.fillRect(0, 0, size, size);
  ctx.strokeStyle = "#aaaaaa";
  ctx.strokeRect(0, 0, size, size);

  var texture = new THREE.Texture( canvas );
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(8000, 8000);
  texture.needsUpdate = true;

  this._plane.material.map = texture;
  this._plane.material.needsUpdate = true;
};


feng.views.view3dobject.DesignPlane.prototype.updateOpacity = function( opt_opacity ){

  this.opacity = goog.isNumber(opt_opacity) ? opt_opacity : this.opacity;

  this._plane.material.opacity = this.opacity;
};goog.provide('feng.views.view3dobject.entities.Computer');

goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * The computer in boy's room
 */
feng.views.view3dobject.entities.Computer = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._onDeskTexture = null;
};
goog.inherits(feng.views.view3dobject.entities.Computer, feng.views.view3dobject.MovableObject);


feng.views.view3dobject.entities.Computer.prototype.createTextures = function(){

  goog.base(this, 'createTextures');

  var preload = feng.models.Preload.getInstance();
  var onBedImg = preload.getAsset(this._view3d.sectionId + '.' + this._view3d.id + '.computer-on-desk-texture');
  this._onDeskTexture = new THREE.Texture( onBedImg );
  this._onDeskTexture.needsUpdate = true;

  if(this.hasPicked) {
    this.object3d.material.map = this._onDeskTexture;
  }
};


feng.views.view3dobject.entities.Computer.prototype.disposeTextures = function(){

  this._onDeskTexture.dispose();
  this._onDeskTexture = null;

  this.object3d.material.map = null;

  goog.base(this, 'disposeTextures');
};


feng.views.view3dobject.entities.Computer.prototype.pick = function(){

  goog.base(this, 'pick');

  this.object3d.material.map = this._onDeskTexture;
  this.object3d.material.needsUpdate = true;
};goog.provide('feng.fx.Renderer');

goog.require('goog.array');


/**
 * @constructor
 */
feng.fx.Renderer = function(canvas, scene, camera){

	this._DPR = 1; //window.devicePixelRatio || 1; working weirdly

	// create default renderer
	this._renderer = new THREE.WebGLRenderer( {
		canvas: canvas,
		antialias: false,
		devicePixelRatio: this._DPR
	});

	this._renderer.gammaInput = true;
	this._renderer.gammaOutput = true;
	this._renderer.autoClear = false;
	this._renderer.setClearColor( 0xffffff, 0 );

	// callbacks
	this.onBeforeRender = null;
	this.onBeforeRenderBlur = null;
	this.onBeforeRenderMask = null;

	// postprocessing

	// create passes
	this._renderPass = new THREE.RenderPass( scene );

	this._fxaaPass = new THREE.ShaderPass( THREE.FXAAShader );
	this._fxaaPass.renderToScreen = true;

	this._vignettePass = new THREE.ShaderPass( THREE.VignetteShader );
	this._vignettePass.uniforms['offset'].value = 0.95;
	this.setVignette( 0 );

	this._blurXPass = new THREE.ShaderPass( THREE.TriangleBlurShader, 'texture' );
	this._blurXPass.uniforms[ 'delta' ].value = new THREE.Vector2( 0, 0 );

	this._blurYPass = new THREE.ShaderPass( THREE.TriangleBlurShader, 'texture' );
	this._blurYPass.uniforms[ 'delta' ].value = new THREE.Vector2( 0, 0 );

	this._brightnessContrastPass = new THREE.ShaderPass( THREE.BrightnessContrastShader );

	this._hueSaturationPass = new THREE.ShaderPass( THREE.HueSaturationShader );

	this._bloomPass = new THREE.BloomPass(.20);

	this._globalBrightness = 0;
	this._globalContrast = 0;
	this._baseGlobalBrightness = 0.05;
	this._baseGlobalContrast = 0.05;

	this._globalBrightnessContrastPass = new THREE.ShaderPass( THREE.BrightnessContrastShader );
	this.setGlobalBrightnessContrast( this._globalBrightness, this._globalContrast );

	this._maskPass = new THREE.MaskPass( scene );
	this._maskPass.enabled = false;

	this._clearMaskPass = new THREE.ClearMaskPass();
	this._clearMaskPass.enabled = false;

	// create composers

	// create a custom render target with a stencil buffer
	// the stencil buffer allows for masking to take place
	var renderTargetParameters = {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat,
		stencilBuffer: true
	};

	var res = feng.renderSettings.renderSize;

	var resolution = (new goog.math.Size( res, res )).scale( this._DPR );

	// create default render texture pass
	var renderTarget = new THREE.WebGLRenderTarget( resolution.width, resolution.height, renderTargetParameters );
	renderTarget.generateMipmaps = false;

	this._renderComposer = new THREE.EffectComposer( this._renderer, renderTarget );
	this._renderComposer.addPass( this._renderPass );

	this._renderTexturePass = new THREE.TexturePass( this._renderComposer.renderTarget2 );

	this._renderTextureForMaskingPass = new THREE.TexturePass( this._renderComposer.renderTarget2 );
	this._renderTextureForMaskingPass.enabled = false;

	// create blur texture pass
	var renderSize = feng.renderSettings.renderSize / 2;
	var renderTarget = new THREE.WebGLRenderTarget( renderSize, renderSize, renderTargetParameters );
	renderTarget.generateMipmaps = false;

	this._blurComposer = new THREE.EffectComposer( this._renderer, renderTarget );
	this._blurComposer.addPass( this._renderPass );
	this._blurComposer.addPass( this._blurXPass );
	this._blurComposer.addPass( this._blurYPass );

	this._blurTexturePass = new THREE.TexturePass( this._blurComposer.renderTarget2 );
	this._blurTexturePass.enabled = false;

	// create output
	var renderTarget = new THREE.WebGLRenderTarget( resolution.width, resolution.height, renderTargetParameters );
	renderTarget.generateMipmaps = false;
	
	this._outputComposer = new THREE.EffectComposer( this._renderer, renderTarget );

	this._outputComposer.addPass( this._renderTexturePass );

	this._outputComposer.addPass( this._blurTexturePass );

	this._outputComposer.addPass( this._brightnessContrastPass );

	this._outputComposer.addPass( this._maskPass );
	this._outputComposer.addPass( this._renderTextureForMaskingPass );
	this._outputComposer.addPass( this._clearMaskPass );
	
	this._outputComposer.addPass( this._bloomPass );

	this._outputComposer.addPass( this._hueSaturationPass );

	this._outputComposer.addPass( this._globalBrightnessContrastPass );

	this._outputComposer.addPass( this._vignettePass );

	this._outputComposer.addPass( this._fxaaPass );

	//
	this.setCamera( camera );
};
goog.inherits(feng.fx.Renderer, goog.events.EventTarget);


feng.fx.Renderer.prototype.getRenderer = function(){

	return this._renderer;
};


feng.fx.Renderer.prototype.getPassIndex = function( pass ){

	return goog.array.indexOf(this._outputComposer.passes, pass);
};


feng.fx.Renderer.prototype.setCamera = function( camera ){

	this._renderPass.camera = camera;
	this._maskPass.camera = camera;
};


feng.fx.Renderer.prototype.setBlur = function( x, y ){

	var blurinessX = x || 0;
	var blurinessY = y || 0;

	var blurAmountX = blurinessX / 512;
	var blurAmountY = blurinessY / 512;

	this._blurXPass.uniforms[ 'delta' ].value.x = blurAmountX;
	this._blurYPass.uniforms[ 'delta' ].value.y = blurAmountY;
};


feng.fx.Renderer.prototype.setGlobalBrightnessContrast = function( brightness, contrast ){

	this._globalBrightness = brightness;
	this._globalContrast = contrast;

	this._globalBrightnessContrastPass.uniforms['brightness'].value = this._baseGlobalBrightness + this._globalBrightness;
	this._globalBrightnessContrastPass.uniforms['contrast'].value = this._baseGlobalContrast + this._globalContrast;
};


feng.fx.Renderer.prototype.setBrightness = function( brightness ){

	this._brightnessContrastPass.uniforms['brightness'].value = brightness;
};


feng.fx.Renderer.prototype.setContrast = function( contrast ){

	this._brightnessContrastPass.uniforms['contrast'].value = contrast;
};


feng.fx.Renderer.prototype.setSaturation = function( saturation ){

	this._hueSaturationPass.uniforms['saturation'].value = saturation;
};


feng.fx.Renderer.prototype.setVignette = function( t ){

	// darkness ranges from 0 - 1
	var darkness = goog.math.lerp(0.5, 1, t);

	this._vignettePass.uniforms['darkness'].value = darkness;
};


feng.fx.Renderer.prototype.setSize = function( width, height ){

	this._renderer.setSize( width, height );

	this._fxaaPass.uniforms['resolution'].value.set( 1 / (width * this._DPR), 1 / (height * this._DPR) );
};


feng.fx.Renderer.prototype.render = function(){

	if(this.onBeforeRender) this.onBeforeRender();

	if(this.onBeforeRenderBlur) this.onBeforeRenderBlur();
	
	if(this._blurTexturePass.enabled) {
		this._blurComposer.render();
	}

	if(this.onBeforeRenderMask) this.onBeforeRenderMask();

	this._renderComposer.render();

	this._outputComposer.render();
};goog.provide('feng.fx.Particle');

goog.require('goog.math');


/**
 * @constructor
 */
feng.fx.Particle = function(timeOffset, jiggleFrequency, maxJiggleAmount, pathTrack){

	this._spline = pathTrack.spline;
	this._isClosed = pathTrack.isClosed;

	var radius = 15;
	var offsetX = Math.round( goog.math.uniformRandom(-radius, radius) );
	var offsetY = Math.round( goog.math.uniformRandom(-radius, radius) );
	var offsetZ = Math.round( goog.math.uniformRandom(-radius, radius) );
	this._offset = new THREE.Vector3(offsetX, offsetY, offsetZ);
	
	this._timeOffset = timeOffset;

	this._time = 0;
	this._lastTime = 0;

	this._jiggle = new THREE.Vector3();
	this._jiggleFrequency = jiggleFrequency || 2;
	this._maxJiggleAmount = maxJiggleAmount || 4;
	
	this._position = new THREE.Vector3();

	this.object3d = this.create();
};


feng.fx.Particle.prototype.create = function() {


};


feng.fx.Particle.prototype.getPosition = function() {

	return this._position;
};


feng.fx.Particle.prototype.setPosition = function( position ) {

	this._position.copy( position );
};


feng.fx.Particle.prototype.update = function( u ) {

	var a = Math.abs( Math.sin( u * this._jiggleFrequency * Math.PI ) );
	var jiggleAmount = Math.cos( a * Math.PI ) * this._maxJiggleAmount;
	this._jiggle.set( jiggleAmount, jiggleAmount, jiggleAmount );

	this._lastTime = this._time;
	this._time = (u + this._timeOffset) % 1;
	
	var pos = this._spline.getPointAt( this._time );
	this._position.copy( pos ).add( this._offset ).add( this._jiggle );

	if(!this._isClosed) {
		var opacity = Math.sin( this._time * Math.PI );
		this.object3d.material.opacity = opacity;
	}

	var shouldReset = this._isClosed ? false : (this._time < this._lastTime);

	if(shouldReset) {

		this.setPosition( this._position );
	}
};goog.provide('feng.fx.Leaf');

goog.require('goog.math');
goog.require('feng.fx.Particle');
goog.require('feng.fx.TextureAnimator');


/**
 * @constructor
 */
feng.fx.Leaf = function(timeOffset, leaf, minSize, maxSize, jiggleFrequency, maxJiggleAmount, pathTrack){

	var preload = feng.models.Preload.getInstance();
	var animSpriteImg = preload.getAsset( 'global.leaf.' + leaf );
	var animTexture = new THREE.Texture( animSpriteImg );

	var numTiles = animSpriteImg.width / 128;
	var frameDuration = goog.math.randomInt( 40 ) + 40;
	this._textureAnimator = new feng.fx.TextureAnimator( animTexture, numTiles, 1, numTiles, frameDuration );

	this._material = new THREE.SpriteMaterial({
		map: leaf ? this._textureAnimator.texture : null,
		transparent: true,
		side: THREE.DoubleSide,
		rotation: Math.random() * Math.PI
	});

	//
	var minSize = minSize || 2;
	var maxSize = minSize + 2;
	this._size = Math.round( goog.math.uniformRandom(minSize, maxSize) );
	this._leaf = leaf;

	//
	this._rotationVelocityX = goog.math.uniformRandom(0.02, 0.04);
	this._rotationVelocityY = goog.math.uniformRandom(0.10, 0.14);

	//
	goog.base(this, timeOffset, jiggleFrequency, maxJiggleAmount, pathTrack);

	this._textureAnimator.start();
};
goog.inherits(feng.fx.Leaf, feng.fx.Particle);


feng.fx.Leaf.prototype.create = function() {

	var scale = goog.math.uniformRandom(3, 6);
	var rotation = THREE.Math.degToRad( Math.random() * 360 );

	var leaf = new THREE.Sprite( this._material );
	leaf.scale.set( scale, scale, scale );

	return leaf;
};


feng.fx.Leaf.prototype.update = function( u ) {

	goog.base(this, 'update', u);
	
	this.object3d.position.copy( this._position );
};goog.provide('feng.fx.Trail');

goog.require('goog.math');
goog.require('feng.fx.Particle');


/**
 * @constructor
 */
feng.fx.Trail = function(timeOffset, color, length, blendMode, jiggleFrequency, maxJiggleAmount, pathTrack){

	//this._numSegments = length + Math.round( goog.math.uniformRandom(-length * .5, length * .5) );
	this._numSegments = 10;

	this._blendMode = blendMode || THREE.AdditiveBlending;

	this._color = ( new THREE.Color() ).set( color );
	this._baseHSL = this._color.getHSL();
	
	this._geometry = new THREE.PlaneGeometry(30, 30, 1, this._numSegments);

	this._material = this.createMaterial( color );

	this._positions = [];
	this._rotations = [];

	this._width = goog.math.uniformRandom(.5, 1);

	//
	goog.base(this, timeOffset, jiggleFrequency, maxJiggleAmount, pathTrack);
};
goog.inherits(feng.fx.Trail, feng.fx.Particle);


feng.fx.Trail.prototype.create = function() {

	var mesh = new THREE.Mesh(this._geometry, this._material);
	mesh.dynamic = true;

	for (var i = 0; i < this._numSegments*2; i++)
	{
	  this._positions[i] = 0;
	  this._rotations[i] = 0;
	}

	return mesh;
};


feng.fx.Trail.prototype.setPosition = function( position ) {

	goog.base(this, 'setPosition', position);


};


feng.fx.Trail.prototype.createMaterial = function( color ) {

	if(!feng.fx.Trail.DefaultTexture) {

	  var size = 32;

	  // create canvas
	  var canvas = document.createElement('canvas');
	  canvas.width = size;
	  canvas.height = size;

	  // get context
	  var context = canvas.getContext('2d');

	  // draw gradient
	  var gradient = context.createLinearGradient( 0, 0, 0, size );
	  gradient.addColorStop(0, '#000000');
	  gradient.addColorStop(.5, '#555555');
	  gradient.addColorStop(1, '#000000'); 
	  context.fillStyle = gradient;
	  var hs = size/2;
	  context.moveTo(0, hs);
	  context.arcTo(hs, 0, size, hs, 10);
	  context.arcTo(hs, size, 0, hs, 10);
	  context.fill();

    var texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

	  feng.fx.Trail.DefaultTexture = texture;
	}

	this._baseHSL.h = goog.math.uniformRandom(this._baseHSL.h - .1, this._baseHSL.h + .1);
	this._baseHSL.l = goog.math.uniformRandom(this._baseHSL.l - .5, this._baseHSL.l);

	this._color.setHSL( this._baseHSL.h, this._baseHSL.s, this._baseHSL.l );

  var material = new THREE.MeshBasicMaterial({
    color: this._color,
    map: feng.fx.Trail.DefaultTexture,
    fog: false,
    side: THREE.DoubleSide,
    wireframe: true,
    //transparent: true,
    //blending: this._blendMode,
    depthTest: false
  });

	return material;
};


feng.fx.Trail.prototype.update = function( u ) {

	goog.base(this, 'update', u);

  this._positions.pop();
  this._positions.pop();
  this._positions.pop();
  
  this._rotations.pop();
  this._rotations.pop();
  this._rotations.pop();
  
  var position = this.getPosition();

  this._positions.unshift( position.x, position.y, position.z );
  this._rotations.unshift( this._width, this._width, 0 );
  
  for (var i = 0; i < this._numSegments; i++) {

    var v1 = this._geometry.vertices[i*2];
    var v2 = this._geometry.vertices[i*2+1];
    
    var ix = i*3;
    var iy = i*3+1;
    var iz = i*3+2;

    v1.x = this._positions[ix] + this._rotations[ix];
    v1.y = this._positions[iy] + this._rotations[iy];
    v1.z = this._positions[iz] + this._rotations[iz];
    v2.x = this._positions[ix] - this._rotations[ix];
    v2.y = this._positions[iy] - this._rotations[iy];
    v2.z = this._positions[iz] - this._rotations[iz];
  }
  
  this._geometry.verticesNeedUpdate = true;
};


feng.fx.Trail.DefaultTexture = null;goog.provide('feng.fx.EnergyFlow');

goog.require('feng.fx.PathTrack');
goog.require('feng.fx.Trail');
goog.require('feng.fx.Leaf');


/**
 * @constructor
 */
feng.fx.EnergyFlow = function(controlPoints, isClosed, preset, debug){

	this._preset = preset || feng.fx.EnergyFlow.Preset.DEFAULT;

	this._start = 0;
	this._timeDiff = 0;
	this._duration = this._preset.duration;
	this._particles = [];
	this._numTrails = this._preset.numTrails;
	this._numLeaves = this._preset.numLeaves;
	this._numParticles = this._numTrails + this._numLeaves;

	this._particles = [];

	//
	var offset = 0;
	var color = '#000000';

	goog.base(this, controlPoints, offset, isClosed, color, debug);
};
goog.inherits(feng.fx.EnergyFlow, feng.fx.PathTrack);


feng.fx.EnergyFlow.prototype.create = function(controlPoints, offset, isClosed, color){

	goog.base(this, 'create', controlPoints, offset, isClosed, color);

	// create particles
	var i, l = this._numParticles;
	for(i = 0; i < l; i++) {

		var isLeaf = (i % (this._numParticles / this._numLeaves) === 0);
		var timeOffset = i / this._numParticles;
		
		var particle = isLeaf ? new feng.fx.Leaf(
			timeOffset,
			this._preset.leaf,
			this._preset.leafMinSize,
			this._preset.leafMaxSize,
			this._preset.jiggleFrequency,
			this._preset.maxJiggleAmount,
			this)
		:
		new feng.fx.Trail(
			timeOffset,
			this._preset.color,
			this._preset.length,
			this._preset.blendMode,
			this._preset.jiggleFrequency,
			this._preset.maxJiggleAmount,
			this);

		particle.setPosition( particle.getPosition() );

		this.add( particle.object3d );

		this._particles.push( particle );
	}
};


feng.fx.EnergyFlow.prototype.activate = function(){
	
	goog.fx.anim.registerAnimation( this );

	this._start = goog.now();

	// update particles
	var i, l = this._numParticles;
	for(i = 0; i < l; i++) {
		var particle = this._particles[i];
		particle.update( 0 );
		particle.setPosition( particle.getPosition() );
	}

	goog.events.listen(window, 'focus', this.onWindowFocus, false, this);
	goog.events.listen(window, 'blur', this.onWindowBlur, false, this);
};


feng.fx.EnergyFlow.prototype.deactivate = function(){

	goog.fx.anim.unregisterAnimation( this );

	goog.events.unlisten(window, 'focus', this.onWindowFocus, false, this);
	goog.events.unlisten(window, 'blur', this.onWindowBlur, false, this);
};


feng.fx.EnergyFlow.prototype.fadeIn = function( duration ){

	this.activate();

	var materials = goog.array.map(this.children, function(child) {
		return child.material;
	});

	var duration = goog.isNumber(duration) ? duration : .5;

	TweenMax.fromTo(materials, duration, {
		'opacity': 0
	}, {
		'opacity': 1
	});
};


feng.fx.EnergyFlow.prototype.fadeOut = function( duration ){

	var materials = goog.array.map(this.children, function(child) {
		return child.material;
	});

	var duration = goog.isNumber(duration) ? duration : .5;

	TweenMax.to(materials, duration, {
		'opacity': 0,
		'onComplete': this.deactivate,
		'onCompleteScope': this
	});
};


feng.fx.EnergyFlow.prototype.onAnimationFrame = function( now ){

	// calculate u
	var diff = goog.now() - this._start;
	var u = ( diff % this._duration ) / this._duration;

	// update particles
	var i, l = this._numParticles;
	for(i = 0; i < l; i++) {
		this._particles[i].update( u );
	}
};


feng.fx.EnergyFlow.prototype.onWindowFocus = function( e ){

	goog.fx.anim.registerAnimation( this );

	this._start = goog.now() - this._timeDiff;
};


feng.fx.EnergyFlow.prototype.onWindowBlur = function( e ){

	goog.fx.anim.unregisterAnimation( this );

	this._timeDiff = goog.now() - this._start;
};


feng.fx.EnergyFlow.Preset = {
	DEFAULT: {
		numTrails: 80,
		numLeaves: 20,
		leaf: null,
		leafMinSize: 0,
		leafMaxSize: 0,
		color: '#48D1CC',
		duration: 20000,
		length: 20,
		blendMode: THREE.AdditiveBlending,
		jiggleFrequency: 2,
		maxJiggleAmount: 4 
	},
	JI: {
		numTrails: 50,
		numLeaves: 10,
		leaf: 'ji',
		leafMinSize: 2,
		leafMaxSize: 4,
		color: '#25DDFF',
		duration: 20000,
		length: 10,//80,
		blendMode: THREE.AdditiveBlending,
		jiggleFrequency: 2,
		maxJiggleAmount: 4 
	},
	SHA: {
		numTrails: 80,
		numLeaves: 10,
		leaf: 'sha',
		leafMinSize: 2,
		leafMaxSize: 4,
		color: '#E49230',
		duration: 8000,
		length: 20,
		blendMode: THREE.AdditiveBlending,
		jiggleFrequency: 2,
		maxJiggleAmount: 4 
	},
	YIN: {
		numTrails: 80,
		numLeaves: 20,
		leaf: 'yin',
		leafMinSize: 2,
		leafMaxSize: 4,
		color: '#00B936',
		duration: 20000,
		length: 20,
		blendMode: THREE.AdditiveBlending,
		jiggleFrequency: 2,
		maxJiggleAmount: 4 
	},
	YANG: {
		numTrails: 80,
		numLeaves: 20,
		leaf: 'yang',
		leafMinSize: 2,
		leafMaxSize: 4,
		color: '#EF3B00',
		duration: 20000,
		length: 20,
		blendMode: THREE.AdditiveBlending,
		jiggleFrequency: 2,
		maxJiggleAmount: 4 
	}
};goog.provide('feng.controllers.view3d.RenderController');

goog.require('goog.events.EventTarget');


/**
 * @constructor
 */
feng.controllers.view3d.RenderController = function( view3d ){

  goog.base(this);

  this._view3d = view3d;

  this._renderer = this._view3d.renderer;
  this._renderer.onBeforeRender = goog.bind(this.onBeforeRender, this);
  this._renderer.onBeforeRenderBlur = goog.bind(this.onBeforeRenderBlur, this);
  this._renderer.onBeforeRenderMask = goog.bind(this.onBeforeRenderMask, this);

  this._maskedObject = null;

  //
  this._maxBlur = 20;
  this._minBrightness = -.20;
  this._minContrast = -.35;
  this._minVignette = 1;
  this._maxVignette = 3;

  this.blur = 0;
  this.brightness = 0;
  this.globalBrightness = 0;
  this.globalContrast = 0;
  this.contrast = 0;
  this.saturation = 0;
  this.vignette = this._minVignette;

  this._closeUpTweener = TweenMax.fromTo(this, .5, {
  	blur: 0,
  	brightness: 0,
  	contrast: 0
  }, {
  	blur: this._maxBlur,
  	brightness: this._minBrightness,
  	contrast: this._minContrast,
  	'ease': Quad.easeInOut,
  	'paused': true,
  	'onStart': this.onCloseUpStart,
  	'onStartScope': this,
  	'onReverseComplete': this.onCloseUpComplete,
  	'onReverseCompleteScope': this
  });

  this._vignetteTweener = TweenMax.fromTo(this, 1, {
  	vignette: this._minVignette
  }, {
  	vignette: this._maxVignette,
  	'paused': true
  });

  this._brightnessTweener = TweenMax.fromTo(this, .5, {
  	brightness: 0,
  	contrast: 0,
  	blur: this.blur,
  	saturation: 0
  }, {
  	brightness: -.65,
  	contrast: -.2,
  	blur: 6,
  	saturation: -.65,
  	'ease': Quad.easeInOut,
  	'paused': true,
  	'onStart': this.onBlurInStart,
  	'onStartScope': this,
  	'onReverseComplete': this.onBlurOutComplete,
  	'onReverseCompleteScope': this
  });
};
goog.inherits(feng.controllers.view3d.RenderController, goog.events.EventTarget);


feng.controllers.view3d.RenderController.prototype.updateByMode = function(mode, nextMode, progress) {

	var progress = progress || 0;

	var modeToCloseUp = (mode === feng.controllers.view3d.ModeController.Mode.CLOSE_UP || nextMode === feng.controllers.view3d.ModeController.Mode.CLOSE_UP);
	var modeToDesign = (mode === feng.controllers.view3d.ModeController.Mode.DESIGN || nextMode === feng.controllers.view3d.ModeController.Mode.DESIGN);

	var notCloseUp = (mode !== feng.controllers.view3d.ModeController.Mode.CLOSE_UP && nextMode !== feng.controllers.view3d.ModeController.Mode.CLOSE_UP);
	var notDesign = (mode !== feng.controllers.view3d.ModeController.Mode.DESIGN && nextMode !== feng.controllers.view3d.ModeController.Mode.DESIGN);

	if(modeToCloseUp) {

		var modeControl;

		if(mode === feng.controllers.view3d.ModeController.Mode.CLOSE_UP) {

			modeControl = this._view3d.modeController.getModeControl( mode );

		}else {
			modeControl = this._view3d.modeController.getModeControl( nextMode );
		}

		this._maskedObject = modeControl._activeObject;

		if(!this._closeUpTweener.isActive() && this.blur < this._maxBlur) {
			this._closeUpTweener.play();
		}
	}

	if(modeToCloseUp || modeToDesign) {

		if(!this._vignetteTweener.isActive() && this.vignette < this._maxVignette) {
			this._vignetteTweener.play();
		}
	}

	if(notCloseUp) {

		if(!this._closeUpTweener.reversed() && this.blur > 0) {
			this._closeUpTweener.reverse();
		}
	}

	if(notCloseUp && notDesign) {

		if(!this._vignetteTweener.reversed() && this.vignette > this._minVignette) {
			this._vignetteTweener.reverse();
		}
	}
};


feng.controllers.view3d.RenderController.prototype.updateByPause = function( pause ) {

	if(pause) {

		if(this._brightnessTweener.isActive()) {
			this._brightnessTweener.play();
		}else {
			this._brightnessTweener.restart();
		}

	}else {

		this._brightnessTweener.reverse();
	}
};


feng.controllers.view3d.RenderController.prototype.onCloseUpStart = function() {

	this._renderer._maskPass.enabled = true;
	this._renderer._renderTextureForMaskingPass.enabled = true;
	this._renderer._clearMaskPass.enabled = true;

	this.onBlurInStart();

	this._renderer.render();
};


feng.controllers.view3d.RenderController.prototype.onCloseUpComplete = function() {

	this._maskedObject = null;

	this._renderer._maskPass.enabled = false;
	this._renderer._renderTextureForMaskingPass.enabled = false;
	this._renderer._clearMaskPass.enabled = false;

	this.onBlurOutComplete();

	this._renderer.render();
};


feng.controllers.view3d.RenderController.prototype.onBlurInStart = function() {

	this._renderer._blurTexturePass.enabled = true;
};


feng.controllers.view3d.RenderController.prototype.onBlurOutComplete = function() {

	if(this.blur === 0) {
		this._renderer._blurTexturePass.enabled = false;
	}
};


feng.controllers.view3d.RenderController.prototype.onBeforeRender = function() {

	this._renderer.setBlur( this.blur, this.blur );
	this._renderer.setBrightness( this.brightness );
	this._renderer.setContrast( this.contrast );
	this._renderer.setGlobalBrightnessContrast( this.globalBrightness, this.globalContrast );
	this._renderer.setSaturation( this.saturation );
	this._renderer.setVignette( this.vignette );
};


feng.controllers.view3d.RenderController.prototype.onBeforeRenderBlur = function() {

	var maskedObject = this._maskedObject;
	var view3dObjects = this._view3d.view3dObjects;

	for(var name in view3dObjects) {

		view3dObjects[ name ].enableRender();
	}

	this._view3d.fx.onBeforeRenderBlur();

	if(maskedObject) {
		
		maskedObject.disableRender();
		this._view3d.arms.disableRender();
	}
};


feng.controllers.view3d.RenderController.prototype.onBeforeRenderMask = function() {

	if(!this._maskedObject) return;

	var maskedObject = this._maskedObject;
	var view3dObjects = this._view3d.view3dObjects;

	for(var name in view3dObjects) {

		view3dObjects[ name ].disableRender();
	}

	this._view3d.fx.onBeforeRenderMask();

	maskedObject.enableRender();

	// force arms to render
	this._view3d.arms.enableRender();
	
	// force skybox to render with wall when enabled
	if(this._view3d.getView3dObject('wall').isRenderEnabled) {
		this._view3d.skybox.enableRender();
	}

	if(maskedObject.hasPicked && maskedObject.dropParent && maskedObject.dropParent.view3dObject) {
		maskedObject.dropParent.view3dObject.enableRender();
	}
};goog.provide('feng.views.view3dobject.entities.GlassBowl');

goog.require('feng.views.view3dobject.TipObject');

/**
 * @constructor
 * The glass bowl where the goldfish lives
 */
feng.views.view3dobject.entities.GlassBowl = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._fish = null;
  
  this._fishPosition = new THREE.Vector3();
  this._fishRotation = new THREE.Euler();

  this._fishMoveTweener = null;
  this._fishBreathTweener = null;

  this._hasDroppedFish = false;
};
goog.inherits(feng.views.view3dobject.entities.GlassBowl, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.GlassBowl.prototype.init = function(){

  goog.base(this, 'init');

  var water = this.object3d.getObjectByName('fish-bowl-water');
  water.material.reflectivity = 0.65;
  water.material.opacity = 0.25;
  water.material.transparent = true;
  water.material.shininess = 10;
  water.material.envMap = this._view3d.createCubeMap( this.getCenter(), 512 );
  water.material.needsUpdate = true;

  //
  this._fish = this._view3d.getView3dObject('goldfish');

  var transform = new THREE.Matrix4().makeRotationY( Math.PI/2 );
  this._fish.object3d.geometry.applyMatrix( transform );

  this._fish.removeFromScene();
};


feng.views.view3dobject.entities.GlassBowl.prototype.onCameraIn = function(){

  goog.base(this, 'onCameraIn');

  if(this._hasDroppedFish) {

    this.tweenFish();
  }
};


feng.views.view3dobject.entities.GlassBowl.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  if(this._hasDroppedFish) {

    if(this._fishMoveTweener) {
      this._fishMoveTweener.kill();
    }

    if(this._fishBreathTweener) {
      this._fishBreathTweener.kill();
    }
  }
};


feng.views.view3dobject.entities.GlassBowl.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  if(!this._hasDroppedFish) {

    this._fish.addToScene( this.object3d );

    TweenMax.fromTo(this._fish.object3d.position, 4, {
      'y': this._fish.object3d.position.y + 30
    }, {
      'y': this._fish.object3d.position.y,
      'immediateRender': true,
      'ease': Expo.easeOut,
      'onComplete': this.onFishDropped,
      'onCompleteScope': this
    });
  }
};


feng.views.view3dobject.entities.GlassBowl.prototype.tweenFish = function(){

  var duration = Math.random() * 3 + 2;
  var delay = Math.random() * 1;
  var radX = 3;
  var radZ = 3;

  var fish = this._fish.object3d;

  var fromPosition = fish.position.clone();
  var toPosition = fish.position.clone().set( goog.math.uniformRandom( -radX, radX ), 0, goog.math.uniformRandom( -radZ, radZ ) );

  var fromRotation = fish.rotation.clone();

  var lookAtQ = feng.utils.ThreeUtils.getQuaternionByLookAt( fromPosition, toPosition );
  var toRotation = fish.rotation.clone().setFromQuaternion( lookAtQ );

  var prop = {
    t: 0,
    fromPosition: fromPosition,
    toPosition: toPosition,
    fromRotation: fromRotation,
    toRotation: toRotation
  };

  this._fishMoveTweener = TweenMax.to( prop, duration, {
    t: 1,
    'delay': delay,
    'onUpdate': this.updateFish,
    'onUpdateParams': [prop],
    'onUpdateScope': this,
    'onComplete': this.tweenFish,
    'onCompleteScope': this
  });

  if(!this._fishBreathTweener || !this._fishBreathTweener.isActive()) {
    this._fishBreathTweener = TweenMax.fromTo( fish.scale, .85, {
      'x': 1
    }, {
      'x': 1.1,
      'yoyo': true,
      'repeat': -1
    });
  }
};


feng.views.view3dobject.entities.GlassBowl.prototype.updateFish = function( prop ){

  var t = prop.t;
  var position = this._fishPosition.copy( prop.fromPosition ).lerp( prop.toPosition, t );
  var rotation = feng.utils.ThreeUtils.getLerpedEuler( prop.fromRotation, prop.toRotation, t, this._fishRotation );

  this._fish.object3d.position.copy( position );
  this._fish.object3d.rotation.copy( rotation );
};


feng.views.view3dobject.entities.GlassBowl.prototype.onFishDropped = function(){

  this.tweenFish();

  this.unlock();
  this.stopInteraction();

  this._hasDroppedFish = true;
};goog.provide('feng.views.view3dobject.entities.Closet');

goog.require('goog.fx.Dragger');
goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * The bathroom closet storing jars to be re-arranged
 */
feng.views.view3dobject.entities.Closet = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._door = this.object3d.getObjectByName('closet-door');

  this._jarsPullOutTweener = null;

  this._anchorX = -41;

  this._anchors = [
    new THREE.Vector3(this._anchorX, 85.489, -40.44),
    new THREE.Vector3(this._anchorX, 74.602, -39.45),
    new THREE.Vector3(this._anchorX, 74.602, -44.72),
    new THREE.Vector3(this._anchorX, 74.602, -50.22),
    new THREE.Vector3(this._anchorX, 74.602, -55.70),
    new THREE.Vector3(this._anchorX, 63.715, -39.70),
    new THREE.Vector3(this._anchorX, 63.715, -46.23),
    new THREE.Vector3(this._anchorX, 63.715, -52.54),
    new THREE.Vector3(this._anchorX, 63.715, -59.22),
    new THREE.Vector3(this._anchorX, 63.715, -65.45)
  ];

  this._anchorFlags = [
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false
  ];

  this._anchorPlane = null;
  this._dragPlane = null;

  this._dummyJar = null;

  this._dummyJars = [];

  this._dragStartPosition = new THREE.Vector3();

  this._cameraZoomTweener = null;

  this._mousePosition = {
    x: 0,
    y: 0
  };

  this._cameraTweenerProp = {
    fov: 0,
    updateDragOffset: false
  };

  this._swingProgress = 0;
  this._positionProgress = 0;

  // dragger to drag the item
  this._dragger = new goog.fx.Dragger( this._view3d.domElement );
  this._dragger.defaultAction = goog.nullFunction;
};
goog.inherits(feng.views.view3dobject.entities.Closet, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Closet.prototype.init = function(){

  goog.base(this, 'init');

  // calculate pulled out position
  var center = this.getCenter();
  var pulledOutPosition = center.clone().setX( center.x + 20 );

  // create plane
  this._dragPlane = new THREE.Mesh( new THREE.PlaneBufferGeometry( 50, 50, 1, 1 ) );
  this._dragPlane.visible = false;
  this._dragPlane.rotation.y = Math.PI/2;
  this._dragPlane.position.copy( pulledOutPosition );

  this._anchorPlane = new THREE.Mesh( new THREE.PlaneBufferGeometry( 50, 50, 1, 1 ) );
  this._anchorPlane.visible = false;
  this._anchorPlane.rotation.y = Math.PI/2;
  this._anchorPlane.position.copy( center ).setX( this._anchorX );

  // get jars
  var jarNames = [
    'jar-1',
    'jar-2',
    'jar-3',
    'jar-4',
    'jar-5',
    'jar-6',
    'jar-7',
    'jar-8',
    'jar-9',
    'jar-10'
  ];

  var swingValues = [.15, .1, -.08, .3, -.07, .1, .05, .2, .05, -.05];

  var pulledOutPositions = {
    'jar-1': {y: 72, z: -36},
    'jar-2': {y: 64, z: -40},
    'jar-3': {y: 72, z: -65},
    'jar-4': {y: 80, z: -58},
    'jar-5': {y: 82, z: -40},
    'jar-6': {y: 64, z: -48},
    'jar-7': {y: 65, z: -60},
    'jar-8': {y: 68, z: -63},
    'jar-9': {y: 64, z: -55},
    'jar-10': {y: 82, z: -67}
  };

  var pulledOutRotations = {
    'jar-1': {x: -0.12, y: 0.04, z: 0.20},
    'jar-2': {x: 1.00, y: 0.06, z: -0.46},
    'jar-3': {x: 0.58, y: 0.08, z: -0.42},
    'jar-4': {x: -0.50, y: -0.64, z: -0.82},
    'jar-5': {x: 0.8, y: 0.06, z: -0.54},
    'jar-6': {x: 0.38, y: -0.18, z: -0.34},
    'jar-7': {x: 0.56, y: -0.82, z: 0.06},
    'jar-8': {x: -0.04, y: 1.00, z: -0.14},
    'jar-9': {x: -0.52, y: -0.08, z: -0.14},
    'jar-10': {x: -0.64, y: -1.08, z: -0.38}
  };

  var jarTweeners = goog.array.map(jarNames, function(jarName, index) {

    // create dummyJars for dragging
    var jar = this.object3d.getObjectByName(jarName).view3dObject;
    var dummyJar = jar.object3d.clone();
    dummyJar.visible = false;
    this._dummyJars.push( dummyJar );

    dummyJar.userData.jar = jar;
    dummyJar.userData.isAnchored = false;
    dummyJar.userData.anchor = null;

    dummyJar.userData.orientation = {
      positionX: dummyJar.position.x,
      positionY: dummyJar.position.y,
      positionZ: dummyJar.position.z,
      rotationX: dummyJar.rotation.x,
      rotationY: dummyJar.rotation.y,
      rotationZ: dummyJar.rotation.z
    };

    dummyJar.userData.dragOffset = new THREE.Vector3();
    dummyJar.userData.swingMultiplier = 1;
    dummyJar.userData.swing = swingValues[index];
    dummyJar.userData.rotationMultiplier = 1;

    var jarTweener = TweenMax.to(dummyJar.userData.orientation, .65, {
      positionX: pulledOutPosition.x,
      positionY: pulledOutPositions[jar.name].y,
      positionZ: pulledOutPositions[jar.name].z,
      rotationX: pulledOutRotations[jar.name].x,
      rotationY: pulledOutRotations[jar.name].y,
      rotationZ: pulledOutRotations[jar.name].z
    });

    return jarTweener;

  }, this);

  this._jarsPullOutTweener = new TimelineMax({
    'paused': true,
    'onComplete': this.onJarsPulledComplete,
    'onCompleteScope': this
  });

  this._jarsPullOutTweener.add( jarTweeners, '+=0', 'start', .15 );
};


feng.views.view3dobject.entities.Closet.prototype.updateRaycaster = function(){

  var mouseX = ( this._mousePosition.x / feng.viewportSize.width ) * 2 - 1;
  var mouseY = - ( this._mousePosition.y / feng.viewportSize.height ) * 2 + 1;
  var camera = this._view3d.cameraController.activeCamera;
  var cameraPosition = this._view3d.modeController.control.getPosition();

  var vector = new THREE.Vector3( mouseX, mouseY, 0.5 ).unproject( camera );
  var direction = vector.sub( cameraPosition ).normalize();

  var raycaster = feng.utils.ThreeUtils.raycaster;
  raycaster.set( cameraPosition, direction );

  return raycaster;
};


feng.views.view3dobject.entities.Closet.prototype.getRaycastPositionOnPlane = function( plane ){

  var raycaster = feng.utils.ThreeUtils.raycaster;
  var intersects = raycaster.intersectObject( plane );

  return (intersects.length > 0 ? intersects[0].point : null);
};


feng.views.view3dobject.entities.Closet.prototype.detectNearestAnchor = function(){

  var raycastPosition = this.getRaycastPositionOnPlane( this._anchorPlane );

  if(raycastPosition) {

    var i, l = this._anchors.length;
    var shortestDistance = 4;
    var nearestAnchor;

    for(i = 0; i < l; i++) {

      var anchor = this._anchors[i];

      if(this._anchorFlags[i]) continue;

      var distance = raycastPosition.distanceTo( anchor );

      if(distance < shortestDistance) {

        shortestDistance = distance;
        nearestAnchor = anchor;
      }
    }

    return nearestAnchor;

  }else {

    return null;
  }
};


feng.views.view3dobject.entities.Closet.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  // add extra meshes to scene for calculation
  var scene = this._view3d.scene;

  scene.add( this._dragPlane );
  scene.add( this._anchorPlane );

  goog.array.forEach(this._dummyJars, function(dummyJar) {
    scene.add( dummyJar );
  });

  // pull out jars
  this._jarsPullOutTweener.restart();

  TweenMax.to(this, 4, {
    _swingProgress: 1,
    _positionProgress: 1
  });

  TweenMax.ticker.addEventListener("tick", this.update, this);
};


feng.views.view3dobject.entities.Closet.prototype.stopInteraction = function(){

  goog.base(this, 'stopInteraction');

  // remove extra meshes to scene for calculation
  var scene = this._view3d.scene;

  scene.remove( this._dragPlane );
  scene.remove( this._anchorPlane );

  goog.array.forEach(this._dummyJars, function(dummyJar) {
    scene.remove( dummyJar );
  });

  TweenMax.to(this, .5, {
    _swingProgress: 0,
    _positionProgress: 0
  });

  TweenMax.ticker.removeEventListener("tick", this.update, this);
};


feng.views.view3dobject.entities.Closet.prototype.updateDragOffsetOfJar = function(){

  var raycastPosition = this.getRaycastPositionOnPlane( this._dragPlane );

  this._dummyJar.userData.dragOffset.subVectors( raycastPosition, this._dragStartPosition );
};


feng.views.view3dobject.entities.Closet.prototype.update = function(){

  var now = goog.now();

  var i, l = this._dummyJars.length;

  for(i = 0; i < l; i++) {

    var dummyJar = this._dummyJars[i];

    var userData = dummyJar.userData;

    var swing = userData.swing;
    var swingMultiplier = userData.swingMultiplier;
    var rotationMultiplier = userData.rotationMultiplier;
    var dragOffset = userData.dragOffset;
    var orientation = userData.orientation;

    dummyJar.position.x = orientation.positionX;
    dummyJar.position.y = orientation.positionY + Math.sin( now * 0.001 * swing ) * this._swingProgress * swingMultiplier * this._positionProgress + dragOffset.y;
    dummyJar.position.z = orientation.positionZ + Math.cos( now * 0.001 * swing ) * this._swingProgress * swingMultiplier * this._positionProgress + dragOffset.z;
  
    dummyJar.rotation.x = orientation.rotationX * rotationMultiplier;
    dummyJar.rotation.y = orientation.rotationY * rotationMultiplier;
    dummyJar.rotation.z = orientation.rotationZ * rotationMultiplier;

    var jarTargetPosition = userData.isAnchored ? userData.anchor : dummyJar.position;

    var jar = dummyJar.userData.jar;
    jar.object3d.position.x += ( jarTargetPosition.x - jar.object3d.position.x ) * .2;
    jar.object3d.position.y += ( jarTargetPosition.y - jar.object3d.position.y ) * .2;
    jar.object3d.position.z += ( jarTargetPosition.z - jar.object3d.position.z ) * .2;

    jar.object3d.rotation.copy( dummyJar.rotation );
  }
};


feng.views.view3dobject.entities.Closet.prototype.onCameraIn = function(){

  this.cameraInDuration = 2000;

  goog.base(this, 'onCameraIn');

  TweenMax.to(this._door.rotation, 1.5, {
    'y': -2.8,
    'ease': Quad.easeInOut
  });

  //feng.soundController.playSfx('refrigerator-open');
};


feng.views.view3dobject.entities.Closet.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  TweenMax.to(this._door.rotation, 1.5, {
    'y': 0,
    'ease': Quad.easeInOut
  });

  TweenMax.delayedCall(.8, function() {
    //feng.soundController.playSfx('refrigerator-close');
  });
};


feng.views.view3dobject.entities.Closet.prototype.onJarsPulledComplete = function(){

  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.START, this.onDragStart, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.DRAG, this.onDrag, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.END, this.onDragEnd, false, this);
};


feng.views.view3dobject.entities.Closet.prototype.onDragStart = function(e){

  var camera = this._view3d.cameraController.activeCamera;
  var viewSize = this._view3d.viewSize;
  var intersects = feng.utils.ThreeUtils.getObjectsBy2DPosition( e.clientX, e.clientY, this._dummyJars, camera, viewSize );

  if ( intersects.length > 0 ) {

    var dummyJar = intersects[0].object;

    if(dummyJar.userData.isAnchored) {

      this._dummyJar = null;
      return;

    }else {

      this._dummyJar = dummyJar;
    }

    this._mousePosition.x = e.clientX;
    this._mousePosition.y = e.clientY;

    TweenMax.to(this._dummyJar.userData, .5, {
      swingMultiplier: 0,
      rotationMultiplier: 0
    });

    // set drag start position of jar
    this.updateRaycaster();

    var raycastPosition = this.getRaycastPositionOnPlane( this._dragPlane );

    var relPosition = feng.utils.ThreeUtils.getLocalPositionOfWorld( this._dummyJar, raycastPosition );
    var actualPositionX = relPosition.x + this._dummyJar.userData.orientation.positionX;
    var actualPositionY = relPosition.y + this._dummyJar.userData.orientation.positionY;
    var actualPositionZ = relPosition.z + this._dummyJar.userData.orientation.positionZ;

    this._dragStartPosition.set( actualPositionX, actualPositionY, actualPositionZ );

    // update drag offset of jar
    this.updateDragOffsetOfJar();

    // zoom in on first drag occurs
    if(!this._cameraZoomTweener) {

      this._cameraTweenerProp.fov = this.specialCameraSettings.fov;
      this._cameraTweenerProp.updateDragOffset = true;

      this._cameraZoomTweener = TweenMax.to(this._cameraTweenerProp, 1, {
        fov: this.specialCameraSettings.fov - 12,
        'ease': Strong.easeOut,
        'onUpdate': this.onCameraZoomUpdate,
        'onUpdateParams': [this._cameraTweenerProp],
        'onUpdateScope': this
      });
    }
  }
};


feng.views.view3dobject.entities.Closet.prototype.onDragEnd = function(e){

  if(!this._dummyJar) {
    return;
  }

  TweenMax.to(this._dummyJar.userData.dragOffset, .5, {
    'x': 0,
    'y': 0,
    'z': 0
  });

  var isAnchored = this._dummyJar.userData.isAnchored;

  TweenMax.to(this._dummyJar.userData, .5, {
    swingMultiplier: isAnchored ? 0 : 1,
    rotationMultiplier: isAnchored ? 0 : 1,
  });

  this._dummyJar = null;

  // update anchor flags
  goog.array.forEach(this._dummyJars, function(dummyJar) {
    var anchorIndex = goog.array.indexOf(this._anchors, dummyJar.userData.anchor);
    this._anchorFlags[ anchorIndex ] = dummyJar.userData.isAnchored;
  }, this);

  // zoom out when complete
  var notAnchoredJar = goog.array.find(this._dummyJars, function(dummyJar) {
    return (dummyJar.userData.isAnchored === false);
  });

  if(!notAnchoredJar) {

    var control = this._view3d.modeController.control;

    this._cameraTweenerProp.fov = control.getFov();
    this._cameraTweenerProp.updateDragOffset = false;

    this._cameraZoomTweener = TweenMax.to(this._cameraTweenerProp, 1, {
      fov: this.specialCameraSettings.fov,
      'onUpdate': this.onCameraZoomUpdate,
      'onUpdateParams': [this._cameraTweenerProp],
      'onUpdateScope': this,
      'onComplete': this.onCameraZoomOutComplete,
      'onCompleteScope': this
    });
  }
};


feng.views.view3dobject.entities.Closet.prototype.onDrag = function(e){

  if(!this._dummyJar) {
    return;
  }

  this._mousePosition.x = e.clientX;
  this._mousePosition.y = e.clientY;

  this.updateRaycaster();

  this.updateDragOffsetOfJar();

  var anchor = this.detectNearestAnchor();
  this._dummyJar.userData.isAnchored = anchor ? true : false;
  this._dummyJar.userData.anchor = anchor;
};


feng.views.view3dobject.entities.Closet.prototype.onCameraZoomUpdate = function(prop){

  var control = this._view3d.modeController.control;

  control.setFov( prop.fov );

  if(prop.updateDragOffset && this._dummyJar) {
    this.updateDragOffsetOfJar();
  }
};


feng.views.view3dobject.entities.Closet.prototype.onCameraZoomOutComplete = function(){

  this.unlock();
  this.stopInteraction();
};goog.provide('feng.views.view3dobject.entities.Wallpaper');

goog.require('feng.views.view3dobject.TipObject');

/**
 * @constructor
 * The animated wallpaper for home office computer
 */
feng.views.view3dobject.entities.Wallpaper = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._video = goog.dom.createDom('video', {
    'preload': 'metadata',
    'loop': true
  }, [
    goog.dom.createDom('source', {
      'src': feng.Config['assetsPath'] + 'video/wallpaper.mp4',
      'type': 'video/mp4; codecs="avc1.42E01E"'
    }),
    goog.dom.createDom('source', {
      'src': feng.Config['assetsPath'] + 'video/wallpaper.ogv',
      'type': 'video/ogg; codecs="theora, vorbis"'
    })
  ]);

  this._videoCanvas = null;
  this._videoCanvasContext = null;

  this._videoTexture = null;
};
goog.inherits(feng.views.view3dobject.entities.Wallpaper, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Wallpaper.prototype.activate = function(){

  goog.base(this, 'activate');

  goog.events.listen( this._video, 'canplay', this.onVideoUpdate, false, this );
};


feng.views.view3dobject.entities.Wallpaper.prototype.deactivate = function(){

  goog.base(this, 'deactivate');

  goog.events.unlisten( this._video, 'canplay', this.onVideoUpdate, false, this );
};


feng.views.view3dobject.entities.Wallpaper.prototype.createTextures = function(){

  goog.base(this, 'createTextures');

  this._videoCanvas = goog.dom.createDom('canvas', {
    'width': 480,
    'height': 268
  });

  this._videoCanvasContext = this._videoCanvas.getContext( '2d' );
  this._videoCanvasContext.fillStyle = '#000000';
  this._videoCanvasContext.fillRect( 0, 0, this._videoCanvas.width, this._videoCanvas.height );

  this._videoTexture = new THREE.Texture( this._videoCanvas );
  this._videoTexture.minFilter = THREE.LinearFilter;
  this._videoTexture.magFilter = THREE.LinearFilter;

  this.object3d.material.map = this._videoTexture;

  this._video.load();
};


feng.views.view3dobject.entities.Wallpaper.prototype.onVideoUpdate = function(){

  this._videoCanvasContext.drawImage( this._video, 0, 0 );
  this._videoTexture.needsUpdate = true;
};


feng.views.view3dobject.entities.Wallpaper.prototype.onCameraIn = function(){

  goog.base(this, 'onCameraIn');

  this._video.play();

  TweenMax.ticker.addEventListener("tick", this.onVideoUpdate, this);
};


feng.views.view3dobject.entities.Wallpaper.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  this._video.pause();

  TweenMax.ticker.removeEventListener("tick", this.onVideoUpdate, this);
};goog.provide('feng.views.view3dobject.GatewayObject');

goog.require('feng.views.view3dobject.InteractiveObject');

/**
 * @constructor
 * An interactive object that leads to another view3d
 */
feng.views.view3dobject.GatewayObject = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this.viewId = this.data.viewid;
  this.gatewayId = this.data.gatewayid;

	this.toHome = this.data.toHome;  
  this.isEntry = this.data.isEntry;
  this.isStairs = this.data.isStairs;

  this.origin = this.data.origin;
  this.origin.position.y = feng.controllers.controls.Controls.Default.STANCE_HEIGHT;

  this._startRotationY = this.object3d.rotation.y;

  this._openSound = feng.soundController.getSfx( this.data.openSound );
  this._closeSound = feng.soundController.getSfx( this.data.closeSound );

	this._openTweener = TweenMax.fromTo( this.object3d.rotation, 2.5, {
		'y': this._startRotationY
	}, {
		'y': this.getEndRotationY(),
		'paused': true,
		'onComplete': this.onOpenComplete,
		'onCompleteScope': this
	});

	this._delayToPause = new goog.async.Delay( this.pause, 250, this );
};
goog.inherits(feng.views.view3dobject.GatewayObject, feng.views.view3dobject.InteractiveObject);


feng.views.view3dobject.GatewayObject.prototype.shouldGoHome = function() {

	return (this.data.toHome === true);
};


feng.views.view3dobject.GatewayObject.prototype.getEndRotationY = function() {

	var direction = this.data.inversed ? -1 : 1;
	var rotation = (this._startRotationY + goog.math.toRadians( -90 * direction ));

	return rotation;
};


feng.views.view3dobject.GatewayObject.prototype.open = function( skipPause ) {

	this._openTweener.updateTo({
		'y': this.getEndRotationY()
	}, true);

	this._openTweener.restart();

	if( !skipPause ) {

		this._delayToPause.start();
	}
};


feng.views.view3dobject.GatewayObject.prototype.close = function() {

	TweenMax.to( this.object3d.rotation, 2, {
		'y': this._startRotationY,
		'ease': Strong.easeIn
	});

	this._delayToPause.stop();
};


feng.views.view3dobject.GatewayObject.prototype.resume = function() {

	this._openTweener.resume();
};


feng.views.view3dobject.GatewayObject.prototype.pause = function() {

	this._openTweener.pause();

	this.dispatchEvent( feng.events.EventType.PAUSE );
};


feng.views.view3dobject.GatewayObject.prototype.playOpenSound = function() {

	if(this._openSound) {
		this._openSound.play();
	}

	if(this._closeSound) {
		this._closeSound.stop();
	}
};


feng.views.view3dobject.GatewayObject.prototype.playCloseSound = function() {

	if(this._closeSound) {
		this._closeSound.play();
	}

	if(this._openSound) {
		this._openSound.stop();
	}
};


feng.views.view3dobject.GatewayObject.prototype.onOpenComplete = function(e) {

	this.dispatchEvent( feng.events.EventType.COMPLETE );
};goog.provide('feng.views.view3dobject.entities.FruitPlate');

goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * A fruit plate that will contain fruits
 */
feng.views.view3dobject.entities.FruitPlate = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._fruits = {
    'apple': false,
    'orange': false,
    'pineapple': false,
    'peach': false
  };
};
goog.inherits(feng.views.view3dobject.entities.FruitPlate, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.FruitPlate.prototype.dropFruit = function( fruitId ){

  if(this._fruits[ fruitId ]) {

    return;

  }else {

    this._fruits[ fruitId ] = true;
  }

  var fruit = this._view3d.getView3dObject( fruitId );

  // animate drop
  var arms = this._view3d.arms;
  arms.removeItem( fruit );

  this.object3d.add( fruit.object3d );

  var startOrientation = arms.getWorldOrientation( fruitId );
  var worldPosition = startOrientation.position;
  var worldRotation = startOrientation.rotation;

  var startPosition = feng.utils.ThreeUtils.getLocalPositionOfWorld( this.object3d, worldPosition );
  var startRotation = feng.utils.ThreeUtils.getLocalRotationOfWorld( this.object3d, worldRotation );

  var endOrientation = feng.views.view3dobject.entities.FruitPlate.Orientations[ fruitId ];

  var endPosition = endOrientation.position.clone().setY( endOrientation.position.y + 10 );
  var endRotation = endOrientation.rotation;

  var prop = {
    t: 0
  };

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();

  TweenMax.to( prop, .8, {
    t: 1,
    'immediateRender': true,
    'ease': Sine.easeInOut,
    'onUpdate': function() {
      
      position = position.copy(startPosition).lerp(endPosition, prop.t);
      fruit.object3d.position.copy( position );

      rotation = feng.utils.ThreeUtils.getLerpedEuler( startRotation, endRotation, prop.t, rotation );
      fruit.object3d.rotation.copy( rotation );
    },
    'onUpdateScope': this
  });

  TweenMax.to( fruit.object3d.position, .8, {
    'y': endOrientation.position.y,
    'delay': 1,
    'ease': Bounce.easeOut,
    'onComplete': this.onFruitDropped,
    'onCompleteScope': this
  });
};


feng.views.view3dobject.entities.FruitPlate.prototype.onFruitDropped = function(){

  // unlock if all fruits are dropped
  var isDone = this._fruits['apple'] && this._fruits['orange'] && this._fruits['pineapple'] && this._fruits['peach'];

  if(isDone) {
    this.unlock();
    this.stopInteraction();
  }
};


feng.views.view3dobject.entities.FruitPlate.Orientations = {
  'apple': {
    position: new THREE.Vector3(-113.86, 52.80, -69.91),
    rotation: new THREE.Euler(0.00, -0.67, 0.00)
  },
  'orange': {
    position: new THREE.Vector3(-118.57, 52.17, -70.48),
    rotation: new THREE.Euler(0.00, 0.96, 0.00)
  },
  'pineapple': {
    position: new THREE.Vector3(-118.35, 56.99, -63.23),
    rotation: new THREE.Euler(0.40, 0.00, 0.00)
  },
  'peach': {
    position: new THREE.Vector3(-112.30, 52.04, -65.70),
    rotation: new THREE.Euler(0.00, -0.49, 0.00)
  }
};goog.provide('feng.views.view3dobject.Arms');

goog.require('feng.views.view3dobject.InteractiveObject');
goog.require('feng.views.view3dobject.MovableObject');

/**
 * @constructor
 * A placeholder of temporarily possessed items in view3d
 */
feng.views.view3dobject.Arms = function( view3d ){

  var object3d = new THREE.Object3D();
  object3d.name = 'arms';

  // a dummy object3d for generating world orientation
  this._orientationTester = new THREE.Object3D();
  object3d.add( this._orientationTester );

  var data = {};

  goog.base(this, object3d, data, view3d);

  this._items = [];

  this.addToScene();
};
goog.inherits(feng.views.view3dobject.Arms, feng.views.view3dobject.InteractiveObject);


feng.views.view3dobject.Arms.prototype.getWorldOrientation = function( id, opt_pos, opt_rot ){

  var localOrientation = feng.views.view3dobject.Arms.Orientations[ id ];

  var worldOrientation = {
    position: feng.utils.ThreeUtils.getWorldPositionOfLocal( this.object3d, localOrientation.position, opt_pos ),
    rotation: feng.utils.ThreeUtils.getWorldRotationOfLocal( this.object3d, localOrientation.rotation, opt_rot )
  };

  return worldOrientation;
};


feng.views.view3dobject.Arms.prototype.hasObject = function(){

  return (this.object3d.children.length > 1);
};


feng.views.view3dobject.Arms.prototype.containsObject = function( view3dObject ){

  return goog.array.contains( this.object3d.children, view3dObject.object3d );
};


feng.views.view3dobject.Arms.prototype.addItem = function( view3dObject ){

  goog.array.insert( this._items, view3dObject );

  var object3d = view3dObject.object3d;

  this.object3d.add( object3d );

  var objectOrientation = feng.views.view3dobject.Arms.Orientations[ view3dObject.name ];
  object3d.position.copy( objectOrientation.position );
  object3d.rotation.copy( objectOrientation.rotation );

  // activate drop button if a movable object is added
  if(view3dObject instanceof feng.views.view3dobject.MovableObject) {

    this._view3d.hud.dropButton.activate( view3dObject );
  }

  this._item = view3dObject;

  console.log( 'collected by arms: ' + view3dObject.name );
};


feng.views.view3dobject.Arms.prototype.removeItem = function( view3dObject ){

  goog.array.remove( this._items, view3dObject );

  var object3d = view3dObject.object3d;

  this.object3d.remove( object3d );

  // deactivate drop button if a movable object is removed
  if(view3dObject instanceof feng.views.view3dobject.MovableObject) {

    this._view3d.hud.dropButton.deactivate();
  }

  this._item = null;

  console.log( 'removed from arms: ' + view3dObject.name );
};


feng.views.view3dobject.Arms.prototype.update = function( position, rotation ){

  this.object3d.rotation.copy( rotation );
  this.object3d.position.copy( position ).setY( feng.controllers.controls.Controls.Default.ARM_HEIGHT );
  this.object3d.translateZ( -10 );
};


feng.views.view3dobject.Arms.Orientations = {
  'apple': {
    position: new THREE.Vector3(0.47, 6.10, -4.36),
    rotation: new THREE.Euler(-0.26, 0.16, 0.02)
  },
  'orange': {
    position: new THREE.Vector3(4.90, 4.31, -2.08),
    rotation: new THREE.Euler(0.70, 0.26, -0.50)
  },
  'pineapple': {
    position: new THREE.Vector3(-4.73, 6.62, -0.80),
    rotation: new THREE.Euler(0.12, -0.16, 0.14)
  },
  'peach': {
    position: new THREE.Vector3(0.69, 4.53, -0.42),
    rotation: new THREE.Euler(0.70, 0.08, -0.60)
  },
  'dining-chair': {
    position: new THREE.Vector3(5, -25, -20),
    rotation: new THREE.Euler(0, 0, 0.17)
  },
  'bear': {
    position: new THREE.Vector3(0.47, 0, -5),
    rotation: new THREE.Euler(-0.26, 3.49, 0.02)
  },
  'computer': {
    position: new THREE.Vector3(0.47, -22, -12),
    rotation: new THREE.Euler(-0.26, 3.49, 0.02)
  },
  'swivel-chair': {
    position: new THREE.Vector3(10, -30, -40),
    rotation: new THREE.Euler(0, 3.49, -0.5)
  },
  'setsquare': {
    position: new THREE.Vector3(0.47, -2, -10),
    rotation: new THREE.Euler(-0.78, -1.57, 0.02)
  },
  'knife': {
    position: new THREE.Vector3(0, 10, -2),
    rotation: new THREE.Euler(1.4, -0.6, -0.50)
  },
  'handheld': {
    position: new THREE.Vector3(0, 7.5, -2),
    rotation: new THREE.Euler(0.2, -1.57, 0)
  }
};goog.provide('feng.views.view3dfx.SelectEffect');

goog.require('goog.fx.anim.Animated');


/**
 * @constructor
 */
feng.views.view3dfx.SelectEffect = function(){

	THREE.Object3D.call( this );

	// create texture
	var canvas = document.createElement('canvas');
	canvas.width = canvas.height = 32;

	var context = canvas.getContext('2d');
	var centerX = canvas.width / 2;
	var centerY = canvas.height / 2;
	var radius = 12;

	context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
	context.fillStyle = 'rgba(255, 255, 255, 1)';
	context.fill();

	var texture = new THREE.Texture( canvas );
	texture.needsUpdate = true;

	// shader attributes
	var dotAttributes = {

	     alpha: { 'type': 'f', 'value': [] }
	};

	for( var i = 0; i < 12; i++ ) {

	     dotAttributes['alpha']['value'][ i ] = .1 + Math.random() * (.9 - .1);
	}

	var lineAttributes = {

		alpha: { 'type': 'f', 'value': null }
    };

	var lineAlphas = new Float32Array( 60 );
           
    for( var i = 0; i < 60; i++ ) {
  
		lineAlphas[ i ] = 0 + Math.random() * (.25 - 0);
    }

	// shader uniforms
	this._uniforms = {
        'color': { 'type': "c", 'value': new THREE.Color( 0xffffff ) },
        'texture': { 'type': 't', 'value': texture },
        'time': { 'type': "f", 'value': 0 },
        'pulse': { 'type': "f", 'value': 1 },
        'globalAlpha': { 'type': "f", 'value': 0 }
    };

	// shader materials
	var dotMaterial = new THREE.ShaderMaterial( {
		'uniforms':       this._uniforms,
		'attributes':     dotAttributes,
		'vertexShader':   feng.shaders.getShader( 'dotsVertexShader' ),
		'fragmentShader': feng.shaders.getShader( 'dotsFragmentShader' ),
		'blending': THREE.AdditiveBlending,
		'depthTest': false,
		'transparent': true
	});

	var lineMaterial = new THREE.ShaderMaterial( {
		'uniforms':       this._uniforms,
		'attributes':     lineAttributes,
		'vertexShader':   feng.shaders.getShader( 'linesVertexShader' ),
		'fragmentShader': feng.shaders.getShader( 'linesFragmentShader' ),
		'blending': THREE.AdditiveBlending,
		'depthTest': false,
		'transparent': true
	});

	// create geometry
	var dotsGeometry = new THREE.IcosahedronGeometry(1, 0);

	var dots = new THREE.PointCloud(dotsGeometry, dotMaterial);
    this.add( dots );

    var lineGeometry = (new THREE.WireframeHelper(dots)).geometry;
    lineGeometry.addAttribute( 'alpha', new THREE.BufferAttribute( lineAlphas, 1 ) );

	var lines = new THREE.Line( lineGeometry, lineMaterial, THREE.LinePieces );
    this.add( lines );

    // tweener
    this._animateInTweener = null;
    this._animateOutTweener = null;

    this._animTarget = new goog.fx.anim.Animated();
    this._animTarget.onAnimationFrame = goog.bind(this.onAnimationFrame, this);

    //
    this._object = null;
};
goog.inherits(feng.views.view3dfx.SelectEffect, THREE.Object3D);


feng.views.view3dfx.SelectEffect.prototype.activate = function() {

	this._uniforms['globalAlpha']['value'] = 0;
	goog.fx.anim.registerAnimation( this._animTarget );
};


feng.views.view3dfx.SelectEffect.prototype.deactivate = function() {

	this._uniforms['globalAlpha']['value'] = 0;
	goog.fx.anim.unregisterAnimation( this._animTarget );
};


feng.views.view3dfx.SelectEffect.prototype.animateIn = function( object ) {

	if(this._object === object) {
		
		return;

	}else {

		this._object = object;
	}

	var boundingSphere = this._object.getBoundingSphere();

	var position = boundingSphere.center;
	var scale = boundingSphere.radius;

	this.position.copy( position );

	if(this._animateOutTweener) {
		this._animateOutTweener.kill();
	}

	this._animateInTweener = TweenMax.fromTo(this.scale, 2, {
		'x': scale * .5,
		'y': scale * .5,
		'z': scale * .5
	}, {
		'x': scale,
		'y': scale,
		'z': scale,
		'ease': Elastic.easeOut,
		'onStart': this.activate,
		'onStartScope': this
	});

	TweenMax.to(this._uniforms.globalAlpha, 2, {
		'value': 1,
		'ease': Elastic.easeOut
	});
};


feng.views.view3dfx.SelectEffect.prototype.animateOut = function( delay ) {

	if(this._animateOutTweener && this._animateOutTweener.isActive()) {
		return;
	}

	this._object = null;

	var scale = this.scale.x * .5;

	this._animateOutTweener = TweenMax.to(this.scale, .5, {
		'x': scale,
		'y': scale,
		'z': scale,
		'delay': delay || 0,
		'ease': Strong.easeOut,
		'onComplete': this.deactivate,
		'onCompleteScope': this
	});

	TweenMax.to(this._uniforms.globalAlpha, .5, {
		'value': 0,
		'delay': delay || 0,
		'ease': Strong.easeOut
	});
};


feng.views.view3dfx.SelectEffect.prototype.onAnimationFrame = function(now) {

	this.rotation.x = now * 0.0005;
	this.rotation.y = now * 0.0002;

	this._uniforms['time']['value'] = Math.sin(now * 0.001) * .5 + .5;
    this._uniforms['pulse']['value'] = goog.math.lerp(.8, 1, Math.sin(now * 0.001) * .5 + .5);
};goog.provide('feng.views.view3dfx.ClickEffect');


/**
 * @constructor
 */
feng.views.view3dfx.ClickEffect = function(){

	var geometry = new THREE.PlaneBufferGeometry( 10, 10 );

	var canvas = goog.dom.createDom('canvas');
	canvas.width = canvas.height = 128;

	var context = canvas.getContext('2d');
	var centerX = canvas.width / 2;
	var centerY = canvas.height / 2;

	context.beginPath();
	context.arc(centerX, centerY, 40, 0, 2 * Math.PI, false);
	context.lineWidth = 30;
	context.strokeStyle = 'rgba(255, 255, 255, .1)';
	context.stroke();
	context.closePath();

	context.beginPath();
	context.arc(centerX, centerY, 30, 0, 2 * Math.PI, false);
	context.lineWidth = 6;
	context.strokeStyle = 'rgba(255, 255, 255, .2)';
	context.stroke();
	context.closePath();

	var texture = new THREE.Texture( canvas );
	texture.needsUpdate = true;

	var material = new THREE.MeshBasicMaterial({
		'map': texture,
		'side': THREE.DoubleSide,
		'fog': false,
		'transparent': true,
		'blending': THREE.AdditiveBlending,
		'depthTest': false
	});

  THREE.Mesh.call( this, geometry, material );

  this._lookAtPosition = new THREE.Vector3();

	TweenMax.set(this.material, {
		'opacity': 0
	});
};
goog.inherits(feng.views.view3dfx.ClickEffect, THREE.Mesh);


feng.views.view3dfx.ClickEffect.prototype.play = function( position, normal ) {

	this.position.copy( position );

	this._lookAtPosition.addVectors( normal, position );
	this.lookAt( this._lookAtPosition );

	TweenMax.fromTo(this.scale, .8, {
		'x': .5,
		'y': .5
	}, {
		'x': 1.5,
		'y': 1.5,
		'ease': Expo.easeOut
	});

	TweenMax.fromTo(this.material, .8, {
		'opacity': 1
	}, {
		'opacity': 0,
		'ease': Expo.easeOut
	});
};goog.provide('feng.fx.LeafSprite');

goog.require('feng.fx.TextureAnimator');


/**
 * @constructor
 */
feng.fx.LeafSprite = function( texture ){

	var material = new THREE.SpriteMaterial({
		'map': texture,
		'transparent': true,
		'side': THREE.DoubleSide,
		'sizeAttenuation': true,
		'alphaTest': 1,
		'fog': true
	});

	THREE.Sprite.call( this, material );

	var numTiles = texture.image.width / 128;
	var frameDuration = goog.math.randomInt( 40 ) + 40;
	this._textureAnimator = new feng.fx.TextureAnimator( texture, numTiles, 1, numTiles, frameDuration );

	this._baseScale = 1;

	this.randomize();
};
goog.inherits(feng.fx.LeafSprite, THREE.Sprite);


feng.fx.LeafSprite.prototype.start = function(){

	this._textureAnimator.start();
};


feng.fx.LeafSprite.prototype.stop = function(){

	this._textureAnimator.stop();
};


feng.fx.LeafSprite.prototype.setScale = function( scaleMultiplier ){

	var finalScale = this._baseScale * scaleMultiplier;

	this.scale.set( finalScale, finalScale, finalScale );
};


feng.fx.LeafSprite.prototype.randomize = function(){

	this._baseScale = goog.math.uniformRandom(0.5, 2);

	this.setScale( 1 );

	var rotation = Math.random() * Math.PI * 2;
	this.material.rotation = rotation;
};goog.provide('feng.fx.Leaves');

goog.require('goog.events.EventHandler');
goog.require('goog.async.Delay');
goog.require('goog.fx.anim.Animated');
goog.require('feng.fx.LeafSprite');
goog.require('feng.models.Preload');

/**
 * @constructor
 * based on http://stemkoski.github.io/Three.js/Particles.html
 */
feng.fx.Leaves = function( eventTarget, color ){

  goog.base(this);

  this.isActive = false;

  this._eventHandler = new goog.events.EventHandler(this);
  this._eventTarget = eventTarget;

  this._color = color;

  this._activeObject = null;

  // create shared textures if not
	var preload = feng.models.Preload.getInstance();

	goog.object.forEach(feng.fx.Leaves.LeafType, function(value, key) {

		if(!feng.fx.Leaves.Texture[key]) {
			var img = preload.getAsset( 'global.leaf.' + value );
			var texture = new THREE.Texture( img );
			feng.fx.Leaves.Texture[key] = texture;
		}
	});

	// create leaves
	var textureIds = [];
	var numLeaves;

	switch(this._color) {
		case feng.fx.Leaves.Color.GREEN:
		textureIds.push('GREEN_1', 'GREEN_2');
		numLeaves = 16;
		break;

		case feng.fx.Leaves.Color.YELLOW:
		textureIds.push('YELLOW_1', 'YELLOW_2');
		numLeaves = 10;
		break;
	}

	for(var i = 0; i < numLeaves; i++) {
		
		var textureId = textureIds[ goog.math.randomInt(textureIds.length) ];
		var randTexture = feng.fx.Leaves.Texture[ textureId ];
		var leaf = new feng.fx.LeafSprite( randTexture.clone() );

		this.add( leaf );
	}

	this._attributes = {
		startPosition: [],
		randomness: []
	};

	this._leafScaleMultiplier = 1;

	this._leafScaleTweener = TweenMax.fromTo(this, 2, {
		_leafScaleMultiplier: 0
	}, {
		_leafScaleMultiplier: 1,
		'paused': true,
		'onUpdate': this.updateLeafScale,
		'onUpdateScope': this,
		'onReverseComplete': this.deactivate,
		'onReverseCompleteScope': this
	});

	this._startTime = 0;

	this._speedFactor = (this._color === feng.fx.Leaves.Color.GREEN) ? 0.001 : 0.002;

	this._animated = new goog.fx.anim.Animated();
	this._animated.onAnimationFrame = goog.bind( this.onAnimationFrame, this );

	this._animateOutDelay = new goog.async.Delay( this.animateOut, 2000, this );
};
goog.inherits(feng.fx.Leaves, THREE.Object3D);


feng.fx.Leaves.prototype.activate = function(){

	this.isActive = true;

	this._eventHandler.listen( this._activeObject.tip, feng.events.EventType.UNLOCK, this.onUnlock, false, this );
};


feng.fx.Leaves.prototype.deactivate = function(){

	var leaves = this.children;

	goog.array.forEach(leaves, function(leaf) {
		leaf.stop();
	});

	goog.fx.anim.unregisterAnimation( this._animated );

	this._eventHandler.removeAll();

	this._animateOutDelay.stop();

	this._activeObject = null;

	this.isActive = false;
};


feng.fx.Leaves.prototype.animateIn = function( tipObject ){

	if(this._activeObject === tipObject) {
		
		return;

	}else {

		this._activeObject = tipObject;
	}

	this._animateOutDelay.stop();

	// calculate object radius
	var boundingSphere = tipObject.getBoundingSphere();
	var radius = Math.max( 15, boundingSphere.radius );

	this.position.copy( boundingSphere.center );

	// arrange leaves
	var leaves = this.children;

	this._attributes.startPosition = [];
	this._attributes.randomness = [];

	goog.array.forEach(leaves, function(leaf) {

		leaf.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

		// for a spherical shell:
		leaf.position.setLength( radius * (Math.random() * 0.1 + 0.9) );

		this._attributes.startPosition.push( leaf.position.clone() );
		this._attributes.randomness.push( Math.random() );

		leaf.randomize();
		leaf.start();

	}, this);

	// scale up leaves
	this._leafScaleTweener.restart();
	this.updateLeafScale();

	// kick off the animation loop
	this._startTime = goog.now();

	goog.fx.anim.registerAnimation( this._animated );

	this.activate();
};


feng.fx.Leaves.prototype.animateOut = function( hasDelay ){

	if(this._leafScaleTweener.reversed() || !this.isActive) {
		return;
	}

	if(hasDelay) {

		this._animateOutDelay.start();

	}else {

		// scale down leaves
		this._leafScaleTweener.reverse();
	}
};


feng.fx.Leaves.prototype.updateLeafScale = function(){

	var leaves = this.children;

	var i, l = leaves.length;
	for(i = 0; i < l; i++) {
		leaves[i].setScale( this._leafScaleMultiplier );
	}
};


feng.fx.Leaves.prototype.onUnlock = function(e){

	this._eventTarget.dispatchEvent({
		type: feng.events.EventType.UNLOCK,
		activeObject: this._activeObject
	});
};


feng.fx.Leaves.prototype.onAnimationFrame = function(now){

	var time = (now - this._startTime) * this._speedFactor;
	
	for ( var c = 0; c < this.children.length; c ++ ) {

		var leaf = this.children[ c ];

		// pulse away/towards center
		// individual rates of movement
		var a = this._attributes.randomness[c] + 1;

		var pulseFactor = (Math.sin(a * time) + 1) / 2;

		if(this._color === feng.fx.Leaves.Color.GREEN) {

			pulseFactor = goog.math.lerp( 0.8, 1, pulseFactor );

		}else if(this._color === feng.fx.Leaves.Color.YELLOW) {

			pulseFactor = goog.math.lerp( 0.8, 2, pulseFactor );
		}

		var startPosition = this._attributes.startPosition[c];
		leaf.position.x = startPosition.x * pulseFactor;
		leaf.position.y = startPosition.y * pulseFactor;
		leaf.position.z = startPosition.z * pulseFactor;
	}

	// rotate the entire group
	this.rotation.y = time * 0.75;
};


feng.fx.Leaves.Color = {
	GREEN: 'green',
	YELLOW: 'yellow'
};


feng.fx.Leaves.LeafType = {
	'GREEN_1': 'green-1',
	'GREEN_2': 'green-2',
	'YELLOW_1': 'yellow-1',
	'YELLOW_2': 'yellow-2'
};


feng.fx.Leaves.Texture = {
	'GREEN_1': null,
	'GREEN_2': null,
	'YELLOW_1': null,
	'YELLOW_2': null
};goog.provide('feng.views.view3dfx.FX');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('feng.events');
goog.require('feng.views.view3dfx.ClickEffect');
goog.require('feng.views.view3dfx.SelectEffect');
goog.require('feng.fx.Leaves');

/**
 * @constructor
 */
feng.views.view3dfx.FX = function(){

  goog.base(this);

  this._eventHandler = new goog.events.EventHandler(this);
  this._eventTarget = new goog.events.EventTarget();

  this.clickEffect = new feng.views.view3dfx.ClickEffect();
  this.add( this.clickEffect );

  this.selectEffect = new feng.views.view3dfx.SelectEffect();
  this.add( this.selectEffect );

  this.greenLeaves = new feng.fx.Leaves( this._eventTarget, feng.fx.Leaves.Color.GREEN );
  this.add( this.greenLeaves );

  this.yellowLeaves = new feng.fx.Leaves( this._eventTarget, feng.fx.Leaves.Color.YELLOW );
  this.add( this.yellowLeaves );
};
goog.inherits(feng.views.view3dfx.FX, THREE.Object3D);


feng.views.view3dfx.FX.prototype.activate = function() {

  this._eventHandler.listen( this._eventTarget, feng.events.EventType.UNLOCK, this.onUnlock, false, this );
};


feng.views.view3dfx.FX.prototype.deactivate = function() {

  this.greenLeaves.deactivate();
  this.yellowLeaves.deactivate();

  this._eventHandler.removeAll();
};


feng.views.view3dfx.FX.prototype.onBeforeRenderBlur = function() {

	this.clickEffect.visible = true;
	this.selectEffect.visible = true;
	this.greenLeaves.visible = this.greenLeaves.isActive;
	this.yellowLeaves.visible = this.yellowLeaves.isActive;
};


feng.views.view3dfx.FX.prototype.onBeforeRenderMask = function() {

	this.clickEffect.visible = false;
	this.selectEffect.visible = false;
	this.greenLeaves.visible = this.greenLeaves.isActive;
	this.yellowLeaves.visible = this.yellowLeaves.isActive;
};


feng.views.view3dfx.FX.prototype.onUnlock = function(e) {

  this.yellowLeaves.animateOut();
  this.greenLeaves.animateIn( e.activeObject );
};goog.provide('feng.views.view3dobject.entities.Lamp');

goog.require('feng.fx.TextureAnimator');
goog.require('feng.models.Preload');
goog.require('feng.views.view3dobject.TipObject');


/**
 * @constructor
 * A lamp whose color should be changed
 */
feng.views.view3dobject.entities.Lamp = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._light = this.object3d.getObjectByName('light');

  this._defaultColor = this._light.color;
  this._color = this._defaultColor.clone();
  this._toColor = new THREE.Color();

  this.setColor( this._color );
};
goog.inherits(feng.views.view3dobject.entities.Lamp, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Lamp.prototype.setColor = function(hex) {

  var startHex = this._color.getHex();
  var toColor = this._toColor.set( hex );

  var prop = {
  	t: 0
  };

  TweenMax.to(prop, .8, {
  	t: 1,
  	'ease': Expo.easeOut,
  	'onUpdate': function() {
  		this._color.set(startHex).lerp( this._toColor, prop.t );
  		this._light.color.copy( this._color );
  		this.object3d.material.color.copy( this._color );
  	},
  	'onUpdateScope': this
  });

  if(!toColor.equals( this._defaultColor )) {
    this.unlock();
  }
};


feng.views.view3dobject.entities.Lamp.prototype.setColorByName = function(name) {

	var hex = this.tip.details['colors'][name]['hex'];
	this.setColor( hex );
};goog.provide('feng.views.view3dobject.entities.Drawer');

goog.require('feng.views.view3dobject.TipObject');

/**
 * @constructor
 * The house kitchen drawer where the knife is put
 */
feng.views.view3dobject.entities.Drawer = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._startZ = this.object3d.position.z;
};
goog.inherits(feng.views.view3dobject.entities.Drawer, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Drawer.prototype.onCameraIn = function(){

  var knife = this._view3d.tipObjects['knife'];

  this.cameraInDuration = (knife.hasPicked && !this.tip.unlocked) ? 4000 : 2000;

  goog.base(this, 'onCameraIn');

  TweenMax.to(this.object3d.position, 1, {
    'z': this._startZ + 20,
    'ease': Quad.easeInOut,
    'onComplete': this.onDrawerOpened,
    'onCompleteScope': this
  });

  //feng.soundController.playSfx('refrigerator-open');
};


feng.views.view3dobject.entities.Drawer.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  TweenMax.to(this.object3d.position, 1, {
    'z': this._startZ,
    'ease': Quad.easeInOut
  });

  /*
  TweenMax.delayedCall(.8, function() {
    //feng.soundController.playSfx('refrigerator-close');
  }, [], this);
	*/
};


feng.views.view3dobject.entities.Drawer.prototype.onDrawerOpened = function(){

  if(this.tip.unlocked) return;

  goog.Timer.callOnce(function() {

    var knife = this._view3d.tipObjects['knife'];

    if(knife.hasPicked) {
      knife.drop();
    }
  }, 400, this);
};goog.provide('feng.views.view3dobject.entities.Knife');

goog.require('feng.views.view3dobject.MovableObject');


/**
 * @constructor
 * The knife found in house kitchen, to be put in kitchen drawer
 */
feng.views.view3dobject.entities.Knife = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._inDrawerTexture = null;
};
goog.inherits(feng.views.view3dobject.entities.Knife, feng.views.view3dobject.MovableObject);


feng.views.view3dobject.entities.Knife.prototype.getCloseUpObjectWhenDropped = function(){

  return this._view3d.tipObjects['drawer'];
};


feng.views.view3dobject.entities.Knife.prototype.createTextures = function(){

  goog.base(this, 'createTextures');

  var preload = feng.models.Preload.getInstance();
  var inDrawerImg = preload.getAsset(this._view3d.sectionId + '.' + this._view3d.id + '.knife-in-drawer-texture');
  this._inDrawerTexture = new THREE.Texture( inDrawerImg );
  this._inDrawerTexture.needsUpdate = true;

  if(this.hasDropped) {
    this.object3d.material.map = this._inDrawerTexture;
  }
};


feng.views.view3dobject.entities.Knife.prototype.disposeTextures = function(){

  this._inDrawerTexture.dispose();
  this._inDrawerTexture = null;

  this.object3d.material.map = null;

  goog.base(this, 'disposeTextures');
};


feng.views.view3dobject.entities.Knife.prototype.drop = function(){

  goog.base(this, 'drop');

  this.object3d.material.map = this._inDrawerTexture;
  this.object3d.material.needsUpdate = true;
};


feng.views.view3dobject.entities.Knife.prototype.unlock = function(){

  goog.base(this, 'unlock');

  var drawerTipObject = this._view3d.tipObjects['drawer'];
  drawerTipObject.unlock();
};goog.provide('feng.views.view3dobject.entities.Showerhead');

goog.require('goog.fx.Dragger');
goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 * The showerhead that is leaking water
 */
feng.views.view3dobject.entities.Showerhead = function( object3d, data, view3d ){

  goog.base(this, object3d, data, view3d);

  this._handle = null;

  this._waterdrop = null;

  this._waterdropStartY = null;

  this._tapCamera = {
    position: new THREE.Vector3(11, 59, 76.65),
    rotation: new THREE.Euler(-0.32, -1.59, 0, 'YXZ'),
    fov: 30
  };

  this._waterPositionTweener = null;
  this._waterScaleTweener = null;
  this._cameraTransitionTweener = null;
  this._cameraZoomTweener = null;

  // dragger to rotate the handle
  this._dragger = new goog.fx.Dragger( this._view3d.domElement );
  this._dragger.setHysteresis( 2 );
  this._dragger.defaultAction = goog.nullFunction;

  this._totalDeg = 0;
  this._lastDeg = 0;
  this._totalCount = 2;
  this._count = 0;
  this._hasDone = false;
};
goog.inherits(feng.views.view3dobject.entities.Showerhead, feng.views.view3dobject.TipObject);


feng.views.view3dobject.entities.Showerhead.prototype.init = function(){

  goog.base(this, 'init');

  this._handle = this.object3d.getObjectByName('shower-handle');

  this._waterdrop = this.object3d.getObjectByName('waterdrop');
  this._waterdropStartY = this._waterdrop.position.y;
};


feng.views.view3dobject.entities.Showerhead.prototype.onCameraIn = function(){

  goog.base(this, 'onCameraIn');

  if(this.tip.unlocked) {
    return;
  }

  this._waterPositionTweener = TweenMax.fromTo(this._waterdrop.position, 1.5, {
    'y': this._waterdropStartY
  },{
    'ease': Expo.easeIn,
    'y': this._waterdropStartY - 180,
    'repeat': -1,
    'repeatDelay': 1,
    'onRepeat': feng.soundController.playSfx,
    'onRepeatParams': ['water-drop'],
    'onRepeatScope': feng.soundController
  });

  this._waterScaleTweener = TweenMax.fromTo(this._waterdrop.scale, 1.5, {
    'y': 1
  },{
    'ease': Expo.easeIn,
    'y': 1.5,
    'repeat': -1,
    'repeatDelay': 1
  });
};


feng.views.view3dobject.entities.Showerhead.prototype.onCameraOut = function(){

  goog.base(this, 'onCameraOut');

  if(this._waterPositionTweener) {
    this._waterPositionTweener.kill();
  }

  if(this._waterScaleTweener) {
    this._waterScaleTweener.kill();
  }

  if(this._cameraTransitionTweener) {
    this._cameraTransitionTweener.kill();
  }
};


feng.views.view3dobject.entities.Showerhead.prototype.startInteraction = function(){

  goog.base(this, 'startInteraction');

  // transition camera to look at handle
  var control = this._view3d.modeController.control;

  var prop = {
    t: 0,
    startPosition: control.getPosition().clone(),
    endPosition: this._tapCamera.position,
    startRotation: control.getRotation().clone(),
    endRotation: this._tapCamera.rotation,
    startFov: control.getFov(),
    endFov: this._tapCamera.fov
  }

  this._cameraTransitionTweener = TweenMax.to( prop, 2, {
    t: 1,
    'ease': Sine.easeInOut,
    'onUpdate': this.onCameraTransitionUpdate,
    'onUpdateParams': [prop],
    'onUpdateScope': this,
    'onComplete': this.onCameraTransitionComplete,
    'onCompleteScope': this
  });
};


feng.views.view3dobject.entities.Showerhead.prototype.stopInteraction = function(){

  goog.base(this, 'stopInteraction');

  if(this._waterPositionTweener) {
    this._waterPositionTweener.kill();
  }

  if(this._waterScaleTweener) {
    this._waterScaleTweener.kill();
  }

  if(this._cameraTransitionTweener) {
    this._cameraTransitionTweener.kill();
  }
};


feng.views.view3dobject.entities.Showerhead.prototype.finish = function(){

  this._waterdrop.view3dObject.removeFromScene();

  this.unlock();
  this.stopInteraction();
};


feng.views.view3dobject.entities.Showerhead.prototype.onCameraTransitionUpdate = function(prop){

  var startPosition = prop.startPosition;
  var endPosition = prop.endPosition;
  var startRotation = prop.startRotation;
  var endRotation = prop.endRotation;
  var startFov = prop.startFov;
  var endFov = prop.endFov;
  var t = prop.t;

  var control = this._view3d.modeController.control;

  control.lerp( startPosition, endPosition, startRotation, endRotation, startFov, endFov, t );
};


feng.views.view3dobject.entities.Showerhead.prototype.onCameraTransitionComplete = function(){

  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.START, this.onDragStart, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.DRAG, this.onDrag, false, this);
  this._interactionHandler.listen( this._dragger, goog.fx.Dragger.EventType.END, this.onDragEnd, false, this);
};


feng.views.view3dobject.entities.Showerhead.prototype.onCameraZoomUpdate = function(prop){

  var control = this._view3d.modeController.control;

  control.setFov( prop.fov );
};


feng.views.view3dobject.entities.Showerhead.prototype.onDragStart = function(e){

  if(this._hasDone) {
    return;
  }

  var control = this._view3d.modeController.control;

  var prop = {
    fov: control.getFov()
  };

  this._cameraZoomTweener = TweenMax.to(prop, .5, {
    fov: this._tapCamera.fov - 5,
    'ease': Strong.easeOut,
    'onUpdate': this.onCameraZoomUpdate,
    'onUpdateParams': [prop],
    'onUpdateScope': this
  });
};


feng.views.view3dobject.entities.Showerhead.prototype.onDragEnd = function(e){

  this._lastDeg = 0;
};


feng.views.view3dobject.entities.Showerhead.prototype.onDrag = function(e){

  if(this._hasDone) {
    return;
  }

  var clientX = e.target.clientX;
  var clientY = e.target.clientY;

  var startX = e.target.startX;
  var startY = e.target.startY;

  var originX = feng.viewportSize.width / 2;
  var originY = feng.viewportSize.height / 2;

  var rad = Math.atan2(clientY - originY, clientX - originX);
  rad -= Math.atan2(startY - originY, startX - originX);

  var mouseDeg = rad * (180 / Math.PI);

  var a1 = mouseDeg * (Math.PI / 180);
  var a2 = this._lastDeg * (Math.PI / 180);

  var radians = Math.atan2(Math.sin(a1 - a2), Math.cos(a1 - a2));
  var diffDeg = Math.max(0, radians * (180 / Math.PI));

  this._lastDeg = mouseDeg;

  this._totalDeg += diffDeg;

  var count = Math.floor( this._totalDeg / 360 );
  var countT = Math.max( 0, Math.min(1, this._totalDeg / (360 * this._totalCount)) );

  this._handle.rotation.x += goog.math.toRadians(diffDeg) * (1 - countT) * .35;

  if(count >= this._totalCount) {

    this._hasDone = true;

    var control = this._view3d.modeController.control;

    var prop = {
      fov: control.getFov()
    };

    this._cameraZoomTweener = TweenMax.to(prop, 1, {
      fov: this._tapCamera.fov,
      'ease': Strong.easeOut,
      'onUpdate': this.onCameraZoomUpdate,
      'onUpdateParams': [prop],
      'onUpdateScope': this,
      'onComplete': this.finish,
      'onCompleteScope': this
    });
  }
};goog.provide('feng.views.View3D');

goog.require('goog.dom');
goog.require('goog.dom.query');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('goog.events');
goog.require('goog.object');
goog.require('feng.controllers.view3d.CameraController');
goog.require('feng.controllers.view3d.ModeController');
goog.require('feng.controllers.view3d.RenderController');
goog.require('feng.fx.EnergyFlow');
goog.require('feng.fx.Renderer');
goog.require('feng.fx.View3DSize');
goog.require('feng.models.Preload');
goog.require('feng.models.View3D');
goog.require('feng.views.book.Book');
goog.require('feng.views.view3dfx.FX');
goog.require('feng.views.view3dobject.View3DObject');
goog.require('feng.views.view3dobject.InteractiveObject');
goog.require('feng.views.view3dobject.Arms');
goog.require('feng.views.view3dobject.DesignPlane');
goog.require('feng.views.view3dobject.ReplaceableObject');
goog.require('feng.views.view3dobject.MovableObject');
goog.require('feng.views.view3dobject.GatewayObject');
goog.require('feng.views.view3dobject.Skybox');
goog.require('feng.views.view3dobject.Mirror');
goog.require('feng.views.view3dobject.TipObject');
goog.require('feng.views.view3dobject.entities.Bear');
goog.require('feng.views.view3dobject.entities.Cat');
goog.require('feng.views.view3dobject.entities.Drawer');
goog.require('feng.views.view3dobject.entities.Knife');
goog.require('feng.views.view3dobject.entities.Lamp');
goog.require('feng.views.view3dobject.entities.Computer');
goog.require('feng.views.view3dobject.entities.Closet');
goog.require('feng.views.view3dobject.entities.Pictures');
goog.require('feng.views.view3dobject.entities.Refrigerator');
goog.require('feng.views.view3dobject.entities.SewingMachine');
goog.require('feng.views.view3dobject.entities.FruitPlate');
goog.require('feng.views.view3dobject.entities.Fruit');
goog.require('feng.views.view3dobject.entities.GlassBowl');
goog.require('feng.views.view3dobject.entities.Wallpaper');
goog.require('feng.views.view3dobject.entities.Windows');
goog.require('feng.views.view3dobject.entities.Showerhead');


/**
 * @constructor
 */
feng.views.View3D = function(sectionId, viewId, containerElement, hud, episode){

  goog.base(this);

  this.id = viewId;
  this.sectionId = sectionId;

  this.isShown = false;
  this.isActivated = false;

  this.containerElement = containerElement;

  this.domElement = goog.dom.createDom('canvas');

  this.hud = hud;

  this.episode = episode;

  this.cameraController = null;
  this.renderController = null;
	this.modeController = null;

	this.scene = null;
	this.fx = null;
	this.energyFlow = null;
	this.arms = null;
	this.designPlane = null;
	this.skybox = null;

	this.onlyObjectToUnlock = null;

	this.view3dObjects = {};
	this.interactiveObjects = {};
	this.tipObjects = {};

	this._cubeCameras = [];

	this.viewSize = new feng.fx.View3DSize(0, 0);

	this._matrixId = null;

	this.startGateway = null;

	this.renderer = null;

	this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.views.View3D, goog.events.EventTarget);


feng.views.View3D.prototype.init = function(){

	this.createScene();

	this.cameraController = new feng.controllers.view3d.CameraController(this);
	this.cameraController.init( this.scene );

	this.renderer = new feng.fx.Renderer(this.domElement, this.scene, this.cameraController.activeCamera);

	this.initScene();
	
	this.renderController = new feng.controllers.view3d.RenderController(this);

	this.modeController = new feng.controllers.view3d.ModeController(this);
	this.modeController.init();

	this.hide();
};


feng.views.View3D.prototype.createResources = function(){

	feng.pubsub.publish( feng.PubSub.Topic.BUFFER_START );

	// upload the texture with a delay between each creation
	// try be friendly to the GPU...

	var i = 0;
	var callbacks = [];

	var objects = goog.object.getValues(this.view3dObjects);
	var count = objects.length;

	var delay = new goog.async.Delay(function() {

		objects[i].createTextures();
		
		if(i === count - 1) {

			feng.pubsub.publish( feng.PubSub.Topic.BUFFER_COMPLETE );
			delay.dispose();

		}else {

			i++;
			delay.start();
		}

	}, 100);

	delay.start();
};


feng.views.View3D.prototype.disposeResources = function(){
	
	console.log(this.id + ' DISPOSED!');
	
	goog.object.forEach(this.view3dObjects, function(object) {
		object.disposeTextures();
	});
};


feng.views.View3D.prototype.getViewSize = function(){

	if(this.viewSize.isEmpty()) {
		this.viewSize = this.viewSize.update();
	}

	return this.viewSize;
};


feng.views.View3D.prototype.getMatrixId = function(){

	return this._matrixId;
};


feng.views.View3D.prototype.getGatewayObjects = function(){

	var gatewayObjects = this.getObjectsByClass( feng.views.view3dobject.GatewayObject );

	return gatewayObjects;
};


feng.views.View3D.prototype.getEntry = function(){

	var gatewayObjects = this.getGatewayObjects();
	
	var entry = goog.array.find( gatewayObjects, function(gatewayObject) {
		return (gatewayObject.isEntry === true);
	});

	return entry;
};


feng.views.View3D.prototype.getSolidObjects = function(){

	var objects = goog.object.getValues( this.view3dObjects );
	goog.array.remove( objects, this.skybox );
	goog.array.remove( objects, this.arms );
	goog.array.remove( objects, this.designPlane );

	objects = goog.array.filter(objects, function(object) {
		return goog.isDefAndNotNull( object.object3d.parent );
	});

  return objects;
};


feng.views.View3D.prototype.getObjectByTip = function( tip ){

	var tipObject = goog.object.findValue( this.tipObjects, function(object) {
		return (object.tip === tip);
	});

	return tipObject;
};


feng.views.View3D.prototype.getView3dObject = function( name ){

	return this.view3dObjects[ name ];
};


feng.views.View3D.prototype.getView3dObjectById = function( id ){

	var view3dObject = goog.object.findValue( this.view3dObjects, function(object) {
		return (object.id === id);
	});

	return view3dObject;
};


feng.views.View3D.prototype.getObjectsByClass = function( objectClass ){

	var result = [];

	goog.object.forEach(this.view3dObjects, function(object, name) {
		if(object instanceof objectClass) {
			result.push( object );
		}
	});

	return result;
};


feng.views.View3D.prototype.createCubeMap = function(position, size){

  var cubeCamera = new THREE.CubeCamera( 0.1, 1000, size || feng.renderSettings.renderSize );
  cubeCamera.position.copy( position );

  this.scene.add( cubeCamera );

  this._cubeCameras.push( cubeCamera );

  return cubeCamera.renderTarget;
};


feng.views.View3D.prototype.updateCubeMaps = function(){

  var renderer = this.renderer.getRenderer();
  var scene = this.scene;

  goog.array.forEach(this._cubeCameras, function(cubeCamera) {

  	cubeCamera.updateCubeMap( renderer, scene );
  });
};


feng.views.View3D.prototype.activate = function(){

	if(this.isActivated) return;
	else this.isActivated = true;

 	this._eventHandler.listen( this.viewSize, goog.events.EventType.RESIZE, this.onResize, false, this );
 	this._eventHandler.listen( this.cameraController, feng.events.EventType.CHANGE, this.onCameraChange, false, this );
 	
 	var tutorialOverlay = this.hud.tutorialOverlay;
 	this._eventHandler.listen( tutorialOverlay, feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this );

 	var creditsOverlay = this.hud.creditsOverlay;
 	this._eventHandler.listen( creditsOverlay, feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this );

 	var endingOverlay = this.hud.endingOverlay;
 	this._eventHandler.listen( endingOverlay, feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this );

 	var finaleOverlay = this.hud.finaleOverlay;
 	this._eventHandler.listen( finaleOverlay, feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this );

 	var book = feng.views.book.Book.getInstance();
	this._eventHandler.listen( book, feng.events.EventType.ANIMATE_IN, this.onBookAnimateIn, false, this );
	this._eventHandler.listen( book, feng.events.EventType.ANIMATE_OUT, this.onBookAnimateOut, false, this );

 	goog.object.forEach(this.interactiveObjects, function(interactiveObject) {
 		interactiveObject.activate();
 	});

 	this.modeController.activate();

 	this.fx.activate();

 	TweenMax.ticker.addEventListener("tick", this.update, this);
};
 
 
feng.views.View3D.prototype.deactivate = function(){
 
 	if(!this.isActivated) return;
	else this.isActivated = false;

	TweenMax.ticker.removeEventListener("tick", this.update, this);
	
	this._eventHandler.removeAll();

 	goog.object.forEach(this.interactiveObjects, function(interactiveObject) {
 		interactiveObject.deactivate();
 	});

 	this.modeController.deactivate();

 	this.fx.deactivate();
};


feng.views.View3D.prototype.show = function(){
 
	if(this.isShown) return;
	else this.isShown = true;

	goog.dom.appendChild( this.containerElement, this.domElement );

	TweenMax.set(this.domElement, {
		'opacity': 0,
		'display': 'block'
	});

 	this.onResize();

	// update all cube maps
	this.updateCubeMaps();

	//
	this.dispatchEvent({
		type: feng.events.EventType.SHOW
	});
};

 
feng.views.View3D.prototype.hide = function(){
 
	if(!this.isShown) return;
	else this.isShown = false;

	TweenMax.set(this.domElement, {
		'opacity': 0,
		'display': 'none'
	});

	this.dispatchEvent({
		type: feng.events.EventType.HIDE
	});
};


feng.views.View3D.prototype.fadeIn = function(){

	if(!this.isShown) {
		this.show();
	}

 	var tweener = TweenMax.to(this.domElement, 1, {
 		'delay': 1,
 		'opacity': 1,
 		'clearProps': 'opacity'
 	});

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATE_IN
	});

 	tweener.eventCallback("onComplete", goog.bind(function() {
 		this.dispatchEvent({
 			type: feng.events.EventType.ANIMATED_IN
 		});
 	}, this));
};


feng.views.View3D.prototype.fadeOut = function(){
 
 	var tweener = TweenMax.to(this.domElement, 1, {
 		'opacity': 0
 	});

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATE_OUT
	});

 	tweener.eventCallback("onComplete", goog.bind(function() {
 		this.hide();
 		this.dispatchEvent({
 			type: feng.events.EventType.ANIMATED_OUT
 		});
 	}, this));
};


feng.views.View3D.prototype.pause = function(){

	this.modeController.control.pause( true );
	this.renderController.updateByPause( true );
	this.hud.pause( true );
};


feng.views.View3D.prototype.resume = function(){

	this.modeController.control.pause( false );
	this.renderController.updateByPause( false );
	this.hud.pause( false );
};


feng.views.View3D.prototype.render = function() {
	
	this.renderer.render();
};


feng.views.View3D.prototype.createScene = function() {

	var constructed = feng.views.View3D.constructScene(this.sectionId, this.id);
	this.scene = constructed.scene;
};


feng.views.View3D.prototype.initScene = function() {

	// add fog to scene for fading 45 deg ground plane
	this.scene.fog = new THREE.FogExp2( 0xd9d9d9, 0.0008 );

	/*
	 * Classes to be created by external json data
	 */
	var objectClass = {
		'tip': feng.views.view3dobject.TipObject,
		'replaceable': feng.views.view3dobject.ReplaceableObject,
		'movable': feng.views.view3dobject.MovableObject,
		'gateway': feng.views.view3dobject.GatewayObject,
		'mirror': feng.views.view3dobject.Mirror,
		'closet': feng.views.view3dobject.entities.Closet,
		'pictures': feng.views.view3dobject.entities.Pictures,
		'computer': feng.views.view3dobject.entities.Computer,
		'lamp': feng.views.view3dobject.entities.Lamp,
		'bear': feng.views.view3dobject.entities.Bear,
		'cat': feng.views.view3dobject.entities.Cat,
		'drawer': feng.views.view3dobject.entities.Drawer,
		'knife': feng.views.view3dobject.entities.Knife,
		'refrigerator': feng.views.view3dobject.entities.Refrigerator,
		'sewingmachine': feng.views.view3dobject.entities.SewingMachine,
		'wallpaper': feng.views.view3dobject.entities.Wallpaper,
		'windows': feng.views.view3dobject.entities.Windows,
		'showerhead': feng.views.view3dobject.entities.Showerhead,
		'fruitplate': feng.views.view3dobject.entities.FruitPlate,
		'fruit': feng.views.view3dobject.entities.Fruit,
		'glassbowl': feng.views.view3dobject.entities.GlassBowl
	};

	// parse scene objects
	var sectionId = this.sectionId;
	var sceneId = this.id;

	var parse = goog.bind( function(object) {

		if(!(object instanceof THREE.Object3D)) return;

		var objectData = feng.models.View3D.getData(sectionId+'.'+sceneId+'.'+object.name);
		var className = objectData.Class;

		if(className) {

			// create specific class object
			var classObject = new objectClass[className](object, objectData, this);

		}else {

			if( object instanceof THREE.Mesh ) {

				// create view3d object
				var view3dObject = new feng.views.view3dobject.View3DObject( object, objectData, this);
			}
		}

	}, this);

	goog.array.forEach(this.scene.children, function(child) {
		feng.views.View3D.parseChildren(child, parse);
	});

	//init pathfinder matrix
	this._matrixId = ([this.sectionId, this.id]).join('-');
	feng.pathfinder.generateMatrix( this._matrixId, this.getSolidObjects() );

	// create energyflow
	var preloadModel = feng.models.Preload.getInstance();
	var energyFlowData = preloadModel.getAsset(this.sectionId+'.'+this.id+'.energyflow-data');

	if(energyFlowData) {
		var controlPoints = energyFlowData['controlPoints'];
		this.energyFlow = new feng.fx.EnergyFlow( controlPoints, this.id, this.sectionId );
		//this.scene.add( this.energyFlow );
	}

	// create design plane
	this.designPlane = new feng.views.view3dobject.DesignPlane( this );

	/* for testing skybox
	goog.object.forEach(this.view3dObjects, function(object) {
		object.removeFromScene();
	});
	*/

	// create skybox
	var assets = preloadModel.getAsset(this.sectionId+'.'+this.id+'.skybox');

	this.skybox = new feng.views.view3dobject.Skybox( assets, this );

	// create arms
	this.arms = new feng.views.view3dobject.Arms( this );

	// create fx(s)
	this.fx = new feng.views.view3dfx.FX();
	this.scene.add( this.fx );

	// init all view3d objects
	goog.object.forEach(this.view3dObjects, function(object) {
		object.init();
	});
};


feng.views.View3D.prototype.update = function(now){

	var control = this.modeController.control;
	this.arms.update( control.getPosition(), control.getRotation() );

	this.render();
};


feng.views.View3D.prototype.onCameraChange = function(e){

	this.renderer.setCamera( e.camera );
};


feng.views.View3D.prototype.onOverlayAnimateIn = function(e){

	this.pause();

	var shouldAddAnimateOutCallback = true;

	var overlay = e.currentTarget;

	if(overlay === this.hud.endingOverlay) {

    	var achievements = feng.models.achievements.Achievements.getInstance();
    	
    	if(achievements.isAllUnlocked()) {
    		shouldAddAnimateOutCallback = false;
    	}
	}
	
	if(shouldAddAnimateOutCallback) {
		this._eventHandler.listenOnce( overlay, feng.events.EventType.ANIMATE_OUT, this.onOverlayAnimateOut, false, this );
	}
};


feng.views.View3D.prototype.onOverlayAnimateOut = function(e){

	this.resume();
};


feng.views.View3D.prototype.onBookAnimateIn = function(e){

	this.pause();

	feng.soundController.stopMix( this.sectionId );
	feng.soundController.fadeLoop( 'book', 0, 1, 2 );
};


feng.views.View3D.prototype.onBookAnimateOut = function(e){

	this.resume();

	feng.soundController.playMix( this.sectionId );
  	feng.soundController.fadeLoop( 'book', null, 0, 2, true, true );
};


feng.views.View3D.prototype.onResize = function(e){

	this.cameraController.onResize( this.viewSize.aspectRatio() );

	this.renderer.setSize( this.viewSize.width, this.viewSize.height );

	this.render();
};


feng.views.View3D.parseChildren = function(object, parseFunc) {

	parseFunc( object );

	if(object instanceof THREE.Object3D) {

		goog.array.forEach(object.children, function(child) {
			feng.views.View3D.parseChildren(child, parseFunc);
		});
	}
};


feng.views.View3D.constructScene = function(sectionId, sceneId) {

	// get scene data
	var preloadModel = feng.models.Preload.getInstance();
	var sceneData = preloadModel.getAsset(sectionId+'.'+sceneId+'.scene-data');
	var scene = feng.utils.ThreeUtils.loader.parse( sceneData );

	return {
		scene: scene
	};
};// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Constant declarations for common key codes.
 *
 * @author eae@google.com (Emil A Eklund)
 * @see ../demos/keyhandler.html
 */

goog.provide('goog.events.KeyCodes');

goog.require('goog.userAgent');


/**
 * Key codes for common characters.
 *
 * This list is not localized and therefore some of the key codes are not
 * correct for non US keyboard layouts. See comments below.
 *
 * @enum {number}
 */
goog.events.KeyCodes = {
  WIN_KEY_FF_LINUX: 0,
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,  // NUMLOCK on FF/Safari Mac
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,     // also NUM_NORTH_EAST
  PAGE_DOWN: 34,   // also NUM_SOUTH_EAST
  END: 35,         // also NUM_SOUTH_WEST
  HOME: 36,        // also NUM_NORTH_WEST
  LEFT: 37,        // also NUM_WEST
  UP: 38,          // also NUM_NORTH
  RIGHT: 39,       // also NUM_EAST
  DOWN: 40,        // also NUM_SOUTH
  PRINT_SCREEN: 44,
  INSERT: 45,      // also NUM_INSERT
  DELETE: 46,      // also NUM_DELETE
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  FF_SEMICOLON: 59, // Firefox (Gecko) fires this for semicolon instead of 186
  FF_EQUALS: 61, // Firefox (Gecko) fires this for equals instead of 187
  FF_DASH: 173, // Firefox (Gecko) fires this for dash instead of 189
  QUESTION_MARK: 63, // needs localization
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91, // WIN_KEY_LEFT
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SCROLL_LOCK: 145,

  // OS-specific media keys like volume controls and browser controls.
  FIRST_MEDIA_KEY: 166,
  LAST_MEDIA_KEY: 183,

  SEMICOLON: 186,            // needs localization
  DASH: 189,                 // needs localization
  EQUALS: 187,               // needs localization
  COMMA: 188,                // needs localization
  PERIOD: 190,               // needs localization
  SLASH: 191,                // needs localization
  APOSTROPHE: 192,           // needs localization
  TILDE: 192,                // needs localization
  SINGLE_QUOTE: 222,         // needs localization
  OPEN_SQUARE_BRACKET: 219,  // needs localization
  BACKSLASH: 220,            // needs localization
  CLOSE_SQUARE_BRACKET: 221, // needs localization
  WIN_KEY: 224,
  MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
  MAC_WK_CMD_LEFT: 91,  // WebKit Left Command key fired, same as META
  MAC_WK_CMD_RIGHT: 93, // WebKit Right Command key fired, different from META
  WIN_IME: 229,

  // We've seen users whose machines fire this keycode at regular one
  // second intervals. The common thread among these users is that
  // they're all using Dell Inspiron laptops, so we suspect that this
  // indicates a hardware/bios problem.
  // http://en.community.dell.com/support-forums/laptop/f/3518/p/19285957/19523128.aspx
  PHANTOM: 255
};


/**
 * Returns true if the event contains a text modifying key.
 * @param {goog.events.BrowserEvent} e A key event.
 * @return {boolean} Whether it's a text modifying key.
 */
goog.events.KeyCodes.isTextModifyingKeyEvent = function(e) {
  if (e.altKey && !e.ctrlKey ||
      e.metaKey ||
      // Function keys don't generate text
      e.keyCode >= goog.events.KeyCodes.F1 &&
      e.keyCode <= goog.events.KeyCodes.F12) {
    return false;
  }

  // The following keys are quite harmless, even in combination with
  // CTRL, ALT or SHIFT.
  switch (e.keyCode) {
    case goog.events.KeyCodes.ALT:
    case goog.events.KeyCodes.CAPS_LOCK:
    case goog.events.KeyCodes.CONTEXT_MENU:
    case goog.events.KeyCodes.CTRL:
    case goog.events.KeyCodes.DOWN:
    case goog.events.KeyCodes.END:
    case goog.events.KeyCodes.ESC:
    case goog.events.KeyCodes.HOME:
    case goog.events.KeyCodes.INSERT:
    case goog.events.KeyCodes.LEFT:
    case goog.events.KeyCodes.MAC_FF_META:
    case goog.events.KeyCodes.META:
    case goog.events.KeyCodes.NUMLOCK:
    case goog.events.KeyCodes.NUM_CENTER:
    case goog.events.KeyCodes.PAGE_DOWN:
    case goog.events.KeyCodes.PAGE_UP:
    case goog.events.KeyCodes.PAUSE:
    case goog.events.KeyCodes.PHANTOM:
    case goog.events.KeyCodes.PRINT_SCREEN:
    case goog.events.KeyCodes.RIGHT:
    case goog.events.KeyCodes.SCROLL_LOCK:
    case goog.events.KeyCodes.SHIFT:
    case goog.events.KeyCodes.UP:
    case goog.events.KeyCodes.WIN_KEY:
    case goog.events.KeyCodes.WIN_KEY_RIGHT:
      return false;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return !goog.userAgent.GECKO;
    default:
      return e.keyCode < goog.events.KeyCodes.FIRST_MEDIA_KEY ||
          e.keyCode > goog.events.KeyCodes.LAST_MEDIA_KEY;
  }
};


/**
 * Returns true if the key fires a keypress event in the current browser.
 *
 * Accoridng to MSDN [1] IE only fires keypress events for the following keys:
 * - Letters: A - Z (uppercase and lowercase)
 * - Numerals: 0 - 9
 * - Symbols: ! @ # $ % ^ & * ( ) _ - + = < [ ] { } , . / ? \ | ' ` " ~
 * - System: ESC, SPACEBAR, ENTER
 *
 * That's not entirely correct though, for instance there's no distinction
 * between upper and lower case letters.
 *
 * [1] http://msdn2.microsoft.com/en-us/library/ms536939(VS.85).aspx)
 *
 * Safari is similar to IE, but does not fire keypress for ESC.
 *
 * Additionally, IE6 does not fire keydown or keypress events for letters when
 * the control or alt keys are held down and the shift key is not. IE7 does
 * fire keydown in these cases, though, but not keypress.
 *
 * @param {number} keyCode A key code.
 * @param {number=} opt_heldKeyCode Key code of a currently-held key.
 * @param {boolean=} opt_shiftKey Whether the shift key is held down.
 * @param {boolean=} opt_ctrlKey Whether the control key is held down.
 * @param {boolean=} opt_altKey Whether the alt key is held down.
 * @return {boolean} Whether it's a key that fires a keypress event.
 */
goog.events.KeyCodes.firesKeyPressEvent = function(keyCode, opt_heldKeyCode,
    opt_shiftKey, opt_ctrlKey, opt_altKey) {
  if (!goog.userAgent.IE &&
      !(goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('525'))) {
    return true;
  }

  if (goog.userAgent.MAC && opt_altKey) {
    return goog.events.KeyCodes.isCharacterKey(keyCode);
  }

  // Alt but not AltGr which is represented as Alt+Ctrl.
  if (opt_altKey && !opt_ctrlKey) {
    return false;
  }

  // Saves Ctrl or Alt + key for IE and WebKit 525+, which won't fire keypress.
  // Non-IE browsers and WebKit prior to 525 won't get this far so no need to
  // check the user agent.
  if (goog.isNumber(opt_heldKeyCode)) {
    opt_heldKeyCode = goog.events.KeyCodes.normalizeKeyCode(opt_heldKeyCode);
  }
  if (!opt_shiftKey &&
      (opt_heldKeyCode == goog.events.KeyCodes.CTRL ||
       opt_heldKeyCode == goog.events.KeyCodes.ALT ||
       goog.userAgent.MAC &&
       opt_heldKeyCode == goog.events.KeyCodes.META)) {
    return false;
  }

  // Some keys with Ctrl/Shift do not issue keypress in WEBKIT.
  if (goog.userAgent.WEBKIT && opt_ctrlKey && opt_shiftKey) {
    switch (keyCode) {
      case goog.events.KeyCodes.BACKSLASH:
      case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
      case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
      case goog.events.KeyCodes.TILDE:
      case goog.events.KeyCodes.SEMICOLON:
      case goog.events.KeyCodes.DASH:
      case goog.events.KeyCodes.EQUALS:
      case goog.events.KeyCodes.COMMA:
      case goog.events.KeyCodes.PERIOD:
      case goog.events.KeyCodes.SLASH:
      case goog.events.KeyCodes.APOSTROPHE:
      case goog.events.KeyCodes.SINGLE_QUOTE:
        return false;
    }
  }

  // When Ctrl+<somekey> is held in IE, it only fires a keypress once, but it
  // continues to fire keydown events as the event repeats.
  if (goog.userAgent.IE && opt_ctrlKey && opt_heldKeyCode == keyCode) {
    return false;
  }

  switch (keyCode) {
    case goog.events.KeyCodes.ENTER:
      // IE9 does not fire KEYPRESS on ENTER.
      return !(goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9));
    case goog.events.KeyCodes.ESC:
      return !goog.userAgent.WEBKIT;
  }

  return goog.events.KeyCodes.isCharacterKey(keyCode);
};


/**
 * Returns true if the key produces a character.
 * This does not cover characters on non-US keyboards (Russian, Hebrew, etc.).
 *
 * @param {number} keyCode A key code.
 * @return {boolean} Whether it's a character key.
 */
goog.events.KeyCodes.isCharacterKey = function(keyCode) {
  if (keyCode >= goog.events.KeyCodes.ZERO &&
      keyCode <= goog.events.KeyCodes.NINE) {
    return true;
  }

  if (keyCode >= goog.events.KeyCodes.NUM_ZERO &&
      keyCode <= goog.events.KeyCodes.NUM_MULTIPLY) {
    return true;
  }

  if (keyCode >= goog.events.KeyCodes.A &&
      keyCode <= goog.events.KeyCodes.Z) {
    return true;
  }

  // Safari sends zero key code for non-latin characters.
  if (goog.userAgent.WEBKIT && keyCode == 0) {
    return true;
  }

  switch (keyCode) {
    case goog.events.KeyCodes.SPACE:
    case goog.events.KeyCodes.QUESTION_MARK:
    case goog.events.KeyCodes.NUM_PLUS:
    case goog.events.KeyCodes.NUM_MINUS:
    case goog.events.KeyCodes.NUM_PERIOD:
    case goog.events.KeyCodes.NUM_DIVISION:
    case goog.events.KeyCodes.SEMICOLON:
    case goog.events.KeyCodes.FF_SEMICOLON:
    case goog.events.KeyCodes.DASH:
    case goog.events.KeyCodes.EQUALS:
    case goog.events.KeyCodes.FF_EQUALS:
    case goog.events.KeyCodes.COMMA:
    case goog.events.KeyCodes.PERIOD:
    case goog.events.KeyCodes.SLASH:
    case goog.events.KeyCodes.APOSTROPHE:
    case goog.events.KeyCodes.SINGLE_QUOTE:
    case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
    case goog.events.KeyCodes.BACKSLASH:
    case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
      return true;
    default:
      return false;
  }
};


/**
 * Normalizes key codes from OS/Browser-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeKeyCode = function(keyCode) {
  if (goog.userAgent.GECKO) {
    return goog.events.KeyCodes.normalizeGeckoKeyCode(keyCode);
  } else if (goog.userAgent.MAC && goog.userAgent.WEBKIT) {
    return goog.events.KeyCodes.normalizeMacWebKitKeyCode(keyCode);
  } else {
    return keyCode;
  }
};


/**
 * Normalizes key codes from their Gecko-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeGeckoKeyCode = function(keyCode) {
  switch (keyCode) {
    case goog.events.KeyCodes.FF_EQUALS:
      return goog.events.KeyCodes.EQUALS;
    case goog.events.KeyCodes.FF_SEMICOLON:
      return goog.events.KeyCodes.SEMICOLON;
    case goog.events.KeyCodes.FF_DASH:
      return goog.events.KeyCodes.DASH;
    case goog.events.KeyCodes.MAC_FF_META:
      return goog.events.KeyCodes.META;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return goog.events.KeyCodes.WIN_KEY;
    default:
      return keyCode;
  }
};


/**
 * Normalizes key codes from their Mac WebKit-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeMacWebKitKeyCode = function(keyCode) {
  switch (keyCode) {
    case goog.events.KeyCodes.MAC_WK_CMD_RIGHT:  // 93
      return goog.events.KeyCodes.META;          // 91
    default:
      return keyCode;
  }
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview This file contains a class for working with keyboard events
 * that repeat consistently across browsers and platforms. It also unifies the
 * key code so that it is the same in all browsers and platforms.
 *
 * Different web browsers have very different keyboard event handling. Most
 * importantly is that only certain browsers repeat keydown events:
 * IE, Opera, FF/Win32, and Safari 3 repeat keydown events.
 * FF/Mac and Safari 2 do not.
 *
 * For the purposes of this code, "Safari 3" means WebKit 525+, when WebKit
 * decided that they should try to match IE's key handling behavior.
 * Safari 3.0.4, which shipped with Leopard (WebKit 523), has the
 * Safari 2 behavior.
 *
 * Firefox, Safari, Opera prevent on keypress
 *
 * IE prevents on keydown
 *
 * Firefox does not fire keypress for shift, ctrl, alt
 * Firefox does fire keydown for shift, ctrl, alt, meta
 * Firefox does not repeat keydown for shift, ctrl, alt, meta
 *
 * Firefox does not fire keypress for up and down in an input
 *
 * Opera fires keypress for shift, ctrl, alt, meta
 * Opera does not repeat keypress for shift, ctrl, alt, meta
 *
 * Safari 2 and 3 do not fire keypress for shift, ctrl, alt
 * Safari 2 does not fire keydown for shift, ctrl, alt
 * Safari 3 *does* fire keydown for shift, ctrl, alt
 *
 * IE provides the keycode for keyup/down events and the charcode (in the
 * keycode field) for keypress.
 *
 * Mozilla provides the keycode for keyup/down and the charcode for keypress
 * unless it's a non text modifying key in which case the keycode is provided.
 *
 * Safari 3 provides the keycode and charcode for all events.
 *
 * Opera provides the keycode for keyup/down event and either the charcode or
 * the keycode (in the keycode field) for keypress events.
 *
 * Firefox x11 doesn't fire keydown events if a another key is already held down
 * until the first key is released. This can cause a key event to be fired with
 * a keyCode for the first key and a charCode for the second key.
 *
 * Safari in keypress
 *
 *        charCode keyCode which
 * ENTER:       13      13    13
 * F1:       63236   63236 63236
 * F8:       63243   63243 63243
 * ...
 * p:          112     112   112
 * P:           80      80    80
 *
 * Firefox, keypress:
 *
 *        charCode keyCode which
 * ENTER:        0      13    13
 * F1:           0     112     0
 * F8:           0     119     0
 * ...
 * p:          112       0   112
 * P:           80       0    80
 *
 * Opera, Mac+Win32, keypress:
 *
 *         charCode keyCode which
 * ENTER: undefined      13    13
 * F1:    undefined     112     0
 * F8:    undefined     119     0
 * ...
 * p:     undefined     112   112
 * P:     undefined      80    80
 *
 * IE7, keydown
 *
 *         charCode keyCode     which
 * ENTER: undefined      13 undefined
 * F1:    undefined     112 undefined
 * F8:    undefined     119 undefined
 * ...
 * p:     undefined      80 undefined
 * P:     undefined      80 undefined
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author eae@google.com (Emil A Eklund)
 * @see ../demos/keyhandler.html
 */

goog.provide('goog.events.KeyEvent');
goog.provide('goog.events.KeyHandler');
goog.provide('goog.events.KeyHandler.EventType');

goog.require('goog.events');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.userAgent');



/**
 * A wrapper around an element that you want to listen to keyboard events on.
 * @param {Element|Document=} opt_element The element or document to listen on.
 * @param {boolean=} opt_capture Whether to listen for browser events in
 *     capture phase (defaults to false).
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.events.KeyHandler = function(opt_element, opt_capture) {
  goog.events.EventTarget.call(this);

  if (opt_element) {
    this.attach(opt_element, opt_capture);
  }
};
goog.inherits(goog.events.KeyHandler, goog.events.EventTarget);


/**
 * This is the element that we will listen to the real keyboard events on.
 * @type {Element|Document|null}
 * @private
 */
goog.events.KeyHandler.prototype.element_ = null;


/**
 * The key for the key press listener.
 * @type {goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyPressKey_ = null;


/**
 * The key for the key down listener.
 * @type {goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyDownKey_ = null;


/**
 * The key for the key up listener.
 * @type {goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyUpKey_ = null;


/**
 * Used to detect keyboard repeat events.
 * @private
 * @type {number}
 */
goog.events.KeyHandler.prototype.lastKey_ = -1;


/**
 * Keycode recorded for key down events. As most browsers don't report the
 * keycode in the key press event we need to record it in the key down phase.
 * @private
 * @type {number}
 */
goog.events.KeyHandler.prototype.keyCode_ = -1;


/**
 * Alt key recorded for key down events. FF on Mac does not report the alt key
 * flag in the key press event, we need to record it in the key down phase.
 * @type {boolean}
 * @private
 */
goog.events.KeyHandler.prototype.altKey_ = false;


/**
 * Enum type for the events fired by the key handler
 * @enum {string}
 */
goog.events.KeyHandler.EventType = {
  KEY: 'key'
};


/**
 * An enumeration of key codes that Safari 2 does incorrectly
 * @type {Object}
 * @private
 */
goog.events.KeyHandler.safariKey_ = {
  '3': goog.events.KeyCodes.ENTER, // 13
  '12': goog.events.KeyCodes.NUMLOCK, // 144
  '63232': goog.events.KeyCodes.UP, // 38
  '63233': goog.events.KeyCodes.DOWN, // 40
  '63234': goog.events.KeyCodes.LEFT, // 37
  '63235': goog.events.KeyCodes.RIGHT, // 39
  '63236': goog.events.KeyCodes.F1, // 112
  '63237': goog.events.KeyCodes.F2, // 113
  '63238': goog.events.KeyCodes.F3, // 114
  '63239': goog.events.KeyCodes.F4, // 115
  '63240': goog.events.KeyCodes.F5, // 116
  '63241': goog.events.KeyCodes.F6, // 117
  '63242': goog.events.KeyCodes.F7, // 118
  '63243': goog.events.KeyCodes.F8, // 119
  '63244': goog.events.KeyCodes.F9, // 120
  '63245': goog.events.KeyCodes.F10, // 121
  '63246': goog.events.KeyCodes.F11, // 122
  '63247': goog.events.KeyCodes.F12, // 123
  '63248': goog.events.KeyCodes.PRINT_SCREEN, // 44
  '63272': goog.events.KeyCodes.DELETE, // 46
  '63273': goog.events.KeyCodes.HOME, // 36
  '63275': goog.events.KeyCodes.END, // 35
  '63276': goog.events.KeyCodes.PAGE_UP, // 33
  '63277': goog.events.KeyCodes.PAGE_DOWN, // 34
  '63289': goog.events.KeyCodes.NUMLOCK, // 144
  '63302': goog.events.KeyCodes.INSERT // 45
};


/**
 * An enumeration of key identifiers currently part of the W3C draft for DOM3
 * and their mappings to keyCodes.
 * http://www.w3.org/TR/DOM-Level-3-Events/keyset.html#KeySet-Set
 * This is currently supported in Safari and should be platform independent.
 * @type {Object}
 * @private
 */
goog.events.KeyHandler.keyIdentifier_ = {
  'Up': goog.events.KeyCodes.UP, // 38
  'Down': goog.events.KeyCodes.DOWN, // 40
  'Left': goog.events.KeyCodes.LEFT, // 37
  'Right': goog.events.KeyCodes.RIGHT, // 39
  'Enter': goog.events.KeyCodes.ENTER, // 13
  'F1': goog.events.KeyCodes.F1, // 112
  'F2': goog.events.KeyCodes.F2, // 113
  'F3': goog.events.KeyCodes.F3, // 114
  'F4': goog.events.KeyCodes.F4, // 115
  'F5': goog.events.KeyCodes.F5, // 116
  'F6': goog.events.KeyCodes.F6, // 117
  'F7': goog.events.KeyCodes.F7, // 118
  'F8': goog.events.KeyCodes.F8, // 119
  'F9': goog.events.KeyCodes.F9, // 120
  'F10': goog.events.KeyCodes.F10, // 121
  'F11': goog.events.KeyCodes.F11, // 122
  'F12': goog.events.KeyCodes.F12, // 123
  'U+007F': goog.events.KeyCodes.DELETE, // 46
  'Home': goog.events.KeyCodes.HOME, // 36
  'End': goog.events.KeyCodes.END, // 35
  'PageUp': goog.events.KeyCodes.PAGE_UP, // 33
  'PageDown': goog.events.KeyCodes.PAGE_DOWN, // 34
  'Insert': goog.events.KeyCodes.INSERT // 45
};


/**
 * If true, the KeyEvent fires on keydown. Otherwise, it fires on keypress.
 *
 * @type {boolean}
 * @private
 */
goog.events.KeyHandler.USES_KEYDOWN_ = goog.userAgent.IE ||
    goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('525');


/**
 * If true, the alt key flag is saved during the key down and reused when
 * handling the key press. FF on Mac does not set the alt flag in the key press
 * event.
 * @type {boolean}
 * @private
 */
goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ = goog.userAgent.MAC &&
    goog.userAgent.GECKO;


/**
 * Records the keycode for browsers that only returns the keycode for key up/
 * down events. For browser/key combinations that doesn't trigger a key pressed
 * event it also fires the patched key event.
 * @param {goog.events.BrowserEvent} e The key down event.
 * @private
 */
goog.events.KeyHandler.prototype.handleKeyDown_ = function(e) {
  // Ctrl-Tab and Alt-Tab can cause the focus to be moved to another window
  // before we've caught a key-up event.  If the last-key was one of these we
  // reset the state.
  if (goog.userAgent.WEBKIT) {
    if (this.lastKey_ == goog.events.KeyCodes.CTRL && !e.ctrlKey ||
        this.lastKey_ == goog.events.KeyCodes.ALT && !e.altKey ||
        goog.userAgent.MAC &&
        this.lastKey_ == goog.events.KeyCodes.META && !e.metaKey) {
      this.lastKey_ = -1;
      this.keyCode_ = -1;
    }
  }

  if (this.lastKey_ == -1) {
    if (e.ctrlKey && e.keyCode != goog.events.KeyCodes.CTRL) {
      this.lastKey_ = goog.events.KeyCodes.CTRL;
    } else if (e.altKey && e.keyCode != goog.events.KeyCodes.ALT) {
      this.lastKey_ = goog.events.KeyCodes.ALT;
    } else if (e.metaKey && e.keyCode != goog.events.KeyCodes.META) {
      this.lastKey_ = goog.events.KeyCodes.META;
    }
  }

  if (goog.events.KeyHandler.USES_KEYDOWN_ &&
      !goog.events.KeyCodes.firesKeyPressEvent(e.keyCode,
          this.lastKey_, e.shiftKey, e.ctrlKey, e.altKey)) {
    this.handleEvent(e);
  } else {
    this.keyCode_ = goog.events.KeyCodes.normalizeKeyCode(e.keyCode);
    if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) {
      this.altKey_ = e.altKey;
    }
  }
};


/**
 * Resets the stored previous values. Needed to be called for webkit which will
 * not generate a key up for meta key operations. This should only be called
 * when having finished with repeat key possiblities.
 */
goog.events.KeyHandler.prototype.resetState = function() {
  this.lastKey_ = -1;
  this.keyCode_ = -1;
};


/**
 * Clears the stored previous key value, resetting the key repeat status. Uses
 * -1 because the Safari 3 Windows beta reports 0 for certain keys (like Home
 * and End.)
 * @param {goog.events.BrowserEvent} e The keyup event.
 * @private
 */
goog.events.KeyHandler.prototype.handleKeyup_ = function(e) {
  this.resetState();
  this.altKey_ = e.altKey;
};


/**
 * Handles the events on the element.
 * @param {goog.events.BrowserEvent} e  The keyboard event sent from the
 *     browser.
 */
goog.events.KeyHandler.prototype.handleEvent = function(e) {
  var be = e.getBrowserEvent();
  var keyCode, charCode;
  var altKey = be.altKey;

  // IE reports the character code in the keyCode field for keypress events.
  // There are two exceptions however, Enter and Escape.
  if (goog.userAgent.IE && e.type == goog.events.EventType.KEYPRESS) {
    keyCode = this.keyCode_;
    charCode = keyCode != goog.events.KeyCodes.ENTER &&
        keyCode != goog.events.KeyCodes.ESC ?
            be.keyCode : 0;

  // Safari reports the character code in the keyCode field for keypress
  // events but also has a charCode field.
  } else if (goog.userAgent.WEBKIT &&
      e.type == goog.events.EventType.KEYPRESS) {
    keyCode = this.keyCode_;
    charCode = be.charCode >= 0 && be.charCode < 63232 &&
        goog.events.KeyCodes.isCharacterKey(keyCode) ?
            be.charCode : 0;

  // Opera reports the keycode or the character code in the keyCode field.
  } else if (goog.userAgent.OPERA) {
    keyCode = this.keyCode_;
    charCode = goog.events.KeyCodes.isCharacterKey(keyCode) ?
        be.keyCode : 0;

  // Mozilla reports the character code in the charCode field.
  } else {
    keyCode = be.keyCode || this.keyCode_;
    charCode = be.charCode || 0;
    if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) {
      altKey = this.altKey_;
    }
    // On the Mac, shift-/ triggers a question mark char code and no key code
    // (normalized to WIN_KEY), so we synthesize the latter.
    if (goog.userAgent.MAC &&
        charCode == goog.events.KeyCodes.QUESTION_MARK &&
        keyCode == goog.events.KeyCodes.WIN_KEY) {
      keyCode = goog.events.KeyCodes.SLASH;
    }
  }

  keyCode = goog.events.KeyCodes.normalizeKeyCode(keyCode);
  var key = keyCode;
  var keyIdentifier = be.keyIdentifier;

  // Correct the key value for certain browser-specific quirks.
  if (keyCode) {
    if (keyCode >= 63232 && keyCode in goog.events.KeyHandler.safariKey_) {
      // NOTE(nicksantos): Safari 3 has fixed this problem,
      // this is only needed for Safari 2.
      key = goog.events.KeyHandler.safariKey_[keyCode];
    } else {

      // Safari returns 25 for Shift+Tab instead of 9.
      if (keyCode == 25 && e.shiftKey) {
        key = 9;
      }
    }
  } else if (keyIdentifier &&
             keyIdentifier in goog.events.KeyHandler.keyIdentifier_) {
    // This is needed for Safari Windows because it currently doesn't give a
    // keyCode/which for non printable keys.
    key = goog.events.KeyHandler.keyIdentifier_[keyIdentifier];
  }

  // If we get the same keycode as a keydown/keypress without having seen a
  // keyup event, then this event was caused by key repeat.
  var repeat = key == this.lastKey_;
  this.lastKey_ = key;

  var event = new goog.events.KeyEvent(key, charCode, repeat, be);
  event.altKey = altKey;
  this.dispatchEvent(event);
};


/**
 * Returns the element listened on for the real keyboard events.
 * @return {Element|Document|null} The element listened on for the real
 *     keyboard events.
 */
goog.events.KeyHandler.prototype.getElement = function() {
  return this.element_;
};


/**
 * Adds the proper key event listeners to the element.
 * @param {Element|Document} element The element to listen on.
 * @param {boolean=} opt_capture Whether to listen for browser events in
 *     capture phase (defaults to false).
 */
goog.events.KeyHandler.prototype.attach = function(element, opt_capture) {
  if (this.keyUpKey_) {
    this.detach();
  }

  this.element_ = element;

  this.keyPressKey_ = goog.events.listen(this.element_,
                                         goog.events.EventType.KEYPRESS,
                                         this,
                                         opt_capture);

  // Most browsers (Safari 2 being the notable exception) doesn't include the
  // keyCode in keypress events (IE has the char code in the keyCode field and
  // Mozilla only included the keyCode if there's no charCode). Thus we have to
  // listen for keydown to capture the keycode.
  this.keyDownKey_ = goog.events.listen(this.element_,
                                        goog.events.EventType.KEYDOWN,
                                        this.handleKeyDown_,
                                        opt_capture,
                                        this);


  this.keyUpKey_ = goog.events.listen(this.element_,
                                      goog.events.EventType.KEYUP,
                                      this.handleKeyup_,
                                      opt_capture,
                                      this);
};


/**
 * Removes the listeners that may exist.
 */
goog.events.KeyHandler.prototype.detach = function() {
  if (this.keyPressKey_) {
    goog.events.unlistenByKey(this.keyPressKey_);
    goog.events.unlistenByKey(this.keyDownKey_);
    goog.events.unlistenByKey(this.keyUpKey_);
    this.keyPressKey_ = null;
    this.keyDownKey_ = null;
    this.keyUpKey_ = null;
  }
  this.element_ = null;
  this.lastKey_ = -1;
  this.keyCode_ = -1;
};


/** @override */
goog.events.KeyHandler.prototype.disposeInternal = function() {
  goog.events.KeyHandler.superClass_.disposeInternal.call(this);
  this.detach();
};



/**
 * This class is used for the goog.events.KeyHandler.EventType.KEY event and
 * it overrides the key code with the fixed key code.
 * @param {number} keyCode The adjusted key code.
 * @param {number} charCode The unicode character code.
 * @param {boolean} repeat Whether this event was generated by keyboard repeat.
 * @param {Event} browserEvent Browser event object.
 * @constructor
 * @extends {goog.events.BrowserEvent}
 * @final
 */
goog.events.KeyEvent = function(keyCode, charCode, repeat, browserEvent) {
  goog.events.BrowserEvent.call(this, browserEvent);
  this.type = goog.events.KeyHandler.EventType.KEY;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = keyCode;

  /**
   * Unicode character code.
   * @type {number}
   */
  this.charCode = charCode;

  /**
   * True if this event was generated by keyboard auto-repeat (i.e., the user is
   * holding the key down.)
   * @type {boolean}
   */
  this.repeat = repeat;
};
goog.inherits(goog.events.KeyEvent, goog.events.BrowserEvent);
goog.provide('feng.apps.PathEdit');

goog.require('goog.dom');
goog.require('goog.events.KeyHandler');
goog.require('goog.events.MouseWheelHandler');
goog.require('goog.fx.anim');
goog.require('feng.templates.main');
goog.require('feng.fx.EnergyFlow');
goog.require('feng.fx.PathTrack');
goog.require('feng.models.Preload');
goog.require('feng.views.Preloader');
goog.require('feng.views.View3D');
goog.require('feng.views.debug.Debugger');
goog.require('feng.PubSub');


feng.apps.PathEdit = function() {

	goog.base(this);

	goog.fx.anim.setAnimationWindow(window);

	feng.pubsub = feng.PubSub.getInstance();

	this._preloader = new feng.views.Preloader(null, 250);

	this._sceneKeys = [
		'studio.livingroom',
		'studio.bathroom',
		'house.livingroom',
		'house.corridor',
		'house.boysroom',
		'house.homeoffice'
	];

	this._scene = null;
	this._scenes = [];
	this._camera = null;
	this._editCamera = null;
	this._motionCamera = null;
	this._motionCameraHelper = null;
	this._renderer = null;
	this._controls = null;
	this._pathTrack = null;

	this._mousePosition = new THREE.Vector3();
	this._offset = new THREE.Vector3();
	this._intersect = null;
	this._controlPoint = null;

	this._motionTweener = null;

	this._keyHandler = null;
	this._mouseWheelHandler = null;
	this._zoomFactor = 1;
	this._zoom = 1;
	this._isObjectsShown = true;

	this.init();
};
goog.inherits(feng.apps.PathEdit, goog.events.EventTarget);
goog.addSingletonGetter(feng.apps.PathEdit);


feng.apps.PathEdit.prototype.init = function() {

	var mainFrag = soy.renderAsFragment(feng.templates.main.Spline);
	goog.dom.appendChild(document.body, mainFrag);

	var domElement = goog.dom.getElement('spline');
	var canvas = goog.dom.query('canvas', domElement)[0];

	this._renderer = new THREE.WebGLRenderer({
		canvas: canvas,
		antialias: true
	});
	this._renderer.setClearColor(0xFFFDF1, 1);
	this._renderer.setSize( window.innerWidth, window.innerHeight );

	this._editCamera = new THREE.CombinedCamera( window.innerWidth, window.innerHeight, 45, 1, 10000, 1, 10000 );
	this._editCamera.position.x = 500;
	this._editCamera.position.y = 500;
	this._editCamera.position.z = 500;

	this._motionCamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );

	this._camera = this._editCamera;

	this._keyHandler = new goog.events.KeyHandler( document );
	goog.events.listen(this._keyHandler, 'key', this.onKey, false, this);

	this._mouseWheelHandler = new goog.events.MouseWheelHandler( this._renderer.domElement );
	goog.events.listen(this._mouseWheelHandler, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.onMouseWheel, false, this);

	goog.events.listen(this._renderer.domElement, 'mousedown', this.onMouseDown, false, this);
	goog.events.listen(window, 'resize', this.onResize, false, this);

	this._controls = new THREE.OrbitControls(this._camera, this._renderer.domElement);
	this._controls.noZoom = true;
	this._controls.noKeys = true;

	var assetKeys = [];
	goog.array.extend(assetKeys, this._sceneKeys, 'global');

	this._preloader.load( assetKeys );
	goog.events.listenOnce(this._preloader, feng.events.EventType.LOAD_COMPLETE, this.onLoadComplete, false, this);
};


feng.apps.PathEdit.prototype.getDefaultPathTrack = function() {

	var pathTrack = goog.array.find(this._scene.children, function(child) {
  	return (child instanceof feng.fx.PathTrack);
  });

  return pathTrack;
};


feng.apps.PathEdit.prototype.highlightControl = function() {

	var pointIndex = goog.array.indexOf(this._pathTrack.controlPoints, this._controlPoint);

	var cubeName = 'cube' + pointIndex;

	var cube = this._pathTrack.getControlCubeByName(cubeName);
	cube.material.opacity = 1;
};


feng.apps.PathEdit.prototype.showObjects = function(shouldShow) {

	this._isObjectsShown = shouldShow;

	goog.array.forEach(this._scene.children, function(child) {
		if(!(child instanceof feng.fx.PathTrack)) {
			child.visible = shouldShow;
		}
	});
};


feng.apps.PathEdit.prototype.updateMotionTweener = function() {

	var tempProgress = this._motionTweener ? this._motionTweener.progress() : 0;
	this._motionTweener = null;
	this.onPlay();
	this._motionTweener.progress(tempProgress);
	this.onPause();
};


feng.apps.PathEdit.prototype.render = function() {

	this._renderer.render(this._scene, this._camera);
};


feng.apps.PathEdit.prototype.onLoadComplete = function(e) {

	var view3dScenes = goog.array.map(this._sceneKeys, function(sceneKey) {

		var preloadModel = feng.models.Preload.getInstance();

		var sectionId = sceneKey.split('.')[0];
		var sceneId = sceneKey.split('.')[1];
		
		var constructed = feng.views.View3D.constructScene( sectionId, sceneId );
		var scene = constructed.scene;

		var motionCameraHelper = new THREE.CameraHelper( this._motionCamera );
		motionCameraHelper.name = 'motionCameraHelper';
		scene.add( motionCameraHelper );

		var coordinates = [
			new THREE.Vector3(100, 40, 0),
			new THREE.Vector3(-30, 50, -50),
			new THREE.Vector3(-100, 50, -200)
		];

		var pathTrack = new feng.fx.EnergyFlow(coordinates, true, feng.fx.EnergyFlow.Preset.JI);
		scene.add( pathTrack );

		return scene;
	}, this);

	goog.array.extend( this._scenes, view3dScenes );

	this._scene = this._scenes[0];
	this._scene.add( this._editCamera );
	this._scene.add( this._motionCamera );

	this._motionCameraHelper = this._scene.getObjectByName('motionCameraHelper');

	this._pathTrack = this.getDefaultPathTrack();
	this._controlPoint = this._pathTrack.controlPoints[0];
	this.highlightControl();

	//
	goog.fx.anim.registerAnimation(this);

	// create debugger
	feng.views.debug.Debugger.Options.CAMERA = false;
	feng.views.debug.Debugger.Options.PATHFINDING = false;
	feng.views.debug.Debugger.Options.MANIPULATE = false;
	feng.views.debug.Debugger.Options.ACHIEVEMENTS = false;
	feng.views.debug.Debugger.Options.PATH_TRACK = true;
	
	feng.views.debug.Debugger.getInstance();

	goog.events.listen(this, feng.events.EventType.ADD, this.onAddControlPoint, false, this);
	goog.events.listen(this, feng.events.EventType.REMOVE, this.onRemoveControlPoint, false, this);
	goog.events.listen(this, feng.events.EventType.CHANGE, this.onChange, false, this);
	goog.events.listen(this, feng.events.EventType.PLAY, this.onPlay, false, this);
	goog.events.listen(this, feng.events.EventType.PAUSE, this.onPause, false, this);
	goog.events.listen(this, feng.events.EventType.PROGRESS, this.onProgress, false, this);

	//
	this.dispatchEvent({
		type: e.type,
		scenes: this._scenes
	});

	this.dispatchEvent({
  	type: feng.events.EventType.CHANGE,
  	controlPoint: this._controlPoint,
  	pathTrack: this._pathTrack
  });
};


feng.apps.PathEdit.prototype.onChange = function(e) {

	if(e.fly === true) {

		this._camera = this._motionCamera;

	}else if(e.fly === false) {

		this._camera = this._editCamera;
	}

	if(e.sceneName) {
		this._scene = goog.array.find(this._scenes, function(scene) {
			return scene.name === e.sceneName;
		});

		this._scene.add( this._editCamera );
		this._scene.add( this._motionCamera );

		if(this._pathTrack) this._pathTrack.deactivate();

	  this._pathTrack = this.getDefaultPathTrack();
	  this._pathTrack.activate();

	  this._controlPoint = this._pathTrack.controlPoints[0];
	  this.highlightControl();

  	this._motionCameraHelper = this._scene.getObjectByName('motionCameraHelper');

		this.updateMotionTweener();

		this.showObjects(true);

		this.dispatchEvent({
	  	type: feng.events.EventType.CHANGE,
	  	controlPoint: this._controlPoint,
	  	pathTrack: this._pathTrack
	  });
	}
};


feng.apps.PathEdit.prototype.onPlay = function(e) {

	if(!this._motionTweener) {

		var prop = {
			progress: 0
		};

		this._motionTweener = TweenMax.to(prop, 10, {
			progress: 1,
			ease: Linear.easeNone,
			onUpdate: this.onProgress,
			onUpdateParams: [prop],
			onUpdateScope: this,
			onComplete: this.onComplete,
			onCompleteScope: this
		});
	}

	if(this._motionTweener.progress() === 1) {
		this._motionTweener.restart();
	}else {
		this._motionTweener.play();
	}
};


feng.apps.PathEdit.prototype.onProgress = function(e) {

	//
	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		progress: e.progress
	});

	//
	var pathCamera = this._pathTrack.getCameraAt( e.progress );

	this._motionCamera.position.copy( pathCamera.position );
	this._motionCamera.rotation.copy( pathCamera.rotation );
};


feng.apps.PathEdit.prototype.onPause = function(e) {

	this._motionTweener.pause();
};


feng.apps.PathEdit.prototype.onComplete = function(e) {

	this.dispatchEvent({
		type: feng.events.EventType.CHANGE,
		complete: true
	});
};


feng.apps.PathEdit.prototype.onAddControlPoint = function(e) {

	if(this._controlPoint) {

		this._pathTrack.addControlPoint( this._controlPoint );

		var currentControlId = goog.array.indexOf(this._pathTrack.controlPoints, this._controlPoint);
		var nextControlId = currentControlId + 1;
		this._controlPoint = this._pathTrack.controlPoints[nextControlId];

		this._pathTrack.updateTrack();
		this.highlightControl();
	}
};


feng.apps.PathEdit.prototype.onRemoveControlPoint = function(e) {

	if(this._controlPoint) {
		var currentControlId = goog.array.indexOf(this._pathTrack.controlPoints, this._controlPoint);
		var nextControlId = Math.max(0, currentControlId-1);

		if(currentControlId === nextControlId) {
			if(this._pathTrack.controlPoints.length <= 1) {
				return;
			}
		}

		var controlToRemove = this._controlPoint;

		this._controlPoint = this._pathTrack.controlPoints[nextControlId];

		this._pathTrack.removeControlPoint( controlToRemove );

		this._pathTrack.updateTrack();
		this.highlightControl();
	}
};


feng.apps.PathEdit.prototype.onMouseDown = function(e) {

	this._mousePosition.x = (e.clientX / window.innerWidth) * 2 - 1;
	this._mousePosition.y = -(e.clientY / window.innerHeight) * 2 + 1;

  var projector = new THREE.Projector();
  var raycaster = projector.pickingRay( this._mousePosition, this._camera );

  var pathTracksChildren = [];

  goog.array.forEach(this._scene.children, function(child) {
  	if(child instanceof feng.fx.PathTrack) {
  		goog.array.extend(pathTracksChildren, child.getControlMeshes());
  	}
  });

  var intersects = raycaster.intersectObjects( pathTracksChildren );

  if(intersects.length > 0) {

  	var intersect = intersects[0];

  	if(intersect.object instanceof THREE.Mesh) {

  		this._intersect = intersect;
  		this._pathTrack = this._intersect.object.parent.parent;
	  	this._controlPoint = this._intersect.object.userData.position;

	    this._offset.copy( this._intersect.point ).sub( this._controlPoint );

	    this._controls.enabled = false;

			goog.events.listen(document, 'mousemove', this.onMouseMove, false, this);
			goog.events.listen(document, 'mouseup', this.onMouseUp, false, this);

			this._pathTrack.updateTrack();
			this.highlightControl();
  	}
  }

  this.dispatchEvent({
  	type: feng.events.EventType.CHANGE,
  	controlPoint: this._controlPoint,
  	pathTrack: this._pathTrack
  });
};


feng.apps.PathEdit.prototype.onMouseMove = function(e) {

	this._mousePosition.x = (e.clientX / window.innerWidth) * 2 - 1;
	this._mousePosition.y = -(e.clientY / window.innerHeight) * 2 + 1;

  var projector = new THREE.Projector();
  var raycaster = projector.pickingRay( this._mousePosition, this._camera );
  var ray = raycaster.ray;

  var targetPos = ray.direction.clone().multiplyScalar( this._intersect.distance ).add( ray.origin );
  targetPos.sub(this._offset);

  this._controlPoint.copy( targetPos );

  this._pathTrack.updateTrack();

  this.highlightControl();

  // refresh progress of new spline
	this.updateMotionTweener();

	this.dispatchEvent({
  	type: feng.events.EventType.CHANGE,
  	controlPoint: this._controlPoint
  });
};


feng.apps.PathEdit.prototype.onMouseUp = function(e) {

	this._controls.enabled = true;

	goog.events.unlisten(document, 'mousemove', this.onMouseMove, false, this);
	goog.events.unlisten(document, 'mouseup', this.onMouseUp, false, this);
};


feng.apps.PathEdit.prototype.onKey = function(e) {

	switch(e.target.tagName) {
		case goog.dom.TagName.TEXTAREA:
		case goog.dom.TagName.INPUT:
		return false;
		break;
	};

	e.preventDefault();

	switch(e.keyCode) {
		case goog.events.KeyCodes.TAB:
		if(this._editCamera.inPerspectiveMode) {
			this._zoomFactor = 10;
			this._editCamera.toOrthographic();
			this._editCamera.setZoom(this._zoom * this._zoomFactor);
		}else {
			this._zoomFactor = 1;
			this._editCamera.toPerspective();
			this._editCamera.setZoom(this._zoom * this._zoomFactor);
		}
		break;

		case goog.events.KeyCodes.ONE:
		this._editCamera.position.x = 0;
		this._editCamera.position.y = 500;
		this._editCamera.position.z = 0;
		break;

		case goog.events.KeyCodes.TWO:
		this._editCamera.position.x = 0;
		this._editCamera.position.y = -500;
		this._editCamera.position.z = 0;
		break;

		case goog.events.KeyCodes.THREE:
		this._editCamera.position.x = 500;
		this._editCamera.position.y = 0;
		this._editCamera.position.z = 0;
		break;

		case goog.events.KeyCodes.FOUR:
		this._editCamera.position.x = -500;
		this._editCamera.position.y = 0;
		this._editCamera.position.z = 0;
		break;

		case goog.events.KeyCodes.FIVE:
		this._editCamera.position.x = 0;
		this._editCamera.position.y = 0;
		this._editCamera.position.z = 500;
		break;

		case goog.events.KeyCodes.SIX:
		this._editCamera.position.x = 0;
		this._editCamera.position.y = 0;
		this._editCamera.position.z = -500;
		break;

		case goog.events.KeyCodes.EQUALS:
		this.onAddControlPoint();
		break;

		case goog.events.KeyCodes.DASH:
		this.onRemoveControlPoint();
		break;

		case goog.events.KeyCodes.C:
		var shouldFly = (this._camera === this._editCamera);
		this.dispatchEvent({
			type: feng.events.EventType.CHANGE,
			fly: shouldFly
		});
		break;

		case goog.events.KeyCodes.H:
		this._isObjectsShown = !this._isObjectsShown;
		this.showObjects( this._isObjectsShown );
		break;
	};
};


feng.apps.PathEdit.prototype.onMouseWheel = function(e) {

	e.preventDefault();

	if(e.deltaY > 0) {

		this._zoom /= 1.1;
	}else {

		this._zoom *= 1.1;
	}

	this._editCamera.setZoom( this._zoom * this._zoomFactor );
};


feng.apps.PathEdit.prototype.onAnimationFrame = function(now) {

	this._controls.update();
	this.render();
};


feng.apps.PathEdit.prototype.onResize = function(e) {

	this._editCamera.setSize( window.innerWidth, window.innerHeight );
	this._editCamera.updateProjectionMatrix();	

	this._motionCamera.aspect = window.innerWidth / window.innerHeight;
	this._motionCamera.updateProjectionMatrix();		

	this._renderer.setSize( window.innerWidth, window.innerHeight );

	this.render();
};// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Abstract interface for storing and retrieving data using
 * some persistence mechanism.
 *
 */

goog.provide('goog.storage.mechanism.Mechanism');



/**
 * Basic interface for all storage mechanisms.
 *
 * @constructor
 */
goog.storage.mechanism.Mechanism = function() {};


/**
 * Set a value for a key.
 *
 * @param {string} key The key to set.
 * @param {string} value The string to save.
 */
goog.storage.mechanism.Mechanism.prototype.set = goog.abstractMethod;


/**
 * Get the value stored under a key.
 *
 * @param {string} key The key to get.
 * @return {?string} The corresponding value, null if not found.
 */
goog.storage.mechanism.Mechanism.prototype.get = goog.abstractMethod;


/**
 * Remove a key and its value.
 *
 * @param {string} key The key to remove.
 */
goog.storage.mechanism.Mechanism.prototype.remove = goog.abstractMethod;
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for storing, retieving and scanning data using some
 * persistence mechanism.
 *
 */

goog.provide('goog.storage.mechanism.IterableMechanism');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.iter');
goog.require('goog.iter.Iterator');
goog.require('goog.storage.mechanism.Mechanism');



/**
 * Interface for all iterable storage mechanisms.
 *
 * @constructor
 * @extends {goog.storage.mechanism.Mechanism}
 */
goog.storage.mechanism.IterableMechanism = function() {
  goog.base(this);
};
goog.inherits(goog.storage.mechanism.IterableMechanism,
              goog.storage.mechanism.Mechanism);


/**
 * Get the number of stored key-value pairs.
 *
 * Could be overridden in a subclass, as the default implementation is not very
 * efficient - it iterates over all keys.
 *
 * @return {number} Number of stored elements.
 */
goog.storage.mechanism.IterableMechanism.prototype.getCount = function() {
  var count = 0;
  goog.iter.forEach(this.__iterator__(true), function(key) {
    goog.asserts.assertString(key);
    count++;
  });
  return count;
};


/**
 * Returns an iterator that iterates over the elements in the storage. Will
 * throw goog.iter.StopIteration after the last element.
 *
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} The iterator.
 */
goog.storage.mechanism.IterableMechanism.prototype.__iterator__ =
    goog.abstractMethod;


/**
 * Remove all key-value pairs.
 *
 * Could be overridden in a subclass, as the default implementation is not very
 * efficient - it iterates over all keys.
 */
goog.storage.mechanism.IterableMechanism.prototype.clear = function() {
  var keys = goog.iter.toArray(this.__iterator__(true));
  var selfObj = this;
  goog.array.forEach(keys, function(key) {
    selfObj.remove(key);
  });
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines error codes to be thrown by storage mechanisms.
 *
 */

goog.provide('goog.storage.mechanism.ErrorCode');


/**
 * Errors thrown by storage mechanisms.
 * @enum {string}
 */
goog.storage.mechanism.ErrorCode = {
  INVALID_VALUE: 'Storage mechanism: Invalid value was encountered',
  QUOTA_EXCEEDED: 'Storage mechanism: Quota exceeded',
  STORAGE_DISABLED: 'Storage mechanism: Storage disabled'
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Base class that implements functionality common
 * across both session and local web storage mechanisms.
 *
 */

goog.provide('goog.storage.mechanism.HTML5WebStorage');

goog.require('goog.asserts');
goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.storage.mechanism.ErrorCode');
goog.require('goog.storage.mechanism.IterableMechanism');



/**
 * Provides a storage mechanism that uses HTML5 Web storage.
 *
 * @param {Storage} storage The Web storage object.
 * @constructor
 * @extends {goog.storage.mechanism.IterableMechanism}
 */
goog.storage.mechanism.HTML5WebStorage = function(storage) {
  goog.base(this);

  /**
   * The web storage object (window.localStorage or window.sessionStorage).
   * @private {Storage}
   */
  this.storage_ = storage;
};
goog.inherits(goog.storage.mechanism.HTML5WebStorage,
              goog.storage.mechanism.IterableMechanism);


/**
 * The key used to check if the storage instance is available.
 * @private {string}
 * @const
 */
goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_ = '__sak';


/**
 * Determines whether or not the mechanism is available.
 * It works only if the provided web storage object exists and is enabled.
 *
 * @return {boolean} True if the mechanism is available.
 */
goog.storage.mechanism.HTML5WebStorage.prototype.isAvailable = function() {
  if (!this.storage_) {
    return false;
  }
  /** @preserveTry */
  try {
    // setItem will throw an exception if we cannot access WebStorage (e.g.,
    // Safari in private mode).
    this.storage_.setItem(
        goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_, '1');
    this.storage_.removeItem(
        goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_);
    return true;
  } catch (e) {
    return false;
  }
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.set = function(key, value) {
  /** @preserveTry */
  try {
    // May throw an exception if storage quota is exceeded.
    this.storage_.setItem(key, value);
  } catch (e) {
    // In Safari Private mode, conforming to the W3C spec, invoking
    // Storage.prototype.setItem will allways throw a QUOTA_EXCEEDED_ERR
    // exception.  Since it's impossible to verify if we're in private browsing
    // mode, we throw a different exception if the storage is empty.
    if (this.storage_.length == 0) {
      throw goog.storage.mechanism.ErrorCode.STORAGE_DISABLED;
    } else {
      throw goog.storage.mechanism.ErrorCode.QUOTA_EXCEEDED;
    }
  }
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.get = function(key) {
  // According to W3C specs, values can be of any type. Since we only save
  // strings, any other type is a storage error. If we returned nulls for
  // such keys, i.e., treated them as non-existent, this would lead to a
  // paradox where a key exists, but it does not when it is retrieved.
  // http://www.w3.org/TR/2009/WD-webstorage-20091029/#the-storage-interface
  var value = this.storage_.getItem(key);
  if (!goog.isString(value) && !goog.isNull(value)) {
    throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
  }
  return value;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.remove = function(key) {
  this.storage_.removeItem(key);
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.getCount = function() {
  return this.storage_.length;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.__iterator__ = function(
    opt_keys) {
  var i = 0;
  var storage = this.storage_;
  var newIter = new goog.iter.Iterator();
  newIter.next = function() {
    if (i >= storage.length) {
      throw goog.iter.StopIteration;
    }
    var key = goog.asserts.assertString(storage.key(i++));
    if (opt_keys) {
      return key;
    }
    var value = storage.getItem(key);
    // The value must exist and be a string, otherwise it is a storage error.
    if (!goog.isString(value)) {
      throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
    }
    return value;
  };
  return newIter;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.clear = function() {
  this.storage_.clear();
};


/**
 * Gets the key for a given key index. If an index outside of
 * [0..this.getCount()) is specified, this function returns null.
 * @param {number} index A key index.
 * @return {?string} A storage key, or null if the specified index is out of
 *     range.
 */
goog.storage.mechanism.HTML5WebStorage.prototype.key = function(index) {
  return this.storage_.key(index);
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides data persistence using HTML5 local storage
 * mechanism. Local storage must be available under window.localStorage,
 * see: http://www.w3.org/TR/webstorage/#the-localstorage-attribute.
 *
 */

goog.provide('goog.storage.mechanism.HTML5LocalStorage');

goog.require('goog.storage.mechanism.HTML5WebStorage');



/**
 * Provides a storage mechanism that uses HTML5 local storage.
 *
 * @constructor
 * @extends {goog.storage.mechanism.HTML5WebStorage}
 */
goog.storage.mechanism.HTML5LocalStorage = function() {
  var storage = null;
  /** @preserveTry */
  try {
    // May throw an exception in cases where the local storage object
    // is visible but access to it is disabled.
    storage = window.localStorage || null;
  } catch (e) {}
  goog.base(this, storage);
};
goog.inherits(goog.storage.mechanism.HTML5LocalStorage,
              goog.storage.mechanism.HTML5WebStorage);
goog.provide('feng.controllers.StorageController');

goog.require('goog.storage.mechanism.HTML5LocalStorage');

/**
 * @constructor
 */
feng.controllers.StorageController = function(){

  goog.base(this);

  if(!goog.isDef(this.isSoundEnabled())) {
    this.onSoundEnabled( true );
  }
};
goog.inherits(feng.controllers.StorageController, goog.storage.mechanism.HTML5LocalStorage);
goog.addSingletonGetter(feng.controllers.StorageController);


feng.controllers.StorageController.prototype.isEpisodeVisited = function( episodeId ){
  
  if( JSON.parse( this.get( 'episode-' + episodeId + '-visited' ) ) === true ) {

    return true;

  }else {

    return false;
  }
};


feng.controllers.StorageController.prototype.isTipUnlocked = function( tipId ){

  if( JSON.parse( this.get( 'tip-' + tipId + '-unlocked' ) ) === true ) {

    return true;
    
  }else {

    return false;
  }
};


feng.controllers.StorageController.prototype.isSoundEnabled = function(){

  if( JSON.parse( this.get( 'sound' ) ) === true ) {

    return true;
    
  }else if( JSON.parse( this.get( 'sound' ) ) === false ) {

    return false;
    
  }else {

    return undefined;
  }
};


feng.controllers.StorageController.prototype.onEpisodeVisited = function( episodeId ){
  
  this.set( 'episode-' + episodeId + '-visited', true );
};


feng.controllers.StorageController.prototype.onTipUnlocked = function( tipId ){
  
  this.set( 'tip-' + tipId + '-unlocked', true );
};


feng.controllers.StorageController.prototype.onSoundEnabled = function( enabled ){
  
  this.set( 'sound', enabled );
};goog.provide('feng.views.popups.Popup');

goog.require('goog.async.Delay');
goog.require('goog.dom');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');


/**
 * @constructor
 */
feng.views.popups.Popup = function(domElement){

	goog.base( this );

  this.domElement = domElement;

  this._isShown = false;

  this._eventHandler = new goog.events.EventHandler(this);

  this._defaultAnimateInDelay = 0;

  this._animateInDelay = new goog.async.Delay( this.doAnimateIn, this._defaultAnimateInDelay, this );

  this._onAnimatedInDelay = new goog.async.Delay( this.onAnimatedIn, 1000, this );

  this._onAnimatedOutDelay = new goog.async.Delay( this.onAnimatedOut, 250, this );
};
goog.inherits(feng.views.popups.Popup, goog.events.EventTarget);


feng.views.popups.Popup.prototype.activate = function() {

};


feng.views.popups.Popup.prototype.deactivate = function() {

	this._eventHandler.removeAll();

	this._onAnimatedInDelay.stop();
	this._onAnimatedOutDelay.stop();
};


feng.views.popups.Popup.prototype.toggle = function() {

	if(!this._isShown) this.animateIn();
	else this.animateOut();
};


feng.views.popups.Popup.prototype.animateIn = function( delay ) {

	var delay = goog.isNumber(delay) ? delay : this._defaultAnimateInDelay;
	this._animateInDelay.start( delay );

	this.dispatchEvent( feng.events.EventType.ANIMATE_IN );
};


feng.views.popups.Popup.prototype.doAnimateIn = function() {

	this._isShown = true;

	goog.dom.classlist.add( this.domElement, 'shown' );

	this._animateInDelay.stop();
	this._onAnimatedOutDelay.stop();

	this._onAnimatedInDelay.start();
};


feng.views.popups.Popup.prototype.animateOut = function() {

	this.deactivate();

	goog.dom.classlist.remove( this.domElement, 'shown' );

	feng.soundController.playSfx('close');

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	this._animateInDelay.stop();
	this._onAnimatedInDelay.stop();

	this._onAnimatedOutDelay.start();
};


feng.views.popups.Popup.prototype.onAnimatedIn = function() {

	this.activate();
};


feng.views.popups.Popup.prototype.onAnimatedOut = function() {

	this._isShown = false;

	this.dispatchEvent( feng.events.EventType.CLOSE );
};goog.provide('feng.views.popups.Tutorial');

goog.require('feng.views.popups.Popup');
goog.require('feng.templates.common');


/**
 * @constructor
 */
feng.views.popups.Tutorial = function(){

	var data = {
		assetsPath: feng.Config['assetsPath']
	};

	var domElement = soy.renderAsFragment(feng.templates.common.TutorialPopup, data);
	
	goog.base( this, domElement );

	// steps
	this._videoEls = goog.dom.query('video', this.domElement);
	this._stepEls = goog.dom.query('.steps li', this.domElement);
	this._titleEls = goog.dom.query('.title li', this.domElement);

	goog.array.forEach(this._videoEls, function(videoEl) {
		goog.style.setStyle( videoEl, 'visibility', 'hidden' );
	}, this);

	this._step = -1;
	this._totalSteps = this._stepEls.length;

	this._videoEl = null;
	this._stepEl = null;

	this._numLoaded = 0;
	this._isLoaded = false;

	this._enterKeyId = null;
	this._escKeyId = null;
	this._animateOut = goog.bind(this.animateOut, this);

	// buttons
	this._prevButton = goog.dom.query('.prev', this.domElement)[0];
	this._nextButton = goog.dom.query('.next', this.domElement)[0];

	// loader
	this._controlsEl = goog.dom.getElementByClass('controls', this.domElement);
	this._loaderEl = goog.dom.getElementByClass('loader', this.domElement);
	this._fillEl = goog.dom.getElementByClass('fill', this.domElement);
	this._counterEl = goog.dom.getElementByClass('counter', this.domElement);

	this._skipButton = goog.dom.getElementByClass('skip', this.domElement);
};
goog.inherits(feng.views.popups.Tutorial, feng.views.popups.Popup);
goog.addSingletonGetter(feng.views.popups.Tutorial);


feng.views.popups.Tutorial.prototype.prevStep = function(){

	var step = Math.max(0, this._step - 1);

	if(this._step !== step) {

		this.gotoStep( step );
	}
};


feng.views.popups.Tutorial.prototype.nextStep = function(){

	var step = Math.min(this._totalSteps - 1, this._step + 1);

	if(this._step !== step) {

		this.gotoStep( step );
	}
};


feng.views.popups.Tutorial.prototype.gotoStep = function( step ){

	this._step = step;

	// handle last step
	if(this._videoEl && this._stepEl && this._titleEl) {

		this._videoEl.pause();
		this._eventHandler.unlisten( this._videoEl, 'ended', this.onVideoEnded, false, this );
		
		goog.dom.classlist.remove( this._titleEl, 'active' );
		goog.dom.classlist.remove( this._stepEl, 'active' );
	}

	this._prevButton.disabled = false;
	this._nextButton.disabled = false;

	if(this._step === 0) {

		this._prevButton.disabled = true;

	}else if(this._step === this._totalSteps - 1) {

		this._nextButton.disabled = true;

		goog.dom.classlist.enable( this._controlsEl, 'hidden', false );
	}

	this._titleEl = this._titleEls[ this._step ];
	this._stepEl = this._stepEls[ this._step ];

	goog.dom.classlist.add( this._titleEl, 'active' );
	goog.dom.classlist.add( this._stepEl, 'active' );

	this._videoEl = this._videoEls[ this._step ];
	this._videoEl.currentTime = 0;
	this._videoEl.play();
	
	this._eventHandler.listenOnce( this._videoEl, 'ended', this.onVideoEnded, false, this );
};


feng.views.popups.Tutorial.prototype.animateIn = function(){

	goog.base(this, 'animateIn', 200);
};


feng.views.popups.Tutorial.prototype.activate = function(){

	goog.base(this, 'activate');

	this._eventHandler.listen( this._skipButton, 'click', this.animateOut, false, this );
	this._eventHandler.listen( this._prevButton, 'click', this.prevStep, false, this );
	this._eventHandler.listen( this._nextButton, 'click', this.nextStep, false, this );

	this._enterKeyId = feng.keyboardController.bind( this._animateOut, feng.keyboardController.key.ENTER, true );
	this._escKeyId = feng.keyboardController.bind( this._animateOut, feng.keyboardController.key.ESC, true );

	if(!this._isLoaded) {

		goog.array.forEach(this._videoEls, function(videoEl) {
			videoEl.load();
			this._eventHandler.listenOnce( videoEl, 'canplay', this.onVideoCanPlay, false, this );
		}, this);

	}else {

		this.gotoStep( 0 );
	}
};


feng.views.popups.Tutorial.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	this._videoEl.pause();

	feng.keyboardController.unbind( this._enterKeyId );
	feng.keyboardController.unbind( this._escKeyId );
};


feng.views.popups.Tutorial.prototype.showLoader = function(){

	TweenMax.fromTo(this._loaderEl, .25, {
		'opacity': 0,
		'y': 20
	}, {
		'opacity': 1,
		'y': 0,
		'display': 'block',
		'ease': Strong.easeInOut
	});

	TweenMax.set(this._skipButton, {
		'display': 'none'
	});
};


feng.views.popups.Tutorial.prototype.showSkipButton = function(){

	TweenMax.to(this._loaderEl, .25, {
		'opacity': 0,
		'y': 20,
		'display': 'none',
		'ease': Strong.easeInOut
	});

	TweenMax.fromTo(this._skipButton, .25, {
		'display': 'none',
		'opacity': 0,
		'y': 20
	}, {
		'delay': .6,
		'opacity': 1,
		'y': 0,
		'display': 'block',
		'ease': Strong.easeInOut
	});
};


feng.views.popups.Tutorial.prototype.setProgress = function(progress){

	var progress = Math.round( progress * 100 );

	goog.style.setStyle( this._fillEl, 'width', progress + '%' );

	this._counterEl.innerHTML = ((progress > 9) ? progress : ('0' + progress)) + '%';
};


feng.views.popups.Tutorial.prototype.setBuffering = function(){

	this._counterEl.innerHTML = "Preparing for your visit";
};


feng.views.popups.Tutorial.prototype.onVideoCanPlay = function(e){

	this._numLoaded ++;

	if(this._numLoaded >= this._totalSteps) {

		this._isLoaded = true;

		if(this._isShown) {

			this.gotoStep( 0 );
		}
	}

	goog.style.setStyle( e.currentTarget, 'visibility', 'visible' );
};


feng.views.popups.Tutorial.prototype.onVideoEnded = function(e){

	e.currentTarget.play();
};


feng.views.popups.Tutorial.prototype.onAnimatedOut = function() {

	goog.base(this, 'onAnimatedOut');

	this.gotoStep( 0 );
};// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for detecting, adding and removing classes.  Prefer
 * this over goog.dom.classes for new code since it attempts to use classList
 * (DOMTokenList: http://dom.spec.whatwg.org/#domtokenlist) which is faster
 * and requires less code.
 *
 * Note: these utilities are meant to operate on HTMLElements
 * and may have unexpected behavior on elements with differing interfaces
 * (such as SVGElements).
 */


goog.provide('goog.dom.classlist');

goog.require('goog.array');


/**
 * Override this define at build-time if you know your target supports it.
 * @define {boolean} Whether to use the classList property (DOMTokenList).
 */
goog.define('goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST', false);


/**
 * Gets an array-like object of class names on an element.
 * @param {Element} element DOM node to get the classes of.
 * @return {!goog.array.ArrayLike} Class names on {@code element}.
 */
goog.dom.classlist.get = function(element) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    return element.classList;
  }

  var className = element.className;
  // Some types of elements don't have a className in IE (e.g. iframes).
  // Furthermore, in Firefox, className is not a string when the element is
  // an SVG element.
  return goog.isString(className) && className.match(/\S+/g) || [];
};


/**
 * Sets the entire class name of an element.
 * @param {Element} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classlist.set = function(element, className) {
  element.className = className;
};


/**
 * Returns true if an element has a class.  This method may throw a DOM
 * exception for an invalid or empty class name if DOMTokenList is used.
 * @param {Element} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classlist.contains = function(element, className) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    return element.classList.contains(className);
  }
  return goog.array.contains(goog.dom.classlist.get(element), className);
};


/**
 * Adds a class to an element.  Does not add multiples of class names.  This
 * method may throw a DOM exception for an invalid or empty class name if
 * DOMTokenList is used.
 * @param {Element} element DOM node to add class to.
 * @param {string} className Class name to add.
 */
goog.dom.classlist.add = function(element, className) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    element.classList.add(className);
    return;
  }

  if (!goog.dom.classlist.contains(element, className)) {
    // Ensure we add a space if this is not the first class name added.
    element.className += element.className.length > 0 ?
        (' ' + className) : className;
  }
};


/**
 * Convenience method to add a number of class names at once.
 * @param {Element} element The element to which to add classes.
 * @param {goog.array.ArrayLike.<string>} classesToAdd An array-like object
 * containing a collection of class names to add to the element.
 * This method may throw a DOM exception if classesToAdd contains invalid
 * or empty class names.
 */
goog.dom.classlist.addAll = function(element, classesToAdd) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    goog.array.forEach(classesToAdd, function(className) {
      goog.dom.classlist.add(element, className);
    });
    return;
  }

  var classMap = {};

  // Get all current class names into a map.
  goog.array.forEach(goog.dom.classlist.get(element),
      function(className) {
        classMap[className] = true;
      });

  // Add new class names to the map.
  goog.array.forEach(classesToAdd,
      function(className) {
        classMap[className] = true;
      });

  // Flatten the keys of the map into the className.
  element.className = '';
  for (var className in classMap) {
    element.className += element.className.length > 0 ?
        (' ' + className) : className;
  }
};


/**
 * Removes a class from an element.  This method may throw a DOM exception
 * for an invalid or empty class name if DOMTokenList is used.
 * @param {Element} element DOM node to remove class from.
 * @param {string} className Class name to remove.
 */
goog.dom.classlist.remove = function(element, className) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    element.classList.remove(className);
    return;
  }

  if (goog.dom.classlist.contains(element, className)) {
    // Filter out the class name.
    element.className = goog.array.filter(
        goog.dom.classlist.get(element),
        function(c) {
          return c != className;
        }).join(' ');
  }
};


/**
 * Removes a set of classes from an element.  Prefer this call to
 * repeatedly calling {@code goog.dom.classlist.remove} if you want to remove
 * a large set of class names at once.
 * @param {Element} element The element from which to remove classes.
 * @param {goog.array.ArrayLike.<string>} classesToRemove An array-like object
 * containing a collection of class names to remove from the element.
 * This method may throw a DOM exception if classesToRemove contains invalid
 * or empty class names.
 */
goog.dom.classlist.removeAll = function(element, classesToRemove) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    goog.array.forEach(classesToRemove, function(className) {
      goog.dom.classlist.remove(element, className);
    });
    return;
  }
  // Filter out those classes in classesToRemove.
  element.className = goog.array.filter(
      goog.dom.classlist.get(element),
      function(className) {
        // If this class is not one we are trying to remove,
        // add it to the array of new class names.
        return !goog.array.contains(classesToRemove, className);
      }).join(' ');
};


/**
 * Adds or removes a class depending on the enabled argument.  This method
 * may throw a DOM exception for an invalid or empty class name if DOMTokenList
 * is used.
 * @param {Element} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classlist.enable = function(element, className, enabled) {
  if (enabled) {
    goog.dom.classlist.add(element, className);
  } else {
    goog.dom.classlist.remove(element, className);
  }
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.  This
 * method may throw a DOM exception if the class names are empty or invalid.
 * @param {Element} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classlist.swap = function(element, fromClass, toClass) {
  if (goog.dom.classlist.contains(element, fromClass)) {
    goog.dom.classlist.remove(element, fromClass);
    goog.dom.classlist.add(element, toClass);
    return true;
  }
  return false;
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.  This method may throw a DOM
 * exception if the class name is empty or invalid.
 * @param {Element} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classlist.toggle = function(element, className) {
  var add = !goog.dom.classlist.contains(element, className);
  goog.dom.classlist.enable(element, className, add);
  return add;
};


/**
 * Adds and removes a class of an element.  Unlike
 * {@link goog.dom.classlist.swap}, this method adds the classToAdd regardless
 * of whether the classToRemove was present and had been removed.  This method
 * may throw a DOM exception if the class names are empty or invalid.
 *
 * @param {Element} element DOM node to swap classes on.
 * @param {string} classToRemove Class to remove.
 * @param {string} classToAdd Class to add.
 */
goog.dom.classlist.addRemove = function(element, classToRemove, classToAdd) {
  goog.dom.classlist.remove(element, classToRemove);
  goog.dom.classlist.add(element, classToAdd);
};
goog.provide('feng.views.MainOptions');

goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.dom.query');
goog.require('goog.events');
goog.require('feng.utils.Utils');


/**
 * @constructor
 */
feng.views.MainOptions = function(){

  goog.base(this);

  this.domElement = goog.dom.getElement('main-options');

  this._infoButton = goog.dom.query('.info', this.domElement)[0];
  this._instructionsButton = goog.dom.query('.instructions', this.domElement)[0];
  this._creditsButton = goog.dom.query('.credits', this.domElement)[0];
  this._soundButton = goog.dom.query('.sound', this.domElement)[0];
  this._soundOnButton = goog.dom.getElementByClass('on', this._soundButton);
  this._soundOffButton = goog.dom.getElementByClass('off', this._soundButton);
  this._facebookButton = goog.dom.query('.facebook', this.domElement)[0];
  this._twitterButton = goog.dom.query('.twitter', this.domElement)[0];
  this._googleButton = goog.dom.query('.google', this.domElement)[0];

  this.showHelpButton( false );

  if( !feng.storageController.isSoundEnabled() ) {
  	this.onMute();
  }

  goog.events.listen(this._instructionsButton, 'click', this.onClick, false, this);
  goog.events.listen(this._creditsButton, 'click', this.onClick, false, this);
  goog.events.listen(this._soundOnButton, 'click', this.onClick, false, this);
  goog.events.listen(this._soundOffButton, 'click', this.onClick, false, this);
  goog.events.listen(this._facebookButton, 'click', this.onClick, false, this);
  goog.events.listen(this._twitterButton, 'click', this.onClick, false, this);
  goog.events.listen(this._googleButton, 'click', this.onClick, false, this);

  feng.soundController.listen( feng.events.EventType.MUTE, this.onMute, false, this);
  feng.soundController.listen( feng.events.EventType.UNMUTE, this.onUnmute, false, this);
};
goog.inherits(feng.views.MainOptions, goog.events.EventTarget);


feng.views.MainOptions.prototype.showHelpButton = function( shouldShow ){

  goog.style.showElement( this._infoButton, shouldShow );
};


feng.views.MainOptions.prototype.onClick = function(e){

	switch(e.currentTarget) {
		case this._instructionsButton:
    feng.tutorial.toggle();
		break;

    case this._creditsButton:
    feng.credits.toggle();
    break;

		case this._soundOnButton:
		feng.soundController.unmute();
		break;

    case this._soundOffButton:
    feng.soundController.mute();
    break;

		case this._facebookButton:
		case this._twitterButton:
		case this._googleButton:
    e.preventDefault();
    feng.utils.Utils.popUp( e.currentTarget.href );
		break;
	}
};


feng.views.MainOptions.prototype.onMute = function(e){

	goog.dom.classlist.add( this._soundButton, 'mute' );
};


feng.views.MainOptions.prototype.onUnmute = function(e){

	goog.dom.classlist.remove( this._soundButton, 'mute' );
};// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview This event monitor wraps the Page Visibility API.
 * @see http://www.w3.org/TR/page-visibility/
 */

goog.provide('goog.labs.dom.PageVisibilityEvent');
goog.provide('goog.labs.dom.PageVisibilityMonitor');
goog.provide('goog.labs.dom.PageVisibilityState');

goog.require('goog.dom');
goog.require('goog.dom.vendor');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.memoize');

goog.scope(function() {
var dom = goog.labs.dom;


/**
 * The different visibility states.
 * @enum {string}
 */
dom.PageVisibilityState = {
  HIDDEN: 'hidden',
  VISIBLE: 'visible',
  PRERENDER: 'prerender',
  UNLOADED: 'unloaded'
};



/**
 * This event handler allows you to catch page visibility change events.
 * @param {!goog.dom.DomHelper=} opt_domHelper
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
dom.PageVisibilityMonitor = function(opt_domHelper) {
  goog.base(this);

  /**
   * @private {!goog.dom.DomHelper}
   */
  this.domHelper_ = opt_domHelper || goog.dom.getDomHelper();

  /**
   * @private {?string}
   */
  this.eventType_ = this.getBrowserEventType_();

  // Some browsers do not support visibilityChange and therefore we don't bother
  // setting up events.
  if (this.eventType_) {
    /**
     * @private {goog.events.Key}
     */
    this.eventKey_ = goog.events.listen(this.domHelper_.getDocument(),
        this.eventType_, goog.bind(this.handleChange_, this));
  }
};
goog.inherits(dom.PageVisibilityMonitor, goog.events.EventTarget);


/**
 * @return {?string} The visibility change event type, or null if not supported.
 *     Memoized for performance.
 * @private
 */
dom.PageVisibilityMonitor.prototype.getBrowserEventType_ =
    goog.memoize(function() {
  var isSupported = this.isSupported();
  var isPrefixed = this.isPrefixed_();

  if (isSupported) {
    return isPrefixed ? goog.dom.vendor.getPrefixedEventType(
        goog.events.EventType.VISIBILITYCHANGE) :
        goog.events.EventType.VISIBILITYCHANGE;
  } else {
    return null;
  }
});


/**
 * @return {?string} The browser-specific document.hidden property.  Memoized
 *     for performance.
 * @private
 */
dom.PageVisibilityMonitor.prototype.getHiddenPropertyName_ = goog.memoize(
    function() {
      return goog.dom.vendor.getPrefixedPropertyName(
          'hidden', this.domHelper_.getDocument());
    });


/**
 * @return {boolean} Whether the visibility API is prefixed.
 * @private
 */
dom.PageVisibilityMonitor.prototype.isPrefixed_ = function() {
  return this.getHiddenPropertyName_() != 'hidden';
};


/**
 * @return {?string} The browser-specific document.visibilityState property.
 *     Memoized for performance.
 * @private
 */
dom.PageVisibilityMonitor.prototype.getVisibilityStatePropertyName_ =
    goog.memoize(function() {
  return goog.dom.vendor.getPrefixedPropertyName(
      'visibilityState', this.domHelper_.getDocument());
});


/**
 * @return {boolean} Whether the visibility API is supported.
 */
dom.PageVisibilityMonitor.prototype.isSupported = function() {
  return !!this.getHiddenPropertyName_();
};


/**
 * @return {boolean} Whether the page is visible.
 */
dom.PageVisibilityMonitor.prototype.isHidden = function() {
  return !!this.domHelper_.getDocument()[this.getHiddenPropertyName_()];
};


/**
 * @return {?dom.PageVisibilityState} The page visibility state, or null if
 *     not supported.
 */
dom.PageVisibilityMonitor.prototype.getVisibilityState = function() {
  if (!this.isSupported()) {
    return null;
  }
  return this.domHelper_.getDocument()[this.getVisibilityStatePropertyName_()];
};


/**
 * Handles the events on the element.
 * @param {goog.events.BrowserEvent} e The underlying browser event.
 * @private
 */
dom.PageVisibilityMonitor.prototype.handleChange_ = function(e) {
  var state = this.getVisibilityState();
  var visibilityEvent = new dom.PageVisibilityEvent(
      this.isHidden(), /** @type {dom.PageVisibilityState} */ (state));
  this.dispatchEvent(visibilityEvent);
};


/** @override */
dom.PageVisibilityMonitor.prototype.disposeInternal = function() {
  goog.events.unlistenByKey(this.eventKey_);
  goog.base(this, 'disposeInternal');
};



/**
 * A page visibility change event.
 * @param {boolean} hidden Whether the page is hidden.
 * @param {goog.labs.dom.PageVisibilityState} visibilityState A more detailed
 *     visibility state.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
dom.PageVisibilityEvent = function(hidden, visibilityState) {
  goog.base(this, goog.events.EventType.VISIBILITYCHANGE);

  /**
   * Whether the page is hidden.
   * @type {boolean}
   */
  this.hidden = hidden;

  /**
   * A more detailed visibility state.
   * @type {dom.PageVisibilityState}
   */
  this.visibilityState = visibilityState;
};
goog.inherits(dom.PageVisibilityEvent, goog.events.Event);

});  // goog.scope
goog.provide('feng.controllers.SoundController');

goog.require('goog.events.EventTarget');
goog.require('goog.object');
goog.require('goog.Timer');
goog.require('goog.labs.dom.PageVisibilityMonitor');
goog.require('feng.events');


/**
 * @constructor
 */
feng.controllers.SoundController = function(){

  goog.base(this);

  this._sounds = {};
  this._sounds[ feng.controllers.SoundController.SoundType.SFX ] = {};
  this._sounds[ feng.controllers.SoundController.SoundType.AMBIENT ] = {};
  this._sounds[ feng.controllers.SoundController.SoundType.LOOP ] = {};

  this._tweeners = {};
  this._tweeners[ feng.controllers.SoundController.SoundType.SFX ] = {};
  this._tweeners[ feng.controllers.SoundController.SoundType.AMBIENT ] = {};
  this._tweeners[ feng.controllers.SoundController.SoundType.LOOP ] = {};

  this._numSoundsToLoad = 0;
  this._numSoundsLoaded = 0;
  this._isLoaded = false;
  this._isMuted = false;

  // define sound data to load
  var onSoundLoad = goog.bind(this.onSoundLoad, this);
  var self = this;

  var urls = function(filename, forcedFormat) {

    var result = [];

    if(forcedFormat) {

      result[0] = feng.Config['assetsPath'] + 'audio/' + filename + '.' + forcedFormat;

    }else {

      result[0] = feng.Config['assetsPath'] + 'audio/' + filename + '.mp3';
      result[1] = feng.Config['assetsPath'] + 'audio/' + filename + '.ogg';
    }

    return result;
  };

  this._data = {};

  this._data[ feng.controllers.SoundController.SoundType.SFX ] = {
    'click': {
      'urls': urls('sfx/click'),
      'onload': onSoundLoad
    },
    'close': {
      'urls': urls('sfx/close'),
      'onload': onSoundLoad
    },
    'confirm': {
      'urls': urls('sfx/confirm'),
      'onload': onSoundLoad
    },
    'thrust-up': {
      'urls': urls('sfx/thrust-up'),
      'onload': onSoundLoad
    },
    'thrust-down': {
      'urls': urls('sfx/thrust-down'),
      'onload': onSoundLoad
    },
    'door-open': {
      'urls': urls('sfx/door-open'),
      'onload': onSoundLoad
    },
    'door-close': {
      'urls': urls('sfx/door-close'),
      'onload': onSoundLoad
    },
    'entry-open': {
      'urls': urls('sfx/entry-open'),
      'onload': onSoundLoad
    },
    'entry-close': {
      'urls': urls('sfx/entry-close'),
      'onload': onSoundLoad
    },
    'footsteps': {
      'urls': urls('sfx/footsteps'),
      'onend': goog.bind(this.replaySound, self, 'footsteps', 'sfx'),
      'onload': onSoundLoad
    },
    'refrigerator-open': {
      'urls': urls('sfx/refrigerator-open'),
      'onload': onSoundLoad
    },
    'refrigerator-close': {
      'urls': urls('sfx/refrigerator-close'),
      'onload': onSoundLoad
    },
    'water-drop': {
      'urls': urls('sfx/water-drop'),
      'onload': onSoundLoad
    }
  };

  this._data[ feng.controllers.SoundController.SoundType.AMBIENT ] = {
    'studio': {
      'urls': urls('ambient/city-distant-traffic'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'studio', 'ambient'),
      'onload': onSoundLoad
    },
    'house': {
      'urls': urls('ambient/subdivision'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'house', 'ambient'),
      'onload': onSoundLoad
    }
  };

  this._data[ feng.controllers.SoundController.SoundType.LOOP ] = {
    'first-class': {
      'urls': urls('loop/first-class'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'first-class', 'loop'),
      'onload': onSoundLoad
    },
    'optimize-loop-1': {
      'urls': urls('loop/optimize-loop-1'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'optimize-loop-1', 'loop'),
      'onload': onSoundLoad
    },
    'serendipity': {
      'urls': urls('loop/serendipity'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'serendipity', 'loop'),
      'onload': onSoundLoad
    },
    'closeup': {
      'urls': urls('loop/optimize-loop-7'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'closeup', 'loop'),
      'onload': onSoundLoad
    },
    'book': {
      'urls': urls('loop/optimize-loop-8'),
      'volume': 0,
      'onend': goog.bind(this.replaySound, self, 'book', 'loop'),
      'onload': onSoundLoad
    }
  };

  // create sound from data
  goog.object.forEach(this._data, function(soundDatas, soundType) {

    goog.object.forEach(soundDatas, function(soundData, soundId) {

      var sound = new Howl(soundData);
      sound.soundId = soundId;
      sound.soundType = soundType;

      this._sounds[ soundType ][ soundId ] = sound;

      var tweener = {
        sound: sound,
        volume: sound.volume(),
        pauseAfterComplete: false,
        stopAfterComplete: false
      };
      this._tweeners[ soundType ][ soundId ] = tweener;

      this._numSoundsToLoad ++;
    }, this);

  }, this);

  // create sound mixes
  var fadeAmbient = goog.bind(this.fadeAmbient, this);
  var fadeLoop = goog.bind(this.fadeLoop, this);

  this._mix = {
    'studio': {
      position: 0,
      time: 0,
      duration: 25000,
      timer: new goog.Timer(1000),
      sounds: [
        this.getLoop('optimize-loop-1'),
        this.getAmbient('studio'),
        this.getLoop('serendipity'),
        this.getAmbient('studio'),
        this.getLoop('first-class'),
        this.getAmbient('studio')
      ],
      fadeAmbient: fadeAmbient,
      fadeLoop: fadeLoop
    },
    'house': {
      position: 0,
      time: 0,
      duration: 25000,
      timer: new goog.Timer(1000),
      sounds: [
        this.getLoop('optimize-loop-1'),
        this.getAmbient('house'),
        this.getLoop('serendipity'),
        this.getAmbient('house'),
        this.getLoop('first-class'),
        this.getAmbient('house')
      ],
      fadeAmbient: fadeAmbient,
      fadeLoop: fadeLoop
    }
  };

  goog.object.forEach(this._mix, function(mix) {

    mix.timer.listen( goog.Timer.TICK, this.onMixTick, false, mix );

  }, this);

  if(feng.storageController.isSoundEnabled()) {
    this.unmute();
  }else {
    this.mute();
  }

  // page visibility events
  var pageVisibilityMonitor = new goog.labs.dom.PageVisibilityMonitor;
  if( pageVisibilityMonitor.isSupported() ) {
    var eventType = pageVisibilityMonitor.getBrowserEventType_();
    goog.events.listen(pageVisibilityMonitor, eventType, this.onPageVisible);
  }
};
goog.inherits(feng.controllers.SoundController, goog.events.EventTarget);
goog.addSingletonGetter(feng.controllers.SoundController);


feng.controllers.SoundController.prototype.replaySound = function( soundId, soundType ){

  var sound;

  switch(soundType) {
    case feng.controllers.SoundController.SoundType.AMBIENT:
    sound = this.getAmbient( soundId );
    break;

    case feng.controllers.SoundController.SoundType.LOOP:
    sound = this.getLoop( soundId );
    break;

    case feng.controllers.SoundController.SoundType.SFX:
    sound = this.getSfx( soundId );
    break;
  }

  sound.play();
};


feng.controllers.SoundController.prototype.mute = function(){
  
  Howler.mute();

  this._isMuted = true;

  feng.storageController.onSoundEnabled( false );

  this.dispatchEvent( feng.events.EventType.MUTE );
};


feng.controllers.SoundController.prototype.unmute = function(){
  
  Howler.unmute();

  this._isMuted = false;

  feng.storageController.onSoundEnabled( true );

  this.dispatchEvent( feng.events.EventType.UNMUTE );
};


feng.controllers.SoundController.prototype.toggle = function(){
  
  if(this._isMuted) {

    this.unmute();

  }else {

    this.mute();
  }
};


feng.controllers.SoundController.prototype.getSfx = function( id ){
  
  return this._sounds[ feng.controllers.SoundController.SoundType.SFX ][ id ];
};


feng.controllers.SoundController.prototype.getAmbient = function( id ){
  
  return this._sounds[ feng.controllers.SoundController.SoundType.AMBIENT ][ id ];
};


feng.controllers.SoundController.prototype.getLoop = function( id ){
  
  return this._sounds[ feng.controllers.SoundController.SoundType.LOOP ][ id ];
};


feng.controllers.SoundController.prototype.getSfxTweener = function( id ){
  
  return this._tweeners[ feng.controllers.SoundController.SoundType.SFX ][ id ];
};


feng.controllers.SoundController.prototype.getAmbientTweener = function( id ){
  
  return this._tweeners[ feng.controllers.SoundController.SoundType.AMBIENT ][ id ];
};


feng.controllers.SoundController.prototype.getLoopTweener = function( id ){
  
  return this._tweeners[ feng.controllers.SoundController.SoundType.LOOP ][ id ];
};


feng.controllers.SoundController.prototype.playSfx = function( id ){

  var sound = this.getSfx( id );

  if(!this._isLoaded) {
    return sound;
  }

  sound.play();

  return sound;
};


feng.controllers.SoundController.prototype.playAmbient = function( id ){
  
  var sound = this.getAmbient( id );

  if(!this._isLoaded) {

    return sound;
  }

  sound.pause();
  sound.play();

  return sound;
};


feng.controllers.SoundController.prototype.playLoop = function( id ){
  
  var sound = this.getLoop( id );

  if(!this._isLoaded) {

    return sound;
  }

  sound.pause();
  sound.play();

  return sound;
};


feng.controllers.SoundController.prototype.playMix = function( mixId, duration, reset ){
  
  var mix = this._mix[ mixId ];

  if(mix.timer.enabled) return;
  else mix.timer.start();

  mix.position = reset ? 0 : mix.position;

  var sound = mix.sounds[ mix.position ];

  var fadeDuration = goog.isNumber(duration) ? duration : 5;

  if(sound.soundType === feng.controllers.SoundController.SoundType.AMBIENT) {

    this.fadeAmbient( sound.soundId, 0, 1, fadeDuration );

  }else if(sound.soundType === feng.controllers.SoundController.SoundType.LOOP) {

    this.fadeLoop( sound.soundId, 0, 1, fadeDuration );
  }
};


feng.controllers.SoundController.prototype.stopMix = function( mixId, duration, reset ){
  
  var mix = this._mix[ mixId ];

  if(!mix.timer.enabled) return;
  else mix.timer.stop();

  var sound = mix.sounds[ mix.position ];

  var fadeDuration = goog.isNumber(duration) ? duration : 5;

  if(sound.soundType === feng.controllers.SoundController.SoundType.AMBIENT) {

    this.fadeAmbient( sound.soundId, null, 0, duration, true );

  }else if(sound.soundType === feng.controllers.SoundController.SoundType.LOOP) {

    this.fadeLoop( sound.soundId, null, 0, duration, true );
  }

  mix.position = reset ? 0 : mix.position;
};


feng.controllers.SoundController.prototype.fade = function( tweener, from, to, duration, pauseAfterComplete, stopAfterComplete ){

  tweener.volume = goog.isNumber(from) ? from : tweener.sound.volume();
  tweener.pauseAfterComplete = pauseAfterComplete;
  tweener.stopAfterComplete = stopAfterComplete;

  var duration = duration || 1;

  TweenMax.to(tweener, duration, {
    volume: to,
    'ease': Linear.easeNone,
    'onUpdate': this.onFadeUpdate,
    'onUpdateParams': [ tweener ],
    'onUpdateScope': this,
    'onComplete': this.onFadeComplete,
    'onCompleteParams': [ tweener ],
    'onCompleteScope': this
  });
};


feng.controllers.SoundController.prototype.fadeLoop = function( id, from, to, duration, pauseAfterComplete, stopAfterComplete ){

  var sound = this.playLoop( id );

  var tweener = this.getLoopTweener( id );

  this.fade( tweener, from, to, duration, pauseAfterComplete, stopAfterComplete );
};


feng.controllers.SoundController.prototype.fadeAmbient = function( id, from, to, duration, pauseAfterComplete, stopAfterComplete ){

  var sound = this.playAmbient( id );

  var tweener = this.getAmbientTweener( id );
  
  this.fade( tweener, from, to, duration, pauseAfterComplete, stopAfterComplete );
};


feng.controllers.SoundController.prototype.onFadeUpdate = function( param ){

  var sound = param.sound;
  var vol = param.volume;

  sound.volume( vol );
};


feng.controllers.SoundController.prototype.onFadeComplete = function( param ){

  var sound = param.sound;
  var stopAfterComplete = param.stopAfterComplete;
  var pauseAfterComplete = param.pauseAfterComplete;

  if(stopAfterComplete === true) {
    sound.stop();
  }

  if(pauseAfterComplete === true) {
    sound.pause();
  }
};


feng.controllers.SoundController.prototype.onMixTick = function( e ){

  var mix = this;

  var shouldSwitch = false;

  if(mix.time >= mix.duration) {

    shouldSwitch = true;

    mix.time = 0;

  }else {

    mix.time += 1000;
  }

  if(!shouldSwitch) {
    
    return;
  }

  var sounds = mix.sounds;

  var lastSound = sounds[ mix.position ];

  if(lastSound.soundType === feng.controllers.SoundController.SoundType.AMBIENT) {

    this.fadeAmbient( lastSound.soundId, null, .4, 10 );

  }else if(lastSound.soundType === feng.controllers.SoundController.SoundType.LOOP) {

    this.fadeLoop( lastSound.soundId, null, 0, 10, true );
  }

  mix.position ++;

  if(mix.position >= mix.sounds.length) {
    mix.position = 0;
  }

  var nextSound = sounds[ mix.position ];

  if(nextSound.soundType === feng.controllers.SoundController.SoundType.AMBIENT) {

    this.fadeAmbient( nextSound.soundId, 0, 1, 10 );

  }else if(nextSound.soundType === feng.controllers.SoundController.SoundType.LOOP) {

    this.fadeLoop( nextSound.soundId, 0, .5, 10 );
  }
};


feng.controllers.SoundController.prototype.onSoundLoad = function(){

  this._numSoundsLoaded ++;
  
  if(this._numSoundsLoaded === this._numSoundsToLoad) {
    this.onLoadComplete();
  }
};


feng.controllers.SoundController.prototype.onLoadComplete = function(){
  
  this._isLoaded = true;

  console.log('all sounds loaded: ', this._sounds);
};


feng.controllers.SoundController.prototype.onPageVisible = function(e){

  if(e.hidden) {

    if(!Howler._muted) {

      Howler.volume( 0 );
    }

  }else {

    if(!Howler._muted) {

      Howler.volume( 1 );
    }
  }
};


feng.controllers.SoundController.SoundType = {
  SFX: 'sfx',
  AMBIENT: 'ambient',
  LOOP: 'loop'
};// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Error codes shared between goog.net.IframeIo and
 * goog.net.XhrIo.
 */

goog.provide('goog.net.ErrorCode');


/**
 * Error codes
 * @enum {number}
 */
goog.net.ErrorCode = {

  /**
   * There is no error condition.
   */
  NO_ERROR: 0,

  /**
   * The most common error from iframeio, unfortunately, is that the browser
   * responded with an error page that is classed as a different domain. The
   * situations, are when a browser error page  is shown -- 404, access denied,
   * DNS failure, connection reset etc.)
   *
   */
  ACCESS_DENIED: 1,

  /**
   * Currently the only case where file not found will be caused is when the
   * code is running on the local file system and a non-IE browser makes a
   * request to a file that doesn't exist.
   */
  FILE_NOT_FOUND: 2,

  /**
   * If Firefox shows a browser error page, such as a connection reset by
   * server or access denied, then it will fail silently without the error or
   * load handlers firing.
   */
  FF_SILENT_ERROR: 3,

  /**
   * Custom error provided by the client through the error check hook.
   */
  CUSTOM_ERROR: 4,

  /**
   * Exception was thrown while processing the request.
   */
  EXCEPTION: 5,

  /**
   * The Http response returned a non-successful http status code.
   */
  HTTP_ERROR: 6,

  /**
   * The request was aborted.
   */
  ABORT: 7,

  /**
   * The request timed out.
   */
  TIMEOUT: 8,

  /**
   * The resource is not available offline.
   */
  OFFLINE: 9
};


/**
 * Returns a friendly error message for an error code. These messages are for
 * debugging and are not localized.
 * @param {goog.net.ErrorCode} errorCode An error code.
 * @return {string} A message for debugging.
 */
goog.net.ErrorCode.getDebugMessage = function(errorCode) {
  switch (errorCode) {
    case goog.net.ErrorCode.NO_ERROR:
      return 'No Error';

    case goog.net.ErrorCode.ACCESS_DENIED:
      return 'Access denied to content document';

    case goog.net.ErrorCode.FILE_NOT_FOUND:
      return 'File not found';

    case goog.net.ErrorCode.FF_SILENT_ERROR:
      return 'Firefox silently errored';

    case goog.net.ErrorCode.CUSTOM_ERROR:
      return 'Application custom error';

    case goog.net.ErrorCode.EXCEPTION:
      return 'An exception occurred';

    case goog.net.ErrorCode.HTTP_ERROR:
      return 'Http response at 400 or 500 level';

    case goog.net.ErrorCode.ABORT:
      return 'Request was aborted';

    case goog.net.ErrorCode.TIMEOUT:
      return 'Request timed out';

    case goog.net.ErrorCode.OFFLINE:
      return 'The resource is not available offline';

    default:
      return 'Unrecognized error code';
  }
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Constants for HTTP status codes.
 */

goog.provide('goog.net.HttpStatus');


/**
 * HTTP Status Codes defined in RFC 2616.
 * @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
 * @enum {number}
 */
goog.net.HttpStatus = {
  // Informational 1xx
  CONTINUE: 100,
  SWITCHING_PROTOCOLS: 101,

  // Successful 2xx
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NON_AUTHORITATIVE_INFORMATION: 203,
  NO_CONTENT: 204,
  RESET_CONTENT: 205,
  PARTIAL_CONTENT: 206,

  // Redirection 3xx
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  USE_PROXY: 305,
  TEMPORARY_REDIRECT: 307,

  // Client Error 4xx
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  REQUEST_ENTITY_TOO_LARGE: 413,
  REQUEST_URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  REQUEST_RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,

  // Server Error 5xx
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,

  /*
   * IE returns this code for 204 due to its use of URLMon, which returns this
   * code for 'Operation Aborted'. The status text is 'Unknown', the response
   * headers are ''. Known to occur on IE 6 on XP through IE9 on Win7.
   */
  QUIRK_IE_NO_CONTENT: 1223
};


/**
 * Returns whether the given status should be considered successful.
 *
 * Successful codes are OK (200), CREATED (201), ACCEPTED (202),
 * NO CONTENT (204), PARTIAL CONTENT (206), NOT MODIFIED (304),
 * and IE's no content code (1223).
 *
 * @param {number} status The status code to test.
 * @return {boolean} Whether the status code should be considered successful.
 */
goog.net.HttpStatus.isSuccess = function(status) {
  switch (status) {
    case goog.net.HttpStatus.OK:
    case goog.net.HttpStatus.CREATED:
    case goog.net.HttpStatus.ACCEPTED:
    case goog.net.HttpStatus.NO_CONTENT:
    case goog.net.HttpStatus.PARTIAL_CONTENT:
    case goog.net.HttpStatus.NOT_MODIFIED:
    case goog.net.HttpStatus.QUIRK_IE_NO_CONTENT:
      return true;

    default:
      return false;
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview JSON utility functions.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.json');
goog.provide('goog.json.Replacer');
goog.provide('goog.json.Reviver');
goog.provide('goog.json.Serializer');


/**
 * @define {boolean} If true, use the native JSON parsing API.
 * NOTE(user): EXPERIMENTAL, handle with care.  Setting this to true might
 * break your code.  The default {@code goog.json.parse} implementation is able
 * to handle invalid JSON, such as JSPB.
 */
goog.define('goog.json.USE_NATIVE_JSON', false);


/**
 * Tests if a string is an invalid JSON string. This only ensures that we are
 * not using any invalid characters
 * @param {string} s The string to test.
 * @return {boolean} True if the input is a valid JSON string.
 * @private
 */
goog.json.isValid_ = function(s) {
  // All empty whitespace is not valid.
  if (/^\s*$/.test(s)) {
    return false;
  }

  // This is taken from http://www.json.org/json2.js which is released to the
  // public domain.
  // Changes: We dissallow \u2028 Line separator and \u2029 Paragraph separator
  // inside strings.  We also treat \u2028 and \u2029 as whitespace which they
  // are in the RFC but IE and Safari does not match \s to these so we need to
  // include them in the reg exps in all places where whitespace is allowed.
  // We allowed \x7f inside strings because some tools don't escape it,
  // e.g. http://www.json.org/java/org/json/JSONObject.java

  // Parsing happens in three stages. In the first stage, we run the text
  // against regular expressions that look for non-JSON patterns. We are
  // especially concerned with '()' and 'new' because they can cause invocation,
  // and '=' because it can cause mutation. But just to be safe, we want to
  // reject all unexpected forms.

  // We split the first stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace all backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

  // Don't make these static since they have the global flag.
  var backslashesRe = /\\["\\\/bfnrtu]/g;
  var simpleValuesRe =
      /"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var openBracketsRe = /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g;
  var remainderRe = /^[\],:{}\s\u2028\u2029]*$/;

  return remainderRe.test(s.replace(backslashesRe, '@').
      replace(simpleValuesRe, ']').
      replace(openBracketsRe, ''));
};


/**
 * Parses a JSON string and returns the result. This throws an exception if
 * the string is an invalid JSON string.
 *
 * Note that this is very slow on large strings. If you trust the source of
 * the string then you should use unsafeParse instead.
 *
 * @param {*} s The JSON string to parse.
 * @throws Error if s is invalid JSON.
 * @return {Object} The object generated from the JSON string, or null.
 */
goog.json.parse = goog.json.USE_NATIVE_JSON ?
    /** @type {function(*):Object} */ (goog.global['JSON']['parse']) :
    function(s) {
      var o = String(s);
      if (goog.json.isValid_(o)) {
        /** @preserveTry */
        try {
          return /** @type {Object} */ (eval('(' + o + ')'));
        } catch (ex) {
        }
      }
      throw Error('Invalid JSON string: ' + o);
    };


/**
 * Parses a JSON string and returns the result. This uses eval so it is open
 * to security issues and it should only be used if you trust the source.
 *
 * @param {string} s The JSON string to parse.
 * @return {Object} The object generated from the JSON string.
 */
goog.json.unsafeParse = goog.json.USE_NATIVE_JSON ?
    /** @type {function(string):Object} */ (goog.global['JSON']['parse']) :
    function(s) {
      return /** @type {Object} */ (eval('(' + s + ')'));
    };


/**
 * JSON replacer, as defined in Section 15.12.3 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * TODO(nicksantos): Array should also be a valid replacer.
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Replacer;


/**
 * JSON reviver, as defined in Section 15.12.2 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Reviver;


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @param {?goog.json.Replacer=} opt_replacer A replacer function
 *     called for each (key, value) pair that determines how the value
 *     should be serialized. By defult, this just returns the value
 *     and allows default serialization to kick in.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.serialize = goog.json.USE_NATIVE_JSON ?
    /** @type {function(*, ?goog.json.Replacer=):string} */
    (goog.global['JSON']['stringify']) :
    function(object, opt_replacer) {
      // NOTE(nicksantos): Currently, we never use JSON.stringify.
      //
      // The last time I evaluated this, JSON.stringify had subtle bugs and
      // behavior differences on all browsers, and the performance win was not
      // large enough to justify all the issues. This may change in the future
      // as browser implementations get better.
      //
      // assertSerialize in json_test contains if branches for the cases
      // that fail.
      return new goog.json.Serializer(opt_replacer).serialize(object);
    };



/**
 * Class that is used to serialize JSON objects to a string.
 * @param {?goog.json.Replacer=} opt_replacer Replacer.
 * @constructor
 */
goog.json.Serializer = function(opt_replacer) {
  /**
   * @type {goog.json.Replacer|null|undefined}
   * @private
   */
  this.replacer_ = opt_replacer;
};


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.Serializer.prototype.serialize = function(object) {
  var sb = [];
  this.serialize_(object, sb);
  return sb.join('');
};


/**
 * Serializes a generic value to a JSON string
 * @private
 * @param {*} object The object to serialize.
 * @param {Array} sb Array used as a string builder.
 * @throws Error if there are loops in the object graph.
 */
goog.json.Serializer.prototype.serialize_ = function(object, sb) {
  switch (typeof object) {
    case 'string':
      this.serializeString_(/** @type {string} */ (object), sb);
      break;
    case 'number':
      this.serializeNumber_(/** @type {number} */ (object), sb);
      break;
    case 'boolean':
      sb.push(object);
      break;
    case 'undefined':
      sb.push('null');
      break;
    case 'object':
      if (object == null) {
        sb.push('null');
        break;
      }
      if (goog.isArray(object)) {
        this.serializeArray(/** @type {!Array} */ (object), sb);
        break;
      }
      // should we allow new String, new Number and new Boolean to be treated
      // as string, number and boolean? Most implementations do not and the
      // need is not very big
      this.serializeObject_(/** @type {Object} */ (object), sb);
      break;
    case 'function':
      // Skip functions.
      // TODO(user) Should we return something here?
      break;
    default:
      throw Error('Unknown type: ' + typeof object);
  }
};


/**
 * Character mappings used internally for goog.string.quote
 * @private
 * @type {!Object}
 */
goog.json.Serializer.charToJsonCharCache_ = {
  '\"': '\\"',
  '\\': '\\\\',
  '/': '\\/',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',

  '\x0B': '\\u000b' // '\v' is not supported in JScript
};


/**
 * Regular expression used to match characters that need to be replaced.
 * The S60 browser has a bug where unicode characters are not matched by
 * regular expressions. The condition below detects such behaviour and
 * adjusts the regular expression accordingly.
 * @private
 * @type {!RegExp}
 */
goog.json.Serializer.charsToReplace_ = /\uffff/.test('\uffff') ?
    /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;


/**
 * Serializes a string to a JSON string
 * @private
 * @param {string} s The string to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeString_ = function(s, sb) {
  // The official JSON implementation does not work with international
  // characters.
  sb.push('"', s.replace(goog.json.Serializer.charsToReplace_, function(c) {
    // caching the result improves performance by a factor 2-3
    if (c in goog.json.Serializer.charToJsonCharCache_) {
      return goog.json.Serializer.charToJsonCharCache_[c];
    }

    var cc = c.charCodeAt(0);
    var rv = '\\u';
    if (cc < 16) {
      rv += '000';
    } else if (cc < 256) {
      rv += '00';
    } else if (cc < 4096) { // \u1000
      rv += '0';
    }
    return goog.json.Serializer.charToJsonCharCache_[c] = rv + cc.toString(16);
  }), '"');
};


/**
 * Serializes a number to a JSON string
 * @private
 * @param {number} n The number to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeNumber_ = function(n, sb) {
  sb.push(isFinite(n) && !isNaN(n) ? n : 'null');
};


/**
 * Serializes an array to a JSON string
 * @param {Array} arr The array to serialize.
 * @param {Array} sb Array used as a string builder.
 * @protected
 */
goog.json.Serializer.prototype.serializeArray = function(arr, sb) {
  var l = arr.length;
  sb.push('[');
  var sep = '';
  for (var i = 0; i < l; i++) {
    sb.push(sep);

    var value = arr[i];
    this.serialize_(
        this.replacer_ ? this.replacer_.call(arr, String(i), value) : value,
        sb);

    sep = ',';
  }
  sb.push(']');
};


/**
 * Serializes an object to a JSON string
 * @private
 * @param {Object} obj The object to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeObject_ = function(obj, sb) {
  sb.push('{');
  var sep = '';
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var value = obj[key];
      // Skip functions.
      // TODO(ptucker) Should we return something for function properties?
      if (typeof value != 'function') {
        sb.push(sep);
        this.serializeString_(key, sb);
        sb.push(':');

        this.serialize_(
            this.replacer_ ? this.replacer_.call(obj, key, value) : value,
            sb);

        sep = ',';
      }
    }
  }
  sb.push('}');
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.net.XhrLike');



/**
 * Interface for the common parts of XMLHttpRequest.
 *
 * Mostly copied from externs/w3c_xml.js.
 *
 * @interface
 * @see http://www.w3.org/TR/XMLHttpRequest/
 */
goog.net.XhrLike = function() {};


/**
 * Typedef that refers to either native or custom-implemented XHR objects.
 * @typedef {!goog.net.XhrLike|!XMLHttpRequest}
 */
goog.net.XhrLike.OrNative;


/**
 * @type {function()|null|undefined}
 * @see http://www.w3.org/TR/XMLHttpRequest/#handler-xhr-onreadystatechange
 */
goog.net.XhrLike.prototype.onreadystatechange;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
 */
goog.net.XhrLike.prototype.responseText;


/**
 * @type {Document}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsexml-attribute
 */
goog.net.XhrLike.prototype.responseXML;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#readystate
 */
goog.net.XhrLike.prototype.readyState;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#status
 */
goog.net.XhrLike.prototype.status;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#statustext
 */
goog.net.XhrLike.prototype.statusText;


/**
 * @param {string} method
 * @param {string} url
 * @param {?boolean=} opt_async
 * @param {?string=} opt_user
 * @param {?string=} opt_password
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method
 */
goog.net.XhrLike.prototype.open = function(method, url, opt_async, opt_user,
    opt_password) {};


/**
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=} opt_data
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
 */
goog.net.XhrLike.prototype.send = function(opt_data) {};


/**
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method
 */
goog.net.XhrLike.prototype.abort = function() {};


/**
 * @param {string} header
 * @param {string} value
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method
 */
goog.net.XhrLike.prototype.setRequestHeader = function(header, value) {};


/**
 * @param {string} header
 * @return {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 */
goog.net.XhrLike.prototype.getResponseHeader = function(header) {};


/**
 * @return {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
 */
goog.net.XhrLike.prototype.getAllResponseHeaders = function() {};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for a factory for creating XMLHttpRequest objects
 * and metadata about them.
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.XmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');



/**
 * Abstract base class for an XmlHttpRequest factory.
 * @constructor
 */
goog.net.XmlHttpFactory = function() {
};


/**
 * Cache of options - we only actually call internalGetOptions once.
 * @type {Object}
 * @private
 */
goog.net.XmlHttpFactory.prototype.cachedOptions_ = null;


/**
 * @return {!goog.net.XhrLike.OrNative} A new XhrLike instance.
 */
goog.net.XmlHttpFactory.prototype.createInstance = goog.abstractMethod;


/**
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 */
goog.net.XmlHttpFactory.prototype.getOptions = function() {
  return this.cachedOptions_ ||
      (this.cachedOptions_ = this.internalGetOptions());
};


/**
 * Override this method in subclasses to preserve the caching offered by
 * getOptions().
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 * @protected
 */
goog.net.XmlHttpFactory.prototype.internalGetOptions = goog.abstractMethod;
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implementation of XmlHttpFactory which allows construction from
 * simple factory methods.
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.WrapperXmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');
goog.require('goog.net.XmlHttpFactory');



/**
 * An xhr factory subclass which can be constructed using two factory methods.
 * This exists partly to allow the preservation of goog.net.XmlHttp.setFactory()
 * with an unchanged signature.
 * @param {function():!goog.net.XhrLike.OrNative} xhrFactory
 *     A function which returns a new XHR object.
 * @param {function():!Object} optionsFactory A function which returns the
 *     options associated with xhr objects from this factory.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 * @final
 */
goog.net.WrapperXmlHttpFactory = function(xhrFactory, optionsFactory) {
  goog.net.XmlHttpFactory.call(this);

  /**
   * XHR factory method.
   * @type {function() : !goog.net.XhrLike.OrNative}
   * @private
   */
  this.xhrFactory_ = xhrFactory;

  /**
   * Options factory method.
   * @type {function() : !Object}
   * @private
   */
  this.optionsFactory_ = optionsFactory;
};
goog.inherits(goog.net.WrapperXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.createInstance = function() {
  return this.xhrFactory_();
};


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.getOptions = function() {
  return this.optionsFactory_();
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Low level handling of XMLHttpRequest.
 * @author arv@google.com (Erik Arvidsson)
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.DefaultXmlHttpFactory');
goog.provide('goog.net.XmlHttp');
goog.provide('goog.net.XmlHttp.OptionType');
goog.provide('goog.net.XmlHttp.ReadyState');
goog.provide('goog.net.XmlHttpDefines');

goog.require('goog.asserts');
goog.require('goog.net.WrapperXmlHttpFactory');
goog.require('goog.net.XmlHttpFactory');


/**
 * Static class for creating XMLHttpRequest objects.
 * @return {!goog.net.XhrLike.OrNative} A new XMLHttpRequest object.
 */
goog.net.XmlHttp = function() {
  return goog.net.XmlHttp.factory_.createInstance();
};


/**
 * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to
 *     true bypasses the ActiveX probing code.
 * NOTE(user): Due to the way JSCompiler works, this define *will not* strip
 * out the ActiveX probing code from binaries.  To achieve this, use
 * {@code goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR} instead.
 * TODO(user): Collapse both defines.
 */
goog.define('goog.net.XmlHttp.ASSUME_NATIVE_XHR', false);


/** @const */
goog.net.XmlHttpDefines = {};


/**
 * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to
 *     true eliminates the ActiveX probing code.
 */
goog.define('goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR', false);


/**
 * Gets the options to use with the XMLHttpRequest objects obtained using
 * the static methods.
 * @return {Object} The options.
 */
goog.net.XmlHttp.getOptions = function() {
  return goog.net.XmlHttp.factory_.getOptions();
};


/**
 * Type of options that an XmlHttp object can have.
 * @enum {number}
 */
goog.net.XmlHttp.OptionType = {
  /**
   * Whether a goog.nullFunction should be used to clear the onreadystatechange
   * handler instead of null.
   */
  USE_NULL_FUNCTION: 0,

  /**
   * NOTE(user): In IE if send() errors on a *local* request the readystate
   * is still changed to COMPLETE.  We need to ignore it and allow the
   * try/catch around send() to pick up the error.
   */
  LOCAL_REQUEST_ERROR: 1
};


/**
 * Status constants for XMLHTTP, matches:
 * http://msdn.microsoft.com/library/default.asp?url=/library/
 *   en-us/xmlsdk/html/0e6a34e4-f90c-489d-acff-cb44242fafc6.asp
 * @enum {number}
 */
goog.net.XmlHttp.ReadyState = {
  /**
   * Constant for when xmlhttprequest.readyState is uninitialized
   */
  UNINITIALIZED: 0,

  /**
   * Constant for when xmlhttprequest.readyState is loading.
   */
  LOADING: 1,

  /**
   * Constant for when xmlhttprequest.readyState is loaded.
   */
  LOADED: 2,

  /**
   * Constant for when xmlhttprequest.readyState is in an interactive state.
   */
  INTERACTIVE: 3,

  /**
   * Constant for when xmlhttprequest.readyState is completed
   */
  COMPLETE: 4
};


/**
 * The global factory instance for creating XMLHttpRequest objects.
 * @type {goog.net.XmlHttpFactory}
 * @private
 */
goog.net.XmlHttp.factory_;


/**
 * Sets the factories for creating XMLHttpRequest objects and their options.
 * @param {Function} factory The factory for XMLHttpRequest objects.
 * @param {Function} optionsFactory The factory for options.
 * @deprecated Use setGlobalFactory instead.
 */
goog.net.XmlHttp.setFactory = function(factory, optionsFactory) {
  goog.net.XmlHttp.setGlobalFactory(new goog.net.WrapperXmlHttpFactory(
      goog.asserts.assert(factory),
      goog.asserts.assert(optionsFactory)));
};


/**
 * Sets the global factory object.
 * @param {!goog.net.XmlHttpFactory} factory New global factory object.
 */
goog.net.XmlHttp.setGlobalFactory = function(factory) {
  goog.net.XmlHttp.factory_ = factory;
};



/**
 * Default factory to use when creating xhr objects.  You probably shouldn't be
 * instantiating this directly, but rather using it via goog.net.XmlHttp.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 */
goog.net.DefaultXmlHttpFactory = function() {
  goog.net.XmlHttpFactory.call(this);
};
goog.inherits(goog.net.DefaultXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.createInstance = function() {
  var progId = this.getProgId_();
  if (progId) {
    return new ActiveXObject(progId);
  } else {
    return new XMLHttpRequest();
  }
};


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.internalGetOptions = function() {
  var progId = this.getProgId_();
  var options = {};
  if (progId) {
    options[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] = true;
    options[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] = true;
  }
  return options;
};


/**
 * The ActiveX PROG ID string to use to create xhr's in IE. Lazily initialized.
 * @type {string|undefined}
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.ieProgId_;


/**
 * Initialize the private state used by other functions.
 * @return {string} The ActiveX PROG ID string to use to create xhr's in IE.
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.getProgId_ = function() {
  if (goog.net.XmlHttp.ASSUME_NATIVE_XHR ||
      goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR) {
    return '';
  }

  // The following blog post describes what PROG IDs to use to create the
  // XMLHTTP object in Internet Explorer:
  // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
  // However we do not (yet) fully trust that this will be OK for old versions
  // of IE on Win9x so we therefore keep the last 2.
  if (!this.ieProgId_ && typeof XMLHttpRequest == 'undefined' &&
      typeof ActiveXObject != 'undefined') {
    // Candidate Active X types.
    var ACTIVE_X_IDENTS = ['MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0',
                           'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'];
    for (var i = 0; i < ACTIVE_X_IDENTS.length; i++) {
      var candidate = ACTIVE_X_IDENTS[i];
      /** @preserveTry */
      try {
        new ActiveXObject(candidate);
        // NOTE(user): cannot assign progid and return candidate in one line
        // because JSCompiler complaings: BUG 658126
        this.ieProgId_ = candidate;
        return candidate;
      } catch (e) {
        // do nothing; try next choice
      }
    }

    // couldn't find any matches
    throw Error('Could not create ActiveXObject. ActiveX might be disabled,' +
                ' or MSXML might not be installed');
  }

  return /** @type {string} */ (this.ieProgId_);
};


//Set the global factory to an instance of the default factory.
goog.net.XmlHttp.setGlobalFactory(new goog.net.DefaultXmlHttpFactory());
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Common events for the network classes.
 */


goog.provide('goog.net.EventType');


/**
 * Event names for network events
 * @enum {string}
 */
goog.net.EventType = {
  COMPLETE: 'complete',
  SUCCESS: 'success',
  ERROR: 'error',
  ABORT: 'abort',
  READY: 'ready',
  READY_STATE_CHANGE: 'readystatechange',
  TIMEOUT: 'timeout',
  INCREMENTAL_DATA: 'incrementaldata',
  PROGRESS: 'progress'
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the collection interface.
 *
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('goog.structs.Collection');



/**
 * An interface for a collection of values.
 * @interface
 * @template T
 */
goog.structs.Collection = function() {};


/**
 * @param {T} value Value to add to the collection.
 */
goog.structs.Collection.prototype.add;


/**
 * @param {T} value Value to remove from the collection.
 */
goog.structs.Collection.prototype.remove;


/**
 * @param {T} value Value to find in the collection.
 * @return {boolean} Whether the collection contains the specified value.
 */
goog.structs.Collection.prototype.contains;


/**
 * @return {number} The number of values stored in the collection.
 */
goog.structs.Collection.prototype.getCount;

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Set.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author pallosp@google.com (Peter Pallos)
 *
 * This class implements a set data structure. Adding and removing is O(1). It
 * supports both object and primitive values. Be careful because you can add
 * both 1 and new Number(1), because these are not the same. You can even add
 * multiple new Number(1) because these are not equal.
 */


goog.provide('goog.structs.Set');

goog.require('goog.structs');
goog.require('goog.structs.Collection');
goog.require('goog.structs.Map');



/**
 * A set that can contain both primitives and objects.  Adding and removing
 * elements is O(1).  Primitives are treated as identical if they have the same
 * type and convert to the same string.  Objects are treated as identical only
 * if they are references to the same object.  WARNING: A goog.structs.Set can
 * contain both 1 and (new Number(1)), because they are not the same.  WARNING:
 * Adding (new Number(1)) twice will yield two distinct elements, because they
 * are two different objects.  WARNING: Any object that is added to a
 * goog.structs.Set will be modified!  Because goog.getUid() is used to
 * identify objects, every object in the set will be mutated.
 * @param {Array.<T>|Object.<?,T>=} opt_values Initial values to start with.
 * @constructor
 * @implements {goog.structs.Collection.<T>}
 * @final
 * @template T
 */
goog.structs.Set = function(opt_values) {
  this.map_ = new goog.structs.Map;
  if (opt_values) {
    this.addAll(opt_values);
  }
};


/**
 * Obtains a unique key for an element of the set.  Primitives will yield the
 * same key if they have the same type and convert to the same string.  Object
 * references will yield the same key only if they refer to the same object.
 * @param {*} val Object or primitive value to get a key for.
 * @return {string} A unique key for this value/object.
 * @private
 */
goog.structs.Set.getKey_ = function(val) {
  var type = typeof val;
  if (type == 'object' && val || type == 'function') {
    return 'o' + goog.getUid(/** @type {Object} */ (val));
  } else {
    return type.substr(0, 1) + val;
  }
};


/**
 * @return {number} The number of elements in the set.
 * @override
 */
goog.structs.Set.prototype.getCount = function() {
  return this.map_.getCount();
};


/**
 * Add a primitive or an object to the set.
 * @param {T} element The primitive or object to add.
 * @override
 */
goog.structs.Set.prototype.add = function(element) {
  this.map_.set(goog.structs.Set.getKey_(element), element);
};


/**
 * Adds all the values in the given collection to this set.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection
 *     containing the elements to add.
 */
goog.structs.Set.prototype.addAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.add(values[i]);
  }
};


/**
 * Removes all values in the given collection from this set.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection
 *     containing the elements to remove.
 */
goog.structs.Set.prototype.removeAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.remove(values[i]);
  }
};


/**
 * Removes the given element from this set.
 * @param {T} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 * @override
 */
goog.structs.Set.prototype.remove = function(element) {
  return this.map_.remove(goog.structs.Set.getKey_(element));
};


/**
 * Removes all elements from this set.
 */
goog.structs.Set.prototype.clear = function() {
  this.map_.clear();
};


/**
 * Tests whether this set is empty.
 * @return {boolean} True if there are no elements in this set.
 */
goog.structs.Set.prototype.isEmpty = function() {
  return this.map_.isEmpty();
};


/**
 * Tests whether this set contains the given element.
 * @param {T} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 * @override
 */
goog.structs.Set.prototype.contains = function(element) {
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};


/**
 * Tests whether this set contains all the values in a given collection.
 * Repeated elements in the collection are ignored, e.g.  (new
 * goog.structs.Set([1, 2])).containsAll([1, 1]) is True.
 * @param {goog.structs.Collection.<T>|Object} col A collection-like object.
 * @return {boolean} True if the set contains all elements.
 */
goog.structs.Set.prototype.containsAll = function(col) {
  return goog.structs.every(col, this.contains, this);
};


/**
 * Finds all values that are present in both this set and the given collection.
 * @param {Array.<S>|Object.<?,S>} col A collection.
 * @return {!goog.structs.Set.<T|S>} A new set containing all the values
 *     (primitives or objects) present in both this set and the given
 *     collection.
 * @template S
 */
goog.structs.Set.prototype.intersection = function(col) {
  var result = new goog.structs.Set();

  var values = goog.structs.getValues(col);
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    if (this.contains(value)) {
      result.add(value);
    }
  }

  return result;
};


/**
 * Finds all values that are present in this set and not in the given
 * collection.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection.
 * @return {!goog.structs.Set} A new set containing all the values
 *     (primitives or objects) present in this set but not in the given
 *     collection.
 */
goog.structs.Set.prototype.difference = function(col) {
  var result = this.clone();
  result.removeAll(col);
  return result;
};


/**
 * Returns an array containing all the elements in this set.
 * @return {!Array.<T>} An array containing all the elements in this set.
 */
goog.structs.Set.prototype.getValues = function() {
  return this.map_.getValues();
};


/**
 * Creates a shallow clone of this set.
 * @return {!goog.structs.Set.<T>} A new set containing all the same elements as
 *     this set.
 */
goog.structs.Set.prototype.clone = function() {
  return new goog.structs.Set(this);
};


/**
 * Tests whether the given collection consists of the same elements as this set,
 * regardless of order, without repetition.  Primitives are treated as equal if
 * they have the same type and convert to the same string; objects are treated
 * as equal if they are references to the same object.  This operation is O(n).
 * @param {goog.structs.Collection.<T>|Object} col A collection.
 * @return {boolean} True if the given collection consists of the same elements
 *     as this set, regardless of order, without repetition.
 */
goog.structs.Set.prototype.equals = function(col) {
  return this.getCount() == goog.structs.getCount(col) && this.isSubsetOf(col);
};


/**
 * Tests whether the given collection contains all the elements in this set.
 * Primitives are treated as equal if they have the same type and convert to the
 * same string; objects are treated as equal if they are references to the same
 * object.  This operation is O(n).
 * @param {goog.structs.Collection.<T>|Object} col A collection.
 * @return {boolean} True if this set is a subset of the given collection.
 */
goog.structs.Set.prototype.isSubsetOf = function(col) {
  var colCount = goog.structs.getCount(col);
  if (this.getCount() > colCount) {
    return false;
  }
  // TODO(user) Find the minimal collection size where the conversion makes
  // the contains() method faster.
  if (!(col instanceof goog.structs.Set) && colCount > 5) {
    // Convert to a goog.structs.Set so that goog.structs.contains runs in
    // O(1) time instead of O(n) time.
    col = new goog.structs.Set(col);
  }
  return goog.structs.every(this, function(value) {
    return goog.structs.contains(col, value);
  });
};


/**
 * Returns an iterator that iterates over the elements in this set.
 * @param {boolean=} opt_keys This argument is ignored.
 * @return {!goog.iter.Iterator} An iterator over the elements in this set.
 */
goog.structs.Set.prototype.__iterator__ = function(opt_keys) {
  return this.map_.__iterator__(false);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs.Set');
goog.require('goog.userAgent');


/** @define {boolean} Whether logging should be enabled. */
goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);


/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  // Chrome interprets onerror return value backwards (http://crbug.com/92062)
  // until it was fixed in webkit revision r94061 (Webkit 535.3). This
  // workaround still needs to be skipped in Safari after the webkit change
  // gets pushed out in Safari.
  // See https://bugs.webkit.org/show_bug.cgi?id=67119
  if (goog.userAgent.WEBKIT &&
      !goog.userAgent.isVersionOrHigher('535.3')) {
    retVal = !retVal;
  }

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just "Script error.". For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to "" for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of {@code obj}.
 */
goog.debug.expose = function(obj, opt_showFn) {
  if (typeof obj == 'undefined') {
    return 'undefined';
  }
  if (obj == null) {
    return 'NULL';
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn && goog.isFunction(obj[x])) {
      continue;
    }
    var s = x + ' = ';
    /** @preserveTry */
    try {
      s += obj[x];
    } catch (e) {
      s += '*** ' + e + ' ***';
    }
    str.push(s);
  }
  return str.join('\n');
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects.  WARNING: If an object is
 * given, it and all its nested objects will be modified.  To detect reference
 * cycles, this method identifies objects using goog.getUid() which mutates the
 * object.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of {@code obj}.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  var str = [];

  var helper = function(obj, space, parentSeen) {
    var nestspace = space + '  ';
    var seen = new goog.structs.Set(parentSeen);

    var indentMultiline = function(str) {
      return str.replace(/\n/g, '\n' + space);
    };

    /** @preserveTry */
    try {
      if (!goog.isDef(obj)) {
        str.push('undefined');
      } else if (goog.isNull(obj)) {
        str.push('NULL');
      } else if (goog.isString(obj)) {
        str.push('"' + indentMultiline(obj) + '"');
      } else if (goog.isFunction(obj)) {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        if (seen.contains(obj)) {
          str.push('*** reference loop detected ***');
        } else {
          seen.add(obj);
          str.push('{');
          for (var x in obj) {
            if (!opt_showFn && goog.isFunction(obj[x])) {
              continue;
            }
            str.push('\n');
            str.push(nestspace);
            str.push(x + ' = ');
            helper(obj[x], nestspace, seen);
          }
          str.push('\n' + space + '}');
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push('*** ' + e + ' ***');
    }
  };

  helper(obj, '', new goog.structs.Set());
  return str.join('');
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  var str = [];
  for (var i = 0; i < arr.length; i++) {
    if (goog.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return '[ ' + str.join(', ') + ' ]';
};


/**
 * Exposes an exception that has been caught by a try...catch and outputs the
 * error with a stack trace.
 * @param {Object} err Error object or string.
 * @param {Function=} opt_fn Optional function to start stack trace from.
 * @return {string} Details of exception.
 */
goog.debug.exposeException = function(err, opt_fn) {
  /** @preserveTry */
  try {
    var e = goog.debug.normalizeErrorObject(err);

    // Create the error message
    var error = 'Message: ' + goog.string.htmlEscape(e.message) +
        '\nUrl: <a href="view-source:' + e.fileName + '" target="_new">' +
        e.fileName + '</a>\nLine: ' + e.lineNumber + '\n\nBrowser stack:\n' +
        goog.string.htmlEscape(e.stack + '-> ') +
        '[end]\n\nJS stack traversal:\n' + goog.string.htmlEscape(
            goog.debug.getStacktrace(opt_fn) + '-> ');
    return error;
  } catch (e2) {
    return 'Exception trying to expose exception! You win, we lose. ' + e2;
  }
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {Object} err Raw error object.
 * @return {Object} Normalized error object.
 */
goog.debug.normalizeErrorObject = function(err) {
  var href = goog.getObjectByName('window.location.href');
  if (goog.isString(err)) {
    return {
      'message': err,
      'name': 'Unknown error',
      'lineNumber': 'Not available',
      'fileName': href,
      'stack': 'Not available'
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || 'Not available';
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing 'lineNumber':
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = 'Not available';
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global['$googDebugFname'] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing 'filename'.
    fileName = 'Not available';
    threwError = true;
  }

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    return {
      'message': err.message || 'Not available',
      'name': err.name || 'UnknownError',
      'lineNumber': lineNumber,
      'fileName': fileName,
      'stack': err.stack || 'Not available'
    };
  }

  // Standards error object
  return err;
};


/**
 * Converts an object to an Error if it's a String,
 * adds a stacktrace if there isn't one,
 * and optionally adds an extra message.
 * @param {Error|string} err  the original thrown object or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {Error} If err is a string, it is used to create a new Error,
 *     which is enhanced and returned.  Otherwise err itself is enhanced
 *     and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  var error = typeof err == 'string' ? Error(err) : err;
  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(arguments.callee.caller);
  }
  if (opt_message) {
    // find the first unoccupied 'messageX' property
    var x = 0;
    while (error['message' + x]) {
      ++x;
    }
    error['message' + x] = String(opt_message);
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn't worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn && (!opt_depth || depth < opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push('()\n');
    /** @preserveTry */
    try {
      fn = fn.caller;
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
      break;
    }
    depth++;
    if (depth >= goog.debug.MAX_STACK_DEPTH) {
      sb.push('[...long stack...]');
      break;
    }
  }
  if (opt_depth && depth >= opt_depth) {
    sb.push('[...reached max depth limit...]');
  } else {
    sb.push('[end]');
  }

  return sb.join('');
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that's currently on the call stack.
 * @param {Function=} opt_fn Optional function to start getting the trace from.
 *     If not provided, defaults to the function that called this.
 * @return {string} Stack trace.
 */
goog.debug.getStacktrace = function(opt_fn) {
  return goog.debug.getStacktraceHelper_(opt_fn || arguments.callee.caller, []);
};


/**
 * Private helper for getStacktrace().
 * @param {Function} fn Function to start getting the trace from.
 * @param {Array} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push('[...circular reference...]');

  // Traverse the call stack until function not found or max depth is reached
  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + '(');
    var args = fn.arguments;
    // Args may be null for some special functions such as host objects or eval.
    for (var i = 0; args && i < args.length; i++) {
      if (i > 0) {
        sb.push(', ');
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case 'object':
          argDesc = arg ? 'object' : 'null';
          break;

        case 'string':
          argDesc = arg;
          break;

        case 'number':
          argDesc = String(arg);
          break;

        case 'boolean':
          argDesc = arg ? 'true' : 'false';
          break;

        case 'function':
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : '[fn]';
          break;

        case 'undefined':
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length > 40) {
        argDesc = argDesc.substr(0, 40) + '...';
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(')\n');
    /** @preserveTry */
    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
    }

  } else if (fn) {
    sb.push('[...long stack...]');
  } else {
    sb.push('[end]');
  }
  return sb.join('');
};


/**
 * Set a custom function name resolver.
 * @param {function(Function): string} resolver Resolves functions to their
 *     names.
 */
goog.debug.setFunctionResolver = function(resolver) {
  goog.debug.fnNameResolver_ = resolver;
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function's name.
 */
goog.debug.getFunctionName = function(fn) {
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }
  if (goog.debug.fnNameResolver_) {
    var name = goog.debug.fnNameResolver_(fn);
    if (name) {
      goog.debug.fnNameCache_[fn] = name;
      return name;
    }
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function ([^\(]+)/.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  return string.replace(/ /g, '[_]')
      .replace(/\f/g, '[f]')
      .replace(/\n/g, '[n]\n')
      .replace(/\r/g, '[r]')
      .replace(/\t/g, '[t]');
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Resolves functions to their names.  Resolved function names will be cached.
 * @type {function(Function):string}
 * @private
 */
goog.debug.fnNameResolver_;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the LogRecord class. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 */

goog.provide('goog.debug.LogRecord');



/**
 * LogRecord objects are used to pass logging requests between
 * the logging framework and individual log Handlers.
 * @constructor
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber);
};


/**
 * Time the LogRecord was created.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.time_;


/**
 * Level of the LogRecord
 * @type {goog.debug.Logger.Level}
 * @private
 */
goog.debug.LogRecord.prototype.level_;


/**
 * Message associated with the record
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.msg_;


/**
 * Name of the logger that created the record.
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.loggerName_;


/**
 * Sequence number for the LogRecord. Each record has a unique sequence number
 * that is greater than all log records created before it.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.sequenceNumber_ = 0;


/**
 * Exception associated with the record
 * @type {Object}
 * @private
 */
goog.debug.LogRecord.prototype.exception_ = null;


/**
 * Exception text associated with the record
 * @type {?string}
 * @private
 */
goog.debug.LogRecord.prototype.exceptionText_ = null;


/**
 * @define {boolean} Whether to enable log sequence numbers.
 */
goog.define('goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS', true);


/**
 * A sequence counter for assigning increasing sequence numbers to LogRecord
 * objects.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.nextSequenceNumber_ = 0;


/**
 * Sets all fields of the log record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord.prototype.reset = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) {
    this.sequenceNumber_ = typeof opt_sequenceNumber == 'number' ?
        opt_sequenceNumber : goog.debug.LogRecord.nextSequenceNumber_++;
  }

  this.time_ = opt_time || goog.now();
  this.level_ = level;
  this.msg_ = msg;
  this.loggerName_ = loggerName;
  delete this.exception_;
  delete this.exceptionText_;
};


/**
 * Get the source Logger's name.
 *
 * @return {string} source logger name (may be null).
 */
goog.debug.LogRecord.prototype.getLoggerName = function() {
  return this.loggerName_;
};


/**
 * Get the exception that is part of the log record.
 *
 * @return {Object} the exception.
 */
goog.debug.LogRecord.prototype.getException = function() {
  return this.exception_;
};


/**
 * Set the exception that is part of the log record.
 *
 * @param {Object} exception the exception.
 */
goog.debug.LogRecord.prototype.setException = function(exception) {
  this.exception_ = exception;
};


/**
 * Get the exception text that is part of the log record.
 *
 * @return {?string} Exception text.
 */
goog.debug.LogRecord.prototype.getExceptionText = function() {
  return this.exceptionText_;
};


/**
 * Set the exception text that is part of the log record.
 *
 * @param {string} text The exception text.
 */
goog.debug.LogRecord.prototype.setExceptionText = function(text) {
  this.exceptionText_ = text;
};


/**
 * Get the source Logger's name.
 *
 * @param {string} loggerName source logger name (may be null).
 */
goog.debug.LogRecord.prototype.setLoggerName = function(loggerName) {
  this.loggerName_ = loggerName;
};


/**
 * Get the logging message level, for example Level.SEVERE.
 * @return {goog.debug.Logger.Level} the logging message level.
 */
goog.debug.LogRecord.prototype.getLevel = function() {
  return this.level_;
};


/**
 * Set the logging message level, for example Level.SEVERE.
 * @param {goog.debug.Logger.Level} level the logging message level.
 */
goog.debug.LogRecord.prototype.setLevel = function(level) {
  this.level_ = level;
};


/**
 * Get the "raw" log message, before localization or formatting.
 *
 * @return {string} the raw message string.
 */
goog.debug.LogRecord.prototype.getMessage = function() {
  return this.msg_;
};


/**
 * Set the "raw" log message, before localization or formatting.
 *
 * @param {string} msg the raw message string.
 */
goog.debug.LogRecord.prototype.setMessage = function(msg) {
  this.msg_ = msg;
};


/**
 * Get event time in milliseconds since 1970.
 *
 * @return {number} event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.getMillis = function() {
  return this.time_;
};


/**
 * Set event time in milliseconds since 1970.
 *
 * @param {number} time event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.setMillis = function(time) {
  this.time_ = time;
};


/**
 * Get the sequence number.
 * <p>
 * Sequence numbers are normally assigned in the LogRecord
 * constructor, which assigns unique sequence numbers to
 * each new LogRecord in increasing order.
 * @return {number} the sequence number.
 */
goog.debug.LogRecord.prototype.getSequenceNumber = function() {
  return this.sequenceNumber_;
};

// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */

goog.provide('goog.debug.LogBuffer');

goog.require('goog.asserts');
goog.require('goog.debug.LogRecord');



/**
 * Creates the log buffer.
 * @constructor
 * @final
 */
goog.debug.LogBuffer = function() {
  goog.asserts.assert(goog.debug.LogBuffer.isBufferingEnabled(),
      'Cannot use goog.debug.LogBuffer without defining ' +
      'goog.debug.LogBuffer.CAPACITY.');
  this.clear();
};


/**
 * A static method that always returns the same instance of LogBuffer.
 * @return {!goog.debug.LogBuffer} The LogBuffer singleton instance.
 */
goog.debug.LogBuffer.getInstance = function() {
  if (!goog.debug.LogBuffer.instance_) {
    // This function is written with the return statement after the assignment
    // to avoid the jscompiler StripCode bug described in http://b/2608064.
    // After that bug is fixed this can be refactored.
    goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer();
  }
  return goog.debug.LogBuffer.instance_;
};


/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.define('goog.debug.LogBuffer.CAPACITY', 0);


/**
 * The array to store the records.
 * @type {!Array.<!goog.debug.LogRecord|undefined>}
 * @private
 */
goog.debug.LogBuffer.prototype.buffer_;


/**
 * The index of the most recently added record or -1 if there are no records.
 * @type {number}
 * @private
 */
goog.debug.LogBuffer.prototype.curIndex_;


/**
 * Whether the buffer is at capacity.
 * @type {boolean}
 * @private
 */
goog.debug.LogBuffer.prototype.isFull_;


/**
 * Adds a log record to the buffer, possibly overwriting the oldest record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @return {!goog.debug.LogRecord} The log record.
 */
goog.debug.LogBuffer.prototype.addRecord = function(level, msg, loggerName) {
  var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;
  this.curIndex_ = curIndex;
  if (this.isFull_) {
    var ret = this.buffer_[curIndex];
    ret.reset(level, msg, loggerName);
    return ret;
  }
  this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;
  return this.buffer_[curIndex] =
      new goog.debug.LogRecord(level, msg, loggerName);
};


/**
 * @return {boolean} Whether the log buffer is enabled.
 */
goog.debug.LogBuffer.isBufferingEnabled = function() {
  return goog.debug.LogBuffer.CAPACITY > 0;
};


/**
 * Removes all buffered log records.
 */
goog.debug.LogBuffer.prototype.clear = function() {
  this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);
  this.curIndex_ = -1;
  this.isFull_ = false;
};


/**
 * Calls the given function for each buffered log record, starting with the
 * oldest one.
 * @param {function(!goog.debug.LogRecord)} func The function to call.
 */
goog.debug.LogBuffer.prototype.forEachRecord = function(func) {
  var buffer = this.buffer_;
  // Corner case: no records.
  if (!buffer[0]) {
    return;
  }
  var curIndex = this.curIndex_;
  var i = this.isFull_ ? curIndex : -1;
  do {
    i = (i + 1) % goog.debug.LogBuffer.CAPACITY;
    func(/** @type {!goog.debug.LogRecord} */ (buffer[i]));
  } while (i != curIndex);
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the Logger class. Please minimize dependencies
 * this file has on other closure classes as any dependency it takes won't be
 * able to use the logging infrastructure.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug.LogManager');
goog.provide('goog.debug.Loggable');
goog.provide('goog.debug.Logger');
goog.provide('goog.debug.Logger.Level');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug');
goog.require('goog.debug.LogBuffer');
goog.require('goog.debug.LogRecord');


/**
 * A message value that can be handled by a Logger.
 *
 * Functions are treated like callbacks, but are only called when the event's
 * log level is enabled. This is useful for logging messages that are expensive
 * to construct.
 *
 * @typedef {string|function(): string}
 */
goog.debug.Loggable;



/**
 * The Logger is an object used for logging debug messages. Loggers are
 * normally named, using a hierarchical dot-separated namespace. Logger names
 * can be arbitrary strings, but they should normally be based on the package
 * name or class name of the logged component, such as goog.net.BrowserChannel.
 *
 * The Logger object is loosely based on the java class
 * java.util.logging.Logger. It supports different levels of filtering for
 * different loggers.
 *
 * The logger object should never be instantiated by application code. It
 * should always use the goog.debug.Logger.getLogger function.
 *
 * @constructor
 * @param {string} name The name of the Logger.
 * @final
 */
goog.debug.Logger = function(name) {
  /**
   * Name of the Logger. Generally a dot-separated namespace
   * @private {string}
   */
  this.name_ = name;

  /**
   * Parent Logger.
   * @private {goog.debug.Logger}
   */
  this.parent_ = null;

  /**
   * Level that this logger only filters above. Null indicates it should
   * inherit from the parent.
   * @private {goog.debug.Logger.Level}
   */
  this.level_ = null;

  /**
   * Map of children loggers. The keys are the leaf names of the children and
   * the values are the child loggers.
   * @private {Object}
   */
  this.children_ = null;

  /**
   * Handlers that are listening to this logger.
   * @private {Array.<Function>}
   */
  this.handlers_ = null;
};


/**
 * @define {boolean} Toggles whether loggers other than the root logger can have
 *     log handlers attached to them and whether they can have their log level
 *     set. Logging is a bit faster when this is set to false.
 */
goog.define('goog.debug.Logger.ENABLE_HIERARCHY', true);


if (!goog.debug.Logger.ENABLE_HIERARCHY) {
  /**
   * @type {!Array.<Function>}
   * @private
   */
  goog.debug.Logger.rootHandlers_ = [];


  /**
   * @type {goog.debug.Logger.Level}
   * @private
   */
  goog.debug.Logger.rootLevel_;
}



/**
 * The Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * <p>
 * Clients should normally use the predefined Level constants such
 * as Level.SEVERE.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (highest value)
 * <li>WARNING
 * <li>INFO
 * <li>CONFIG
 * <li>FINE
 * <li>FINER
 * <li>FINEST  (lowest value)
 * </ul>
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 *
 * @param {string} name The name of the level.
 * @param {number} value The numeric value of the level.
 * @constructor
 * @final
 */
goog.debug.Logger.Level = function(name, value) {
  /**
   * The name of the level
   * @type {string}
   */
  this.name = name;

  /**
   * The numeric value of the level
   * @type {number}
   */
  this.value = value;
};


/**
 * @return {string} String representation of the logger level.
 * @override
 */
goog.debug.Logger.Level.prototype.toString = function() {
  return this.name;
};


/**
 * OFF is a special level that can be used to turn off logging.
 * This level is initialized to <CODE>Infinity</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.OFF =
    new goog.debug.Logger.Level('OFF', Infinity);


/**
 * SHOUT is a message level for extra debugging loudness.
 * This level is initialized to <CODE>1200</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level('SHOUT', 1200);


/**
 * SEVERE is a message level indicating a serious failure.
 * This level is initialized to <CODE>1000</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level('SEVERE', 1000);


/**
 * WARNING is a message level indicating a potential problem.
 * This level is initialized to <CODE>900</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level('WARNING', 900);


/**
 * INFO is a message level for informational messages.
 * This level is initialized to <CODE>800</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.INFO = new goog.debug.Logger.Level('INFO', 800);


/**
 * CONFIG is a message level for static configuration messages.
 * This level is initialized to <CODE>700</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level('CONFIG', 700);


/**
 * FINE is a message level providing tracing information.
 * This level is initialized to <CODE>500</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINE = new goog.debug.Logger.Level('FINE', 500);


/**
 * FINER indicates a fairly detailed tracing message.
 * This level is initialized to <CODE>400</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINER = new goog.debug.Logger.Level('FINER', 400);

/**
 * FINEST indicates a highly detailed tracing message.
 * This level is initialized to <CODE>300</CODE>.
 * @type {!goog.debug.Logger.Level}
 */

goog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level('FINEST', 300);


/**
 * ALL indicates that all messages should be logged.
 * This level is initialized to <CODE>0</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.ALL = new goog.debug.Logger.Level('ALL', 0);


/**
 * The predefined levels.
 * @type {!Array.<!goog.debug.Logger.Level>}
 * @final
 */
goog.debug.Logger.Level.PREDEFINED_LEVELS = [
  goog.debug.Logger.Level.OFF,
  goog.debug.Logger.Level.SHOUT,
  goog.debug.Logger.Level.SEVERE,
  goog.debug.Logger.Level.WARNING,
  goog.debug.Logger.Level.INFO,
  goog.debug.Logger.Level.CONFIG,
  goog.debug.Logger.Level.FINE,
  goog.debug.Logger.Level.FINER,
  goog.debug.Logger.Level.FINEST,
  goog.debug.Logger.Level.ALL];


/**
 * A lookup map used to find the level object based on the name or value of
 * the level object.
 * @type {Object}
 * @private
 */
goog.debug.Logger.Level.predefinedLevelsCache_ = null;


/**
 * Creates the predefined levels cache and populates it.
 * @private
 */
goog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {
  goog.debug.Logger.Level.predefinedLevelsCache_ = {};
  for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
       i++) {
    goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;
    goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;
  }
};


/**
 * Gets the predefined level with the given name.
 * @param {string} name The name of the level.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevel = function(name) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;
};


/**
 * Gets the highest predefined level <= #value.
 * @param {number} value Level value.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  if (value in goog.debug.Logger.Level.predefinedLevelsCache_) {
    return goog.debug.Logger.Level.predefinedLevelsCache_[value];
  }

  for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {
    var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
    if (level.value <= value) {
      return level;
    }
  }
  return null;
};


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise a new logger is
 * created. If a new logger is created its log level will be configured based
 * on the LogManager configuration and it will configured to also send logging
 * output to its parent's handlers. It will be registered in the LogManager
 * global namespace.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 * @deprecated use goog.log instead. http://go/goog-debug-logger-deprecated
 */
goog.debug.Logger.getLogger = function(name) {
  return goog.debug.LogManager.getLogger(name);
};


/**
 * Logs a message to profiling tools, if available.
 * {@see http://code.google.com/webtoolkit/speedtracer/logging-api.html}
 * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}
 * @param {string} msg The message to log.
 */
goog.debug.Logger.logToProfilers = function(msg) {
  // Using goog.global, as loggers might be used in window-less contexts.
  if (goog.global['console']) {
    if (goog.global['console']['timeStamp']) {
      // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.
      goog.global['console']['timeStamp'](msg);
    } else if (goog.global['console']['markTimeline']) {
      // TODO(user): markTimeline is deprecated. Drop this else clause entirely
      // after Chrome M14 hits stable.
      goog.global['console']['markTimeline'](msg);
    }
  }

  if (goog.global['msWriteProfilerMark']) {
    // Logs a message to the Microsoft profiler
    goog.global['msWriteProfilerMark'](msg);
  }
};


/**
 * Gets the name of this logger.
 * @return {string} The name of this logger.
 */
goog.debug.Logger.prototype.getName = function() {
  return this.name_;
};


/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to add.
 */
goog.debug.Logger.prototype.addHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      if (!this.handlers_) {
        this.handlers_ = [];
      }
      this.handlers_.push(handler);
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call addHandler on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootHandlers_.push(handler);
    }
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.debug.Logger.prototype.removeHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ? this.handlers_ :
        goog.debug.Logger.rootHandlers_;
    return !!handlers && goog.array.remove(handlers, handler);
  } else {
    return false;
  }
};


/**
 * Returns the parent of this logger.
 * @return {goog.debug.Logger} The parent logger or null if this is the root.
 */
goog.debug.Logger.prototype.getParent = function() {
  return this.parent_;
};


/**
 * Returns the children of this logger as a map of the child name to the logger.
 * @return {!Object} The map where the keys are the child leaf names and the
 *     values are the Logger objects.
 */
goog.debug.Logger.prototype.getChildren = function() {
  if (!this.children_) {
    this.children_ = {};
  }
  return this.children_;
};


/**
 * Set the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the new level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @param {goog.debug.Logger.Level} level The new level.
 */
goog.debug.Logger.prototype.setLevel = function(level) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      this.level_ = level;
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call setLevel() on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootLevel_ = level;
    }
  }
};


/**
 * Gets the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getLevel = function() {
  return goog.debug.LOGGING_ENABLED ?
      this.level_ : goog.debug.Logger.Level.OFF;
};


/**
 * Returns the effective level of the logger based on its ancestors' levels.
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getEffectiveLevel = function() {
  if (!goog.debug.LOGGING_ENABLED) {
    return goog.debug.Logger.Level.OFF;
  }

  if (!goog.debug.Logger.ENABLE_HIERARCHY) {
    return goog.debug.Logger.rootLevel_;
  }
  if (this.level_) {
    return this.level_;
  }
  if (this.parent_) {
    return this.parent_.getEffectiveLevel();
  }
  goog.asserts.fail('Root logger has no level set.');
  return null;
};


/**
 * Checks if a message of the given level would actually be logged by this
 * logger. This check is based on the Loggers effective level, which may be
 * inherited from its parent.
 * @param {goog.debug.Logger.Level} level The level to check.
 * @return {boolean} Whether the message would be logged.
 */
goog.debug.Logger.prototype.isLoggable = function(level) {
  return goog.debug.LOGGING_ENABLED &&
      level.value >= this.getEffectiveLevel().value;
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 */
goog.debug.Logger.prototype.log = function(level, msg, opt_exception) {
  // java caches the effective level, not sure it's necessary here
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {
    // Message callbacks can be useful when a log message is expensive to build.
    if (goog.isFunction(msg)) {
      msg = msg();
    }

    this.doLogRecord_(this.getLogRecord(level, msg, opt_exception));
  }
};


/**
 * Creates a new log record and adds the exception (if present) to it.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 * @return {!goog.debug.LogRecord} A log record.
 */
goog.debug.Logger.prototype.getLogRecord = function(level, msg, opt_exception) {
  if (goog.debug.LogBuffer.isBufferingEnabled()) {
    var logRecord =
        goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);
  } else {
    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);
  }
  if (opt_exception) {
    logRecord.setException(opt_exception);
    logRecord.setExceptionText(
        goog.debug.exposeException(opt_exception, arguments.callee.caller));
  }
  return logRecord;
};


/**
 * Logs a message at the Logger.Level.SHOUT level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.shout = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.severe = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.warning = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.info = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.CONFIG level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.config = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.fine = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINER level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finer = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINEST level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finest = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);
  }
};


/**
 * Logs a LogRecord. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 */
goog.debug.Logger.prototype.logRecord = function(logRecord) {
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) {
    this.doLogRecord_(logRecord);
  }
};


/**
 * Logs a LogRecord.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 * @private
 */
goog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {
  goog.debug.Logger.logToProfilers('log:' + logRecord.getMessage());
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var target = this;
    while (target) {
      target.callPublish_(logRecord);
      target = target.getParent();
    }
  } else {
    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++]; ) {
      handler(logRecord);
    }
  }
};


/**
 * Calls the handlers for publish.
 * @param {goog.debug.LogRecord} logRecord The log record to publish.
 * @private
 */
goog.debug.Logger.prototype.callPublish_ = function(logRecord) {
  if (this.handlers_) {
    for (var i = 0, handler; handler = this.handlers_[i]; i++) {
      handler(logRecord);
    }
  }
};


/**
 * Sets the parent of this logger. This is used for setting up the logger tree.
 * @param {goog.debug.Logger} parent The parent logger.
 * @private
 */
goog.debug.Logger.prototype.setParent_ = function(parent) {
  this.parent_ = parent;
};


/**
 * Adds a child to this logger. This is used for setting up the logger tree.
 * @param {string} name The leaf name of the child.
 * @param {goog.debug.Logger} logger The child logger.
 * @private
 */
goog.debug.Logger.prototype.addChild_ = function(name, logger) {
  this.getChildren()[name] = logger;
};


/**
 * There is a single global LogManager object that is used to maintain a set of
 * shared state about Loggers and log services. This is loosely based on the
 * java class java.util.logging.LogManager.
 */
goog.debug.LogManager = {};


/**
 * Map of logger names to logger objects.
 *
 * @type {!Object.<string, !goog.debug.Logger>}
 * @private
 */
goog.debug.LogManager.loggers_ = {};


/**
 * The root logger which is the root of the logger tree.
 * @type {goog.debug.Logger}
 * @private
 */
goog.debug.LogManager.rootLogger_ = null;


/**
 * Initializes the LogManager if not already initialized.
 */
goog.debug.LogManager.initialize = function() {
  if (!goog.debug.LogManager.rootLogger_) {
    goog.debug.LogManager.rootLogger_ = new goog.debug.Logger('');
    goog.debug.LogManager.loggers_[''] = goog.debug.LogManager.rootLogger_;
    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);
  }
};


/**
 * Returns all the loggers.
 * @return {!Object.<string, !goog.debug.Logger>} Map of logger names to logger
 *     objects.
 */
goog.debug.LogManager.getLoggers = function() {
  return goog.debug.LogManager.loggers_;
};


/**
 * Returns the root of the logger tree namespace, the logger with the empty
 * string as its name.
 *
 * @return {!goog.debug.Logger} The root logger.
 */
goog.debug.LogManager.getRoot = function() {
  goog.debug.LogManager.initialize();
  return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);
};


/**
 * Finds a named logger.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 */
goog.debug.LogManager.getLogger = function(name) {
  goog.debug.LogManager.initialize();
  var ret = goog.debug.LogManager.loggers_[name];
  return ret || goog.debug.LogManager.createLogger_(name);
};


/**
 * Creates a function that can be passed to goog.debug.catchErrors. The function
 * will log all reported errors using the given logger.
 * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.
 *     Defaults to the root logger.
 * @return {function(Object)} The created function.
 */
goog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {
  return function(info) {
    var logger = opt_logger || goog.debug.LogManager.getRoot();
    logger.severe('Error: ' + info.message + ' (' + info.fileName +
                  ' @ Line: ' + info.line + ')');
  };
};


/**
 * Creates the named logger. Will also create the parents of the named logger
 * if they don't yet exist.
 * @param {string} name The name of the logger.
 * @return {!goog.debug.Logger} The named logger.
 * @private
 */
goog.debug.LogManager.createLogger_ = function(name) {
  // find parent logger
  var logger = new goog.debug.Logger(name);
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var lastDotIndex = name.lastIndexOf('.');
    var parentName = name.substr(0, lastDotIndex);
    var leafName = name.substr(lastDotIndex + 1);
    var parentLogger = goog.debug.LogManager.getLogger(parentName);

    // tell the parent about the child and the child about the parent
    parentLogger.addChild_(leafName, logger);
    logger.setParent_(parentLogger);
  }

  goog.debug.LogManager.loggers_[name] = logger;
  return logger;
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Basic strippable logging definitions.
 * @see http://go/closurelogging
 *
 * @author johnlenz@google.com (John Lenz)
 */

goog.provide('goog.log');
goog.provide('goog.log.Level');
goog.provide('goog.log.LogRecord');
goog.provide('goog.log.Logger');

goog.require('goog.debug');
goog.require('goog.debug.LogManager');
goog.require('goog.debug.LogRecord');
goog.require('goog.debug.Logger');


/** @define {boolean} Whether logging is enabled. */
goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);



/**
 * @constructor
 * @final
 */
goog.log.Logger = goog.debug.Logger;



/**
 * @constructor
 * @final
 */
goog.log.Level = goog.debug.Logger.Level;



/**
 * @constructor
 * @final
 */
goog.log.LogRecord = goog.debug.LogRecord;


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise a new logger is
 * created. If a new logger is created its log level will be configured based
 * on the goog.debug.LogManager configuration and it will configured to also
 * send logging output to its parent's handlers.
 * @see goog.debug.LogManager
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 *     name and should normally be based on the package name or class name of
 *     the subsystem, such as goog.net.BrowserChannel.
 * @param {goog.log.Level=} opt_level If provided, override the
 *     default logging level with the provided level.
 * @return {goog.log.Logger} The named logger or null if logging is disabled.
 */
goog.log.getLogger = function(name, opt_level) {
  if (goog.log.ENABLED) {
    var logger = goog.debug.LogManager.getLogger(name);
    if (opt_level && logger) {
      logger.setLevel(opt_level);
    }
    return logger;
  } else {
    return null;
  }
};


// TODO(johnlenz): try to tighten the types to these functions.
/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {goog.log.Logger} logger
 * @param {Function} handler Handler function to add.
 */
goog.log.addHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    logger.addHandler(handler);
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {goog.log.Logger} logger
 * @param {Function} handler Handler function to remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.log.removeHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    return logger.removeHandler(handler);
  } else {
    return false;
  }
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.log.Level} level One of the level identifiers.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 */
goog.log.log = function(logger, level, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.log(level, msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.error = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.severe(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.warning = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.warning(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.info = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.info(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.Fine level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.fine = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.fine(msg, opt_exception);
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper class for handling XmlHttpRequests.
 *
 * One off requests can be sent through goog.net.XhrIo.send() or an
 * instance can be created to send multiple requests.  Each request uses its
 * own XmlHttpRequest object and handles clearing of the event callback to
 * ensure no leaks.
 *
 * XhrIo is event based, it dispatches events when a request finishes, fails or
 * succeeds or when the ready-state changes. The ready-state or timeout event
 * fires first, followed by a generic completed event. Then the abort, error,
 * or success event is fired as appropriate. Lastly, the ready event will fire
 * to indicate that the object may be used to make another request.
 *
 * The error event may also be called before completed and
 * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.
 *
 * This class does not support multiple requests, queuing, or prioritization.
 *
 * Tested = IE6, FF1.5, Safari, Opera 8.5
 *
 * TODO(user): Error cases aren't playing nicely in Safari.
 *
 */


goog.provide('goog.net.XhrIo');
goog.provide('goog.net.XhrIo.ResponseType');

goog.require('goog.Timer');
goog.require('goog.array');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.EventTarget');
goog.require('goog.json');
goog.require('goog.log');
goog.require('goog.net.ErrorCode');
goog.require('goog.net.EventType');
goog.require('goog.net.HttpStatus');
goog.require('goog.net.XmlHttp');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.userAgent');



/**
 * Basic class for handling XMLHttpRequests.
 * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when
 *     creating XMLHttpRequest objects.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.net.XhrIo = function(opt_xmlHttpFactory) {
  goog.net.XhrIo.base(this, 'constructor');

  /**
   * Map of default headers to add to every request, use:
   * XhrIo.headers.set(name, value)
   * @type {!goog.structs.Map}
   */
  this.headers = new goog.structs.Map();

  /**
   * Optional XmlHttpFactory
   * @private {goog.net.XmlHttpFactory}
   */
  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;

  /**
   * Whether XMLHttpRequest is active.  A request is active from the time send()
   * is called until onReadyStateChange() is complete, or error() or abort()
   * is called.
   * @private {boolean}
   */
  this.active_ = false;

  /**
   * The XMLHttpRequest object that is being used for the transfer.
   * @private {?goog.net.XhrLike.OrNative}
   */
  this.xhr_ = null;

  /**
   * The options to use with the current XMLHttpRequest object.
   * @private {Object}
   */
  this.xhrOptions_ = null;

  /**
   * Last URL that was requested.
   * @private {string|goog.Uri}
   */
  this.lastUri_ = '';

  /**
   * Method for the last request.
   * @private {string}
   */
  this.lastMethod_ = '';

  /**
   * Last error code.
   * @private {!goog.net.ErrorCode}
   */
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;

  /**
   * Last error message.
   * @private {Error|string}
   */
  this.lastError_ = '';

  /**
   * Used to ensure that we don't dispatch an multiple ERROR events. This can
   * happen in IE when it does a synchronous load and one error is handled in
   * the ready statte change and one is handled due to send() throwing an
   * exception.
   * @private {boolean}
   */
  this.errorDispatched_ = false;

  /**
   * Used to make sure we don't fire the complete event from inside a send call.
   * @private {boolean}
   */
  this.inSend_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.open.
   * @private {boolean}
   */
  this.inOpen_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.abort.
   * @private {boolean}
   */
  this.inAbort_ = false;

  /**
   * Number of milliseconds after which an incomplete request will be aborted
   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout
   * is set.
   * @private {number}
   */
  this.timeoutInterval_ = 0;

  /**
   * Timer to track request timeout.
   * @private {?number}
   */
  this.timeoutId_ = null;

  /**
   * The requested type for the response. The empty string means use the default
   * XHR behavior.
   * @private {goog.net.XhrIo.ResponseType}
   */
  this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;

  /**
   * Whether a "credentialed" request is to be sent (one that is aware of
   * cookies and authentication). This is applicable only for cross-domain
   * requests and more recent browsers that support this part of the HTTP Access
   * Control standard.
   *
   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute
   *
   * @private {boolean}
   */
  this.withCredentials_ = false;

  /**
   * True if we can use XMLHttpRequest's timeout directly.
   * @private {boolean}
   */
  this.useXhr2Timeout_ = false;
};
goog.inherits(goog.net.XhrIo, goog.events.EventTarget);


/**
 * Response types that may be requested for XMLHttpRequests.
 * @enum {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute
 */
goog.net.XhrIo.ResponseType = {
  DEFAULT: '',
  TEXT: 'text',
  DOCUMENT: 'document',
  // Not supported as of Chrome 10.0.612.1 dev
  BLOB: 'blob',
  ARRAY_BUFFER: 'arraybuffer'
};


/**
 * A reference to the XhrIo logger
 * @private {goog.debug.Logger}
 * @const
 */
goog.net.XhrIo.prototype.logger_ =
    goog.log.getLogger('goog.net.XhrIo');


/**
 * The Content-Type HTTP header name
 * @type {string}
 */
goog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';


/**
 * The pattern matching the 'http' and 'https' URI schemes
 * @type {!RegExp}
 */
goog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;


/**
 * The methods that typically come along with form data.  We set different
 * headers depending on whether the HTTP action is one of these.
 */
goog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];


/**
 * The Content-Type HTTP header value for a url-encoded form
 * @type {string}
 */
goog.net.XhrIo.FORM_CONTENT_TYPE =
    'application/x-www-form-urlencoded;charset=utf-8';


/**
 * The XMLHttpRequest Level two timeout delay ms property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';


/**
 * The XMLHttpRequest Level two ontimeout handler property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';


/**
 * All non-disposed instances of goog.net.XhrIo created
 * by {@link goog.net.XhrIo.send} are in this Array.
 * @see goog.net.XhrIo.cleanup
 * @private {!Array.<!goog.net.XhrIo>}
 */
goog.net.XhrIo.sendInstances_ = [];


/**
 * Static send that creates a short lived instance of XhrIo to send the
 * request.
 * @see goog.net.XhrIo.cleanup
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {Function=} opt_callback Callback function for when request is
 *     complete.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}
 *     opt_content Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 * @param {number=} opt_timeoutInterval Number of milliseconds after which an
 *     incomplete request will be aborted; 0 means no timeout is set.
 * @param {boolean=} opt_withCredentials Whether to send credentials with the
 *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.
 */
goog.net.XhrIo.send = function(url, opt_callback, opt_method, opt_content,
                               opt_headers, opt_timeoutInterval,
                               opt_withCredentials) {
  var x = new goog.net.XhrIo();
  goog.net.XhrIo.sendInstances_.push(x);
  if (opt_callback) {
    x.listen(goog.net.EventType.COMPLETE, opt_callback);
  }
  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);
  if (opt_timeoutInterval) {
    x.setTimeoutInterval(opt_timeoutInterval);
  }
  if (opt_withCredentials) {
    x.setWithCredentials(opt_withCredentials);
  }
  x.send(url, opt_method, opt_content, opt_headers);
};


/**
 * Disposes all non-disposed instances of goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send}.
 * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance
 * it creates when the request completes or fails.  However, if
 * the request never completes, then the goog.net.XhrIo is not disposed.
 * This can occur if the window is unloaded before the request completes.
 * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo
 * it creates and make the client of {@link goog.net.XhrIo.send} be
 * responsible for disposing it in this case.  However, this makes things
 * significantly more complicated for the client, and the whole point
 * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.
 * Clients of {@link goog.net.XhrIo.send} should call
 * {@link goog.net.XhrIo.cleanup} when doing final
 * cleanup on window unload.
 */
goog.net.XhrIo.cleanup = function() {
  var instances = goog.net.XhrIo.sendInstances_;
  while (instances.length) {
    instances.pop().dispose();
  }
};


/**
 * Installs exception protection for all entry point introduced by
 * goog.net.XhrIo instances which are not protected by
 * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},
 * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or
 * {@link goog.events.protectBrowserEventEntryPoint}.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point(s).
 */
goog.net.XhrIo.protectEntryPoints = function(errorHandler) {
  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
      errorHandler.protectEntryPoint(
          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
};


/**
 * Disposes of the specified goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send} and removes it from
 * {@link goog.net.XhrIo.pendingStaticSendInstances_}.
 * @private
 */
goog.net.XhrIo.prototype.cleanupSend_ = function() {
  this.dispose();
  goog.array.remove(goog.net.XhrIo.sendInstances_, this);
};


/**
 * Returns the number of milliseconds after which an incomplete request will be
 * aborted, or 0 if no timeout is set.
 * @return {number} Timeout interval in milliseconds.
 */
goog.net.XhrIo.prototype.getTimeoutInterval = function() {
  return this.timeoutInterval_;
};


/**
 * Sets the number of milliseconds after which an incomplete request will be
 * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no
 * timeout is set.
 * @param {number} ms Timeout interval in milliseconds; 0 means none.
 */
goog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {
  this.timeoutInterval_ = Math.max(0, ms);
};


/**
 * Sets the desired type for the response. At time of writing, this is only
 * supported in very recent versions of WebKit (10.0.612.1 dev and later).
 *
 * If this is used, the response may only be accessed via {@link #getResponse}.
 *
 * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.
 */
goog.net.XhrIo.prototype.setResponseType = function(type) {
  this.responseType_ = type;
};


/**
 * Gets the desired type for the response.
 * @return {goog.net.XhrIo.ResponseType} The desired type for the response.
 */
goog.net.XhrIo.prototype.getResponseType = function() {
  return this.responseType_;
};


/**
 * Sets whether a "credentialed" request that is aware of cookie and
 * authentication information should be made. This option is only supported by
 * browsers that support HTTP Access Control. As of this writing, this option
 * is not supported in IE.
 *
 * @param {boolean} withCredentials Whether this should be a "credentialed"
 *     request.
 */
goog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {
  this.withCredentials_ = withCredentials;
};


/**
 * Gets whether a "credentialed" request is to be sent.
 * @return {boolean} The desired type for the response.
 */
goog.net.XhrIo.prototype.getWithCredentials = function() {
  return this.withCredentials_;
};


/**
 * Instance send that actually uses XMLHttpRequest to make a server call.
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}
 *     opt_content Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 */
goog.net.XhrIo.prototype.send = function(url, opt_method, opt_content,
                                         opt_headers) {
  if (this.xhr_) {
    throw Error('[goog.net.XhrIo] Object is active with another request=' +
        this.lastUri_ + '; newUri=' + url);
  }

  var method = opt_method ? opt_method.toUpperCase() : 'GET';

  this.lastUri_ = url;
  this.lastError_ = '';
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
  this.lastMethod_ = method;
  this.errorDispatched_ = false;
  this.active_ = true;

  // Use the factory to create the XHR object and options
  this.xhr_ = this.createXhr();
  this.xhrOptions_ = this.xmlHttpFactory_ ?
      this.xmlHttpFactory_.getOptions() : goog.net.XmlHttp.getOptions();

  // Set up the onreadystatechange callback
  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);

  /**
   * Try to open the XMLHttpRequest (always async), if an error occurs here it
   * is generally permission denied
   * @preserveTry
   */
  try {
    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));
    this.inOpen_ = true;
    this.xhr_.open(method, String(url), true);  // Always async!
    this.inOpen_ = false;
  } catch (err) {
    goog.log.fine(this.logger_,
        this.formatMsg_('Error opening Xhr: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
    return;
  }

  // We can't use null since this won't allow requests with form data to have a
  // content length specified which will cause some proxies to return a 411
  // error.
  var content = opt_content || '';

  var headers = this.headers.clone();

  // Add headers specific to this request
  if (opt_headers) {
    goog.structs.forEach(opt_headers, function(value, key) {
      headers.set(key, value);
    });
  }

  // Find whether a content type header is set, ignoring case.
  // HTTP header names are case-insensitive.  See:
  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  var contentTypeKey = goog.array.find(headers.getKeys(),
      goog.net.XhrIo.isContentTypeHeader_);

  var contentIsFormData = (goog.global['FormData'] &&
      (content instanceof goog.global['FormData']));
  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&
      !contentTypeKey && !contentIsFormData) {
    // For requests typically with form data, default to the url-encoded form
    // content type unless this is a FormData request.  For FormData,
    // the browser will automatically add a multipart/form-data content type
    // with an appropriate multipart boundary.
    headers.set(goog.net.XhrIo.CONTENT_TYPE_HEADER,
                goog.net.XhrIo.FORM_CONTENT_TYPE);
  }

  // Add the headers to the Xhr object
  goog.structs.forEach(headers, function(value, key) {
    this.xhr_.setRequestHeader(key, value);
  }, this);

  if (this.responseType_) {
    this.xhr_.responseType = this.responseType_;
  }

  if (goog.object.containsKey(this.xhr_, 'withCredentials')) {
    this.xhr_.withCredentials = this.withCredentials_;
  }

  /**
   * Try to send the request, or other wise report an error (404 not found).
   * @preserveTry
   */
  try {
    this.cleanUpTimeoutTimer_(); // Paranoid, should never be running.
    if (this.timeoutInterval_ > 0) {
      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);
      goog.log.fine(this.logger_, this.formatMsg_('Will abort after ' +
          this.timeoutInterval_ + 'ms if incomplete, xhr2 ' +
          this.useXhr2Timeout_));
      if (this.useXhr2Timeout_) {
        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;
        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =
            goog.bind(this.timeout_, this);
      } else {
        this.timeoutId_ = goog.Timer.callOnce(this.timeout_,
            this.timeoutInterval_, this);
      }
    }
    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));
    this.inSend_ = true;
    this.xhr_.send(content);
    this.inSend_ = false;

  } catch (err) {
    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
  }
};


/**
 * Determines if the argument is an XMLHttpRequest that supports the level 2
 * timeout value and event.
 *
 * Currently, FF 21.0 OS X has the fields but won't actually call the timeout
 * handler.  Perhaps the confusion in the bug referenced below hasn't
 * entirely been resolved.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816
 *
 * @param {!goog.net.XhrLike.OrNative} xhr The request.
 * @return {boolean} True if the request supports level 2 timeout.
 * @private
 */
goog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {
  return goog.userAgent.IE &&
      goog.userAgent.isVersionOrHigher(9) &&
      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &&
      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);
};


/**
 * @param {string} header An HTTP header key.
 * @return {boolean} Whether the key is a content type header (ignoring
 *     case.
 * @private
 */
goog.net.XhrIo.isContentTypeHeader_ = function(header) {
  return goog.string.caseInsensitiveEquals(
      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);
};


/**
 * Creates a new XHR object.
 * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.
 * @protected
 */
goog.net.XhrIo.prototype.createXhr = function() {
  return this.xmlHttpFactory_ ?
      this.xmlHttpFactory_.createInstance() : goog.net.XmlHttp();
};


/**
 * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}
 * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts
 * the request.
 * @private
 */
goog.net.XhrIo.prototype.timeout_ = function() {
  if (typeof goog == 'undefined') {
    // If goog is undefined then the callback has occurred as the application
    // is unloading and will error.  Thus we let it silently fail.
  } else if (this.xhr_) {
    this.lastError_ = 'Timed out after ' + this.timeoutInterval_ +
                      'ms, aborting';
    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;
    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));
    this.dispatchEvent(goog.net.EventType.TIMEOUT);
    this.abort(goog.net.ErrorCode.TIMEOUT);
  }
};


/**
 * Something errorred, so inactivate, fire error callback and clean up
 * @param {goog.net.ErrorCode} errorCode The error code.
 * @param {Error} err The error object.
 * @private
 */
goog.net.XhrIo.prototype.error_ = function(errorCode, err) {
  this.active_ = false;
  if (this.xhr_) {
    this.inAbort_ = true;
    this.xhr_.abort();  // Ensures XHR isn't hung (FF)
    this.inAbort_ = false;
  }
  this.lastError_ = err;
  this.lastErrorCode_ = errorCode;
  this.dispatchErrors_();
  this.cleanUpXhr_();
};


/**
 * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do
 * not dispatch multiple error events.
 * @private
 */
goog.net.XhrIo.prototype.dispatchErrors_ = function() {
  if (!this.errorDispatched_) {
    this.errorDispatched_ = true;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ERROR);
  }
};


/**
 * Abort the current XMLHttpRequest
 * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -
 *     defaults to ABORT.
 */
goog.net.XhrIo.prototype.abort = function(opt_failureCode) {
  if (this.xhr_ && this.active_) {
    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));
    this.active_ = false;
    this.inAbort_ = true;
    this.xhr_.abort();
    this.inAbort_ = false;
    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ABORT);
    this.cleanUpXhr_();
  }
};


/**
 * Nullifies all callbacks to reduce risks of leaks.
 * @override
 * @protected
 */
goog.net.XhrIo.prototype.disposeInternal = function() {
  if (this.xhr_) {
    // We explicitly do not call xhr_.abort() unless active_ is still true.
    // This is to avoid unnecessarily aborting a successful request when
    // dispose() is called in a callback triggered by a complete response, but
    // in which browser cleanup has not yet finished.
    // (See http://b/issue?id=1684217.)
    if (this.active_) {
      this.active_ = false;
      this.inAbort_ = true;
      this.xhr_.abort();
      this.inAbort_ = false;
    }
    this.cleanUpXhr_(true);
  }

  goog.net.XhrIo.base(this, 'disposeInternal');
};


/**
 * Internal handler for the XHR object's readystatechange event.  This method
 * checks the status and the readystate and fires the correct callbacks.
 * If the request has ended, the handlers are cleaned up and the XHR object is
 * nullified.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChange_ = function() {
  if (this.isDisposed()) {
    // This method is the target of an untracked goog.Timer.callOnce().
    return;
  }
  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {
    // Were not being called from within a call to this.xhr_.send
    // this.xhr_.abort, or this.xhr_.open, so this is an entry point
    this.onReadyStateChangeEntryPoint_();
  } else {
    this.onReadyStateChangeHelper_();
  }
};


/**
 * Used to protect the onreadystatechange handler entry point.  Necessary
 * as {#onReadyStateChange_} maybe called from within send or abort, this
 * method is only called when {#onReadyStateChange_} is called as an
 * entry point.
 * {@see #protectEntryPoints}
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {
  this.onReadyStateChangeHelper_();
};


/**
 * Helper for {@link #onReadyStateChange_}.  This is used so that
 * entry point calls to {@link #onReadyStateChange_} can be routed through
 * {@link #onReadyStateChangeEntryPoint_}.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {
  if (!this.active_) {
    // can get called inside abort call
    return;
  }

  if (typeof goog == 'undefined') {
    // NOTE(user): If goog is undefined then the callback has occurred as the
    // application is unloading and will error.  Thus we let it silently fail.

  } else if (
      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&
      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&
      this.getStatus() == 2) {
    // NOTE(user): In IE if send() errors on a *local* request the readystate
    // is still changed to COMPLETE.  We need to ignore it and allow the
    // try/catch around send() to pick up the error.
    goog.log.fine(this.logger_, this.formatMsg_(
        'Local request error detected and ignored'));

  } else {

    // In IE when the response has been cached we sometimes get the callback
    // from inside the send call and this usually breaks code that assumes that
    // XhrIo is asynchronous.  If that is the case we delay the callback
    // using a timer.
    if (this.inSend_ &&
        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {
      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);
      return;
    }

    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);

    // readyState indicates the transfer has finished
    if (this.isComplete()) {
      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));

      this.active_ = false;

      try {
        // Call the specific callbacks for success or failure. Only call the
        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)
        if (this.isSuccess()) {
          this.dispatchEvent(goog.net.EventType.COMPLETE);
          this.dispatchEvent(goog.net.EventType.SUCCESS);
        } else {
          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;
          this.lastError_ =
              this.getStatusText() + ' [' + this.getStatus() + ']';
          this.dispatchErrors_();
        }
      } finally {
        this.cleanUpXhr_();
      }
    }
  }
};


/**
 * Remove the listener to protect against leaks, and nullify the XMLHttpRequest
 * object.
 * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to
 *     fire any events).
 * @private
 */
goog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {
  if (this.xhr_) {
    // Cancel any pending timeout event handler.
    this.cleanUpTimeoutTimer_();

    // Save reference so we can mark it as closed after the READY event.  The
    // READY event may trigger another request, thus we must nullify this.xhr_
    var xhr = this.xhr_;
    var clearedOnReadyStateChange =
        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?
            goog.nullFunction : null;
    this.xhr_ = null;
    this.xhrOptions_ = null;

    if (!opt_fromDispose) {
      this.dispatchEvent(goog.net.EventType.READY);
    }

    try {
      // NOTE(user): Not nullifying in FireFox can still leak if the callbacks
      // are defined in the same scope as the instance of XhrIo. But, IE doesn't
      // allow you to set the onreadystatechange to NULL so nullFunction is
      // used.
      xhr.onreadystatechange = clearedOnReadyStateChange;
    } catch (e) {
      // This seems to occur with a Gears HTTP request. Delayed the setting of
      // this onreadystatechange until after READY is sent out and catching the
      // error to see if we can track down the problem.
      goog.log.error(this.logger_,
          'Problem encountered resetting onreadystatechange: ' + e.message);
    }
  }
};


/**
 * Make sure the timeout timer isn't running.
 * @private
 */
goog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {
  if (this.xhr_ && this.useXhr2Timeout_) {
    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;
  }
  if (goog.isNumber(this.timeoutId_)) {
    goog.Timer.clear(this.timeoutId_);
    this.timeoutId_ = null;
  }
};


/**
 * @return {boolean} Whether there is an active request.
 */
goog.net.XhrIo.prototype.isActive = function() {
  return !!this.xhr_;
};


/**
 * @return {boolean} Whether the request has completed.
 */
goog.net.XhrIo.prototype.isComplete = function() {
  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;
};


/**
 * @return {boolean} Whether the request completed with a success.
 */
goog.net.XhrIo.prototype.isSuccess = function() {
  var status = this.getStatus();
  // A zero status code is considered successful for local files.
  return goog.net.HttpStatus.isSuccess(status) ||
      status === 0 && !this.isLastUriEffectiveSchemeHttp_();
};


/**
 * @return {boolean} whether the effective scheme of the last URI that was
 *     fetched was 'http' or 'https'.
 * @private
 */
goog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {
  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));
  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);
};


/**
 * Get the readystate from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.
 */
goog.net.XhrIo.prototype.getReadyState = function() {
  return this.xhr_ ?
      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :
      goog.net.XmlHttp.ReadyState.UNINITIALIZED;
};


/**
 * Get the status from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {number} Http status.
 */
goog.net.XhrIo.prototype.getStatus = function() {
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is receiving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   * @preserveTry
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.status : -1;
  } catch (e) {
    return -1;
  }
};


/**
 * Get the status text from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {string} Status text.
 */
goog.net.XhrIo.prototype.getStatusText = function() {
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is recieving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   * @preserveTry
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.statusText : '';
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);
    return '';
  }
};


/**
 * Get the last Uri that was requested
 * @return {string} Last Uri.
 */
goog.net.XhrIo.prototype.getLastUri = function() {
  return String(this.lastUri_);
};


/**
 * Get the response text from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {string} Result from the server, or '' if no result available.
 */
goog.net.XhrIo.prototype.getResponseText = function() {
  /** @preserveTry */
  try {
    return this.xhr_ ? this.xhr_.responseText : '';
  } catch (e) {
    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
    // states that responseText should return '' (and responseXML null)
    // when the state is not LOADING or DONE. Instead, IE can
    // throw unexpected exceptions, for example when a request is aborted
    // or no data is available yet.
    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);
    return '';
  }
};


/**
 * Get the response body from the Xhr object. This property is only available
 * in IE since version 7 according to MSDN:
 * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx
 * Will only return correct result when called from the context of a callback.
 *
 * One option is to construct a VBArray from the returned object and convert
 * it to a JavaScript array using the toArray method:
 * {@code (new window['VBArray'](xhrIo.getResponseBody())).toArray()}
 * This will result in an array of numbers in the range of [0..255]
 *
 * Another option is to use the VBScript CStr method to convert it into a
 * string as outlined in http://stackoverflow.com/questions/1919972
 *
 * @return {Object} Binary result from the server or null if not available.
 */
goog.net.XhrIo.prototype.getResponseBody = function() {
  /** @preserveTry */
  try {
    if (this.xhr_ && 'responseBody' in this.xhr_) {
      return this.xhr_['responseBody'];
    }
  } catch (e) {
    // IE can throw unexpected exceptions, for example when a request is aborted
    // or no data is yet available.
    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);
  }
  return null;
};


/**
 * Get the response XML from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {Document} The DOM Document representing the XML file, or null
 * if no result available.
 */
goog.net.XhrIo.prototype.getResponseXml = function() {
  /** @preserveTry */
  try {
    return this.xhr_ ? this.xhr_.responseXML : null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);
    return null;
  }
};


/**
 * Get the response and evaluates it as JSON from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for
 *     stripping of the response before parsing. This needs to be set only if
 *     your backend server prepends the same prefix string to the JSON response.
 * @return {Object|undefined} JavaScript object.
 */
goog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {
  if (!this.xhr_) {
    return undefined;
  }

  var responseText = this.xhr_.responseText;
  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {
    responseText = responseText.substring(opt_xssiPrefix.length);
  }

  return goog.json.parse(responseText);
};


/**
 * Get the response as the type specificed by {@link #setResponseType}. At time
 * of writing, this is only directly supported in very recent versions of WebKit
 * (10.0.612.1 dev and later). If the field is not supported directly, we will
 * try to emulate it.
 *
 * Emulating the response means following the rules laid out at
 * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute
 *
 * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only
 * response types of DEFAULT or TEXT may be used, and the response returned will
 * be the text response.
 *
 * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),
 * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the
 * response returned will be either the text response or the Mozilla
 * implementation of the array buffer response.
 *
 * On browsers will full support, any valid response type supported by the
 * browser may be used, and the response provided by the browser will be
 * returned.
 *
 * @return {*} The response.
 */
goog.net.XhrIo.prototype.getResponse = function() {
  /** @preserveTry */
  try {
    if (!this.xhr_) {
      return null;
    }
    if ('response' in this.xhr_) {
      return this.xhr_.response;
    }
    switch (this.responseType_) {
      case goog.net.XhrIo.ResponseType.DEFAULT:
      case goog.net.XhrIo.ResponseType.TEXT:
        return this.xhr_.responseText;
        // DOCUMENT and BLOB don't need to be handled here because they are
        // introduced in the same spec that adds the .response field, and would
        // have been caught above.
        // ARRAY_BUFFER needs an implementation for Firefox 4, where it was
        // implemented using a draft spec rather than the final spec.
      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:
        if ('mozResponseArrayBuffer' in this.xhr_) {
          return this.xhr_.mozResponseArrayBuffer;
        }
    }
    // Fell through to a response type that is not supported on this browser.
    goog.log.error(this.logger_,
        'Response type ' + this.responseType_ + ' is not ' +
        'supported on this browser');
    return null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);
    return null;
  }
};


/**
 * Get the value of the response-header with the given name from the Xhr object
 * Will only return correct result when called from the context of a callback
 * and the request has completed
 * @param {string} key The name of the response-header to retrieve.
 * @return {string|undefined} The value of the response-header named key.
 */
goog.net.XhrIo.prototype.getResponseHeader = function(key) {
  return this.xhr_ && this.isComplete() ?
      this.xhr_.getResponseHeader(key) : undefined;
};


/**
 * Gets the text of all the headers in the response.
 * Will only return correct result when called from the context of a callback
 * and the request has completed.
 * @return {string} The value of the response headers or empty string.
 */
goog.net.XhrIo.prototype.getAllResponseHeaders = function() {
  return this.xhr_ && this.isComplete() ?
      this.xhr_.getAllResponseHeaders() : '';
};


/**
 * Returns all response headers as a key-value map.
 * Multiple values for the same header key can be combined into one,
 * separated by a comma and a space.
 * Note that the native getResponseHeader method for retrieving a single header
 * does a case insensitive match on the header name. This method does not
 * include any case normalization logic, it will just return a key-value
 * representation of the headers.
 * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 * @return {!Object.<string, string>} An object with the header keys as keys
 *     and header values as values.
 */
goog.net.XhrIo.prototype.getResponseHeaders = function() {
  var headersObject = {};
  var headersArray = this.getAllResponseHeaders().split('\r\n');
  for (var i = 0; i < headersArray.length; i++) {
    if (goog.string.isEmpty(headersArray[i])) {
      continue;
    }
    var keyValue = goog.string.splitLimit(headersArray[i], ': ', 2);
    if (headersObject[keyValue[0]]) {
      headersObject[keyValue[0]] += ', ' + keyValue[1];
    } else {
      headersObject[keyValue[0]] = keyValue[1];
    }
  }
  return headersObject;
};


/**
 * Get the last error message
 * @return {goog.net.ErrorCode} Last error code.
 */
goog.net.XhrIo.prototype.getLastErrorCode = function() {
  return this.lastErrorCode_;
};


/**
 * Get the last error message
 * @return {string} Last error message.
 */
goog.net.XhrIo.prototype.getLastError = function() {
  return goog.isString(this.lastError_) ? this.lastError_ :
      String(this.lastError_);
};


/**
 * Adds the last method, status and URI to the message.  This is used to add
 * this information to the logging calls.
 * @param {string} msg The message text that we want to add the extra text to.
 * @return {string} The message with the extra text appended.
 * @private
 */
goog.net.XhrIo.prototype.formatMsg_ = function(msg) {
  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +
      this.getStatus() + ']';
};


// Register the xhr handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
    });
goog.provide('feng.fx.Shaders');

goog.require('goog.dom.query');
goog.require('goog.net.XhrIo');


feng.fx.Shaders = function() {

	this.shaderEls = null;

	var shadersUrl = feng.Config['assetsPath'] + 'html/shaders.html';

	var onComplete = goog.bind( this.onComplete, this );

	goog.net.XhrIo.send( shadersUrl, onComplete );
};
goog.addSingletonGetter(feng.fx.Shaders);


feng.fx.Shaders.prototype.getShader = function( id ) {

  var shadersData = goog.array.find(this.shaderEls, function(el) {
  	return el.id === id;
  });

  return shadersData.textContent;
};


feng.fx.Shaders.prototype.onComplete = function( e ) {

	if( e.target.isSuccess() ) {

		var dom = goog.dom.createDom('div');
		dom.innerHTML = e.target.getResponseText();

		var shaderEls = goog.dom.getChildren( dom );

		this.shaderEls = goog.array.map(shaderEls, function(el) {
			return el;
		});

		//console.log( 'shaders load complete', this.shaderEls );

	}else {

		// handling load errors

	}
};goog.provide('feng.controllers.KeyboardController');

goog.require('goog.events.EventTarget');
goog.require('goog.events.KeyHandler');
goog.require('goog.object');
goog.require('goog.string');

/**
 * @constructor
 */
feng.controllers.KeyboardController = function(){
	
  goog.base(this);

  this.key = {
  	ESC: goog.events.KeyCodes.ESC,
  	ENTER: goog.events.KeyCodes.ENTER,
  	LEFT: goog.events.KeyCodes.LEFT,
  	RIGHT: goog.events.KeyCodes.RIGHT,
  	UP: goog.events.KeyCodes.UP,
  	DOWN: goog.events.KeyCodes.DOWN
  };

  this._bindMappings = {
  	/*
		'id': {'handler': function, 'keycode': number}
  	*/
  };

  this._keycodeMappings = {
  	/*
		'keycode': [id, id...]
  	*/
  };

  this._keyHandler = new goog.events.KeyHandler(document);

  goog.events.listen( this._keyHandler, goog.events.KeyHandler.EventType.KEY, this.onKey, false, this);
};
goog.inherits(feng.controllers.KeyboardController, goog.events.EventTarget);
goog.addSingletonGetter(feng.controllers.KeyboardController);


feng.controllers.KeyboardController.prototype.bind = function(handler, keycode, once){

	var duplicateId = goog.object.findKey( this._bindMappings, function(id, obj) {
		return (obj.handler === handler && obj.keycode === keycode && obj.once === once);
	});

	if(duplicateId) {
		return duplicateId;
	}

	// add bind mapping
	var id = goog.string.getRandomString();

	var val = {
		handler: handler,
		keycode: keycode,
		once: once
	};

	goog.object.set( this._bindMappings, id, val );

	// add keycode mapping
	this._keycodeMappings[keycode] = this._keycodeMappings[keycode] || [];
	goog.array.insert( this._keycodeMappings[keycode], id );

	return id;
};


feng.controllers.KeyboardController.prototype.unbind = function(id){

	var bindMapping = this._bindMappings[ id ];

	if(!bindMapping) return;

	var keycode = bindMapping.keycode;

	goog.array.remove( this._keycodeMappings[keycode], id );

	goog.object.remove( this._bindMappings, id );
};


feng.controllers.KeyboardController.prototype.onKey = function(e){

  var bindIds = this._keycodeMappings[ e.keyCode ];

  if(!bindIds || e.repeat) return false;

  goog.array.forEach(bindIds, function(id) {

  	var bindMapping = this._bindMappings[id];
  	bindMapping.handler();

  	if( bindMapping.once ) {
  		this.unbind( id );
  	}
  }, this);
};// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Event Simulation.
 *
 * Utility functions for simulating events at the Closure level. All functions
 * in this package generate events by calling goog.events.fireListeners,
 * rather than interfacing with the browser directly. This is intended for
 * testing purposes, and should not be used in production code.
 *
 * The decision to use Closure events and dispatchers instead of the browser's
 * native events and dispatchers was conscious and deliberate. Native event
 * dispatchers have their own set of quirks and edge cases. Pure JS dispatchers
 * are more robust and transparent.
 *
 * If you think you need a testing mechanism that uses native Event objects,
 * please, please email closure-tech first to explain your use case before you
 * sink time into this.
 *
 * @author nicksantos@google.com (Nick Santos)
 */

goog.provide('goog.testing.events');
goog.provide('goog.testing.events.Event');

goog.require('goog.Disposable');
goog.require('goog.asserts');
goog.require('goog.dom.NodeType');
goog.require('goog.events');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.object');
goog.require('goog.style');
goog.require('goog.userAgent');



/**
 * goog.events.BrowserEvent expects an Event so we provide one for JSCompiler.
 *
 * This clones a lot of the functionality of goog.events.Event. This used to
 * use a mixin, but the mixin results in confusing the two types when compiled.
 *
 * @param {string} type Event Type.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event.
 * @constructor
 * @extends {Event}
 */
goog.testing.events.Event = function(type, opt_target) {
  this.type = type;

  this.target = /** @type {EventTarget} */ (opt_target || null);

  this.currentTarget = this.target;
};


/**
 * Whether to cancel the event in internal capture/bubble processing for IE.
 * @type {boolean}
 * @public
 * @suppress {underscore|visibility} Technically public, but referencing this
 *     outside this package is strongly discouraged.
 */
goog.testing.events.Event.prototype.propagationStopped_ = false;


/** @override */
goog.testing.events.Event.prototype.defaultPrevented = false;


/**
 * Return value for in internal capture/bubble processing for IE.
 * @type {boolean}
 * @public
 * @suppress {underscore|visibility} Technically public, but referencing this
 *     outside this package is strongly discouraged.
 */
goog.testing.events.Event.prototype.returnValue_ = true;


/** @override */
goog.testing.events.Event.prototype.stopPropagation = function() {
  this.propagationStopped_ = true;
};


/** @override */
goog.testing.events.Event.prototype.preventDefault = function() {
  this.defaultPrevented = true;
  this.returnValue_ = false;
};


/**
 * Asserts an event target exists.  This will fail if target is not defined.
 *
 * TODO(nnaze): Gradually add this to the methods in this file, and eventually
 *     update the method signatures to not take nullables.  See http://b/8961907
 *
 * @param {EventTarget} target A target to assert.
 * @return {!EventTarget} The target, guaranteed to exist.
 * @private
 */
goog.testing.events.assertEventTarget_ = function(target) {
  return goog.asserts.assert(target, 'EventTarget should be defined.');
};


/**
 * A static helper function that sets the mouse position to the event.
 * @param {Event} event A simulated native event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @private
 */
goog.testing.events.setEventClientXY_ = function(event, opt_coords) {
  if (!opt_coords && event.target &&
      event.target.nodeType == goog.dom.NodeType.ELEMENT) {
    try {
      opt_coords =
          goog.style.getClientPosition(/** @type {Element} **/ (event.target));
    } catch (ex) {
      // IE sometimes throws if it can't get the position.
    }
  }
  event.clientX = opt_coords ? opt_coords.x : 0;
  event.clientY = opt_coords ? opt_coords.y : 0;

  // Pretend the browser window is at (0, 0).
  event.screenX = event.clientX;
  event.screenY = event.clientY;
};


/**
 * Simulates a mousedown, mouseup, and then click on the given event target,
 * with the left mouse button.
 * @param {EventTarget} target The target for the event.
 * @param {goog.events.BrowserEvent.MouseButton=} opt_button Mouse button;
 *     defaults to {@code goog.events.BrowserEvent.MouseButton.LEFT}.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireClickSequence =
    function(target, opt_button, opt_coords, opt_eventProperties) {
  // Fire mousedown, mouseup, and click. Then return the bitwise AND of the 3.
  return !!(goog.testing.events.fireMouseDownEvent(
      target, opt_button, opt_coords, opt_eventProperties) &
            goog.testing.events.fireMouseUpEvent(
                target, opt_button, opt_coords, opt_eventProperties) &
            goog.testing.events.fireClickEvent(
                target, opt_button, opt_coords, opt_eventProperties));
};


/**
 * Simulates the sequence of events fired by the browser when the user double-
 * clicks the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireDoubleClickSequence = function(
    target, opt_coords, opt_eventProperties) {
  // Fire mousedown, mouseup, click, mousedown, mouseup, click, dblclick.
  // Then return the bitwise AND of the 7.
  var btn = goog.events.BrowserEvent.MouseButton.LEFT;
  return !!(goog.testing.events.fireMouseDownEvent(
      target, btn, opt_coords, opt_eventProperties) &
            goog.testing.events.fireMouseUpEvent(
                target, btn, opt_coords, opt_eventProperties) &
            goog.testing.events.fireClickEvent(
                target, btn, opt_coords, opt_eventProperties) &
            // IE fires a selectstart instead of the second mousedown in a
            // dblclick, but we don't care about selectstart.
            (goog.userAgent.IE ||
            goog.testing.events.fireMouseDownEvent(
                target, btn, opt_coords, opt_eventProperties)) &
            goog.testing.events.fireMouseUpEvent(
                target, btn, opt_coords, opt_eventProperties) &
            // IE doesn't fire the second click in a dblclick.
            (goog.userAgent.IE ||
            goog.testing.events.fireClickEvent(
                target, btn, opt_coords, opt_eventProperties)) &
            goog.testing.events.fireDoubleClickEvent(
                target, opt_coords, opt_eventProperties));
};


/**
 * Simulates a complete keystroke (keydown, keypress, and keyup). Note that
 * if preventDefault is called on the keydown, the keypress will not fire.
 *
 * @param {EventTarget} target The target for the event.
 * @param {number} keyCode The keycode of the key pressed.
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireKeySequence = function(
    target, keyCode, opt_eventProperties) {
  return goog.testing.events.fireNonAsciiKeySequence(target, keyCode, keyCode,
                                                     opt_eventProperties);
};


/**
 * Simulates a complete keystroke (keydown, keypress, and keyup) when typing
 * a non-ASCII character. Same as fireKeySequence, the keypress will not fire
 * if preventDefault is called on the keydown.
 *
 * @param {EventTarget} target The target for the event.
 * @param {number} keyCode The keycode of the keydown and keyup events.
 * @param {number} keyPressKeyCode The keycode of the keypress event.
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireNonAsciiKeySequence = function(
    target, keyCode, keyPressKeyCode, opt_eventProperties) {
  var keydown =
      new goog.testing.events.Event(goog.events.EventType.KEYDOWN, target);
  var keyup =
      new goog.testing.events.Event(goog.events.EventType.KEYUP, target);
  var keypress =
      new goog.testing.events.Event(goog.events.EventType.KEYPRESS, target);
  keydown.keyCode = keyup.keyCode = keyCode;
  keypress.keyCode = keyPressKeyCode;

  if (opt_eventProperties) {
    goog.object.extend(keydown, opt_eventProperties);
    goog.object.extend(keyup, opt_eventProperties);
    goog.object.extend(keypress, opt_eventProperties);
  }

  // Fire keydown, keypress, and keyup. Note that if the keydown is
  // prevent-defaulted, then the keypress will not fire on IE.
  var result = true;
  if (!goog.testing.events.isBrokenGeckoMacActionKey_(keydown)) {
    result = goog.testing.events.fireBrowserEvent(keydown);
  }
  if (goog.events.KeyCodes.firesKeyPressEvent(
      keyCode, undefined, keydown.shiftKey, keydown.ctrlKey,
      keydown.altKey) &&
      !(goog.userAgent.IE && !result)) {
    result &= goog.testing.events.fireBrowserEvent(keypress);
  }
  return !!(result & goog.testing.events.fireBrowserEvent(keyup));
};


/**
 * @param {goog.testing.events.Event} e The event.
 * @return {boolean} Whether this is the Gecko/Mac's Meta-C/V/X, which
 *     is broken and requires special handling.
 * @private
 */
goog.testing.events.isBrokenGeckoMacActionKey_ = function(e) {
  return goog.userAgent.MAC && goog.userAgent.GECKO &&
      (e.keyCode == goog.events.KeyCodes.C ||
       e.keyCode == goog.events.KeyCodes.X ||
       e.keyCode == goog.events.KeyCodes.V) && e.metaKey;
};


/**
 * Simulates a mouseover event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {EventTarget} relatedTarget The related target for the event (e.g.,
 *     the node that the mouse is being moved out of).
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireMouseOverEvent = function(target, relatedTarget,
    opt_coords) {
  var mouseover =
      new goog.testing.events.Event(goog.events.EventType.MOUSEOVER, target);
  mouseover.relatedTarget = relatedTarget;
  goog.testing.events.setEventClientXY_(mouseover, opt_coords);
  return goog.testing.events.fireBrowserEvent(mouseover);
};


/**
 * Simulates a mousemove event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireMouseMoveEvent = function(target, opt_coords) {
  var mousemove =
      new goog.testing.events.Event(goog.events.EventType.MOUSEMOVE, target);

  goog.testing.events.setEventClientXY_(mousemove, opt_coords);
  return goog.testing.events.fireBrowserEvent(mousemove);
};


/**
 * Simulates a mouseout event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {EventTarget} relatedTarget The related target for the event (e.g.,
 *     the node that the mouse is being moved into).
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireMouseOutEvent = function(target, relatedTarget,
    opt_coords) {
  var mouseout =
      new goog.testing.events.Event(goog.events.EventType.MOUSEOUT, target);
  mouseout.relatedTarget = relatedTarget;
  goog.testing.events.setEventClientXY_(mouseout, opt_coords);
  return goog.testing.events.fireBrowserEvent(mouseout);
};


/**
 * Simulates a mousedown event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.events.BrowserEvent.MouseButton=} opt_button Mouse button;
 *     defaults to {@code goog.events.BrowserEvent.MouseButton.LEFT}.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireMouseDownEvent =
    function(target, opt_button, opt_coords, opt_eventProperties) {

  var button = opt_button || goog.events.BrowserEvent.MouseButton.LEFT;
  button = !goog.events.BrowserFeature.HAS_W3C_BUTTON ?
      goog.events.BrowserEvent.IEButtonMap[button] : button;
  return goog.testing.events.fireMouseButtonEvent_(
      goog.events.EventType.MOUSEDOWN, target, button, opt_coords,
      opt_eventProperties);
};


/**
 * Simulates a mouseup event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.events.BrowserEvent.MouseButton=} opt_button Mouse button;
 *     defaults to {@code goog.events.BrowserEvent.MouseButton.LEFT}.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireMouseUpEvent =
    function(target, opt_button, opt_coords, opt_eventProperties) {
  var button = opt_button || goog.events.BrowserEvent.MouseButton.LEFT;
  button = !goog.events.BrowserFeature.HAS_W3C_BUTTON ?
      goog.events.BrowserEvent.IEButtonMap[button] : button;
  return goog.testing.events.fireMouseButtonEvent_(
      goog.events.EventType.MOUSEUP, target, button, opt_coords,
      opt_eventProperties);
};


/**
 * Simulates a click event on the given target. IE only supports click with
 * the left mouse button.
 * @param {EventTarget} target The target for the event.
 * @param {goog.events.BrowserEvent.MouseButton=} opt_button Mouse button;
 *     defaults to {@code goog.events.BrowserEvent.MouseButton.LEFT}.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireClickEvent =
    function(target, opt_button, opt_coords, opt_eventProperties) {
  return goog.testing.events.fireMouseButtonEvent_(goog.events.EventType.CLICK,
      target, opt_button, opt_coords, opt_eventProperties);
};


/**
 * Simulates a double-click event on the given target. Always double-clicks
 * with the left mouse button since no browser supports double-clicking with
 * any other buttons.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireDoubleClickEvent =
    function(target, opt_coords, opt_eventProperties) {
  return goog.testing.events.fireMouseButtonEvent_(
      goog.events.EventType.DBLCLICK, target,
      goog.events.BrowserEvent.MouseButton.LEFT, opt_coords,
      opt_eventProperties);
};


/**
 * Helper function to fire a mouse event.
 * with the left mouse button since no browser supports double-clicking with
 * any other buttons.
 * @param {string} type The event type.
 * @param {EventTarget} target The target for the event.
 * @param {number=} opt_button Mouse button; defaults to
 *     {@code goog.events.BrowserEvent.MouseButton.LEFT}.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 * @private
 */
goog.testing.events.fireMouseButtonEvent_ =
    function(type, target, opt_button, opt_coords, opt_eventProperties) {
  var e =
      new goog.testing.events.Event(type, target);
  e.button = opt_button || goog.events.BrowserEvent.MouseButton.LEFT;
  goog.testing.events.setEventClientXY_(e, opt_coords);
  if (opt_eventProperties) {
    goog.object.extend(e, opt_eventProperties);
  }
  return goog.testing.events.fireBrowserEvent(e);
};


/**
 * Simulates a contextmenu event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireContextMenuEvent = function(target, opt_coords) {
  var button = (goog.userAgent.MAC && goog.userAgent.WEBKIT) ?
      goog.events.BrowserEvent.MouseButton.LEFT :
      goog.events.BrowserEvent.MouseButton.RIGHT;
  var contextmenu =
      new goog.testing.events.Event(goog.events.EventType.CONTEXTMENU, target);
  contextmenu.button = !goog.events.BrowserFeature.HAS_W3C_BUTTON ?
      goog.events.BrowserEvent.IEButtonMap[button] : button;
  contextmenu.ctrlKey = goog.userAgent.MAC;
  goog.testing.events.setEventClientXY_(contextmenu, opt_coords);
  return goog.testing.events.fireBrowserEvent(contextmenu);
};


/**
 * Simulates a mousedown, contextmenu, and the mouseup on the given event
 * target, with the right mouse button.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Mouse position. Defaults to event's
 * target's position (if available), otherwise (0, 0).
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireContextMenuSequence = function(target, opt_coords) {
  var props = goog.userAgent.MAC ? {ctrlKey: true} : {};
  var button = (goog.userAgent.MAC && goog.userAgent.WEBKIT) ?
      goog.events.BrowserEvent.MouseButton.LEFT :
      goog.events.BrowserEvent.MouseButton.RIGHT;

  var result = goog.testing.events.fireMouseDownEvent(target,
      button, opt_coords, props);
  if (goog.userAgent.WINDOWS) {
    // All browsers are consistent on Windows.
    result &= goog.testing.events.fireMouseUpEvent(target,
        button, opt_coords) &
              goog.testing.events.fireContextMenuEvent(target, opt_coords);
  } else {
    result &= goog.testing.events.fireContextMenuEvent(target, opt_coords);

    // GECKO on Mac and Linux always fires the mouseup after the contextmenu.

    // WEBKIT is really weird.
    //
    // On Linux, it sometimes fires mouseup, but most of the time doesn't.
    // It's really hard to reproduce consistently. I think there's some
    // internal race condition. If contextmenu is preventDefaulted, then
    // mouseup always fires.
    //
    // On Mac, it always fires mouseup and then fires a click.
    result &= goog.testing.events.fireMouseUpEvent(target,
        button, opt_coords, props);

    if (goog.userAgent.WEBKIT && goog.userAgent.MAC) {
      result &= goog.testing.events.fireClickEvent(
          target, button, opt_coords, props);
    }
  }
  return !!result;
};


/**
 * Simulates a popstate event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {Object} state History state object.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.firePopStateEvent = function(target, state) {
  var e = new goog.testing.events.Event(goog.events.EventType.POPSTATE, target);
  e.state = state;
  return goog.testing.events.fireBrowserEvent(e);
};


/**
 * Simulate a blur event on the given target.
 * @param {EventTarget} target The target for the event.
 * @return {boolean} The value returned by firing the blur browser event,
 *      which returns false iff 'preventDefault' was invoked.
 */
goog.testing.events.fireBlurEvent = function(target) {
  var e = new goog.testing.events.Event(
      goog.events.EventType.BLUR, target);
  return goog.testing.events.fireBrowserEvent(e);
};


/**
 * Simulate a focus event on the given target.
 * @param {EventTarget} target The target for the event.
 * @return {boolean} The value returned by firing the focus browser event,
 *     which returns false iff 'preventDefault' was invoked.
 */
goog.testing.events.fireFocusEvent = function(target) {
  var e = new goog.testing.events.Event(
      goog.events.EventType.FOCUS, target);
  return goog.testing.events.fireBrowserEvent(e);
};


/**
 * Simulates an event's capturing and bubbling phases.
 * @param {Event} event A simulated native event. It will be wrapped in a
 *     normalized BrowserEvent and dispatched to Closure listeners on all
 *     ancestors of its target (inclusive).
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireBrowserEvent = function(event) {
  event.returnValue_ = true;

  // generate a list of ancestors
  var ancestors = [];
  for (var current = event.target; current; current = current.parentNode) {
    ancestors.push(current);
  }

  // dispatch capturing listeners
  for (var j = ancestors.length - 1;
       j >= 0 && !event.propagationStopped_;
       j--) {
    goog.events.fireListeners(ancestors[j], event.type, true,
        new goog.events.BrowserEvent(event, ancestors[j]));
  }

  // dispatch bubbling listeners
  for (var j = 0;
       j < ancestors.length && !event.propagationStopped_;
       j++) {
    goog.events.fireListeners(ancestors[j], event.type, false,
        new goog.events.BrowserEvent(event, ancestors[j]));
  }

  return event.returnValue_;
};


/**
 * Simulates a touchstart event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Touch position. Defaults to event's
 *     target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireTouchStartEvent = function(
    target, opt_coords, opt_eventProperties) {
  // TODO: Support multi-touch events with array of coordinates.
  var touchstart =
      new goog.testing.events.Event(goog.events.EventType.TOUCHSTART, target);
  goog.testing.events.setEventClientXY_(touchstart, opt_coords);
  if (opt_eventProperties) {
    goog.object.extend(touchstart, opt_eventProperties);
  }
  return goog.testing.events.fireBrowserEvent(touchstart);
};


/**
 * Simulates a touchmove event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Touch position. Defaults to event's
 *     target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireTouchMoveEvent = function(
    target, opt_coords, opt_eventProperties) {
  // TODO: Support multi-touch events with array of coordinates.
  var touchmove =
      new goog.testing.events.Event(goog.events.EventType.TOUCHMOVE, target);
  goog.testing.events.setEventClientXY_(touchmove, opt_coords);
  if (opt_eventProperties) {
    goog.object.extend(touchmove, opt_eventProperties);
  }
  return goog.testing.events.fireBrowserEvent(touchmove);
};


/**
 * Simulates a touchend event on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Touch position. Defaults to event's
 *     target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the event: false if preventDefault() was
 *     called on it, true otherwise.
 */
goog.testing.events.fireTouchEndEvent = function(
    target, opt_coords, opt_eventProperties) {
  // TODO: Support multi-touch events with array of coordinates.
  var touchend =
      new goog.testing.events.Event(goog.events.EventType.TOUCHEND, target);
  goog.testing.events.setEventClientXY_(touchend, opt_coords);
  if (opt_eventProperties) {
    goog.object.extend(touchend, opt_eventProperties);
  }
  return goog.testing.events.fireBrowserEvent(touchend);
};


/**
 * Simulates a simple touch sequence on the given target.
 * @param {EventTarget} target The target for the event.
 * @param {goog.math.Coordinate=} opt_coords Touch position. Defaults to event
 *     target's position (if available), otherwise (0, 0).
 * @param {Object=} opt_eventProperties Event properties to be mixed into the
 *     BrowserEvent.
 * @return {boolean} The returnValue of the sequence: false if preventDefault()
 *     was called on any of the events, true otherwise.
 */
goog.testing.events.fireTouchSequence = function(
    target, opt_coords, opt_eventProperties) {
  // TODO: Support multi-touch events with array of coordinates.
  // Fire touchstart, touchmove, touchend then return the bitwise AND of the 3.
  return !!(goog.testing.events.fireTouchStartEvent(
      target, opt_coords, opt_eventProperties) &
            goog.testing.events.fireTouchEndEvent(
                target, opt_coords, opt_eventProperties));
};


/**
 * Mixins a listenable into the given object. This turns the object
 * into a goog.events.Listenable. This is useful, for example, when
 * you need to mock a implementation of listenable and still want it
 * to work with goog.events.
 * @param {!Object} obj The object to mixin into.
 */
goog.testing.events.mixinListenable = function(obj) {
  var listenable = new goog.events.EventTarget();

  listenable.setTargetForTesting(obj);

  var listenablePrototype = goog.events.EventTarget.prototype;
  var disposablePrototype = goog.Disposable.prototype;
  for (var key in listenablePrototype) {
    if (listenablePrototype.hasOwnProperty(key) ||
        disposablePrototype.hasOwnProperty(key)) {
      var member = listenablePrototype[key];
      if (goog.isFunction(member)) {
        obj[key] = goog.bind(member, listenable);
      } else {
        obj[key] = member;
      }
    }
  }
};
goog.provide('feng.views.EpisodeSelection');

goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.dom.query');
goog.require('goog.testing.events');


/**
 * @constructor
 */
feng.views.EpisodeSelection = function(){

  goog.base(this);

  var templateData = {
  	token: feng.controllers.NavigationController.Token
  };

  this.domElement = soy.renderAsFragment(feng.templates.main.EpisodeSelection, templateData);

  this._isBuffering = false;

  feng.pubsub.subscribeOnce( feng.PubSub.Topic.MAIN_LOAD_COMPLETE, this.init, this );
};
goog.inherits(feng.views.EpisodeSelection, goog.events.EventTarget);
goog.addSingletonGetter(feng.views.EpisodeSelection);


feng.views.EpisodeSelection.prototype.init = function(){

	this._promptEl = goog.dom.query('> .prompt', this.domElement)[0];

  this._studioEl = goog.dom.getElementByClass('studio', this.domElement);
  this._houseEl = goog.dom.getElementByClass('house', this.domElement);

  this._studioButton = goog.dom.query('a.studio', this.domElement)[0];
  this._houseButton = goog.dom.query('a.house', this.domElement)[0];

  //
  this._activationDelay = 0;
  this._episodePromptAnimateInDelay = 0;

  this._hoveredSceneEl = null;

  this._episode = null;
  this._oldEpisode = null;

  this._eventHandler = new goog.events.EventHandler(this);

  this._hoverStudio = goog.bind(this.hoverStudio, this);
  this._hoverHouse = goog.bind(this.hoverHouse, this);
  this._onPressEnter = goog.bind(this.onPressEnter, this);

	this._hoverStudioKeyId = null;
	this._hoverHouseKeyId = null;
	this._enterKeyId = null;

	//
	this.reset();
};


feng.views.EpisodeSelection.prototype.activate = function(){

	this._eventHandler.listenOnce( this.domElement, 'mousemove', this.onMouseMoveOnce, false, this );
	this._eventHandler.listen( this._studioEl, feng.events.EventType.INPUT_OVER, this.onInputOver, false, this );
	this._eventHandler.listen( this._houseEl, feng.events.EventType.INPUT_OVER, this.onInputOver, false, this );
	this._eventHandler.listen( this._studioEl, 'mouseout', this.onMouseOut, false, this );
	this._eventHandler.listen( this._houseEl, 'mouseout', this.onMouseOut, false, this );
	this._eventHandler.listen( this._studioButton, 'click', this.onClickStartButton, false, this );
	this._eventHandler.listen( this._houseButton, 'click', this.onClickStartButton, false, this );

	feng.sectionController.listen( feng.events.EventType.START, this.onLoadStart, false, this );
	feng.sectionController.listen( feng.events.EventType.PROGRESS, this.onLoadProgress, false, this );
	feng.sectionController.listen( feng.events.EventType.COMPLETE, this.onLoadComplete, false, this );

	this._hoverStudioKeyId = feng.keyboardController.bind( this._hoverStudio, feng.keyboardController.key.LEFT );
	this._hoverHouseKeyId = feng.keyboardController.bind( this._hoverHouse, feng.keyboardController.key.RIGHT );
	this._enterKeyId = feng.keyboardController.bind( this._onPressEnter, feng.keyboardController.key.ENTER, true );
};


feng.views.EpisodeSelection.prototype.deactivate = function(){

	this._eventHandler.removeAll();

	goog.Timer.clear( this._activationDelay );
	goog.Timer.clear( this._episodePromptAnimateInDelay );

	feng.keyboardController.unbind( this._hoverStudioKeyId );
	feng.keyboardController.unbind( this._hoverHouseKeyId );
	feng.keyboardController.unbind( this._enterKeyId );
};


feng.views.EpisodeSelection.prototype.reset = function(){

	goog.dom.removeNode( feng.tutorial.domElement );

	goog.dom.classlist.enable( this._promptEl, 'hidden', false );
	goog.dom.classlist.enable( this._studioEl, 'active', false );
	goog.dom.classlist.enable( this._studioEl, 'inactive', false );
	goog.dom.classlist.enable( this._studioEl, 'loading', false );
	goog.dom.classlist.enable( this._studioEl, 'hidden', false );
	goog.dom.classlist.enable( this._houseEl, 'active', false );
	goog.dom.classlist.enable( this._houseEl, 'inactive', false );
	goog.dom.classlist.enable( this._houseEl, 'loading', false );
	goog.dom.classlist.enable( this._houseEl, 'hidden', false );
	
	this._hoveredSceneEl = null;
};


feng.views.EpisodeSelection.prototype.animateIn = function(){

	this.reset();

	this._activationDelay = goog.Timer.callOnce(this.activate, 2000, this);
};


feng.views.EpisodeSelection.prototype.animateOut = function(){

	this.deactivate();

	feng.soundController.fadeAmbient( 'studio', null, 0, 4, true );
	feng.soundController.fadeAmbient( 'house', null, 0, 4, true );
};


feng.views.EpisodeSelection.prototype.animateOutOnComplete = function( episodeId ){

	this.deactivate();

	feng.soundController.fadeAmbient( 'studio', null, 0, 4, true );
	feng.soundController.fadeAmbient( 'house', null, 0, 4, true );
};


feng.views.EpisodeSelection.prototype.updateSceneStatus = function(){

	if(this._hoveredSceneEl === this._studioEl) {

		goog.dom.classlist.enable( this._studioEl, 'active', true );
		goog.dom.classlist.enable( this._studioEl, 'inactive', false );
		goog.dom.classlist.enable( this._houseEl, 'active', false );
		goog.dom.classlist.enable( this._houseEl, 'inactive', true );

		goog.dom.classlist.enable( this._promptEl, 'hidden', true );
		goog.dom.classlist.addRemove( this._promptEl, 'house', 'studio' );

	  feng.soundController.fadeAmbient( 'studio', null, 1, 4 );
	  feng.soundController.fadeAmbient( 'house', null, 0, 4 );

	}else if(this._hoveredSceneEl === this._houseEl) {

		goog.dom.classlist.enable( this._studioEl, 'active', false );
		goog.dom.classlist.enable( this._studioEl, 'inactive', true );
		goog.dom.classlist.enable( this._houseEl, 'active', true );
		goog.dom.classlist.enable( this._houseEl, 'inactive', false );

		goog.dom.classlist.enable( this._promptEl, 'hidden', true );
		goog.dom.classlist.addRemove( this._promptEl, 'studio', 'house' );

		feng.soundController.fadeAmbient( 'studio', null, 0, 4 );
	  feng.soundController.fadeAmbient( 'house', null, 1, 4 );

	}else {

		goog.dom.classlist.enable( this._studioEl, 'active', false );
		goog.dom.classlist.enable( this._studioEl, 'inactive', false );
		goog.dom.classlist.enable( this._houseEl, 'active', false );
		goog.dom.classlist.enable( this._houseEl, 'inactive', false );

		goog.dom.classlist.enable( this._promptEl, 'hidden', false );
		goog.dom.classlist.remove( this._promptEl, 'studio' );
		goog.dom.classlist.remove( this._promptEl, 'house' );

		feng.soundController.fadeAmbient( 'studio', null, 0, 4 );
	  feng.soundController.fadeAmbient( 'house', null, 0, 4 );
	}
};


feng.views.EpisodeSelection.prototype.hoverStudio = function(){

	if(this._hoveredSceneEl === this._studioEl) return;
	else this._hoveredSceneEl = this._studioEl;

	this.updateSceneStatus();
};


feng.views.EpisodeSelection.prototype.hoverHouse = function(){

	if(this._hoveredSceneEl === this._houseEl) return;
	else this._hoveredSceneEl = this._houseEl;

	this.updateSceneStatus();
};


feng.views.EpisodeSelection.prototype.doAfterComplete = function(){

	this._episode.animateIn();
	
	this.dispatchEvent({
		type: feng.events.EventType.COMPLETE,
		episode: this._episode
	});
};


feng.views.EpisodeSelection.prototype.onPressEnter = function(){

	if(this._hoveredSceneEl === this._studioEl) {

		feng.navigationController.setToken( feng.controllers.NavigationController.Token.STUDIO );

	}else if(this._hoveredSceneEl === this._houseEl) {

		feng.navigationController.setToken( feng.controllers.NavigationController.Token.HOUSE );
	}
};


feng.views.EpisodeSelection.prototype.onInputOver = function(e){

	if(e.currentTarget === this._hoveredSceneEl) return false;

	switch(e.currentTarget) {

		case this._studioEl:
		this.hoverStudio();
		break;

		case this._houseEl:
		this.hoverHouse();
		break;
	}
};


feng.views.EpisodeSelection.prototype.onMouseOut = function(e){

  if(!e.relatedTarget || !goog.dom.contains(this.domElement, e.relatedTarget)) {

  	this._hoveredSceneEl = null;
	this.updateSceneStatus();
  }
};


feng.views.EpisodeSelection.prototype.onMouseMoveOnce = function(e){

  if(goog.dom.contains(this._studioEl, e.target)) {

  	goog.testing.events.fireMouseOverEvent( this._studioEl );

  }else if(goog.dom.contains(this._houseEl, e.target)) {

  	goog.testing.events.fireMouseOverEvent( this._houseEl );
  }
};


feng.views.EpisodeSelection.prototype.onClickStartButton = function(e){

	e.preventDefault();

	this.deactivate();

	goog.dom.classlist.enable( this._promptEl, 'hidden', true );

	feng.tutorial.setProgress( 0 );
	feng.tutorial.showLoader();
	feng.tutorial.animateIn();

	switch(e.currentTarget) {

		case this._studioButton:
		goog.dom.classlist.enable( this._studioEl, 'loading', true );
		goog.dom.classlist.enable( this._houseEl, 'hidden', true );
		goog.dom.appendChild( this._studioEl, feng.tutorial.domElement );
		break;

		case this._houseButton:
		goog.dom.classlist.enable( this._studioEl, 'hidden', true );
		goog.dom.classlist.enable( this._houseEl, 'loading', true );
		goog.dom.appendChild( this._houseEl, feng.tutorial.domElement );
		break;
	}

	goog.Timer.callOnce(function() {
		window.location.href = e.currentTarget.href;
	}, 2000);

	feng.soundController.playSfx('confirm');
};


feng.views.EpisodeSelection.prototype.onLoadStart = function(e){

	this._oldEpisode = this._episode;

	this._episode = e.target.getParentEventTarget();
	console.log(this._episode.id + ': load start');

	this._isBuffering = false;

	feng.pubsub.subscribeOnce( feng.PubSub.Topic.BUFFER_START, this.onBufferStart, this );
  	feng.pubsub.subscribeOnce( feng.PubSub.Topic.BUFFER_COMPLETE, this.onBufferComplete, this );
};


feng.views.EpisodeSelection.prototype.onLoadProgress = function(e){

	//console.log(this._episode.id + ': load progress ' + e.progress);

	feng.tutorial.setProgress( e.progress );
};


feng.views.EpisodeSelection.prototype.onLoadComplete = function(e){

	console.log(this._episode.id + ': load complete');

	feng.tutorial.setBuffering();

	if(this._oldEpisode) {
		this._oldEpisode.hide();
		this._oldEpisode = null;
	}

	feng.sectionController.unlisten( feng.events.EventType.START, this.onLoadStart, false, this );
	feng.sectionController.unlisten( feng.events.EventType.PROGRESS, this.onLoadProgress, false, this );
	feng.sectionController.unlisten( feng.events.EventType.COMPLETE, this.onLoadComplete, false, this );

	feng.tutorial.listenOnce( feng.events.EventType.CLOSE, this.doAfterComplete, false, this );
};


feng.views.EpisodeSelection.prototype.onBufferStart = function(e){

	this._isBuffering = true;
};


feng.views.EpisodeSelection.prototype.onBufferComplete = function(e){

	this._isBuffering = false;

	feng.tutorial.showSkipButton();
};goog.provide('feng.views.popups.Credits');

goog.require('goog.net.XhrIo');
goog.require('feng.fx.ScrollBar');
goog.require('feng.views.popups.Popup');
goog.require('feng.templates.common');


/**
 * @constructor
 */
feng.views.popups.Credits = function(){

	var domElement = soy.renderAsFragment(feng.templates.common.CreditsPopup);
	
	goog.base( this, domElement );

	this._scrollerEl = goog.dom.getElementByClass('scroller', this.domElement);
	this._scrollBarEl = goog.dom.getElementByClass('scrollbar', this._scrollerEl);
	this._scrollerContentEl = goog.dom.getElementByClass('content', this._scrollerEl);

	this._skipButton = goog.dom.getElementByClass('skip', this.domElement);

    this._scrollBar = new feng.fx.ScrollBar( this._scrollBarEl, this._scrollerContentEl );

	this._escKeyId = null;
	this._animateOut = goog.bind(this.animateOut, this);

	this._onContentLoad = goog.bind(this.onContentLoad, this);

	this._hasLoaded = false;
};
goog.inherits(feng.views.popups.Credits, feng.views.popups.Popup);
goog.addSingletonGetter(feng.views.popups.Credits);


feng.views.popups.Credits.prototype.animateIn = function(){

	goog.base(this, 'animateIn', 200);
};


feng.views.popups.Credits.prototype.doAnimateIn = function(){

	goog.base(this, 'doAnimateIn');

	if( this._hasLoaded ) {

		this._scrollBar.scrollTo( 0 )
		this._scrollBar.resize();

	}else {

		goog.dom.classlist.add( this.domElement, 'loading' );

		TweenMax.set(this._scrollerEl, {
			'opacity': 0
		});

		// load ajax content
		var url = feng.Config['assetsPath'] + 'html/credits.html';
		goog.net.XhrIo.send( url, this._onContentLoad );
	}
};


feng.views.popups.Credits.prototype.activate = function(){

	goog.base(this, 'activate');

	this._scrollBar.activate();

	goog.events.listen(window, 'resize', this.onResize, false, this);

	this._escKeyId = feng.keyboardController.bind( this._animateOut, feng.keyboardController.key.ESC, true );

	this._eventHandler.listen( this._skipButton, 'click', this.animateOut, false, this );
};


feng.views.popups.Credits.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	this._scrollBar.deactivate();

	goog.events.unlisten(window, 'resize', this.onResize, false, this);

	feng.keyboardController.unbind( this._escKeyId );
};


feng.views.popups.Credits.prototype.onContentLoad = function(e){

	this._hasLoaded = true;

	var response = e.target.getResponseText();
	var bodyText = /<body.*?>([\s\S]*)<\/body>/.exec( response )[1];

	this._scrollerContentEl.innerHTML = bodyText;

	this._scrollBar.resize();

	TweenMax.to(this._scrollerEl, .5, {
		'delay': 1,
		'opacity': 1,
		'onComplete': function() {
			goog.dom.classlist.remove( this.domElement, 'loading' );
		},
		'onCompleteScope': this
	});
};


feng.views.popups.Credits.prototype.onResize = function(e){

	this._scrollBar.resize();
};goog.provide('feng.views.sections.home.Screen');

goog.require('goog.dom');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');


/**
 * @constructor
 */
feng.views.sections.home.Screen = function(domElement){

	goog.base( this );

  this.domElement = domElement;

  this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.views.sections.home.Screen, goog.events.EventTarget);


feng.views.sections.home.Screen.prototype.activate = function() {


};


feng.views.sections.home.Screen.prototype.deactivate = function() {

	this._eventHandler.removeAll();
};


feng.views.sections.home.Screen.prototype.show = function() {

	goog.style.showElement( this.domElement, true );
};


feng.views.sections.home.Screen.prototype.hide = function() {

	goog.style.showElement( this.domElement, false );
};


feng.views.sections.home.Screen.prototype.animateIn = function() {

	this.show();
};


feng.views.sections.home.Screen.prototype.animateOut = function() {

	this.deactivate();
};goog.provide('feng.views.sections.home.EpisodeScreen');

goog.require('feng.views.sections.home.Screen');


/**
 * @constructor
 */
feng.views.sections.home.EpisodeScreen = function(domElement){

	goog.base(this, domElement);

	this._episodeSelection = feng.episodeSelection;
	goog.dom.appendChild( this.domElement, this._episodeSelection.domElement );
};
goog.inherits(feng.views.sections.home.EpisodeScreen, feng.views.sections.home.Screen);


feng.views.sections.home.EpisodeScreen.prototype.activate = function() {

	goog.base(this, 'activate');

	this._eventHandler.listen( this._episodeSelection, feng.events.EventType.COMPLETE, this.onLoadComplete, false, this );
};


feng.views.sections.home.EpisodeScreen.prototype.deactivate = function() {

	goog.base(this, 'deactivate');

	this._episodeSelection.deactivate();
};



feng.views.sections.home.EpisodeScreen.prototype.reset = function() {

	this._episodeSelection.animateIn();
};


feng.views.sections.home.EpisodeScreen.prototype.animateIn = function() {

	goog.base(this, 'animateIn');

	this.activate();

	this._episodeSelection.animateIn();
};


feng.views.sections.home.EpisodeScreen.prototype.animateOut = function() {

	goog.base(this, 'animateOut');

	this.deactivate();

	this._episodeSelection.animateOut();
};


feng.views.sections.home.EpisodeScreen.prototype.onLoadComplete = function(e) {

	this._episodeSelection.animateOutOnComplete( e.episode.id );

	this.dispatchEvent( e );
};goog.provide('feng.views.sections.Section');

goog.require('goog.dom');
goog.require('goog.dom.query');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('feng.events');
goog.require('feng.views.Preloader');


/**
 * @constructor
 */
feng.views.sections.Section = function(domElement){
	
  goog.base(this);

  this.domElement = domElement;
  this.id = this.domElement.id;

  this._animateInTweener = new TimelineMax({
  	'paused': true,
  	'onComplete': this.onAnimatedIn,
  	'onCompleteScope': this
  });

  this._animateOutTweener = new TimelineMax({
  	'paused': true,
  	'onComplete': this.onAnimatedOut,
  	'onCompleteScope': this
  });

  // section loader
  this._preloaderDom = goog.dom.query('.preloader', this.domElement)[0];
  this._preloader = new feng.views.Preloader( this._preloaderDom, 2000 );
  this._preloader.setParentEventTarget(this);

  // permanent events
  goog.events.listen( feng.navigationController, feng.events.EventType.CHANGE, this.onNavigationChange, false, this );

  // activatable events
  this._eventHandler = new goog.events.EventHandler(this);

  // asset keys
  this._assetKeys = [];
  this._loadedAssetKeys = [];
};
goog.inherits(feng.views.sections.Section, goog.events.EventTarget);


feng.views.sections.Section.prototype.init = function(){

  // hide section by default
  this.hide();
  
	this.setAnimations();
};


feng.views.sections.Section.prototype.show = function(){

	goog.style.showElement(this.domElement, true);

	this.dispatchEvent({
		type: feng.events.EventType.SHOW
	});
};


feng.views.sections.Section.prototype.hide = function(){

	goog.style.showElement(this.domElement, false);

	this.dispatchEvent({
		type: feng.events.EventType.HIDE
	});
};


feng.views.sections.Section.prototype.isShown = function(){

	return goog.style.isElementShown(this.domElement);
};


feng.views.sections.Section.prototype.activate = function(){

};


feng.views.sections.Section.prototype.deactivate = function(){

	this._eventHandler.removeAll();
};


feng.views.sections.Section.prototype.addPreloadListeners = function(){

	this.listen(feng.events.EventType.START, this.onLoadStart, false, this);
	this.listen(feng.events.EventType.PROGRESS, this.onLoadProgress, false, this);
	this.listen(feng.events.EventType.LOAD_COMPLETE, this.onLoadComplete, false, this);
	this.listen(feng.events.EventType.COMPLETE, this.onLoadAnimationComplete, false, this);
};


feng.views.sections.Section.prototype.load = function(){

	this.addPreloadListeners();

	this._assetKeys = goog.array.filter( this._assetKeys, function(key) {
		return !goog.array.contains(this._loadedAssetKeys, key);
	}, this);

	this._preloader.load( this._assetKeys );
};


feng.views.sections.Section.prototype.setAnimations = function(){

	var fadeInTweener = TweenMax.fromTo(this.domElement, 1, {
		'opacity': 0
	}, {
		'opacity': 1
	});

	this._animateInTweener.add( fadeInTweener );

	var fadeOutTweener = TweenMax.fromTo(this.domElement, .5, {
		'opacity': 1
	}, {
		'opacity': 0
	});

	this._animateOutTweener.add( fadeOutTweener );
};


feng.views.sections.Section.prototype.animateIn = function(){

	if(this.isShown()) return false;

	this.show();
	this.activate();
	this._animateInTweener.restart();

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATE_IN
	});

	return true;
};


feng.views.sections.Section.prototype.animateOut = function(){

	if(!this.isShown()) return false;

	this.deactivate();
	this._animateOutTweener.restart();

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATE_OUT
	});

	return true;
};


feng.views.sections.Section.prototype.doNavigate = function(){

	this.load();
};


feng.views.sections.Section.prototype.onAnimatedIn = function(e){

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATED_IN
	});
};


feng.views.sections.Section.prototype.onAnimatedOut = function(e){

	this.hide();

	this.dispatchEvent({
		type: feng.events.EventType.ANIMATED_OUT
	});
};


feng.views.sections.Section.prototype.onLoadStart = function(e){

	//console.log("section load start");
};


feng.views.sections.Section.prototype.onLoadProgress = function(e){

	//console.log("section load progress: " + e.progress);
};


feng.views.sections.Section.prototype.onLoadComplete = function(e){
	
	//console.log("section load complete");

	goog.array.forEach( this._assetKeys, function(key) {
		goog.array.insert(this._loadedAssetKeys, key);
	}, this);

	goog.array.clear( this._assetKeys );
};


feng.views.sections.Section.prototype.onLoadAnimationComplete = function(e){
	
	//console.log("section load animation complete");
};


feng.views.sections.Section.prototype.onNavigationChange = function(e){

	var navController = e.target;

	var sectionResult = navController.testToken( e.tokenArray, feng.controllers.NavigationController.Token.SECTION );

	if(sectionResult && (sectionResult['sectionId'] === this.id)) {
		this.doNavigate();
	}
};goog.provide('feng.fx.CanvasSprite');

goog.require('goog.dom');
goog.require('goog.events.KeyHandler');


feng.fx.CanvasSprite = function( img, data, opt_canvas, opt_debug ) {

	this._canvasEl = opt_canvas || goog.dom.createDom('canvas');
  	this._canvasContext = this._canvasEl.getContext('2d');

  	this._size = new goog.math.Size( data['size']['w'], data['size']['h'] );
  	
  	this._sourceCanvas = goog.dom.createDom('canvas');
  	this._sourceCanvas.width = img.width;
	this._sourceCanvas.height = img.height;
  	this._sourceContext = this._sourceCanvas.getContext('2d');
  	this._sourceContext.drawImage( img, 0, 0 );

	this._frameDic = data['frames'];

	this._frameIds = goog.object.getKeys(this._frameDic).sort();

	this._frames = goog.array.map(this._frameIds, function(frameId) {
		return this._frameDic[frameId];
	}, this);

	this.frameIndex = 0;
	this.numFrames = this._frames.length;

	this.restoreSize();
	this.update();

	// added key events for debugging
	if(opt_debug) {
	
		var keyHandler = new goog.events.KeyHandler( document );
		goog.events.listen( keyHandler, goog.events.KeyHandler.EventType.KEY, function(e) {
			switch(e.keyCode) {
				case goog.events.KeyCodes.LEFT:
				case goog.events.KeyCodes.UP:
				this.prevFrame();
				break;

				case goog.events.KeyCodes.RIGHT:
				case goog.events.KeyCodes.DOWN:
				this.nextFrame();
				break;
			}
		}, false, this);
	}
};


feng.fx.CanvasSprite.prototype.getCanvas = function() {

	return this._canvasEl;
};


feng.fx.CanvasSprite.prototype.getTweener = function( vars, fps, duration ) {

	var fps = fps || 60;
	var duration = duration || (this.numFrames / fps);

	var fromVars = {
		frameIndex: 0
	};

	var toVars = {
  	frameIndex: this.numFrames - 1,
  	'paused': true,
  	'ease': Linear.easeNone,
  	'repeat': -1,
  	'onUpdate': this.update,
  	'onUpdateScope': this
	};

	goog.object.extend(toVars, (vars || {}));

	var tweener = TweenMax.fromTo(this, duration, fromVars, toVars);

  return tweener;
};


feng.fx.CanvasSprite.prototype.restoreSize = function() {

	this._canvasEl.width = this._size.width;
	this._canvasEl.height = this._size.height;
};


feng.fx.CanvasSprite.prototype.getProgress = function() {

	return this.frameIndex / (this.numFrames - 1);
};


feng.fx.CanvasSprite.prototype.getCurrentFrame = function() {

	return this.frameIndex;
};


feng.fx.CanvasSprite.prototype.setProgress = function( progress ) {

	var frameIndex = Math.round( (this.numFrames - 1) * progress );
	this.gotoFrameByIndex( frameIndex );
};


feng.fx.CanvasSprite.prototype.gotoFrameById = function( frameId ) {

	var frameIndex = goog.array.findIndex( this._frameIds, function(key) {
		return (key === frameId);
	});

	this.gotoFrameByIndex( frameIndex );
};


feng.fx.CanvasSprite.prototype.gotoFrameByIndex = function( frameIndex ) {

	this.frameIndex = Math.round(frameIndex);

	var frameData = this._frames[ this.frameIndex ];

	var sx = frameData['sx'], sy = frameData['sy'];
	var sw = frameData['sw'], sh = frameData['sh'];
	var x = frameData['x'], y = frameData['y'];

	this._canvasContext.clearRect( 0, 0, this._canvasEl.width, this._canvasEl.height );

	var imgData = this._sourceContext.getImageData( sx, sy, sw, sh );
	this._canvasContext.putImageData( imgData, x, y );
};


feng.fx.CanvasSprite.prototype.prevFrame = function() {

	this.frameIndex = Math.max(0, this.frameIndex - 1);
	this.update();
};


feng.fx.CanvasSprite.prototype.nextFrame = function() {

	this.frameIndex = Math.min(this.numFrames - 1, this.frameIndex + 1);
	this.update();
};


feng.fx.CanvasSprite.prototype.update = function() {

	this.gotoFrameByIndex( this.frameIndex );
};goog.provide('feng.fx.AnimatedHouseLogo');

goog.require('feng.fx.CanvasSprite');


feng.fx.AnimatedHouseLogo = function( opt_canvas ) {

    var img = feng.fx.AnimatedHouseLogo.Img;
    var data = feng.fx.AnimatedHouseLogo.Data;

    goog.base(this, img, data, opt_canvas);
};
goog.inherits(feng.fx.AnimatedHouseLogo, feng.fx.CanvasSprite);


feng.fx.AnimatedHouseLogo.getImg = function() {

    var img = feng.fx.AnimatedHouseLogo.Img;
    img.src = feng.Config['assetsPath'] + 'images/house-logo-loop.png';

    return img;
};


feng.fx.AnimatedHouseLogo.Img = new Image();


feng.fx.AnimatedHouseLogo.Data = {
    "frames": {
        
            "00": {
                "sx": 842,
                "sy": 496,
                "sw": 120,
                "sh": 124,
                "x": 20,
                "y": 15
            }, 
        
            "01": {
                "sx": 718,
                "sy": 372,
                "sw": 130,
                "sh": 124,
                "x": 15,
                "y": 15
            }, 
        
            "02": {
                "sx": 448,
                "sy": 496,
                "sw": 138,
                "sh": 124,
                "x": 11,
                "y": 15
            }, 
        
            "03": {
                "sx": 304,
                "sy": 620,
                "sw": 144,
                "sh": 124,
                "x": 8,
                "y": 15
            }, 
        
            "04": {
                "sx": 154,
                "sy": 620,
                "sw": 150,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "05": {
                "sx": 0,
                "sy": 620,
                "sw": 154,
                "sh": 124,
                "x": 3,
                "y": 15
            }, 
        
            "06": {
                "sx": 780,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "07": {
                "sx": 624,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "08": {
                "sx": 468,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "09": {
                "sx": 152,
                "sy": 868,
                "sw": 152,
                "sh": 124,
                "x": 4,
                "y": 15
            }, 
        
            "10": {
                "sx": 748,
                "sy": 248,
                "sw": 148,
                "sh": 124,
                "x": 6,
                "y": 15
            }, 
        
            "11": {
                "sx": 444,
                "sy": 868,
                "sw": 140,
                "sh": 124,
                "x": 10,
                "y": 15
            }, 
        
            "12": {
                "sx": 586,
                "sy": 496,
                "sw": 132,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "13": {
                "sx": 838,
                "sy": 744,
                "sw": 124,
                "sh": 124,
                "x": 18,
                "y": 15
            }, 
        
            "14": {
                "sx": 848,
                "sy": 372,
                "sw": 112,
                "sh": 124,
                "x": 24,
                "y": 15
            }, 
        
            "15": {
                "sx": 962,
                "sy": 744,
                "sw": 100,
                "sh": 124,
                "x": 30,
                "y": 15
            }, 
        
            "16": {
                "sx": 962,
                "sy": 496,
                "sw": 112,
                "sh": 124,
                "x": 24,
                "y": 15
            }, 
        
            "17": {
                "sx": 714,
                "sy": 868,
                "sw": 124,
                "sh": 124,
                "x": 18,
                "y": 15
            }, 
        
            "18": {
                "sx": 586,
                "sy": 372,
                "sw": 132,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "19": {
                "sx": 444,
                "sy": 744,
                "sw": 140,
                "sh": 124,
                "x": 10,
                "y": 15
            }, 
        
            "20": {
                "sx": 600,
                "sy": 248,
                "sw": 148,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "21": {
                "sx": 152,
                "sy": 744,
                "sw": 152,
                "sh": 124,
                "x": 4,
                "y": 15
            }, 
        
            "22": {
                "sx": 312,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 1,
                "y": 15
            }, 
        
            "23": {
                "sx": 156,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "24": {
                "sx": 0,
                "sy": 124,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "25": {
                "sx": 0,
                "sy": 496,
                "sw": 154,
                "sh": 124,
                "x": 3,
                "y": 15
            }, 
        
            "26": {
                "sx": 154,
                "sy": 496,
                "sw": 150,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "27": {
                "sx": 304,
                "sy": 496,
                "sw": 144,
                "sh": 124,
                "x": 8,
                "y": 15
            }, 
        
            "28": {
                "sx": 448,
                "sy": 372,
                "sw": 138,
                "sh": 124,
                "x": 11,
                "y": 15
            }, 
        
            "29": {
                "sx": 584,
                "sy": 868,
                "sw": 130,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "30": {
                "sx": 842,
                "sy": 620,
                "sw": 120,
                "sh": 124,
                "x": 20,
                "y": 15
            }, 
        
            "31": {
                "sx": 712,
                "sy": 620,
                "sw": 130,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "32": {
                "sx": 936,
                "sy": 124,
                "sw": 138,
                "sh": 124,
                "x": 11,
                "y": 15
            }, 
        
            "33": {
                "sx": 304,
                "sy": 372,
                "sw": 144,
                "sh": 124,
                "x": 8,
                "y": 15
            }, 
        
            "34": {
                "sx": 154,
                "sy": 372,
                "sw": 150,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "35": {
                "sx": 0,
                "sy": 372,
                "sw": 154,
                "sh": 124,
                "x": 3,
                "y": 15
            }, 
        
            "36": {
                "sx": 780,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "37": {
                "sx": 624,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "38": {
                "sx": 468,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 1,
                "y": 15
            }, 
        
            "39": {
                "sx": 0,
                "sy": 868,
                "sw": 152,
                "sh": 124,
                "x": 4,
                "y": 15
            }, 
        
            "40": {
                "sx": 452,
                "sy": 248,
                "sw": 148,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "41": {
                "sx": 304,
                "sy": 868,
                "sw": 140,
                "sh": 124,
                "x": 10,
                "y": 15
            }, 
        
            "42": {
                "sx": 580,
                "sy": 620,
                "sw": 132,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "43": {
                "sx": 714,
                "sy": 744,
                "sw": 124,
                "sh": 124,
                "x": 18,
                "y": 15
            }, 
        
            "44": {
                "sx": 962,
                "sy": 372,
                "sw": 112,
                "sh": 124,
                "x": 24,
                "y": 15
            }, 
        
            "45": {
                "sx": 962,
                "sy": 620,
                "sw": 100,
                "sh": 124,
                "x": 30,
                "y": 15
            }, 
        
            "46": {
                "sx": 958,
                "sy": 868,
                "sw": 112,
                "sh": 124,
                "x": 24,
                "y": 15
            }, 
        
            "47": {
                "sx": 718,
                "sy": 496,
                "sw": 124,
                "sh": 124,
                "x": 18,
                "y": 15
            }, 
        
            "48": {
                "sx": 448,
                "sy": 620,
                "sw": 132,
                "sh": 124,
                "x": 14,
                "y": 15
            }, 
        
            "49": {
                "sx": 304,
                "sy": 744,
                "sw": 140,
                "sh": 124,
                "x": 10,
                "y": 15
            }, 
        
            "50": {
                "sx": 304,
                "sy": 248,
                "sw": 148,
                "sh": 124,
                "x": 6,
                "y": 15
            }, 
        
            "51": {
                "sx": 0,
                "sy": 744,
                "sw": 152,
                "sh": 124,
                "x": 4,
                "y": 15
            }, 
        
            "52": {
                "sx": 312,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "53": {
                "sx": 156,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "54": {
                "sx": 0,
                "sy": 0,
                "sw": 156,
                "sh": 124,
                "x": 2,
                "y": 15
            }, 
        
            "55": {
                "sx": 0,
                "sy": 248,
                "sw": 154,
                "sh": 124,
                "x": 3,
                "y": 15
            }, 
        
            "56": {
                "sx": 154,
                "sy": 248,
                "sw": 150,
                "sh": 124,
                "x": 5,
                "y": 15
            }, 
        
            "57": {
                "sx": 896,
                "sy": 248,
                "sw": 144,
                "sh": 124,
                "x": 8,
                "y": 15
            }, 
        
            "58": {
                "sx": 936,
                "sy": 0,
                "sw": 138,
                "sh": 124,
                "x": 11,
                "y": 15
            }, 
        
            "59": {
                "sx": 584,
                "sy": 744,
                "sw": 130,
                "sh": 124,
                "x": 15,
                "y": 15
            }, 
        
            "60": {
                "sx": 838,
                "sy": 868,
                "sw": 120,
                "sh": 124,
                "x": 20,
                "y": 15
            }
        
    },
    "size": {
        "w": 160,
        "h": 160
    }
};goog.provide('feng.views.sections.home.PreloadScreen');

goog.require('goog.Timer');
goog.require('feng.views.sections.home.Screen');
goog.require('feng.fx.AnimatedHouseLogo');


/**
 * @constructor
 */
feng.views.sections.home.PreloadScreen = function(domElement){

	goog.base(this, domElement);

	this._houseLogo = null;
	this._houseLogoTweener = null;
};
goog.inherits(feng.views.sections.home.PreloadScreen, feng.views.sections.home.Screen);


feng.views.sections.home.PreloadScreen.prototype.activate = function() {

	goog.base(this, 'activate');

	var houseLogoImg = feng.fx.AnimatedHouseLogo.getImg();
	this._eventHandler.listenOnce( houseLogoImg, goog.events.EventType.LOAD, this.createHouseLogo, false, this );
};


feng.views.sections.home.PreloadScreen.prototype.hide = function() {

	goog.base(this, 'hide');

	this._houseLogoTweener.pause();
};


feng.views.sections.home.PreloadScreen.prototype.createHouseLogo = function() {

	var logoEl = goog.dom.getElementByClass('house-logo', this.domElement);
	this._houseLogo = new feng.fx.AnimatedHouseLogo( logoEl );
	this._houseLogoTweener = this._houseLogo.getTweener({
		'repeat': -1,
		'repeatDelay': 1.5,
		'ease': Sine.easeInOut
	}, 60);

	this._houseLogoTweener.restart();
};


feng.views.sections.home.PreloadScreen.prototype.animateOut = function() {

	goog.base(this, 'animateOut');

	TweenMax.to(this.domElement, 1, {
		'delay': .8,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteScope': this
	});
};


feng.views.sections.home.PreloadScreen.prototype.onLoadAnimationComplete = function(e){

	goog.Timer.callOnce(function() {
		this.dispatchEvent( feng.events.EventType.CLOSE );
	}, 2000, this);
};goog.provide('feng.views.sections.Home');

goog.require('goog.dom');
goog.require('goog.events.EventTarget');
goog.require('feng.events');
goog.require('feng.views.sections.Section');
goog.require('feng.models.achievements.Achievements');
goog.require('feng.views.book.Book');
goog.require('feng.views.sections.home.PreloadScreen');
goog.require('feng.views.sections.home.EpisodeScreen');


/**
 * @constructor
 */
feng.views.sections.Home = function(){

	var domElement = goog.dom.getElement('home');
  goog.base(this, domElement);

  var preloadScreenEl = goog.dom.getElement('main-preloader');
  this._preloadScreen = new feng.views.sections.home.PreloadScreen( preloadScreenEl );
  this._preloadScreen.activate();

  var episodeScreenEl = goog.dom.getElement('main-episode-selection');
  this._episodeScreen = new feng.views.sections.home.EpisodeScreen( episodeScreenEl );
  this._episodeScreen.hide();

  this._hasLoadedOnce = false;
};
goog.inherits(feng.views.sections.Home, feng.views.sections.Section);


feng.views.sections.Home.prototype.init = function(){

	goog.base(this, 'init');
};


feng.views.sections.Home.prototype.activate = function(){

	goog.base(this, 'activate');

	this._eventHandler.listen( this._preloadScreen, feng.events.EventType.CLOSE, this.onScreenClose, false, this );
	this._eventHandler.listen( this._episodeScreen, feng.events.EventType.CLOSE, this.onScreenClose, false, this );
	this._eventHandler.listen( this._episodeScreen, feng.events.EventType.COMPLETE, this.onEpisodeLoadComplete, false, this );
};


feng.views.sections.Home.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	this._preloadScreen.deactivate();
	this._episodeScreen.deactivate();
};


feng.views.sections.Home.prototype.load = function(){

	this._assetKeys = [this.id, 'global'];
	
	goog.base(this, 'load');
};


feng.views.sections.Home.prototype.onAnimatedIn = function(e){

	goog.base(this, 'onAnimatedIn', e);
};


feng.views.sections.Home.prototype.onScreenClose = function(e){

	switch( e.target ) {
		case this._preloadScreen:
		this._preloadScreen.animateOut();
		this._episodeScreen.animateIn();
		break;

		case this._episodeScreen:
		this._episodeScreen.animateOut();
		break;
	}
};


feng.views.sections.Home.prototype.onLoadStart = function(e){

	goog.base(this, 'onLoadStart', e);

	this.animateIn();
};


feng.views.sections.Home.prototype.onLoadComplete = function(e){

	goog.base(this, 'onLoadComplete', e);

	if(!this._hasLoadedOnce) {

		// init main modules with loaded fengshui data
		var globalAssets = e.target.model.getAsset('global');
		var fsData = globalAssets['fengshui-data'];
		var tipsData = fsData['tips'];

		var achievements = feng.models.achievements.Achievements.getInstance();
		achievements.init( tipsData );

		var sectionController = feng.controllers.SectionController.getInstance();
		sectionController.init();

		var book = feng.views.book.Book.getInstance();

		feng.pubsub.publish( feng.PubSub.Topic.MAIN_LOAD_COMPLETE, globalAssets );

	}else {

		this._episodeScreen.reset();
	}

	//
	this._hasLoadedOnce = true;
};


feng.views.sections.Home.prototype.onLoadAnimationComplete = function(e){

	goog.base(this, 'onLoadAnimationComplete', e);

	this._preloadScreen.onLoadAnimationComplete();
};


feng.views.sections.Home.prototype.onEpisodeLoadComplete = function(e){

	this.animateOut();
};goog.provide('feng.views.Overlay');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');


/**
 * @constructor
 */
feng.views.Overlay = function(domElement, canHalt){
	
  goog.base(this);

  this.domElement = domElement;

  this.isShown = false;

  this._canHalt = canHalt;

  this._eventHandler = new goog.events.EventHandler(this);

  this.hide( false );
};
goog.inherits(feng.views.Overlay, goog.events.EventTarget);


feng.views.Overlay.prototype.activate = function(){

	this._eventHandler.listen(window, 'resize', this.onResize, false, this);
};


feng.views.Overlay.prototype.deactivate = function(){

	this._eventHandler.removeAll();
};


feng.views.Overlay.prototype.show = function( shouldDispatch ){

	this.isShown = true;

	goog.style.showElement(this.domElement, this.isShown);

	this.onResize();

	this.activate();

	var shouldDispatch = (shouldDispatch === false) ? false : true;

	if(shouldDispatch) {

		this.dispatchEvent({
			type: feng.events.EventType.SHOW,
			canHalt: this._canHalt
		});
	}
};


feng.views.Overlay.prototype.hide = function( shouldDispatch ){

	this.isShown = false;
	
	goog.style.showElement(this.domElement, this.isShown);

	this.deactivate();

	var shouldDispatch = (shouldDispatch === false) ? false : true;

	if(shouldDispatch) {

		this.dispatchEvent({
			type: feng.events.EventType.HIDE,
			canHalt: this._canHalt
		});
	}
};


feng.views.Overlay.prototype.animateIn = function(){

	this.show( true );

	this.dispatchEvent( feng.events.EventType.ANIMATE_IN );
};


feng.views.Overlay.prototype.animateOut = function(){

	this.hide( true );

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );
};


feng.views.Overlay.prototype.onResize = function(e){


};goog.provide('feng.views.sections.overlays.LoaderOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.models.Preload');
goog.require('feng.views.Overlay');
goog.require('feng.fx.CanvasSprite');


/**
 * @constructor
 */
feng.views.sections.overlays.LoaderOverlay = function(domElement){

  this._loaderEl = goog.dom.getElementByClass('loader', domElement);
  this._spinnerEl = goog.dom.getElementByClass('spinner', domElement);
  this._progressEl = goog.dom.getElementByClass('progress', domElement);

  var preload = feng.models.Preload.getInstance();
  var img = feng.fx.AnimatedHouseLogo.Img;
	var data = feng.fx.AnimatedHouseLogo.Data;
  this._spinner = new feng.fx.CanvasSprite( img, data, this._spinnerEl );

  this._spinnerTweener = this._spinner.getTweener();

  var canHalt = true;

  goog.base(this, domElement, canHalt);
};
goog.inherits(feng.views.sections.overlays.LoaderOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.LoaderOverlay);


feng.views.sections.overlays.LoaderOverlay.prototype.animateIn = function(){

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});

	TweenMax.fromTo(this._loaderEl, .8, {
		'opacity': 0
	}, {
		'delay': .8,
		'opacity': 1
	});

	this._spinnerTweener.restart();
};


feng.views.sections.overlays.LoaderOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.LoaderOverlay.prototype.hide = function( shouldDispatch ){

	goog.base(this, 'hide', shouldDispatch);

	this._spinnerTweener.pause();
};


feng.views.sections.overlays.LoaderOverlay.prototype.onLoadStart = function(e){

	this.animateIn();
};


feng.views.sections.overlays.LoaderOverlay.prototype.onLoadProgress = function(e){

	var numStr = Math.round(e.progress * 100).toString();
	this._progressEl.innerHTML = (numStr.length > 1) ? numStr : ('0' + numStr);
};


feng.views.sections.overlays.LoaderOverlay.prototype.onLoadComplete = function(e){

	feng.pubsub.subscribeOnce( feng.PubSub.Topic.HIDE_VIEW3D, this.animateOut, this );
};


feng.views.sections.overlays.LoaderOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);
};goog.provide('feng.views.sections.overlays.TutorialOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.views.Overlay');


/**
 * @constructor
 */
feng.views.sections.overlays.TutorialOverlay = function(domElement){

	var canHalt = true;

  goog.base(this, domElement, canHalt);
};
goog.inherits(feng.views.sections.overlays.TutorialOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.TutorialOverlay);


feng.views.sections.overlays.TutorialOverlay.prototype.show = function( shouldDispatch ){

	goog.base(this, 'show', shouldDispatch);
	
	goog.dom.appendChild( this.domElement, feng.tutorial.domElement );
};


feng.views.sections.overlays.TutorialOverlay.prototype.animateIn = function(){

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});
};


feng.views.sections.overlays.TutorialOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'delay': .25,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteParams': [ true ],
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.TutorialOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);
};goog.provide('feng.views.sections.overlays.FinaleOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.views.Overlay');
goog.require('feng.views.popups.Popup');
goog.require('feng.models.Preload');
goog.require('feng.utils.Utils');


/**
 * @constructor
 */
feng.views.sections.overlays.FinaleOverlay = function(domElement){

	var canHalt = true;

  goog.base(this, domElement, canHalt);

  var popupEl = goog.dom.getElementByClass('popup', this.domElement);
  this._popup = new feng.views.popups.Popup( popupEl );

  this._shareButtons = goog.dom.query('ul a', this.domElement);

  this._escKeyId = null;

  this._animateOutFunc = goog.bind(function() {
  	this._popup.animateOut();
  }, this);

  this.updateContent();
};
goog.inherits(feng.views.sections.overlays.FinaleOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.FinaleOverlay);


feng.views.sections.overlays.FinaleOverlay.prototype.activate = function(){

	goog.base(this, 'activate');

	goog.array.forEach(this._shareButtons, function(shareButton) {
		this._eventHandler.listen( shareButton, 'click', this.onClickShareButton, false, this );
	}, this);

	this._eventHandler.listenOnce( this._popup, feng.events.EventType.ANIMATE_OUT, this.animateOut, false, this );
	
	this._escKeyId = feng.keyboardController.bind( this._animateOutFunc, feng.keyboardController.key.ESC, true );
};


feng.views.sections.overlays.FinaleOverlay.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	feng.keyboardController.unbind( this._escKeyId );
};


feng.views.sections.overlays.FinaleOverlay.prototype.updateContent = function(){

	var preload = feng.models.Preload.getInstance();
	var copy = preload.getAsset('global.fengshui-data')['dialog']['finale'];

	var title = copy['title'];
	var paragraph = copy['paragraph'];

	var titleEl = goog.dom.query('h1', this.domElement)[0];
	var paragraphEl = goog.dom.query('p', this.domElement)[0];

	titleEl.innerHTML = title;
	paragraphEl.innerHTML = paragraph;
};


feng.views.sections.overlays.FinaleOverlay.prototype.animateIn = function(){

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});

	this._popup.animateIn();
};


feng.views.sections.overlays.FinaleOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'delay': .25,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteParams': [ true ],
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.FinaleOverlay.prototype.onClickShareButton = function(e) {

  e.preventDefault();

  feng.utils.Utils.popUp( e.currentTarget.href );
};


feng.views.sections.overlays.FinaleOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);

	feng.utils.Utils.centerAlign( this._popup.domElement, feng.viewportSize );
};// This file was automatically generated from captions.soy.
// Please don't edit this file by hand.

goog.provide('feng.templates.captions');

goog.require('soy');
goog.require('soydata');
goog.require('feng.templates.common');


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.Caption = function(opt_data, opt_ignored) {
  return '<div class="caption ' + opt_data.position + '"><div class="panel"><div class="panel-button"><button class="icon"></button><h3>Learn<br>More</h3></div><div class="panel-content"><div class="content"><h1>' + opt_data.tip.name + '</h1><div class="scroller"><div class="scroller-inner">' + ((opt_data.tip.hint) ? '<section class="hint"><div class="inner"><div class="inner-scroller"><p>' + opt_data.tip.hint + '</p>' + feng.templates.common.PrimaryButton({icon: 'icon-yes', classname: 'hint-button', text: 'I see'}) + '</div></div>' + feng.templates.common.ScrollBar(null) + '</section>' : '') + ((opt_data.tip.problem) ? '<section class="problem"><div class="inner"><div class="inner-scroller"><p>' + opt_data.tip.problem + '</p><!-- either close to interact, or scroll down to go interaction section if available -->' + feng.templates.common.PrimaryButton({classname: 'prompt-button', icon: 'icon-yes', text: opt_data.tip.prompt}) + '</div></div>' + feng.templates.common.ScrollBar(null) + '</section>' : '') + ((opt_data.interactionContent) ? '<section class="interaction"><div class="inner"><div class="inner-scroller">' + opt_data.interactionContent + '</div></div>' + feng.templates.common.ScrollBar(null) + '</section>' : '') + ((opt_data.tip.advice) ? '<section class="advice"><div class="inner"><div class="inner-scroller"><h3>Feng Shui Tips</h3><p>' + opt_data.tip.advice + '</p></div></div>' + feng.templates.common.ScrollBar(null) + '</section>' : '') + '</div></div></div></div></div><div class="controls"><ul class="share"><li><a href="https://www.facebook.com/sharer/sharer.php?u=http://fengshuirealtime.com/assets/html/share/' + opt_data.tip.id + '.html" target="_blank" class="icon icon-facebook"></a></li><li><a href="https://twitter.com/intent/tweet?original_referer=http://fengshuirealtime.com/assets/html/share/' + opt_data.tip.id + '.html" target="_blank" class="icon icon-twitter"></a></li><li><a href="https://plus.google.com/share?url=http://fengshuirealtime.com/assets/html/share/' + opt_data.tip.id + '.html" target="_blank" class="icon icon-google"></a></li></ul>' + feng.templates.common.CloseButton(null) + '</div></div>';
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.ChangePictureCaption = function(opt_data, opt_ignored) {
  var param102 = '<div class="change-picture"><h2>Click on a picture to change</h2><ul class="pictures">';
  var pictureKeyList104 = soy.$$getMapKeys(opt_data.tip.details['pictures']);
  var pictureKeyListLen104 = pictureKeyList104.length;
  for (var pictureKeyIndex104 = 0; pictureKeyIndex104 < pictureKeyListLen104; pictureKeyIndex104++) {
    var pictureKeyData104 = pictureKeyList104[pictureKeyIndex104];
    param102 += '<li><button class="item-button" data-picture="' + pictureKeyData104 + '"></button></li>';
  }
  param102 += '</ul><ul class="info">';
  var pictureKeyList110 = soy.$$getMapKeys(opt_data.tip.details['pictures']);
  var pictureKeyListLen110 = pictureKeyList110.length;
  for (var pictureKeyIndex110 = 0; pictureKeyIndex110 < pictureKeyListLen110; pictureKeyIndex110++) {
    var pictureKeyData110 = pictureKeyList110[pictureKeyIndex110];
    param102 += '<li data-picture="' + pictureKeyData110 + '"><h3>' + opt_data.tip.details['pictures'][pictureKeyData110]['name'] + '</h3><p>' + opt_data.tip.details['pictures'][pictureKeyData110]['description'] + '</p></li>';
  }
  param102 += '</ul></div>';
  var output = feng.templates.captions.Caption(soy.$$augmentMap(opt_data, {interactionContent: param102}));
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.ChangeColorCaption = function(opt_data, opt_ignored) {
  var param122 = '<div class="change-color"><h2>Choose a better color.</h2><ul class="colors">';
  var colorKeyList124 = soy.$$getMapKeys(opt_data.tip.details['colors']);
  var colorKeyListLen124 = colorKeyList124.length;
  for (var colorKeyIndex124 = 0; colorKeyIndex124 < colorKeyListLen124; colorKeyIndex124++) {
    var colorKeyData124 = colorKeyList124[colorKeyIndex124];
    param122 += '<li><button class="item-button" style="background-color: ' + opt_data.tip.details['colors'][colorKeyData124]['hex'] + '" data-color="' + colorKeyData124 + '"></button></li>';
  }
  param122 += '</ul><ul class="info">';
  var colorKeyList132 = soy.$$getMapKeys(opt_data.tip.details['colors']);
  var colorKeyListLen132 = colorKeyList132.length;
  for (var colorKeyIndex132 = 0; colorKeyIndex132 < colorKeyListLen132; colorKeyIndex132++) {
    var colorKeyData132 = colorKeyList132[colorKeyIndex132];
    param122 += '<li data-color="' + colorKeyData132 + '"><h3>' + opt_data.tip.details['colors'][colorKeyData132]['name'] + '</h3><p>' + opt_data.tip.details['colors'][colorKeyData132]['description'] + '</p></li>';
  }
  param122 += '</ul></div>';
  var output = feng.templates.captions.Caption(soy.$$augmentMap(opt_data, {interactionContent: param122}));
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.ChangeObjectCaption = function(opt_data, opt_ignored) {
  var param144 = '<div class="change-object"><h2>Replace with a new element.</h2><ul class="objects">';
  var objectKeyList146 = soy.$$getMapKeys(opt_data.tip.details['names']);
  var objectKeyListLen146 = objectKeyList146.length;
  for (var objectKeyIndex146 = 0; objectKeyIndex146 < objectKeyListLen146; objectKeyIndex146++) {
    var objectKeyData146 = objectKeyList146[objectKeyIndex146];
    param144 += '<li><button class="item-button" data-object="' + objectKeyData146 + '"></button></li>';
  }
  param144 += '</ul><ul class="info">';
  var objectKeyList152 = soy.$$getMapKeys(opt_data.tip.details['descriptions']);
  var objectKeyListLen152 = objectKeyList152.length;
  for (var objectKeyIndex152 = 0; objectKeyIndex152 < objectKeyListLen152; objectKeyIndex152++) {
    var objectKeyData152 = objectKeyList152[objectKeyIndex152];
    param144 += '<li data-object="' + objectKeyData152 + '"><h3>' + opt_data.tip.details['names'][objectKeyData152] + '</h3><p>' + opt_data.tip.details['descriptions'][objectKeyData152] + '</p></li>';
  }
  param144 += '</ul></div>';
  var output = feng.templates.captions.Caption(soy.$$augmentMap(opt_data, {interactionContent: param144}));
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.DropFruitsCaption = function(opt_data, opt_ignored) {
  var param164 = '<div class="drop-fruits"><h2>Fill the plate with fruits.</h2><ul class="fruits">';
  var fruitKeyList166 = soy.$$getMapKeys(opt_data.tip.details['fruits']);
  var fruitKeyListLen166 = fruitKeyList166.length;
  for (var fruitKeyIndex166 = 0; fruitKeyIndex166 < fruitKeyListLen166; fruitKeyIndex166++) {
    var fruitKeyData166 = fruitKeyList166[fruitKeyIndex166];
    param164 += '<li><button class="item-button" data-fruit="' + fruitKeyData166 + '"></button></li>';
  }
  param164 += '</ul><ul class="info">';
  var fruitKeyList172 = soy.$$getMapKeys(opt_data.tip.details['fruits']);
  var fruitKeyListLen172 = fruitKeyList172.length;
  for (var fruitKeyIndex172 = 0; fruitKeyIndex172 < fruitKeyListLen172; fruitKeyIndex172++) {
    var fruitKeyData172 = fruitKeyList172[fruitKeyIndex172];
    param164 += '<li data-fruit="' + fruitKeyData172 + '"><h3>' + opt_data.tip.details['fruits'][fruitKeyData172]['name'] + '</h3><p>' + opt_data.tip.details['fruits'][fruitKeyData172]['description'] + '</p></li>';
  }
  param164 += '</ul></div>';
  var output = feng.templates.captions.Caption(soy.$$augmentMap(opt_data, {interactionContent: param164}));
  return output;
};


/**
 * @param {Object.<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @return {string}
 * @notypecheck
 */
feng.templates.captions.FloatText = function(opt_data, opt_ignored) {
  var output = '<p class="floatText">';
  var lineList185 = opt_data.lines;
  var lineListLen185 = lineList185.length;
  for (var lineIndex185 = 0; lineIndex185 < lineListLen185; lineIndex185++) {
    var lineData185 = lineList185[lineIndex185];
    output += '<span>' + lineData185 + '</span>';
  }
  output += '</p>';
  return output;
};
goog.provide('feng.views.sections.captions.Caption');

goog.require('goog.events.EventHandler');
goog.require('feng.templates.captions');
goog.require('feng.utils.Utils');
goog.require('feng.fx.ScrollBar');


/**
 * @constructor
 */
feng.views.sections.captions.Caption = function( object, renderController, renderSize, controls, hud ){

  goog.base(this);

  this._object = object;
  this._renderController = renderController;
  this._renderSize = renderSize;
  this._controls = controls;
  this._hud = hud;

  this._eventHandler = new goog.events.EventHandler(this);

  this._template = this._template || feng.templates.captions.Caption;
  
  this._templateData = this._templateData || {
    tip: object.tip,
    position: 'right'
  };

  this._closeKeyId = null;

  this._onESC = goog.bind( this.onESC, this );

  // render HTML template
  this.domElement = soy.renderAsFragment(this._template, this._templateData);

  this._panelEl = goog.dom.getElementByClass('panel', this.domElement);
  this._scrollerInnerEl = goog.dom.getElementByClass('scroller-inner', this.domElement);

  this._closeButton = goog.dom.getElementByClass('close-button', this.domElement);
  this._panelButton = goog.dom.getElementByClass('panel-button', this.domElement);
  this._hintButton = goog.dom.getElementByClass('hint-button', this.domElement);
  this._promptButton = goog.dom.getElementByClass('prompt-button', this.domElement);

  this._problemSection = goog.dom.getElementByClass('problem', this.domElement);
  this._hintSection = goog.dom.getElementByClass('hint', this.domElement);
  this._interactionSection = goog.dom.getElementByClass('interaction', this.domElement);
  this._adviceSection = goog.dom.getElementByClass('advice', this.domElement);

  this._sections = goog.array.filter([
      this._hintSection,
      this._problemSection,
      this._interactionSection,
      this._adviceSection
    ], function(section) {
      return goog.isDefAndNotNull(section);
    });

  this._section = null;

  this.scrollBars = goog.array.map(this._sections, function(section) {
    var scrollerEl = goog.dom.getElementByClass('inner-scroller', section);
    var scrollBarEl = goog.dom.getElementByClass('scrollbar', section);
    var scrollBar = new feng.fx.ScrollBar( scrollBarEl, scrollerEl );
    return scrollBar;
  });

  this.scrollBar = null;

  this._controlsEl = goog.dom.getElementByClass('controls', this.domElement);

  this._shareEl = goog.dom.getElementByClass('share', this.domElement);
  this._shareButtons = goog.dom.query('a', this._shareEl);

  this._sectionTweener = null;

  // set default status
  this._isInteracting = false;
  this._isPanelAnimatedOut = true;
  goog.dom.classlist.enable( this.domElement, 'hide-panel', this._isPanelAnimatedOut );

  // set elements status by tip
  this.updateStatus();
};
goog.inherits(feng.views.sections.captions.Caption, goog.events.EventTarget);


feng.views.sections.captions.Caption.prototype.show = function() {

  this.activate();

  goog.style.showElement( this.domElement, true );

  this.onResize();
};


feng.views.sections.captions.Caption.prototype.hide = function() {

  this.deactivate();

  this._section = null;

  if(this._isPanelAnimatedOut) {

    goog.style.showElement( this.domElement, false );

  }else {

    this.animateOutPanel( false, true );
  }
};


feng.views.sections.captions.Caption.prototype.activate = function() {

  this._eventHandler.listen( this._closeButton, 'click', this.close, false, this );
  this._eventHandler.listen( this._panelButton, 'click', this.togglePanel, false, this );
  
  // listen for unlock ready event from view3d object
  this._eventHandler.listen( this._object, feng.events.EventType.UNLOCK, this.updateStatus, false, this );
  this._eventHandler.listen( window, 'resize', this.onResize, false, this );

  // listen for object camera animated in event to animate in panel
  this._eventHandler.listen( this._object, feng.events.EventType.ANIMATED_IN, this.animateInPanel, false, this );

  // listen for object interaction start/end
  this._eventHandler.listen( this._object, feng.events.EventType.START, this.onInteractionStart, false, this );
  this._eventHandler.listen( this._object, feng.events.EventType.END, this.onInteractionEnd, false, this );

  // listen for share button click events
  goog.array.forEach(this._shareButtons, function(shareButton) {
    this._eventHandler.listen( shareButton, 'click', this.onClickShareButton, false, this );
  }, this);

  //
  this._closeKeyId = feng.keyboardController.bind( this._onESC, feng.keyboardController.key.ESC, false );

  goog.style.showElement(this._panelButton, false);

  this.enableControls( false );

  this.updateStatus();
};


feng.views.sections.captions.Caption.prototype.deactivate = function() {

  this._eventHandler.removeAll();

  feng.keyboardController.unbind( this._closeKeyId );

  this._object.stopInteraction();

  goog.array.forEach(this.scrollBars, function(scrollBar) {
    scrollBar.deactivate();
  });
};


feng.views.sections.captions.Caption.prototype.enableControls = function( enabled ) {

  var shouldEnable = goog.isBoolean(enabled) ? enabled : true;

  goog.dom.classlist.enable( this._controlsEl, 'hidden', !shouldEnable );
};


feng.views.sections.captions.Caption.prototype.enableHintSection = function( shouldEnable ) {

  if(shouldEnable) {

    this._eventHandler.listen( this._hintButton, 'click', this.close, false, this );

  }else {

    this._eventHandler.unlisten( this._hintButton, 'click', this.close, false, this );
  }
};


feng.views.sections.captions.Caption.prototype.enableProblemSection = function( shouldEnable ) {

  if(shouldEnable) {

    this._eventHandler.listen( this._promptButton, 'click', this.onClick, false, this );

  }else {

    this._eventHandler.unlisten( this._promptButton, 'click', this.onClick, false, this );
  }
};


feng.views.sections.captions.Caption.prototype.enableInteractionSection = function( shouldEnable ) {

  this._object.startInteraction();
};


feng.views.sections.captions.Caption.prototype.enableAdviceSection = function( shouldEnable ) {

};


feng.views.sections.captions.Caption.prototype.getSectionX = function( section ) {

  return goog.array.indexOf( this._sections, section ) * goog.style.getSize(this._scrollerInnerEl).width;
};


feng.views.sections.captions.Caption.prototype.gotoSection = function( section, instant ) {

  if(this._section === section) {
    return;
  }else {
    this._section = section;
  }

  if(this.scrollBar) {
    this.scrollBar.deactivate();
  }

  this.scrollBar = this.scrollBars[ goog.array.indexOf(this._sections, section) ];
  this.scrollBar.activate();

  var fromSection = this._section;
  var toSection = section;

  var duration = instant ? 0 : .25;

  this._sectionTweener = TweenMax.to(this._scrollerInnerEl, duration, {
    'x': - this.getSectionX( toSection ),
    'ease': Quad.easeOut,
    'onStart': this.onScrollFromSection,
    'onStartParams': [fromSection],
    'onStartScope': this,
    'onComplete': this.onScrolledToSection,
    'onCompleteParams': [toSection],
    'onCompleteScope': this
  });
};


feng.views.sections.captions.Caption.prototype.onScrollFromSection = function( fromSection ) {

  if(!fromSection) {

    return;
  }

  goog.dom.classlist.addRemove( fromSection, 'animate-in', 'animate-out' );

  switch(fromSection) {

    case this._interactionSection:
    this.enableInteractionSection( false );
    break;

    case this._hintSection:
    this.enableHintSection( false );
    break;

    case this._problemSection:
    this.enableProblemSection( false );
    break;

    case this._adviceSection:
    this.enableAdviceSection( false );
    break;
  }
};


feng.views.sections.captions.Caption.prototype.onScrolledToSection = function( toSection ) {

  if(!this._isPanelAnimatedOut) {
    goog.dom.classlist.addRemove( toSection, 'animate-out', 'animate-in' );
  }

  switch(toSection) {

    case this._interactionSection:
    this.enableInteractionSection( true );
    break;

    case this._hintSection:
    this.enableHintSection( true );
    break;

    case this._problemSection:
    this.enableProblemSection( true );
    break;

    case this._adviceSection:
    this.enableAdviceSection( true );
    break;
  }
};


feng.views.sections.captions.Caption.prototype.animateInPanel = function() {

  if(this._isPanelAnimatedOut) {

    this._isPanelAnimatedOut = false;

  }else {

    return;
  }

  goog.style.showElement(this._panelButton, true);

  this.enableControls( !this._isInteracting );

  goog.dom.classlist.enable(this.domElement, 'hide-panel', false);

  goog.dom.classlist.addRemove(this._panelEl, 'animate-out', 'animate-in' );

  if(this._section) {
    goog.dom.classlist.addRemove( this._section, 'animate-out', 'animate-in' );
  } 

  TweenMax.to( this._renderController, .5, {
    globalBrightness: -.15,
    globalContrast: -.15,
    'ease': Sine.easeInOut
  });

  TweenMax.to( this._renderSize, .5, {
    ratioX: .7,
    'ease': Sine.easeInOut,
    'onUpdate': this._renderSize.update,
    'onUpdateScope': this._renderSize
  });
};


feng.views.sections.captions.Caption.prototype.animateOutPanel = function( shouldDoCloseWhenComplete, shouldHideWhenComplete ) {

  if(this._isPanelAnimatedOut) {

    return;
  }

  goog.dom.classlist.enable(this.domElement, 'hide-panel', true);

  goog.dom.classlist.addRemove(this._panelEl, 'animate-in', 'animate-out' );

  if(this._section) {
    goog.dom.classlist.addRemove( this._section, 'animate-in', 'animate-out' );
  } 

  TweenMax.to( this._renderController, .5, {
    globalBrightness: 0,
    globalContrast: 0,
    'ease': Sine.easeInOut
  });

  TweenMax.to( this._renderSize, .5, {
    ratioX: 1,
    'ease': Sine.easeInOut,
    'onUpdate': this._renderSize.update,
    'onUpdateScope': this._renderSize,
    'onComplete': this.onPanelAnimatedOut,
    'onCompleteParams': [shouldDoCloseWhenComplete, shouldHideWhenComplete],
    'onCompleteScope': this
  });
};


feng.views.sections.captions.Caption.prototype.togglePanel = function() {

  if(this._isPanelAnimatedOut) {
    this.animateInPanel();
  }else {
    this.animateOutPanel();
  }
};


feng.views.sections.captions.Caption.prototype.close = function() {

  if(this._isPanelAnimatedOut) {

    this.onPanelAnimatedOut( true );

  }else {
    
    this.animateOutPanel( true );
  }

  feng.keyboardController.unbind( this._closeKeyId );

  feng.soundController.playSfx('close');
};


feng.views.sections.captions.Caption.prototype.unlock = function() {

  // trigger tip object to unlock
  this._object.unlock();

  this.animateInPanel();
};


feng.views.sections.captions.Caption.prototype.updateStatus = function() {

  // check if should go hint section
  var tip = this._object.tip;

  var requiredTip = tip.getRequiredTip();
  var hasLockedRequiredTip = (requiredTip && !requiredTip.unlocked);

  if(hasLockedRequiredTip) {

    this.gotoSection( this._hintSection );
    return;
  }

  // check if should go problem section
  if(this._promptButton) {
    goog.style.showElement( this._promptButton, !tip.unlocked );
  }

  if(!tip.unlocked) {

    if(this._problemSection) {
      
      this.gotoSection( this._problemSection );
      return;
    }
  }
  
  //
  goog.style.showElement( this._shareEl, tip.unlocked );
  
  if(this._interactionSection) {
    goog.dom.classlist.add( this._interactionSection, 'unlocked' );
  }

  // check if should go advice section
  if(tip.unlocked) {

    if(this._adviceSection) {
      
      this.gotoSection( this._adviceSection );
      return;
    }

    if(this._interactionSection){

      this.gotoSection( this._interactionSection );
      return;
    }
  }
};


feng.views.sections.captions.Caption.prototype.onPanelAnimatedOut = function( shouldDoClose, shouldHide ) {

  this._isPanelAnimatedOut = true;

  if(shouldDoClose) {

    this.dispatchEvent({
      type: feng.events.EventType.CLOSE
    });
  }

  if(shouldHide) {
    this.hide();
  }
};


feng.views.sections.captions.Caption.prototype.onInteractionStart = function( e ) {

  this._isInteracting = true;

  if(this._interactionSection) {

    this.gotoSection( this._interactionSection );

  }else {

    this.enableControls( false );

    this.animateOutPanel();
  }
};


feng.views.sections.captions.Caption.prototype.onInteractionEnd = function( e ) {

  this._isInteracting = false;

  if(this._object.tip.isFinal && this._object.tip.unlocked) {

    this.animateInPanel();

  }else {

    this.close();
  }
};


feng.views.sections.captions.Caption.prototype.onESC = function() {

  if(!this._isInteracting) {

    this.close();
  }
};


feng.views.sections.captions.Caption.prototype.onClick = function( e ) {

  switch(e.currentTarget) {
    case this._promptButton:
    this._object.startInteraction();
    feng.soundController.playSfx('confirm');
    break;
  }
};


feng.views.sections.captions.Caption.prototype.onClickShareButton = function( e ) {

  e.preventDefault();

  feng.utils.Utils.popUp( e.currentTarget.href );
};


feng.views.sections.captions.Caption.prototype.onResize = function( e ) {

  goog.style.setStyle( this._panelEl, 'height', this._renderSize.height + 'px' );

  if(this.scrollBar) {
    this.scrollBar.resize();
  }

  if(this._sectionTweener) {

    var sectionX = this.getSectionX( this._section );

    if(this._sectionTweener.isActive()) {

      this._sectionTweener.updateTo({
        'x': - sectionX
      });

    }else {

      TweenMax.set(this._scrollerInnerEl, {
        'x': - sectionX
      });
    }
  }
};goog.provide('feng.views.sections.captions.ChangeColorCaption');

goog.require('goog.soy');
goog.require('feng.templates.captions');
goog.require('feng.views.sections.captions.Caption');


/**
 * @constructor
 */
feng.views.sections.captions.ChangeColorCaption = function( object, renderController, renderSize, controls, hud ){

  this._template = feng.templates.captions.ChangeColorCaption;
  
  this._templateData = {
    tip: object.tip,
    position: 'right'
  };

  goog.base(this, object, renderController, renderSize, controls, hud);

  this._colorId = null;

  this._itemEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.item-button', this.domElement), 'data-color' );
  this._infoEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.info li', this.domElement), 'data-color' );
};
goog.inherits(feng.views.sections.captions.ChangeColorCaption, feng.views.sections.captions.Caption);


feng.views.sections.captions.ChangeColorCaption.prototype.show = function() {

  goog.base(this, 'show');

  goog.object.forEach(this._itemEls, function(itemEl) {
    this._eventHandler.listen(itemEl, 'click', this.onClickItem, false, this);
  }, this);
};


feng.views.sections.captions.ChangeColorCaption.prototype.hide = function() {

  goog.base(this, 'hide');

  this._object.stopInteraction();
};


feng.views.sections.captions.ChangeColorCaption.prototype.onClickItem = function(e) {

  if(this._colorId) {
    goog.dom.classlist.enable( this._itemEls[this._colorId], 'active', false );
    goog.dom.classlist.enable( this._infoEls[this._colorId], 'active', false );
  }

  this._colorId = e.currentTarget.getAttribute('data-color');

  goog.dom.classlist.enable( this._itemEls[this._colorId], 'active', true );
  goog.dom.classlist.enable( this._infoEls[this._colorId], 'active', true );

  this.scrollBar.resize();
  
  this._object.setColorByName( this._colorId );

  feng.soundController.playSfx('click');
};// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the goog.async.Throttle class.
 *
 * @see ../demos/timers.html
 */

goog.provide('goog.Throttle');
goog.provide('goog.async.Throttle');

goog.require('goog.Disposable');
goog.require('goog.Timer');



/**
 * Throttle will perform an action that is passed in no more than once
 * per interval (specified in milliseconds). If it gets multiple signals
 * to perform the action while it is waiting, it will only perform the action
 * once at the end of the interval.
 * @param {function(this: T)} listener Function to callback when the action is
 *     triggered.
 * @param {number} interval Interval over which to throttle. The listener can
 *     only be called once per interval.
 * @param {T=} opt_handler Object in whose scope to call the listener.
 * @constructor
 * @extends {goog.Disposable}
 * @final
 * @template T
 */
goog.async.Throttle = function(listener, interval, opt_handler) {
  goog.Disposable.call(this);

  /**
   * Function to callback
   * @type {function(this: T)}
   * @private
   */
  this.listener_ = listener;

  /**
   * Interval for the throttle time
   * @type {number}
   * @private
   */
  this.interval_ = interval;

  /**
   * "this" context for the listener
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;

  /**
   * Cached callback function invoked after the throttle timeout completes
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.onTimer_, this);
};
goog.inherits(goog.async.Throttle, goog.Disposable);



/**
 * A deprecated alias.
 * @deprecated Use goog.async.Throttle instead.
 * @constructor
 * @final
 */
goog.Throttle = goog.async.Throttle;


/**
 * Indicates that the action is pending and needs to be fired.
 * @type {boolean}
 * @private
 */
goog.async.Throttle.prototype.shouldFire_ = false;


/**
 * Indicates the count of nested pauses currently in effect on the throttle.
 * When this count is not zero, fired actions will be postponed until the
 * throttle is resumed enough times to drop the pause count to zero.
 * @type {number}
 * @private
 */
goog.async.Throttle.prototype.pauseCount_ = 0;


/**
 * Timer for scheduling the next callback
 * @type {?number}
 * @private
 */
goog.async.Throttle.prototype.timer_ = null;


/**
 * Notifies the throttle that the action has happened. It will throttle the call
 * so that the callback is not called too often according to the interval
 * parameter passed to the constructor.
 */
goog.async.Throttle.prototype.fire = function() {
  if (!this.timer_ && !this.pauseCount_) {
    this.doAction_();
  } else {
    this.shouldFire_ = true;
  }
};


/**
 * Cancels any pending action callback. The throttle can be restarted by
 * calling {@link #fire}.
 */
goog.async.Throttle.prototype.stop = function() {
  if (this.timer_) {
    goog.Timer.clear(this.timer_);
    this.timer_ = null;
    this.shouldFire_ = false;
  }
};


/**
 * Pauses the throttle.  All pending and future action callbacks will be
 * delayed until the throttle is resumed.  Pauses can be nested.
 */
goog.async.Throttle.prototype.pause = function() {
  this.pauseCount_++;
};


/**
 * Resumes the throttle.  If doing so drops the pausing count to zero, pending
 * action callbacks will be executed as soon as possible, but still no sooner
 * than an interval's delay after the previous call.  Future action callbacks
 * will be executed as normal.
 */
goog.async.Throttle.prototype.resume = function() {
  this.pauseCount_--;
  if (!this.pauseCount_ && this.shouldFire_ && !this.timer_) {
    this.shouldFire_ = false;
    this.doAction_();
  }
};


/** @override */
goog.async.Throttle.prototype.disposeInternal = function() {
  goog.async.Throttle.superClass_.disposeInternal.call(this);
  this.stop();
};


/**
 * Handler for the timer to fire the throttle
 * @private
 */
goog.async.Throttle.prototype.onTimer_ = function() {
  this.timer_ = null;

  if (this.shouldFire_ && !this.pauseCount_) {
    this.shouldFire_ = false;
    this.doAction_();
  }
};


/**
 * Calls the callback
 * @private
 */
goog.async.Throttle.prototype.doAction_ = function() {
  this.timer_ = goog.Timer.callOnce(this.callback_, this.interval_);
  this.listener_.call(this.handler_);
};
goog.provide('feng.views.sections.controls.ProgressBar');

goog.require('goog.async.Throttle');
goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.ProgressBar = function(domElement, tips){

  goog.base(this, domElement);

  this._tipsWrapperEl = goog.dom.query('.tips-wrapper', this.domElement)[0];
  this._tipsEls = goog.dom.query('.tips', this.domElement);
  this._allTipEls = goog.dom.query('.tips > li', this.domElement);
  this._dotEls = goog.dom.query('.tips .dot', this.domElement);
  //this._prevButtonEl = goog.dom.getElementByClass('prev', this.domElement);
  //this._nextButtonEl = goog.dom.getElementByClass('next', this.domElement);

  this._tipsEl = this._tipsEls[0];
  this._tipEls = goog.dom.query( 'li', this._tipsEl );

  this._viewIds = goog.array.map( this._tipsEls, function(tipsEl) {
    return tipsEl.getAttribute('data-view-id');
  });

  this._viewId = this._viewIds[0];

  this._tips = {};
  
  goog.array.forEach(tips, function(tip) {
		this._tips[ tip.id ] = tip;
  }, this);

  this._nearbyTipEl = null;

  //
  this._detectNearbyThrottle = new goog.async.Throttle(this.detectNearbyObjects, 1000/5, this);
  
  this._nearbyObjects = [];

  this._tipsWidthViewportRatio = 0.5;
  this._maxTipMargin = 50;

  this._tweener = new TimelineMax();
};
goog.inherits(feng.views.sections.controls.ProgressBar, feng.views.sections.controls.Controls);


feng.views.sections.controls.ProgressBar.prototype.setView3D = function( view3d ){

  goog.base(this, 'setView3D', view3d);

  this._viewId = view3d.id;

  var tipsEl = goog.array.find(this._tipsEls, function(tipsEl) {
    return (tipsEl.getAttribute('data-view-id') === view3d.id);
  });

  this.calculateTipsLayout( tipsEl );
  this.goTipsOfView( view3d.id );
};


feng.views.sections.controls.ProgressBar.prototype.calculateTipsLayout = function( tipsEl ){

  this._tipEls = goog.dom.query( 'li', tipsEl );

  // arrange tip dots
  var numDots = this._tipEls.length;
  var dotsWidth = numDots * this._maxTipMargin * 2;
  var actualWidth = Math.min( dotsWidth, this._tipsWidthViewportRatio * feng.viewportSize.width );
  var dotWidth = actualWidth / numDots;
  var margin = dotWidth / 2;

  goog.array.forEach(this._tipEls, function(tipEl) {
    goog.style.setStyle( tipEl, 'margin', '0 ' + margin + 'px' );
  });

  return actualWidth;
};


feng.views.sections.controls.ProgressBar.prototype.activate = function() {

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

  //this._eventHandler.listen(this._prevButtonEl, 'click', this.goPrevTips, false, this);
  //this._eventHandler.listen(this._nextButtonEl, 'click', this.goNextTips, false, this);

  goog.array.forEach(this._allTipEls, function(tipEl) {
    this._eventHandler.listen(tipEl, goog.events.EventType.MOUSEOVER, this.onTipMouseOver, false, this);
    this._eventHandler.listen(tipEl, goog.events.EventType.MOUSEOUT, this.onTipMouseOut, false, this);
  }, this);

  goog.object.forEach(this._tips, function(tip) {

    tip.listen(feng.events.EventType.UNLOCK, this.onTipUnlock, false, this);
    if(tip.unlocked) this.unlockTip( tip.id );
  }, this);

  this._detectNearbyThrottle.fire();

  goog.dom.classlist.enable(this.domElement, 'hidden', false);
};


feng.views.sections.controls.ProgressBar.prototype.deactivate = function() {

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

  goog.object.forEach(this._tips, function(tip) {
    tip.unlisten(feng.events.EventType.UNLOCK, this.onTipUnlock, false, this);
  }, this);

  this._detectNearbyThrottle.stop();

  this._tweener.kill();

  goog.dom.classlist.enable(this.domElement, 'hidden', true);
};


feng.views.sections.controls.ProgressBar.prototype.goTipsOfView = function( viewId ) {

  this._viewId = viewId;

  // get tips element of the view id
  var tipsEl = goog.array.find(this._tipsEls, function(tipsEl) {
    return (tipsEl.getAttribute('data-view-id') === viewId);
  });

  // calculate new tips layout before set display none
  var tipsWrapperWidth = this.calculateTipsLayout( tipsEl );

  // animate tips
  var tweener = TweenMax.to(this._tipsEls, 0, {
    'display': 'none'
  });

  // assign new tips el
  this._tipsEl = tipsEl;

  var tweener2 = TweenMax.to( this._tipsWrapperEl, .5, {
    'width': tipsWrapperWidth,
    'ease': Strong.easeOut
  });

  //
  var tweener3 = new TimelineMax();

  var tweeners = goog.array.map( this._tipEls, function(tipEl) {

    var t = TweenMax.fromTo(tipEl, .25, {
      'opacity': 0,
      'y': 20
    }, {
      'opacity': 1,
      'y': 0
    });

    return t;
  });

  tweener3.add( tweeners, '+=0', 'start', .05 );

  var tweener4 = TweenMax.to(this._tipsEl, .25, {
    'opacity': 1,
    'display': 'block'
  });

  this._tweener.clear();
  this._tweener.add([tweener, tweener2, tweener3, tweener4]);
};

/*
feng.views.sections.controls.ProgressBar.prototype.goPrevTips = function() {

  var currentTipsIndex = goog.array.indexOf(this._viewIds, this._tipsEl.getAttribute('data-view-id'));

  currentTipsIndex --;

  if(currentTipsIndex < 0) currentTipsIndex = this._viewIds.length - 1;

  this.goTipsOfView( this._viewIds[currentTipsIndex] );
};


feng.views.sections.controls.ProgressBar.prototype.goNextTips = function() {

  var currentTipsIndex = goog.array.indexOf(this._viewIds, this._tipsEl.getAttribute('data-view-id'));

  currentTipsIndex ++;

  if(currentTipsIndex > this._viewIds.length - 1) currentTipsIndex = 0;

  this.goTipsOfView( this._viewIds[currentTipsIndex] );
};
*/

feng.views.sections.controls.ProgressBar.prototype.setNearbyObjects = function( objects ){

  this._nearbyObjects = objects;

  if(this._nearbyObjects && this._nearbyObjects.length > 0) {

    this._detectNearbyThrottle.fire();
  }
};


feng.views.sections.controls.ProgressBar.prototype.detectNearbyObjects = function(){

  if(!this._nearbyObjects || this._nearbyObjects.length === 0) {

    this._detectNearbyThrottle.stop();
    return;

  }else {

    this._detectNearbyThrottle.fire();
  }

  var control = this._view3d.modeController.control;
  var cameraPosition = control.getPosition();
  var cameraDirection = control.getForwardVector( true );
  var highestDot = Math.cos( THREE.Math.degToRad(45) );
  var nearestObject;

  goog.array.forEach(this._nearbyObjects, function(object) {
    
    var objectDirection = object.getCenter().clone().sub( cameraPosition ).normalize();
    var dot = objectDirection.dot( cameraDirection );
    //console.log(dot, object.name)
    if(dot >= highestDot) {
      highestDot = dot;
      nearestObject = object;
    }
  });

  if(nearestObject) {

    //console.log(nearestObject.name);
    var tip = nearestObject.tip;
    var providedTip = tip.getProvidedTip();

    var tipId = providedTip ? providedTip.id : tip.id;

    var tipEl = goog.array.find(this._allTipEls, function(tipEl) {
      return (tipEl.getAttribute('data-tip-id') === tipId);
    });
    
    if(this._nearbyTipEl !== tipEl) {

      if(this._nearbyTipEl) {
        goog.dom.classlist.remove(this._nearbyTipEl, 'nearby');
      }

      //console.log(this._nearbyTipEl, tipEl, tipId, providedTip);

      this._nearbyTipEl = tipEl;
      goog.dom.classlist.add(this._nearbyTipEl, 'nearby');

      var viewId = tipEl.getAttribute('data-view-id');

      if(viewId !== this._viewId) {
        this.goTipsOfView( viewId );
      }
    }

  }else {

    if(this._nearbyTipEl) {
      goog.dom.classlist.remove(this._nearbyTipEl, 'nearby');
      this._nearbyTipEl = null;
    }
  }
};


feng.views.sections.controls.ProgressBar.prototype.unlockTip = function( tipId ){
  
  var unlockedTipEl = goog.array.find(this._tipEls, function(tipEl) {
    return tipEl.getAttribute('data-tip-id') === tipId;
  });

  if(!unlockedTipEl) return;

  // assign url to book
  goog.dom.query('a', unlockedTipEl)[0].href = this._tips[tipId].readTipToken;

  goog.dom.classlist.add( unlockedTipEl, 'unlocked' );
};


feng.views.sections.controls.ProgressBar.prototype.onTipMouseOver = function(e){

  if(goog.dom.classlist.contains(e.currentTarget, 'hover')) {

    return false;

  }else {

    goog.dom.classlist.add(e.currentTarget, 'hover');

    feng.pubsub.publish( feng.PubSub.Topic.SHOW_WIDGET, this );
  }
};


feng.views.sections.controls.ProgressBar.prototype.onTipMouseOut = function(e){

  if(!e.relatedTarget || !goog.dom.contains(e.currentTarget, e.relatedTarget)) {

    goog.dom.classlist.remove(e.currentTarget, 'hover');

    feng.pubsub.publish( feng.PubSub.Topic.HIDE_WIDGET, this );
  }
};


feng.views.sections.controls.ProgressBar.prototype.onTipUnlock = function(e){

  var tipId = e.tip.id;
  this.unlockTip( tipId );
};


feng.views.sections.controls.ProgressBar.prototype.onModeChange = function(e){

  goog.base(this, 'onModeChange', e);

  var mode = e.nextMode || e.mode;

  switch(mode) {

    case feng.controllers.view3d.ModeController.Mode.BROWSE:
    case feng.controllers.view3d.ModeController.Mode.WALK:
    this.activate();
    break;

    default:
    this.deactivate();
    break;
  }
};


feng.views.sections.controls.ProgressBar.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

  var domSize = goog.style.getSize( this.domElement );

  var y = feng.viewportSize.height - 115;
	goog.style.setStyle( this.domElement, 'top', y + 'px' );

  this.calculateTipsLayout( this._tipsEl );
  this.goTipsOfView( this._viewId );
};goog.provide('feng.views.helpers.Helper');

goog.require('goog.style');

/**
 * @constructor
 */
feng.views.helpers.Helper = function( domElement ){

  goog.base(this);

  this.domElement = domElement;

  this._closeButton = goog.dom.getElementByClass('close-button', this.domElement);

  this._x = 0;
  this._y = 0;

  this._size = goog.style.getSize( this.domElement );
  this._box = new goog.math.Box();

  this._positionPriority = feng.views.helpers.Helper.POSITION_PRIORITY.HORIZONTAL;

  this._arrowClasses = ['arrow-left', 'arrow-right', 'arrow-top', 'arrow-bottom'];

  this.hasOtherWidgetShown = false;
  this.isShown = false;
  this.isCompleted = false;
};
goog.inherits(feng.views.helpers.Helper, goog.events.EventTarget);


feng.views.helpers.Helper.prototype.disposeInternal = function() {

  goog.base(this, 'disposeInternal');

  this.deactivate();

  this._closeButton = null;
};


feng.views.helpers.Helper.prototype.activate = function() {

	goog.events.listen( this._closeButton, 'click', this.doComplete, false, this );
	goog.events.listen( window, 'resize', this.onResize, false, this );

	feng.pubsub.subscribe( feng.PubSub.Topic.SHOW_WIDGET, this.onShowWidget, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.HIDE_WIDGET, this.onHideWidget, this );

	this.hasOtherWidgetShown = (feng.pubsub.getShownWidgets().length > 0);

	this._size = goog.style.getSize( this.domElement );
};


feng.views.helpers.Helper.prototype.deactivate = function() {

  	goog.events.unlisten( this._closeButton, 'click', this.doComplete, false, this );
  	goog.events.unlisten( window, 'resize', this.onResize, false, this );
};


feng.views.helpers.Helper.prototype.show = function( box ) {

	if(this.isShown) return;
	else this.isShown = true;

	goog.dom.classlist.enable( this.domElement, 'shown', true );

	if(box) {
	
		this.calculatePosition( box );

		this.updatePosition();
	}

	if(this.isShown) {

		this.onResize();
	}

	feng.pubsub.publish( feng.PubSub.Topic.SHOW_WIDGET, this );
};


feng.views.helpers.Helper.prototype.hide = function() {

	if(!this.isShown) return;
	else this.isShown = false;

	goog.dom.classlist.enable( this.domElement, 'shown', false );

	feng.pubsub.publish( feng.PubSub.Topic.HIDE_WIDGET, this );
};


feng.views.helpers.Helper.prototype.doComplete = function() {

	this.isCompleted = true;

	this.deactivate();

	this.hide();

	this.dispatchEvent( feng.events.EventType.COMPLETE );
};


feng.views.helpers.Helper.prototype.updatePosition = function() {

	goog.style.setStyle( this.domElement, 'transform', 'translate(' + this._x + 'px, ' + this._y + 'px)' );
};


feng.views.helpers.Helper.prototype.resolveHorizontalPosition = function( box ) {

	var size = this._size;
	var viewportSize = feng.viewportSize;

	var isFit = false;

	if( viewportSize.width - box.right > size.width ) {

		// snap to right
		this._x = box.right;

		goog.dom.classlist.removeAll( this.domElement, this._arrowClasses );
		goog.dom.classlist.add( this.domElement, 'arrow-left' );

		isFit = true;

	}else if( box.left > size.width ) {

		// snap to left
		this._x = box.left - size.width;

		goog.dom.classlist.removeAll( this.domElement, this._arrowClasses );
		goog.dom.classlist.add( this.domElement, 'arrow-right' );

		isFit = true;
	}

	this._y = box.top - (size.height - (box.bottom - box.top)) / 2;

	if(this._y < 25 || (this._y + size.height) > (viewportSize.height - 150)) {

		isFit = false;
	}

	return isFit;
};


feng.views.helpers.Helper.prototype.resolveVerticalPosition = function( box ) {

	var size = this._size;
	var viewportSize = feng.viewportSize;

	var isFit = false;

	if( box.top > size.height ) {

		this._y = box.top - size.height;

		goog.dom.classlist.removeAll( this.domElement, this._arrowClasses );
		goog.dom.classlist.add( this.domElement, 'arrow-bottom' );

		isFit = true;

	}else if( viewportSize.height - box.bottom > size.height ) {

		this._y = box.bottom;

		goog.dom.classlist.removeAll( this.domElement, this._arrowClasses );
		goog.dom.classlist.add( this.domElement, 'arrow-top' );

		isFit = true;
	}

	this._x = box.left - (size.width - (box.right - box.left)) / 2;

	if(this._x < 150 || (this._x + size.width) > (viewportSize.width - 150)) {

		isFit = false;
	}

	return isFit;
};


feng.views.helpers.Helper.prototype.calculatePosition = function( box ) {

	var size = this._size;
	var viewportSize = feng.viewportSize;

	switch(this._positionPriority) {

		case feng.views.helpers.Helper.POSITION_PRIORITY.HORIZONTAL:

		var resolveHorizontal = this.resolveHorizontalPosition( box );

		if(!resolveHorizontal) {
			this.resolveVerticalPosition( box );
		}
		break;

		case feng.views.helpers.Helper.POSITION_PRIORITY.VERTICAL:

		var resolveVertical = this.resolveVerticalPosition( box );

		if(!resolveVertical) {
			this.resolveHorizontalPosition( box );
		}
		break;
	}
	
	this._x = Math.max(150, Math.min(viewportSize.width - 150 - size.width, this._x));
	this._y = Math.max(25, Math.min(viewportSize.height - 150 - size.height, this._y));

	this._box = box;
};


feng.views.helpers.Helper.prototype.onShowWidget = function( widget ){

	if(widget === this) {

		return;

	}else {

		this.hasOtherWidgetShown = true;

		this.hide();
	}
};


feng.views.helpers.Helper.prototype.onHideWidget = function( widget ){

	if(widget === this) {
		
		return;

	}else {

		this.hasOtherWidgetShown = false;
	}
};


feng.views.helpers.Helper.prototype.onResize = function( e ) {

	this._size = goog.style.getSize( this.domElement );

	if(this._box) {
	
		this.calculatePosition( this._box );

		this.updatePosition();
	}
};


feng.views.helpers.Helper.POSITION_PRIORITY = {
	HORIZONTAL: 'horizontal',
	VERTICAL: 'vertical'
};goog.provide('feng.views.helpers.SelectorHelper');

goog.require('feng.views.helpers.Helper');

/**
 * @constructor
 */
feng.views.helpers.SelectorHelper = function( domElement ){

  goog.base(this, domElement);

  this._positionPriority = feng.views.helpers.Helper.POSITION_PRIORITY.VERTICAL;

  this._object3d = null;
  this._camera = null;
  this._viewSize = null;
  this._box3 = new THREE.Box3();
};
goog.inherits(feng.views.helpers.SelectorHelper, feng.views.helpers.Helper);


feng.views.helpers.SelectorHelper.prototype.disposeInternal = function() {

	goog.base(this, 'disposeInternal');

	this._object3d = null;
	this._camera = null;
	this._viewSize = null;
};


feng.views.helpers.SelectorHelper.prototype.activate = function() {

	goog.base(this, 'activate');

	feng.pubsub.subscribe( feng.PubSub.Topic.TRIGGER_SELECTOR, this.onTriggerSelector, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.UNTRIGGER_SELECTOR, this.onUntriggerSelector, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.COMPLETE_SELECTOR, this.onCompleteSelector, this );
};


feng.views.helpers.SelectorHelper.prototype.deactivate = function() {

  	goog.base(this, 'deactivate');

  	feng.pubsub.unsubscribe( feng.PubSub.Topic.TRIGGER_SELECTOR, this.onTriggerSelector, this );
  	feng.pubsub.unsubscribe( feng.PubSub.Topic.UNTRIGGER_SELECTOR, this.onUntriggerSelector, this );
  	feng.pubsub.unsubscribe( feng.PubSub.Topic.COMPLETE_SELECTOR, this.onCompleteSelector, this );

  	goog.fx.anim.unregisterAnimation( this );
};


feng.views.helpers.SelectorHelper.prototype.onTriggerSelector = function( object3d, camera, viewSize ) {

	if(this.hasOtherWidgetShown) {
		return;
	}
	
	this._object3d = object3d;
	this._camera = camera;
	this._viewSize = viewSize;

	this.show();

	goog.fx.anim.registerAnimation( this );
};


feng.views.helpers.SelectorHelper.prototype.onUntriggerSelector = function() {

	this.hide();

	goog.fx.anim.unregisterAnimation( this );
};


feng.views.helpers.SelectorHelper.prototype.onCompleteSelector = function() {

	this.doComplete();
};


feng.views.helpers.SelectorHelper.prototype.onAnimationFrame = function( now ) {

	var pos3d = this._box3.setFromObject( this._object3d ).center();
	var pos2d = feng.utils.ThreeUtils.get2DCoordinates( pos3d, this._camera, this._viewSize );

	this._box.top = pos2d.y - 50;
	this._box.right = pos2d.x + 50;
	this._box.bottom = pos2d.y + 50;
	this._box.left = pos2d.x - 50;

	this.calculatePosition( this._box );

	this.updatePosition();
};goog.provide('feng.views.helpers.CompassHelper');

goog.require('feng.views.helpers.Helper');

/**
 * @constructor
 */
feng.views.helpers.CompassHelper = function( domElement ){

  goog.base(this, domElement);

  this._compassEl = null;
};
goog.inherits(feng.views.helpers.CompassHelper, feng.views.helpers.Helper);


feng.views.helpers.CompassHelper.prototype.disposeInternal = function() {

  goog.base(this, 'disposeInternal');

  this._compassEl = null;
};


feng.views.helpers.CompassHelper.prototype.activate = function() {

	goog.base(this, 'activate');

	feng.pubsub.subscribe( feng.PubSub.Topic.TRIGGER_COMPASS, this.onTriggerCompass, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.UNTRIGGER_COMPASS, this.onUntriggerCompass, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.COMPLETE_COMPASS, this.onCompleteCompass, this );
};


feng.views.helpers.CompassHelper.prototype.deactivate = function() {

  	goog.base(this, 'deactivate');

  	feng.pubsub.unsubscribe( feng.PubSub.Topic.TRIGGER_COMPASS, this.onTriggerCompass, this );
  	feng.pubsub.unsubscribe( feng.PubSub.Topic.UNTRIGGER_COMPASS, this.onUntriggerCompass, this );
  	feng.pubsub.unsubscribe( feng.PubSub.Topic.COMPLETE_COMPASS, this.onCompleteCompass, this );
};


feng.views.helpers.CompassHelper.prototype.updateCompassBox = function() {

	if(!this._compassEl) return;

	var position = goog.style.getPageOffset( this._compassEl );
	var size = goog.style.getSize( this._compassEl );

	this._box.top = position.y;
	this._box.right = position.x + size.width;
	this._box.bottom = position.y + size.height;
	this._box.left = position.x;
};


feng.views.helpers.CompassHelper.prototype.onTriggerCompass = function( compass ) {

	if(this.hasOtherWidgetShown) {
		return;
	}
	
	this._compassEl = compass.domElement;

	this.updateCompassBox();

	this.show( this._box );
};


feng.views.helpers.CompassHelper.prototype.onUntriggerCompass = function() {

	this.hide();
};


feng.views.helpers.CompassHelper.prototype.onCompleteCompass = function() {

	this.doComplete();
};


feng.views.helpers.CompassHelper.prototype.onResize = function(e) {

	this.updateCompassBox();

	goog.base(this, 'onResize', e);
};goog.provide('feng.views.helpers.WalkHelper');

goog.require('goog.async.Delay');
goog.require('feng.views.helpers.Helper');

/**
 * @constructor
 */
feng.views.helpers.WalkHelper = function( domElement ){

  goog.base(this, domElement);

  this._mousewheelEl = goog.dom.getElementByClass('mousewheel', this.domElement);
  this._clickEl = goog.dom.getElementByClass('click', this.domElement);

  this._hasShownMousewheel = false;
  this._hasShownClick = false;

  this._delayToShow = new goog.async.Delay( this.show, 1000, this );
  this._delayToComplete = new goog.async.Delay( this.doComplete, 5000, this );
};
goog.inherits(feng.views.helpers.WalkHelper, feng.views.helpers.Helper);


feng.views.helpers.WalkHelper.prototype.disposeInternal = function() {

	goog.base(this, 'disposeInternal');

	this._delayToComplete.dispose();
};


feng.views.helpers.WalkHelper.prototype.show = function() {

	goog.base(this, 'show');

	this._delayToShow.dispose();

	this.calculatePosition();

	this.updatePosition();
};


feng.views.helpers.WalkHelper.prototype.hide = function() {

	goog.base(this, 'hide');

	this._delayToShow.stop();
	this._delayToComplete.stop();
};


feng.views.helpers.WalkHelper.prototype.calculatePosition = function() {

	var size = goog.style.getSize( this.domElement );
	var viewportSize = feng.viewportSize;

	this._x = ( viewportSize.width - size.width ) / 2;
	this._y = ( viewportSize.height - size.height ) / 2;
};


feng.views.helpers.WalkHelper.prototype.activate = function() {

	goog.base(this, 'activate');

	feng.pubsub.subscribe( feng.PubSub.Topic.TRIGGER_WALK, this.onTriggerWalk, this );
};


feng.views.helpers.WalkHelper.prototype.deactivate = function() {

  	goog.base(this, 'deactivate');

  	feng.pubsub.unsubscribe( feng.PubSub.Topic.TRIGGER_WALK, this.onTriggerWalk, this );
};


feng.views.helpers.WalkHelper.prototype.onTriggerWalk = function( type ) {

	if(this._hasShownClick && this._hasShownMousewheel) {
		return;
	}

	if(this.hasOtherWidgetShown) {
		return;
	}

	if(type === 'mousewheel') {

		goog.style.showElement(this._mousewheelEl, false);
		goog.style.showElement(this._clickEl, true);

		this._hasShownClick = true;
	
	}else if(type === 'click') {

		goog.style.showElement(this._mousewheelEl, true);
		goog.style.showElement(this._clickEl, false);

		this._hasShownMousewheel = true;
	}

	if(!this._delayToShow.isActive() && !this._delayToShow.isDisposed()) {
		this._delayToShow.start();
	}

	this._delayToComplete.start();
};goog.provide('feng.views.helpers.Helpers');

goog.require('feng.templates.common');
goog.require('feng.views.helpers.CompassHelper');
goog.require('feng.views.helpers.SelectorHelper');
goog.require('feng.views.helpers.WalkHelper');

/**
 * @constructor
 */
feng.views.helpers.Helpers = function(){

  goog.base(this);

  this.domElement = soy.renderAsFragment(feng.templates.common.Helpers);

  var compassHelperEl = goog.dom.getElementByClass('compass', this.domElement);
  this._compassHelper = new feng.views.helpers.CompassHelper( compassHelperEl );
  this._compassHelper.setParentEventTarget( this );

  var selectorHelperEl = goog.dom.getElementByClass('selector', this.domElement);
  this._selectorHelper = new feng.views.helpers.SelectorHelper( selectorHelperEl );
  this._selectorHelper.setParentEventTarget( this );

  var walkHelperEl = goog.dom.getElementByClass('walk', this.domElement);
  this._walkHelper = new feng.views.helpers.WalkHelper( walkHelperEl );
  this._walkHelper.setParentEventTarget( this );

  this._numCompletedHelpers = 0;
  this._totalHelpers = 3;

  this._isActivated = false;
};
goog.inherits(feng.views.helpers.Helpers, goog.events.EventTarget);
goog.addSingletonGetter(feng.views.helpers.Helpers);


feng.views.helpers.Helpers.prototype.disposeInternal = function() {

  goog.base(this, 'disposeInternal');

  this.deactivate();

  this._compassHelper.dispose();
  this._selectorHelper.dispose();
  this._walkHelper.dispose();

  this._compassHelper = null;
  this._selectorHelper = null;
  this._walkHelper = null;

  if(this.domElement.parentNode) {
    goog.dom.removeNode( this.domElement );
  }

  this.domElement = null;
};


feng.views.helpers.Helpers.prototype.activate = function() {

  if(this.isDisposed()) {
    return;
  }

  if(this._isActivated) {
    return;
  }else {
    this._isActivated = true;
  }

  goog.events.listen( this, feng.events.EventType.COMPLETE, this.onHelperComplete, false, this );

  if(!this._compassHelper.isCompleted) {
    this._compassHelper.activate();
  }

  if(!this._selectorHelper.isCompleted) {
    this._selectorHelper.activate();
  }

  if(!this._walkHelper.isCompleted) {
    this._walkHelper.activate();
  }
};


feng.views.helpers.Helpers.prototype.deactivate = function() {

  if(this.isDisposed()) {
    return;
  }
  
  if(!this._isActivated) {
    return;
  }else {
    this._isActivated = false;
  }

  goog.events.unlisten( this, feng.events.EventType.COMPLETE, this.onHelperComplete, false, this );

  this._compassHelper.deactivate();
  this._selectorHelper.deactivate();
  this._walkHelper.deactivate();
};


feng.views.helpers.Helpers.prototype.show = function( shouldShow ){

  var shouldShow = goog.isBoolean(shouldShow) ? shouldShow : true;

  goog.dom.classlist.enable( this.domElement, 'hidden', !shouldShow );
  
  if(!shouldShow) {

    this._compassHelper.hide();
    this._selectorHelper.hide();
    this._walkHelper.hide();
  }
};


feng.views.helpers.Helpers.prototype.onHelperComplete = function(e) {

  this._numCompletedHelpers ++;

  if(this._numCompletedHelpers === this._totalHelpers) {
    this.dispose();
  }
};goog.provide('feng.fx.AnimatedSprite');

goog.require('goog.math.Size');
goog.require('goog.math.Coordinate');


feng.fx.AnimatedSprite = function( domElement, image, framesHorizontal, framesVertical, numFrames, useRetina ) {

	this.domElement = domElement;
	this.image = image;

	this._framesHorizontal = framesHorizontal;
	this._framesVertical = framesVertical;
	this._numFrames = numFrames;

	this._retinaScale = (useRetina === true && window.devicePixelRatio > 1) ? 2 : 1;

	var domWidth = this.image.width / this._framesHorizontal / this._retinaScale;
	var domHeight = this.image.height / this._framesVertical / this._retinaScale;
	this.size = new goog.math.Size( domWidth, domHeight );

	this._frameId = 0;
	this._framePosition = new goog.math.Coordinate(0, 0);

	goog.style.setStyle(this.domElement, {
		'background-image': 'url('+this.image.src+')',
		'background-size': (this.image.width / this._retinaScale) + 'px ' + (this.image.height / this._retinaScale) + 'px',
		'background-repeat': 'no-repeat',
		'width': domWidth + 'px',
		'height': domHeight + 'px'
	});

	this.gotoFrame( 0 );
};


feng.fx.AnimatedSprite.prototype.getProgress = function() {

	return this._frameId / (this._numFrames - 1);
};


feng.fx.AnimatedSprite.prototype.getCurrentFrame = function() {

	return this._frameId;
};


feng.fx.AnimatedSprite.prototype.getFramePositionById = function( frameId ) {

	var frameCol = frameId % this._framesHorizontal;
	this._framePosition.x = frameCol / this._framesHorizontal * this.image.width / this._retinaScale;

	var frameRow = Math.floor(frameId / this._framesHorizontal);
	this._framePosition.y = frameRow / this._framesVertical * this.image.height / this._retinaScale;

	return this._framePosition;
};


feng.fx.AnimatedSprite.prototype.getFramePosition = function() {

	return this.getFramePositionById( this._frameId );
};


feng.fx.AnimatedSprite.prototype.setProgress = function( progress ) {

	var frameId = Math.round( (this._numFrames - 1) * progress );
	this.gotoFrame( frameId );
};


feng.fx.AnimatedSprite.prototype.gotoFrame = function( frameId ) {

	this._frameId = frameId;

	var framePosition = this.getFramePositionById( this._frameId );

	goog.style.setStyle(this.domElement, 'background-position', (-framePosition.x + 'px ') + (-framePosition.y + 'px'));
};goog.provide('feng.views.sections.controls.Compass');

goog.require('goog.dom');
goog.require('feng.events');
goog.require('feng.fx.AnimatedSprite');
goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.Compass = function(domElement){
	
  goog.base(this, domElement);

  this._mainEl = goog.dom.getElement('main');
  
  var browseEl = goog.dom.getElementByClass('browse', this.domElement);
  var img = feng.models.Preload.getInstance().getAsset('global.cube-browse');
  this._browseSprite = new feng.fx.AnimatedSprite(browseEl, img, 12, 9, 100);

  var designEl = goog.dom.getElementByClass('design', this.domElement);
  var img = feng.models.Preload.getInstance().getAsset('global.cube-design');
  this._designSprite = new feng.fx.AnimatedSprite(designEl, img, 12, 9, 100);

  this._hoveredDesign = false;
  this._hoveredBrowse = false;

  this._rotation = 0;
  this._startRotation = 0;

  this._isInDesignMode = false;
  this._isInBrowseMode = false;
};
goog.inherits(feng.views.sections.controls.Compass, feng.views.sections.controls.Controls);


feng.views.sections.controls.Compass.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

  this._eventHandler.listen(this.domElement, 'mouseover', this.onMouseOver, false, this);
  this._eventHandler.listen(this.domElement, 'mousemove', this.onMouseMove, false, this);
  this._eventHandler.listen(this.domElement, 'mouseout', this.onMouseOut, false, this);
  this._eventHandler.listen(this.domElement, 'click', this.onClick, false, this);

  if(this._view3d) {
    this._view3d.modeController.listen( feng.events.EventType.UPDATE, this.onView3dUpdate, false, this );
  }
};


feng.views.sections.controls.Compass.prototype.deactivate = function(){

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

  feng.pubsub.publish( feng.PubSub.Topic.UNTRIGGER_COMPASS );
};


feng.views.sections.controls.Compass.prototype.setView3D = function( view3d ){

  goog.base(this, 'setView3D', view3d);

  if(this._view3d) {
    this._view3d.modeController.unlisten( feng.events.EventType.UPDATE, this.onView3dUpdate, false, this );
  }

  this._view3d.modeController.listen( feng.events.EventType.UPDATE, this.onView3dUpdate, false, this );
};


feng.views.sections.controls.Compass.prototype.setProgress = function(progress){

	this._browseSprite.setProgress( progress );
	this._designSprite.setProgress( progress );
};


feng.views.sections.controls.Compass.prototype.setRotation = function(rotation){

	this._rotation = goog.math.modulo( rotation, 2 * Math.PI );

	var progress = this._rotation / (2 * Math.PI);
	this.setProgress( progress );

	return this._rotation;
};


feng.views.sections.controls.Compass.prototype.onMouseOver = function(e){

	if(e.relatedTarget && goog.dom.contains(this.domElement, e.relatedTarget)) return false;

	feng.pubsub.publish( feng.PubSub.Topic.TRIGGER_COMPASS, this );
};


feng.views.sections.controls.Compass.prototype.onMouseMove = function(e){

	if(e.offsetY > 40) {

		// browse mode
		goog.dom.classlist.addRemove(this.domElement, 'hover-design', 'hover-browse');
		this._hoveredDesign = false;
		this._hoveredBrowse = true;

	}else {

		// design mode
		goog.dom.classlist.addRemove(this.domElement, 'hover-browse', 'hover-design');
		this._hoveredDesign = true;
		this._hoveredBrowse = false;
	}
};


feng.views.sections.controls.Compass.prototype.onMouseOut = function(e){

	if(e.relatedTarget && goog.dom.contains(e.currentTarget, e.relatedTarget)) {
		return false;
	}

	goog.dom.classlist.remove(this.domElement, 'hover-browse');
	goog.dom.classlist.remove(this.domElement, 'hover-design');
	this._hoveredDesign = false;
	this._hoveredBrowse = false;

	if(this._isInBrowseMode) {

		feng.pubsub.publish( feng.PubSub.Topic.UNTRIGGER_COMPASS );
	}
};


feng.views.sections.controls.Compass.prototype.onClick = function(e){

	if(this._hoveredDesign) {

		if(this._isInDesignMode) return false;

		this.dispatchEvent({
			type: feng.events.EventType.CLICK_COMPASS,
			mode: 'design'
		});

		feng.pubsub.publish( feng.PubSub.Topic.TRIGGER_COMPASS, this );

	}else if(this._hoveredBrowse) {

		if(!this._isInDesignMode) return false;

		this.dispatchEvent({
			type: feng.events.EventType.CLICK_COMPASS,
			mode: 'browse'
		});

		feng.pubsub.publish( feng.PubSub.Topic.COMPLETE_COMPASS, this );
	}
};


feng.views.sections.controls.Compass.prototype.onResize = function(e){

	goog.style.setPosition(this.domElement, feng.viewportSize.width - 100 - 30, 30);
};


feng.views.sections.controls.Compass.prototype.onView3dUpdate = function(e){

	this.setRotation( e.rotationY );
};


feng.views.sections.controls.Compass.prototype.onModeChange = function(e){

  goog.base(this, 'onModeChange', e);

  if(e.mode === feng.controllers.view3d.ModeController.Mode.BROWSE) {

  	this._isInBrowseMode = true;

  }else {

  	this._isInBrowseMode = false;
  }

  if(e.mode === feng.controllers.view3d.ModeController.Mode.DESIGN) {

  	goog.dom.classlist.addRemove(this.domElement, 'browse', 'design');

  	this._isInDesignMode = true;

  }else {

  	goog.dom.classlist.addRemove(this.domElement, 'design', 'browse');

  	this._isInDesignMode = false;
  }
  
  switch(e.mode) {

    case feng.controllers.view3d.ModeController.Mode.CLOSE_UP:
	this.deactivate();
    break;

    default:
	this.activate();
    break;
  }
};goog.provide('feng.views.sections.captions.ChangePictureCaption');

goog.require('goog.soy');
goog.require('feng.templates.captions');
goog.require('feng.views.sections.captions.Caption');


/**
 * @constructor
 */
feng.views.sections.captions.ChangePictureCaption = function( object, renderController, renderSize, controls, hud ){

  this._template = feng.templates.captions.ChangePictureCaption;
  
  this._templateData = {
    tip: object.tip,
    position: 'right'
  };

  goog.base(this, object, renderController, renderSize, controls, hud);

  this._pictureId = null;

  this._itemEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.item-button', this.domElement), 'data-picture' );
  this._infoEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.info li', this.domElement), 'data-picture' );
};
goog.inherits(feng.views.sections.captions.ChangePictureCaption, feng.views.sections.captions.Caption);


feng.views.sections.captions.ChangePictureCaption.prototype.show = function() {

  goog.base(this, 'show');

  goog.object.forEach(this._itemEls, function(itemEl) {
    this._eventHandler.listen(itemEl, 'click', this.onClickItem, false, this);
  }, this);
};


feng.views.sections.captions.ChangePictureCaption.prototype.hide = function() {

  goog.base(this, 'hide');

  this._object.stopInteraction();
};


feng.views.sections.captions.ChangePictureCaption.prototype.onClickItem = function(e) {

  if(this._pictureId) {
    goog.dom.classlist.enable( this._itemEls[this._pictureId], 'active', false );
    goog.dom.classlist.enable( this._infoEls[this._pictureId], 'active', false );
  }

  this._pictureId = e.currentTarget.getAttribute("data-picture");

  goog.dom.classlist.enable( this._itemEls[this._pictureId], 'active', true );
  goog.dom.classlist.enable( this._infoEls[this._pictureId], 'active', true );

  this.scrollBar.resize();
  
  this._object.setPicture( this._pictureId );

  this._object.nextPicture();

  feng.soundController.playSfx('click');
};goog.provide('feng.views.sections.controls.ObjectSelector');

goog.require('goog.events');
goog.require('goog.async.Delay');
goog.require('goog.async.Throttle');
goog.require('feng.fx.AnimatedSprite');
goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.ObjectSelector = function(domElement){

  goog.base(this, domElement);

  this._selectableObjects = [];

  this._domElement = domElement;
  this._fillEl = goog.dom.getElementByClass('fill', this._domElement);

  var img = feng.models.Preload.getInstance().getAsset('global.circular-fill');
  this._fillSprite = new feng.fx.AnimatedSprite(this._fillEl, img, 16, 2, 31);

  this._selectedObject = null;
  this._downObject = null;
  this._isEnabled = false;
  this._startTime = 0;
  this._duration = 500;

  this._isMouseDown = false;

  this._callbacks = {};

  // a delay to kick off the progress, to differentiate the mouse behavior between a fast click and object selecting
  this._delay = new goog.async.Delay(this.startSelect, 200, this);

  // a throttle to not let the object hover detection fire too often
  this._mouseMoveThrottle = new goog.async.Throttle(this.doHoverDetection, 250, this);
  this._mouseMovePosition = {x: 0, y: 0};

  this._intersectedObject = null;

  this._hitTestMeshes = [];

	this.show( false );
};
goog.inherits(feng.views.sections.controls.ObjectSelector, feng.views.sections.controls.Controls);


feng.views.sections.controls.ObjectSelector.prototype.setPosition = function ( x, y ) {

	goog.style.setPosition(this.domElement, x, y);
};


feng.views.sections.controls.ObjectSelector.prototype.setSelectableObjects = function ( objects ) {

	this._selectableObjects = objects;

	this._hitTestMeshes = goog.array.map(this._selectableObjects, function(object) {

		return object.getProxyBox();
	}, this);
};


feng.views.sections.controls.ObjectSelector.prototype.activate = function( callbacks ) {

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;
  
	this._callbacks = {
	  	'onProgress': callbacks['onProgress'] || goog.nullFunction,
	  	'onStart': callbacks['onStart'] || goog.nullFunction,
	  	'onCancel': callbacks['onCancel'] || goog.nullFunction,
	  	'onComplete': callbacks['onComplete'] || goog.nullFunction
	  };

	this._eventHandler.listen(this._renderEl, 'mousedown', this.onMouseDown, false, this);
	this._eventHandler.listen(this._renderEl, 'mousemove', this.onMouseMove, false, this);
	this._eventHandler.listen(this._renderEl, 'mouseup', this.onMouseUp, false, this);
};


feng.views.sections.controls.ObjectSelector.prototype.deactivate = function() {

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

  this._isMouseDown = false;

	this._delay.stop();

	this._mouseMoveThrottle.stop();

	goog.fx.anim.unregisterAnimation( this );

	feng.pubsub.publish( feng.PubSub.Topic.UNTRIGGER_SELECTOR );
};


feng.views.sections.controls.ObjectSelector.prototype.animateIn = function () {

	TweenMax.fromTo(this.domElement, .25, {
		'scale': 0,
		'opacity': 0,
		'display': 'none'
	}, {
		'scale': 1,
		'opacity': 1,
		'display': 'block',
		'ease': Expo.easeOut
	});

	TweenMax.fromTo(this._fillEl, .4, {
		'scale': 0
	}, {
		'delay': .1,
		'scale': 1,
		'ease': Back.easeOut
	});
};


feng.views.sections.controls.ObjectSelector.prototype.animateOut = function () {

	TweenMax.to(this.domElement, .25, {
		'scale': .5,
		'opacity': 0,
		'display': 'none',
		'ease': Expo.easeOut,
		'onComplete': this.hide,
		'onCompleteScope': this
	});
};


feng.views.sections.controls.ObjectSelector.prototype.doSelect = function () {

	this._selectedObject = this._downObject;

	this.animateOut();

	this._callbacks['onComplete']( this._selectedObject );

	feng.pubsub.publish( feng.PubSub.Topic.COMPLETE_SELECTOR );
};


feng.views.sections.controls.ObjectSelector.prototype.cancelSelect = function () {

	this.animateOut();

	this._view3d.fx.selectEffect.animateOut();

	this._callbacks['onCancel']();
};


feng.views.sections.controls.ObjectSelector.prototype.startSelect = function () {

	if(!this._view3d.onlyObjectToUnlock || (this._downObject === this._view3d.onlyObjectToUnlock)) {

		this._view3d.fx.selectEffect.animateIn( this._downObject );

		this.show();
		this.animateIn();
		
		this._startTime = goog.now();
		goog.fx.anim.registerAnimation( this );

		this._callbacks['onStart']( this._downObject );
	}
};


feng.views.sections.controls.ObjectSelector.prototype.doHoverDetection = function () {
	
	var mouseX = this._mouseMovePosition.x;
	var mouseY = this._mouseMovePosition.y;

	var camera = this._cameraController.activeCamera;

	var intersects = feng.utils.ThreeUtils.getObjectsBy2DPosition( mouseX, mouseY, this._hitTestMeshes, camera, this._viewSize );
	
	var isIntersected = (intersects.length > 0);

	if(isIntersected) {

		this._intersectedObject = intersects[0].object;

		if(!this._view3d.onlyObjectToUnlock || (this._intersectedObject.view3dObject === this._view3d.onlyObjectToUnlock)) {

			this._view3d.fx.selectEffect.animateIn( this._intersectedObject.view3dObject );
		}

	}else {

		this._intersectedObject = null;

		this._view3d.fx.selectEffect.animateOut();
	}
};


feng.views.sections.controls.ObjectSelector.prototype.onMouseDown = function ( e ) {

	this._isMouseDown = true;

	this._selectedObject = null;

	var camera = this._cameraController.activeCamera;

	var intersects = feng.utils.ThreeUtils.getObjectsBy2DPosition( e.clientX, e.clientY, this._hitTestMeshes, camera, this._viewSize );

	if(intersects.length === 0) {
		return false;
	}

	this._downObject = intersects[0].object.view3dObject;
	this.setPosition( e.clientX, e.clientY );

	this._eventHandler.listen(document, 'mousemove', this.onMouseDownCancel, false, this);
	this._eventHandler.listen(document, 'mouseup', this.onMouseDownCancel, false, this);

	this._delay.start();
};


feng.views.sections.controls.ObjectSelector.prototype.onMouseUp = function ( e ) {

	this._isMouseDown = false;
};


feng.views.sections.controls.ObjectSelector.prototype.onMouseDownCancel = function ( e ) {

	this._delay.stop();

	this._eventHandler.unlisten(document, 'mousemove', this.onMouseDownCancel, false, this);
	this._eventHandler.unlisten(document, 'mouseup', this.onMouseDownCancel, false, this);

	goog.fx.anim.unregisterAnimation( this );

	this.cancelSelect();
};


feng.views.sections.controls.ObjectSelector.prototype.onMouseMove = function ( e ) {

	if(this._isMouseDown) {

		this._mouseMoveThrottle.stop();
		return false;
	}

	this._mouseMovePosition.x = e.clientX;
	this._mouseMovePosition.y = e.clientY;

	this._mouseMoveThrottle.fire();

	if(this._intersectedObject) {

		var camera = this._cameraController.activeCamera;

		feng.pubsub.publish( feng.PubSub.Topic.TRIGGER_SELECTOR, this._intersectedObject, camera, this._viewSize );

	}else {

		feng.pubsub.publish( feng.PubSub.Topic.UNTRIGGER_SELECTOR );
	}
};


feng.views.sections.controls.ObjectSelector.prototype.onAnimationFrame = function ( now ) {

	var progress = Math.min(1, (now - this._startTime) / this._duration);
	//console.log('object select progress: ' + progress);

	this._fillSprite.setProgress( progress );

	if(progress === 1) {

		this._eventHandler.unlisten(document, 'mousemove', this.onMouseDownCancel, false, this);
		this._eventHandler.unlisten(document, 'mouseup', this.onMouseDownCancel, false, this);

		goog.fx.anim.unregisterAnimation( this );

		this.doSelect();
	}

	this._callbacks['onProgress']( this._downObject, progress );
};goog.provide('feng.views.sections.captions.ChangeObjectCaption');

goog.require('goog.soy');
goog.require('feng.templates.captions');
goog.require('feng.views.sections.captions.Caption');


/**
 * @constructor
 */
feng.views.sections.captions.ChangeObjectCaption = function( object, renderController, renderSize, controls, hud ){

  this._template = feng.templates.captions.ChangeObjectCaption;
  console.log(object.tip)
  this._templateData = {
    tip: object.tip,
    position: 'right'
  };

  goog.base(this, object, renderController, renderSize, controls, hud);

  this._objectId = null;

  this._itemEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.item-button', this.domElement), 'data-object' );
  this._infoEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.info li', this.domElement), 'data-object' );
};
goog.inherits(feng.views.sections.captions.ChangeObjectCaption, feng.views.sections.captions.Caption);


feng.views.sections.captions.ChangeObjectCaption.prototype.show = function() {

  goog.base(this, 'show');

  goog.object.forEach(this._itemEls, function(itemEl) {
    goog.dom.classlist.enable( itemEl, 'loading', false );
    this._eventHandler.listen(itemEl, 'click', this.onClickItem, false, this);
  }, this);

  this._eventHandler.listen( this._object, feng.events.EventType.LOAD, this.onLoadStart, false, this );
  this._eventHandler.listen( this._object, feng.events.EventType.LOAD_COMPLETE, this.onLoadComplete, false, this );
};


feng.views.sections.captions.ChangeObjectCaption.prototype.hide = function() {

  goog.base(this, 'hide');

  this._object.stopInteraction();
};


feng.views.sections.captions.ChangeObjectCaption.prototype.onClickItem = function(e) {

  if(this._objectId) {
    goog.dom.classlist.enable( this._itemEls[this._objectId], 'active', false );
    goog.dom.classlist.enable( this._infoEls[this._objectId], 'active', false );
  }

  this._objectId = e.currentTarget.getAttribute('data-object');

  goog.dom.classlist.enable( this._itemEls[this._objectId], 'active', true );
  goog.dom.classlist.enable( this._infoEls[this._objectId], 'active', true );

  this.scrollBar.resize();
  
  this._object.change( this._objectId );

  feng.soundController.playSfx('click');
};


feng.views.sections.captions.ChangeObjectCaption.prototype.onLoadStart = function(e) {

  goog.dom.classlist.enable( this._itemEls[e.id], 'loading', true );
};


feng.views.sections.captions.ChangeObjectCaption.prototype.onLoadComplete = function(e) {

  goog.dom.classlist.enable( this._itemEls[e.id], 'loading', false );
};goog.provide('feng.views.sections.controls.HomeButton');

goog.require('goog.dom');
goog.require('feng.events');
goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.HomeButton = function(domElement){
	
  goog.base(this, domElement);

  this._promptShown = false;
  this._promptEl = goog.dom.getElementByClass('home-button-prompt', this.domElement.parentNode);

  this._yesButtonEl = goog.dom.getElementByClass('yes', this._promptEl);
  this._noButtonEl = goog.dom.getElementByClass('no', this._promptEl);
};
goog.inherits(feng.views.sections.controls.HomeButton, feng.views.sections.controls.Controls);


feng.views.sections.controls.HomeButton.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

  this._eventHandler.listen( document.body, 'mousedown', this.onMouseDown, false, this );
  this._eventHandler.listen( this._noButtonEl, 'click', this.hidePrompt, false, this );
};


feng.views.sections.controls.HomeButton.prototype.deactivate = function(){

  var shouldDeactivate = goog.base(this, 'deactivate');
  
  if(!shouldDeactivate) return;

  this.hidePrompt();
};


feng.views.sections.controls.HomeButton.prototype.showPrompt = function(){

	this._promptShown = true;

	goog.dom.classlist.add( this.domElement, 'pending' );
	goog.dom.classlist.add( this._promptEl, 'shown' );

	feng.pubsub.publish( feng.PubSub.Topic.SHOW_WIDGET, this );
};


feng.views.sections.controls.HomeButton.prototype.hidePrompt = function(){

	this._promptShown = false;

	goog.dom.classlist.remove( this.domElement, 'pending' );
	goog.dom.classlist.remove( this._promptEl, 'shown' );

	feng.pubsub.publish( feng.PubSub.Topic.HIDE_WIDGET, this );
};


feng.views.sections.controls.HomeButton.prototype.onMouseDown = function(e){

	var isClickedOnHomeButton = goog.dom.contains( this.domElement, e.target );
	var isClickedOnPrompt = goog.dom.contains( this._promptEl, e.target );

	var isClickedOutside = (!isClickedOnHomeButton && !isClickedOnPrompt);
	
	if(isClickedOutside && this._promptShown) {

		this.hidePrompt();
		return false;
	}

	if(isClickedOnHomeButton) {
		
		if(this._promptShown) {

			this.hidePrompt();

		}else {

			this.showPrompt();
		}
	}
};goog.provide('feng.views.sections.overlays.OpeningOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.views.Overlay');
goog.require('feng.views.popups.Popup');
goog.require('feng.models.Preload');
goog.require('feng.utils.Utils');


/**
 * @constructor
 */
feng.views.sections.overlays.OpeningOverlay = function(domElement){

	var canHalt = true;

  goog.base(this, domElement, canHalt);

  var popupEl = goog.dom.getElementByClass('popup', this.domElement);
  this._popup = new feng.views.popups.Popup( popupEl );

  this._okButton = goog.dom.getElementByClass('ok', popupEl);

  this._character = '';

  this._sectionId = null;
  this._viewId = null;
  this._shownOnce = {};

  this._enterKeyId = null;
	this._escKeyId = null;
	this._onClickOK = goog.bind( this.onClickOK, this );

  this._preload = feng.models.Preload.getInstance();
};
goog.inherits(feng.views.sections.overlays.OpeningOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.OpeningOverlay);


feng.views.sections.overlays.OpeningOverlay.prototype.activate = function(){

	goog.base(this, 'activate');

	this._eventHandler.listenOnce( this._okButton, 'click', this.onClickOK, false, this );
	this._eventHandler.listenOnce( this._popup, feng.events.EventType.ANIMATE_OUT, this.animateOut, false, this );

	this._enterKeyId = feng.keyboardController.bind( this._onClickOK, feng.keyboardController.key.ENTER, true );
	this._escKeyId = feng.keyboardController.bind( this._onClickOK, feng.keyboardController.key.ESC, true );
};


feng.views.sections.overlays.OpeningOverlay.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	feng.keyboardController.unbind( this._enterKeyId );
	feng.keyboardController.unbind( this._escKeyId );
};


feng.views.sections.overlays.OpeningOverlay.prototype.shouldShow = function( sectionId, viewId ){

	var shouldShow;

	if( !this._shownOnce[sectionId] ) {

		shouldShow = true;

	}else {

		if( this._shownOnce[sectionId][viewId] !== true ) shouldShow = true;
		else shouldShow = false;
	}

	return shouldShow;
};


feng.views.sections.overlays.OpeningOverlay.prototype.updateContent = function( sectionId, viewId ){

	this._sectionId = sectionId;
	this._viewId = viewId;

	var copy = this._preload.getAsset('global.fengshui-data')['dialog']['opening'][sectionId][viewId];

	var character = copy['character'];
	var title = copy['title'];
	var paragraph = copy['paragraph'];

	var titleEl = goog.dom.query('h1', this.domElement)[0];
	var paragraphEl = goog.dom.query('p', this.domElement)[0];
	var characterEl = goog.dom.getElementByClass('character', this.domElement);

	titleEl.innerHTML = title;
	paragraphEl.innerHTML = paragraph;

	if(this._character.length > 0) {
		
		goog.dom.classlist.remove( characterEl, this._character );
	}

	this._character = character;

	goog.dom.classlist.add( characterEl, this._character );
};


feng.views.sections.overlays.OpeningOverlay.prototype.animateIn = function(){

	var shouldShow = this.shouldShow( this._sectionId, this._viewId );

	if(!shouldShow) return false;

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});

	this._popup.animateIn( 800 );

	this._shownOnce[this._sectionId] = this._shownOnce[this._sectionId] || {};
	this._shownOnce[this._sectionId][this._viewId] = true;
};


feng.views.sections.overlays.OpeningOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'delay': .25,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteParams': [ true ],
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.OpeningOverlay.prototype.onClickOK = function(e){

	this._popup.animateOut();
};


feng.views.sections.overlays.OpeningOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);

	feng.utils.Utils.centerAlign( this._popup.domElement, feng.viewportSize );
};goog.provide('feng.views.sections.overlays.EndingOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.views.Overlay');
goog.require('feng.views.popups.Popup');
goog.require('feng.models.Preload');
goog.require('feng.utils.Utils');


/**
 * @constructor
 */
feng.views.sections.overlays.EndingOverlay = function(domElement){

	var canHalt = true;

  goog.base(this, domElement, canHalt);

  var popupEl = goog.dom.getElementByClass('popup', this.domElement);
  this._popup = new feng.views.popups.Popup( popupEl );

  this._stayButton = goog.dom.getElementByClass('stay', popupEl);
  this._nextButton = goog.dom.getElementByClass('next', popupEl);

	this._sectionId = null;
  this._shownOnce = {};

  this._character = '';

  this._enterKeyId = null;
	this._escKeyId = null;
	this._onClickNext = goog.bind( this.onClickNext, this );
	this._onClickStay = goog.bind( this.onClickStay, this );

  this._preload = feng.models.Preload.getInstance();
};
goog.inherits(feng.views.sections.overlays.EndingOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.EndingOverlay);


feng.views.sections.overlays.EndingOverlay.prototype.activate = function(){

	goog.base(this, 'activate');

	this._eventHandler.listenOnce( this._stayButton, 'click', this.onClickStay, false, this );
	this._eventHandler.listenOnce( this._nextButton, 'click', this.onClickNext, false, this );
	this._eventHandler.listenOnce( this._popup, feng.events.EventType.ANIMATE_OUT, this.animateOut, false, this );

	this._enterKeyId = feng.keyboardController.bind( this._onClickNext, feng.keyboardController.key.ENTER, true );
	this._escKeyId = feng.keyboardController.bind( this._onClickStay, feng.keyboardController.key.ESC, true );
};


feng.views.sections.overlays.EndingOverlay.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	feng.keyboardController.unbind( this._enterKeyId );
	feng.keyboardController.unbind( this._escKeyId );
};


feng.views.sections.overlays.EndingOverlay.prototype.updateContent = function( sectionId ){

	this._sectionId = sectionId;

	var copy = this._preload.getAsset('global.fengshui-data')['dialog']['ending'][sectionId];

	var character = copy['character'];
	var title = copy['title'];
	var paragraph = copy['paragraph'];

	var titleEl = goog.dom.query('h1', this.domElement)[0];
	var paragraphEl = goog.dom.query('p', this.domElement)[0];
	var characterEl = goog.dom.getElementByClass('character', this.domElement);

	titleEl.innerHTML = title;
	paragraphEl.innerHTML = paragraph;

	if(this._character.length > 0) {
		
		goog.dom.classlist.remove( characterEl, this._character );
	}

	this._character = character;

	goog.dom.classlist.add( characterEl, this._character );
};


feng.views.sections.overlays.EndingOverlay.prototype.animateIn = function(){

	if( !this._shownOnce[this._sectionId] ) {

		this._shownOnce[this._sectionId] = true;

	}else {

		return false;
	}

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});

	this._popup.animateIn();
};


feng.views.sections.overlays.EndingOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'delay': .25,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteParams': [ true ],
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.EndingOverlay.prototype.onClickStay = function(e){

	this._popup.animateOut();
};


feng.views.sections.overlays.EndingOverlay.prototype.onClickNext = function(e){

	this._popup.animateOut();
};


feng.views.sections.overlays.EndingOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);

	feng.utils.Utils.centerAlign( this._popup.domElement, feng.viewportSize );
};goog.provide('feng.views.sections.controls.DropButton');

goog.require('feng.views.sections.controls.Controls');


/**
 * @constructor
 */
feng.views.sections.controls.DropButton = function(domElement){
	
  goog.base(this, domElement);

  this._movableObject = null;

  goog.dom.classlist.addRemove( this.domElement, 'fadeIn', 'fadeOut' );
  goog.dom.classlist.enable( this.domElement, 'hidden', true );
};
goog.inherits(feng.views.sections.controls.DropButton, feng.views.sections.controls.Controls);


feng.views.sections.controls.DropButton.prototype.activate = function( movableObject ){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

  this._movableObject = movableObject;

  goog.dom.classlist.enable( this.domElement, 'hidden', false );

  this.fadeIn();

	this._eventHandler.listen(this.domElement, 'click', this.onClick, false, this);

	TweenMax.ticker.addEventListener("tick", this.update, this);
};


feng.views.sections.controls.DropButton.prototype.deactivate = function(){

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

  this._movableObject = null;

  goog.dom.classlist.enable( this.domElement, 'hidden', true );

  TweenMax.ticker.removeEventListener("tick", this.update, this);
};


feng.views.sections.controls.DropButton.prototype.fadeIn = function(){

  goog.dom.classlist.addRemove( this.domElement, 'fadeOut', 'fadeIn' );
};


feng.views.sections.controls.DropButton.prototype.fadeOut = function(){

  goog.dom.classlist.addRemove( this.domElement, 'fadeIn', 'fadeOut' );
};


feng.views.sections.controls.DropButton.prototype.onClick = function(e){

	if(goog.dom.classlist.contains(this.domElement, 'fadeOut')) {

    return false;
  }

	this.fadeOut();

  feng.soundController.playSfx('confirm');

  var browseControls = this._view3d.modeController.getModeControl( feng.controllers.view3d.ModeController.Mode.BROWSE );
  
  browseControls.dispatchEvent({
    type: feng.events.EventType.CHANGE,
    mode: feng.controllers.view3d.ModeController.Mode.TRANSITION,
    nextMode: feng.controllers.view3d.ModeController.Mode.CLOSE_UP,
    object: this._movableObject.getCloseUpObjectWhenDropped()
  });
};


feng.views.sections.controls.DropButton.prototype.update = function() {

  var camera = this._cameraController.activeCamera;
  var viewSize = this._viewSize;

  var pos3d = this._movableObject.getDestination();
  var pos2d = feng.utils.ThreeUtils.get2DCoordinates( pos3d, camera, viewSize );

  var control = this._view3d.modeController.control;
  var controlPosition = control.getPosition();
  var distance = controlPosition.distanceTo( pos3d );
  
  //
  var directionToObject = pos3d.sub( controlPosition ).normalize();
  var forward = control.getForwardVector();
  var dot = directionToObject.dot( forward );

  var shouldShow = (distance <= this._movableObject.range && dot > 0);

  goog.style.setStyle( this.domElement, 'transform', 'translateX(' + pos2d.x + 'px) translateY(' + pos2d.y + 'px)');

  if(shouldShow) {
    this.fadeIn();
  }else {
    this.fadeOut();
  }
};goog.provide('feng.views.sections.controls.Book');

goog.require('goog.dom');
goog.require('goog.fx.Dragger');
goog.require('feng.events');
goog.require('feng.fx.AnimatedSprite');
goog.require('feng.views.sections.controls.Controls');
goog.require('feng.views.book.Book');


/**
 * @constructor
 */
feng.views.sections.controls.Book = function(domElement){
	
  goog.base(this, domElement);

  var iconEl = goog.dom.getElementByClass('icon', this.domElement);
  var img = feng.models.Preload.getInstance().getAsset('global.book');
  this._bookSprite = new feng.fx.AnimatedSprite(iconEl, img, 10, 3, 30);

	var prop = {
		progress: 0
	};

	this._bookTweener = TweenMax.fromTo(prop, .25, {
		progress: 0
	},{
		progress: 1,
		'paused': true,
		'ease': Linear.easeNone,
		'onUpdate': function() {
			this._bookSprite.setProgress( prop.progress );
		},
		'onUpdateScope': this
	});
};
goog.inherits(feng.views.sections.controls.Book, feng.views.sections.controls.Controls);


feng.views.sections.controls.Book.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

	this._eventHandler.listen(this.domElement, 'mouseover', this.onMouseOver, false, this);
	this._eventHandler.listen(this.domElement, 'mouseout', this.onMouseOut, false, this);
};


feng.views.sections.controls.Book.prototype.onMouseOver = function(e){

	this._bookTweener.play();
};


feng.views.sections.controls.Book.prototype.onMouseOut = function(e){

	this._bookTweener.reverse();
};


feng.views.sections.controls.Book.prototype.onResize = function(e){

	var viewportSize = feng.viewportSize;
	goog.style.setPosition(this.domElement, viewportSize.width - 100 - 30, 150);
};


feng.views.sections.controls.Book.prototype.onModeChange = function(e){

  goog.base(this, 'onModeChange', e);

  switch(e.mode) {

    case feng.controllers.view3d.ModeController.Mode.CLOSE_UP:
		if(this._isActivated) {
			this.deactivate();
		}
    break;

    default:
    if(!this._isActivated) {
		this.activate();
    }
    break;
  }
};goog.provide('feng.views.sections.controls.Tooltips');

goog.require('goog.async.Throttle');
goog.require('goog.dom.classlist');
goog.require('feng.views.sections.controls.Controls');
goog.require('feng.utils.ThreeUtils');


/**
 * @constructor
 */
feng.views.sections.controls.Tooltips = function( domElement ){

  goog.base(this, domElement);

  this._detectBlockingThrottle = new goog.async.Throttle( this.detectBlocking, 400, this );

  this._raycaster = new THREE.Raycaster();

  this._rayDirection = new THREE.Vector3();

  this._detectObjects = [];

  // object id as keys
  this._tooltips = {};

  // tooltips of current view3d
  this._currentTooltips = {};
  this._tooltipObjects = [];
};
goog.inherits(feng.views.sections.controls.Tooltips, feng.views.sections.controls.Controls);


feng.views.sections.controls.Tooltips.prototype.createTooltips = function( view3d ){

  // create tip tooltips
  var sectionId = view3d.sectionId;
  var viewId = view3d.id;

  goog.object.forEach( view3d.tipObjects, function(tipObject) {

    var objectId = tipObject.id;
    
    if(!this._tooltips[ objectId ]) {

      var goTipToken = feng.controllers.NavigationController.Token.GO_TIP.replace('{sectionId}', sectionId).replace('{viewId}', viewId).replace('{objectId}', objectId);

      var tooltipEl = soy.renderAsFragment(feng.templates.controls.TipTooltip, {
        object: tipObject,
        goTipToken: goTipToken
      });

      goog.dom.appendChild( this.domElement, tooltipEl );

      this._tooltips[ tipObject.id ] = tooltipEl;
    }
  }, this);

  // create gateway tooltips
  goog.object.forEach( view3d.getGatewayObjects(), function(gatewayObject) {

    if(!this._tooltips[ gatewayObject.id ] && !gatewayObject.toHome) {

      var tooltipEl = soy.renderAsFragment(feng.templates.controls.GatewayTooltip, {
        gateway: gatewayObject
      });

      goog.dom.appendChild( this.domElement, tooltipEl );

      this._tooltips[ gatewayObject.id ] = tooltipEl;
    }
  }, this);
};


feng.views.sections.controls.Tooltips.prototype.setView3D = function( view3d ){

  goog.base(this, 'setView3D', view3d);

  // create tooltips if not
  this.createTooltips( view3d );

  // find tooltip objects of view3d
  var tipObjects = goog.object.getValues( view3d.tipObjects );

  var gatewayObjects = goog.array.filter(view3d.getGatewayObjects(), function(gatewayObject) {
    return !gatewayObject.toHome;
  });
  
  this._tooltipObjects = ([]).concat( tipObjects, gatewayObjects );

  // set current tooltips from objects
  this._currentTooltips = {};

  goog.array.forEach( this._tooltipObjects, function(object) {

    var id = object.id;
    this._currentTooltips[ id ] = this._tooltips[ id ];
  }, this);

  // listen to tip unlock event
  goog.array.forEach( tipObjects, function(tipObject) {

    var id = tipObject.id;
    var tooltipEl = this._tooltips[ id ];

    var tip = tipObject.tip;
    goog.dom.classlist.enable( tooltipEl, 'locked', !(tip.unlocked && tip.isFinal) );

    if(!tip.unlocked && tip.isFinal) {
      goog.events.listenOnce( tip, feng.events.EventType.UNLOCK, this.onTipUnlock, false, this );
    }
  }, this);

  // listen to click event of gateway tooltip
  goog.array.forEach( gatewayObjects, function(gatewayObject) {

    var tooltipEl = this._tooltips[ gatewayObject.id ];
    goog.events.listenOnce( tooltipEl, 'click', this.onClickGatewayTooltip, false, this );
  }, this);

  this.updateDetectObjects();
};


feng.views.sections.controls.Tooltips.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

  goog.object.forEach( this._currentTooltips, function(tooltip) {
    goog.dom.classlist.addRemove( tooltip, 'fadeOut', 'fadeIn' );
  });

  this.updateDetectObjects();

  TweenMax.ticker.addEventListener("tick", this.update, this);
};


feng.views.sections.controls.Tooltips.prototype.deactivate = function(){

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

  goog.object.forEach( this._currentTooltips, function(tooltip) {
    goog.dom.classlist.addRemove( tooltip, 'fadeIn', 'fadeOut' );
  });

  TweenMax.ticker.removeEventListener("tick", this.update, this);
};


feng.views.sections.controls.Tooltips.prototype.onModeChange = function( e ){
  
  goog.base(this, 'onModeChange', e);

  switch(e.mode) {

    case feng.controllers.view3d.ModeController.Mode.CLOSE_UP:
    this.deactivate();
    break;

    default:
    this.activate();
    break;
  }
};


feng.views.sections.controls.Tooltips.prototype.updateDetectObjects = function(){

  if(!this._view3d) return;

  // check objects to detect blocking
  this._detectObjects = goog.array.map(this._view3d.getSolidObjects(), function(object) {
    return object.object3d;
  });
};


feng.views.sections.controls.Tooltips.prototype.detectBlocking = function(){

  if(this._view3d.arms.hasObject()) {

    goog.object.forEach(this._currentTooltips, function(tooltip) {
      goog.dom.classlist.enable( tooltip, 'hidden', true );
    });

    return;
  }
  
  var control = this._view3d.modeController.control;
  var controlPosition = control.getPosition();
  var controlDirection = control.getForwardVector( true );
  var thresholdDot = Math.cos( THREE.Math.degToRad(45) );

  var i, l = this._tooltipObjects.length;

  for(i = 0; i < l; i++) {

    var object = this._tooltipObjects[i];

    var tooltip = this._currentTooltips[ object.id ];

    var objectCenter = object.getCenter();
    var direction = this._rayDirection.subVectors( objectCenter, controlPosition ).normalize();
    this._raycaster.set( controlPosition, direction );

    var objectDirection = objectCenter.sub( controlPosition ).normalize();
    var dot = objectDirection.dot( controlDirection );

    if(dot >= thresholdDot) {

      goog.dom.classlist.enable( tooltip, 'hidden', false );

    }else {

      goog.dom.classlist.enable( tooltip, 'hidden', true );
      continue;
    }

    var shouldShow = feng.utils.ThreeUtils.isFirstIntersectedObject( this._detectObjects, object.object3d, object.getProxyBox(), this._raycaster );

    goog.dom.classlist.enable( tooltip, 'hidden', !shouldShow );
  }
};


feng.views.sections.controls.Tooltips.prototype.onTipUnlock = function(e){

  var tooltipEls = goog.dom.query('.tooltip[data-tip-id=' + e.tip.id + ']', this.domElement);

  goog.array.forEach(tooltipEls, function(tooltipEl) {
    goog.dom.classlist.remove( tooltipEl, 'locked' );
  });
};


feng.views.sections.controls.Tooltips.prototype.onClickGatewayTooltip = function(e){

  e.preventDefault();

  var gatewayId = e.currentTarget.getAttribute('data-id');
  var gateway = this._view3d.getView3dObject( gatewayId );

  this.dispatchEvent({
    type: feng.events.EventType.CLICK_GATEWAY,
    gateway: gateway
  });
};


feng.views.sections.controls.Tooltips.prototype.onModeChange = function(e){

  goog.base(this, 'onModeChange', e);

  goog.dom.classlist.enable(this.domElement, 'design', (e.mode === feng.controllers.view3d.ModeController.Mode.DESIGN));

  switch(e.mode) {
    case feng.controllers.view3d.ModeController.Mode.ENTRY:
    this.deactivate();
    this._raycaster.far = 400/2;
    break;

    case feng.controllers.view3d.ModeController.Mode.BROWSE:
    this.activate();
    this._raycaster.far = 400/2;
    break;

    case feng.controllers.view3d.ModeController.Mode.DESIGN:
    this.activate();
    this._raycaster.far = Infinity;
    break;

    default:
    this.deactivate();
    break;
  }
};


feng.views.sections.controls.Tooltips.prototype.update = function() {

  var camera = this._cameraController.activeCamera;
  var viewSize = this._viewSize;

  goog.array.forEach( this._tooltipObjects, function(object) {

    var pos3d = object.getCenter();
    var pos2d = feng.utils.ThreeUtils.get2DCoordinates( pos3d, camera, viewSize );

    var id = object.id;
    var tooltip = this._currentTooltips[ id ];

    var inScreenRect = (pos2d.x > 140 && pos2d.x < (viewSize.width - 140) && pos2d.y > 140 && pos2d.y < (viewSize.height - 140));

    if(inScreenRect) {

      goog.dom.classlist.addRemove( tooltip, 'fadeOut', 'fadeIn' );

    }else {

      goog.dom.classlist.addRemove( tooltip, 'fadeIn', 'fadeOut' );
    }

    goog.style.setStyle( tooltip, 'transform', 'translateX(' + pos2d.x + 'px) translateY(' + pos2d.y + 'px)' );

  }, this);

  this._detectBlockingThrottle.fire();
};goog.provide('feng.views.sections.overlays.CreditsOverlay');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('feng.views.Overlay');


/**
 * @constructor
 */
feng.views.sections.overlays.CreditsOverlay = function(domElement){

	var canHalt = true;

  goog.base(this, domElement, canHalt);
};
goog.inherits(feng.views.sections.overlays.CreditsOverlay, feng.views.Overlay);
goog.addSingletonGetter(feng.views.sections.overlays.CreditsOverlay);


feng.views.sections.overlays.CreditsOverlay.prototype.show = function( shouldDispatch ){

	goog.base(this, 'show', shouldDispatch);
	
	goog.dom.appendChild( this.domElement, feng.credits.domElement );
};


feng.views.sections.overlays.CreditsOverlay.prototype.animateIn = function(){

	goog.base(this, 'animateIn');

	TweenMax.fromTo(this.domElement, .8, {
		'opacity': 0
	}, {
		'opacity': 1,
		'ease': Strong.easeInOut
	});
};


feng.views.sections.overlays.CreditsOverlay.prototype.animateOut = function(){

	this.dispatchEvent( feng.events.EventType.ANIMATE_OUT );

	TweenMax.to(this.domElement, .8, {
		'delay': .25,
		'opacity': 0,
		'ease': Strong.easeInOut,
		'onComplete': this.hide,
		'onCompleteParams': [ true ],
		'onCompleteScope': this
	});
};


feng.views.sections.overlays.CreditsOverlay.prototype.onResize = function(e){

	goog.base(this, 'onResize', e);

	goog.style.setSize(this.domElement, feng.viewportSize);
};goog.provide('feng.views.sections.controls.Reminder');

goog.require('goog.async.Delay');
goog.require('goog.Timer');
goog.require('feng.models.achievements.Achievements');
goog.require('feng.models.Preload');
goog.require('feng.views.sections.controls.Controls');

/**
 * @constructor
 */
feng.views.sections.controls.Reminder = function( domElement, tips ){
	
  goog.base(this, domElement);

  this._tips = tips;
  this._currentTips = [];

  this._isHintShown = false;

  this._hintIndex = 0;
  this._numHints = 0;

  this._hintTimer = new goog.Timer( 30000 );

  this._hintDialogueEl = goog.dom.query('.dialogue.hint', this.domElement)[0];
  this._prevEl = goog.dom.query('.prev', this.domElement)[0];
  this._nextEl = goog.dom.query('.next', this.domElement)[0];
  this._characterEl = goog.dom.getElementByClass('character', this.domElement);
  this._canvasEl = goog.dom.query('canvas', this._characterEl)[0];
  this._canvasContext = this._canvasEl.getContext('2d');

  this._hintEls = null;
  this._hintEl = null;

  this._characterAnimations = null;
  this._characterAnimation = null;

  this._hasOtherWidgetShown = false;

  this._hideHintDelay = new goog.async.Delay(this.hideHint, 6000, this);
};
goog.inherits(feng.views.sections.controls.Reminder, feng.views.sections.controls.Controls);


feng.views.sections.controls.Reminder.prototype.init = function(){

	goog.base(this, 'init');

	goog.array.forEach(this._tips, function(tip) {
		tip.listenOnce(feng.events.EventType.UNLOCK, this.onTipUnlock, false, this);
	}, this);

	this._characterAnimations = this.getCharacterAnimations();
};


feng.views.sections.controls.Reminder.prototype.getLockedTipsOfView = function(){

  var achievements = feng.models.achievements.Achievements.getInstance();
  this._currentTips = achievements.getTipsOfView( this._view3d.id, this._view3d.sectionId );

  this._currentTips = goog.array.filter(this._currentTips, function(tip) {
  	var requiredTip = tip.getRequiredTip();
  	var requiredTipUnlocked = requiredTip ? requiredTip.unlocked : true;
  	return (!tip.unlocked && requiredTipUnlocked);
  });
  
  this._numHints = this._currentTips.length;

  return this._currentTips;
};


feng.views.sections.controls.Reminder.prototype.setView3D = function( view3d ){

  goog.base(this, 'setView3D', view3d);

  this._currentTips = this.getLockedTipsOfView();

  this._hintEls = goog.dom.query('.hints li', this._hintDialogueEl);

  if(this._characterAnimation) {
  	this._characterAnimation.loop.pause();
  	this._characterAnimation.raise.pause();
  }

  this._characterAnimation = goog.object.findValue(this._characterAnimations, function(data) {
  	return (data.viewId === view3d.id);
  });

  // if no character animation was found by view id, use the default character
  this._characterAnimation = this._characterAnimation || goog.object.getValues(this._characterAnimations)[0];
  //

  this._canvasEl.width = this._characterAnimation.size['width'];
  this._canvasEl.height = this._characterAnimation.size['height'];
  this._characterAnimation.loop.restart();
};


feng.views.sections.controls.Reminder.prototype.activate = function(){

  var shouldActivate = goog.base(this, 'activate');

  if(!shouldActivate) return;

	this._eventHandler.listen(this._prevEl, 'click', this.onClick, false, this);
	this._eventHandler.listen(this._nextEl, 'click', this.onClick, false, this);
	this._eventHandler.listen(this._characterEl, 'mousedown', this.onMouseDown, false, this);
	this._eventHandler.listen(this._hintDialogueEl, 'mouseover', this.onMouseOver, false, this);
	this._eventHandler.listen(this._hintDialogueEl, 'mouseout', this.onMouseOut, false, this);
	this._eventHandler.listen(this._hintTimer, 'tick', this.onHintTick, false, this);

	feng.pubsub.subscribe( feng.PubSub.Topic.SHOW_WIDGET, this.onShowWidget, this );
	feng.pubsub.subscribe( feng.PubSub.Topic.HIDE_WIDGET, this.onHideWidget, this );

	this._hasOtherWidgetShown = (feng.pubsub.getShownWidgets().length > 0);

	this._hintTimer.start();
};


feng.views.sections.controls.Reminder.prototype.deactivate = function(){

  var shouldDeactivate = goog.base(this, 'deactivate');

  if(!shouldDeactivate) return;

	feng.pubsub.unsubscribe( feng.PubSub.Topic.SHOW_WIDGET, this.onShowWidget, this );
	feng.pubsub.unsubscribe( feng.PubSub.Topic.HIDE_WIDGET, this.onHideWidget, this );

	this._hintTimer.stop();
};


feng.views.sections.controls.Reminder.prototype.getCharacterAnimations = function(){

	// extract unique character names from tips
	var animations = {};
	var preload = feng.models.Preload.getInstance();

	goog.array.forEach(this._tips, function(tip) {

		var character = tip.character;

		if(animations[character]) return;

		var sectionId = tip.sectionId;
		var viewId = tip.viewId;

		var img = preload.getAsset( sectionId + '.global.character.' + character );
		var data = preload.getAsset( sectionId + '.global.character.' + character + '-data' );
		var frames = data['frames'];
		var size = data['size'];

		var keys = goog.object.getKeys( frames );

		var loopKeys = goog.array.filter(keys, function(key) {
			return goog.string.startsWith(key, 'loop-');
		});

		var raiseKeys = goog.array.filter(keys, function(key) {
			return goog.string.startsWith(key, 'raise-');
		});

		var loopProp = {
			frame: 0
		};

		var numLoopFrames = loopKeys.length;

		var loopTweener = TweenMax.to(loopProp, numLoopFrames/30, {
			frame: numLoopFrames - 1,
			'ease': Linear.easeNone,
			'paused': true,
			'yoyo': true,
			'repeat': -1,
			'repeatDelay': 2,
			'onUpdate': function() {
				var frame = Math.round( loopProp.frame );
				this.drawCharacter( img, frames[ 'loop-' + frame ] );
			},
			'onUpdateScope': this
		});

		var raiseProp = {
			frame: 0
		};

		var numRaiseFrames = raiseKeys.length;

		var raiseTweener = TweenMax.to(raiseProp, numRaiseFrames/30 * .5, {
			frame: numRaiseFrames - 1,
			'ease': Linear.easeNone,
			'paused': true,
			'onUpdate': function() {
				var frame = Math.round( raiseProp.frame );
				this.drawCharacter( img, frames[ 'raise-' + frame ] );
			},
			'onUpdateScope': this,
			'onComplete': this.onCharacterRaiseComplete,
			'onCompleteScope': this,
			'onReverseComplete': function() {
				loopTweener.restart();
			}
		});

		animations[character] = {
			viewId: tip.viewId,
			size: size,
			loop: loopTweener,
			raise: raiseTweener
		};

	}, this);

	/* data structure */
	/*
	character: {
		size: <Object>,
		loop: <TweenMax>,
		raise: <TweenMax>,
		viewId: <String>
	}
	*/

	return animations;
};


feng.views.sections.controls.Reminder.prototype.getCurrentTip = function(){

	var tip = goog.array.find(this._currentTips, function(tip) {
		return !tip.unlocked;
	});

	return tip;
};


feng.views.sections.controls.Reminder.prototype.drawCharacter = function(img, frame){

	var x = frame['x'], y = frame['y'];
	var width = this._canvasEl.width, height = this._canvasEl.height;

	this._canvasContext.clearRect( 0, 0, width, height );
	this._canvasContext.drawImage( img, x, y, width, height, 0, 0, width, height );
};


feng.views.sections.controls.Reminder.prototype.prevHint = function(){

	this._hintIndex --;
	if(this._hintIndex < 0) this._hintIndex = this._numHints - 1;

	this.gotoHintByTip( this._currentTips[this._hintIndex].id );
};


feng.views.sections.controls.Reminder.prototype.nextHint = function(){

	this._hintIndex ++;
	if(this._hintIndex > this._numHints - 1) this._hintIndex = 0;

	this.gotoHintByTip( this._currentTips[this._hintIndex].id );
};


feng.views.sections.controls.Reminder.prototype.gotoResolvedHint = function(){

	if(this._hintEl) {
		goog.dom.classlist.remove( this._hintEl, 'shown' );
	}

	this._hintEl = goog.array.find(this._hintEls, function(el) {
		return (el.getAttribute('data-view-id') === this._view3d.id);
	}, this);

	goog.dom.classlist.add( this._hintEl, 'shown' );

	this._prevEl.disabled = this._nextEl.disabled = true;
};


feng.views.sections.controls.Reminder.prototype.gotoHintByTip = function( tipId ){

	if(this._hintEl) {
		goog.dom.classlist.remove( this._hintEl, 'shown' );
	}

	this._hintEl = goog.array.find(this._hintEls, function(el) {
		return (el.getAttribute('data-tip-id') === tipId);
	});

	goog.dom.classlist.add( this._hintEl, 'shown' );

	this._prevEl.disabled = this._nextEl.disabled = false;
};


feng.views.sections.controls.Reminder.prototype.showHint = function( tipId ){

	if(this._isHintShown) {

		return;

	}else {

		this._isHintShown = true;
	}

	if(tipId) {

		this.gotoHintByTip( tipId );

	}else {

		this.gotoResolvedHint();
	}

	this._hideHintDelay.start();

	this._hintTimer.stop();

	this._characterAnimation.loop.pause();
	this._characterAnimation.raise.restart();
};


feng.views.sections.controls.Reminder.prototype.hideHint = function( instance ){

	if(!this._isHintShown) {

		return;

	}else {

		this._isHintShown = false;
	}

	var duration = instance ? 0 : .4;

	goog.dom.classlist.addRemove( this.domElement, 'active', 'inactive' );

	this._hintTimer.start();

	this._characterAnimation.raise.reverse();
};


feng.views.sections.controls.Reminder.prototype.onClick = function(e){

	switch(e.currentTarget) {
		case this._prevEl:
		this.prevHint();
		break;

		case this._nextEl:
		this.nextHint();
		break;
	}
};


feng.views.sections.controls.Reminder.prototype.onMouseDown = function(e){

	if(!e.isMouseActionButton()) {
		return false;
	}

	if(this._isHintShown) {

		this.hideHint();

	}else {

		var tip = this.getCurrentTip();
		this.showHint( tip ? tip.id : null );
	}
};


feng.views.sections.controls.Reminder.prototype.onMouseOver = function(e){

	if(e.currentTarget === this._hintDialogueEl) {

		this._hideHintDelay.stop();
	}
};


feng.views.sections.controls.Reminder.prototype.onMouseOut = function(e){

	if(e.currentTarget === this._hintDialogueEl) {

		if(!e.relatedTarget || !goog.dom.contains(e.currentTarget, e.relatedTarget)) {
			this._hideHintDelay.start();
		}
	}
};


feng.views.sections.controls.Reminder.prototype.onHintTick = function(e){

	if(!this._hasOtherWidgetShown) {

		var tip = this.getCurrentTip();
		this.showHint( tip ? tip.id : null );
	}
};


feng.views.sections.controls.Reminder.prototype.onTipUnlock = function(e){

	var tipId = e.tip.id;

	var unlockedHintEl = goog.dom.query('.hints li[data-tip-id="' + tipId + '"]', this._hintDialogueEl)[0];
	goog.dom.removeNode( unlockedHintEl );

	this._currentTips = this.getLockedTipsOfView();
};


feng.views.sections.controls.Reminder.prototype.onCharacterRaiseComplete = function(){

	goog.dom.classlist.addRemove( this.domElement, 'inactive', 'active' );
};


feng.views.sections.controls.Reminder.prototype.onModeChange = function(e){

	goog.base(this, 'onModeChange', e);
	
	var mode = e.nextMode || e.mode;

	switch(mode) {

		case feng.controllers.view3d.ModeController.Mode.BROWSE:
		case feng.controllers.view3d.ModeController.Mode.WALK:
		this.activate();
		break;

		default:
		this.deactivate();
		break;
	}
};


feng.views.sections.controls.Reminder.prototype.onShowWidget = function( widget ){

	if(widget === this) {

		return;

	}else {

		this._hasOtherWidgetShown = true;
	}

	this.hideHint();
};


feng.views.sections.controls.Reminder.prototype.onHideWidget = function( widget ){

	if(widget === this) {
		
		return;

	}else {

		this._hasOtherWidgetShown = false;
	}
};


feng.views.sections.controls.Reminder.prototype.onResize = function(e){

	goog.style.setPosition(this.domElement, feng.viewportSize.width - 100 - 30, feng.viewportSize.height - 100 - 30);
};goog.provide('feng.views.sections.captions.DropFruitsCaption');

goog.require('goog.soy');
goog.require('feng.templates.captions');
goog.require('feng.views.sections.captions.Caption');


/**
 * @constructor
 */
feng.views.sections.captions.DropFruitsCaption = function( object, renderController, renderSize, controls, hud ){

  this._template = feng.templates.captions.DropFruitsCaption;
  
  this._templateData = {
    tip: object.tip,
    position: 'right'
  };

  goog.base(this, object, renderController, renderSize, controls, hud);

  this._fruitId = null;

  this._itemEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.item-button', this.domElement), 'data-fruit' );
  this._infoEls = feng.utils.Utils.createDomCollectionByAttributes( goog.dom.query('.info li', this.domElement), 'data-fruit' );
};
goog.inherits(feng.views.sections.captions.DropFruitsCaption, feng.views.sections.captions.Caption);


feng.views.sections.captions.DropFruitsCaption.prototype.show = function() {

  goog.base(this, 'show');

  //this._eventHandler.listen( this._object, feng.events.EventType.CHANGE, this.onFruitPlateChange, false, this );

  goog.object.forEach(this._itemEls, function(itemEl) {
    this._eventHandler.listen(itemEl, 'click', this.onClickItem, false, this);
  }, this);
};


feng.views.sections.captions.DropFruitsCaption.prototype.onFruitPlateChange = function(e) {

  this.setActiveFruit( e.fruit );
};


feng.views.sections.captions.DropFruitsCaption.prototype.setActiveFruit = function(fruit) {

  goog.array.forEach(this._fruitButtonEls, function(fruitButtonEl) {

    if(fruitButtonEl.getAttribute('data-fruit-id') === fruit) {
      goog.dom.classlist.add(fruitButtonEl, 'active');
    }else {
      goog.dom.classlist.remove(fruitButtonEl, 'active');
    }
  });

  goog.array.forEach(this._descriptionEls, function(descriptionEl) {

    if(descriptionEl.getAttribute('data-fruit-id') === fruit) {
      goog.dom.classlist.add(descriptionEl, 'active');
    }else {
      goog.dom.classlist.remove(descriptionEl, 'active');
    }
  });

  goog.dom.classlist.add( this._descriptionEl, 'shown' );
};


feng.views.sections.captions.DropFruitsCaption.prototype.onClickItem = function(e) {

  if(this._fruitId) {
    goog.dom.classlist.enable( this._itemEls[this._fruitId], 'active', false );
    goog.dom.classlist.enable( this._infoEls[this._fruitId], 'active', false );
  }

  this._fruitId = e.currentTarget.getAttribute("data-fruit");

  goog.dom.classlist.enable( this._itemEls[this._fruitId], 'active', true );
  goog.dom.classlist.enable( this._itemEls[this._fruitId], 'show-fruit', true );
  goog.dom.classlist.enable( this._infoEls[this._fruitId], 'active', true );

  this.scrollBar.resize();

  this._object.dropFruit( this._fruitId );

  feng.soundController.playSfx('click');
};goog.provide('feng.views.View3DHud');

goog.require('feng.views.helpers.Helpers');
goog.require('feng.views.sections.controls.ObjectSelector');
goog.require('feng.views.sections.controls.DropButton');
goog.require('feng.views.sections.controls.Compass');
goog.require('feng.views.sections.controls.Book');
goog.require('feng.views.sections.controls.Reminder');
goog.require('feng.views.sections.controls.HomeButton');
goog.require('feng.views.sections.controls.ProgressBar');
goog.require('feng.views.sections.controls.Tooltips');
goog.require('feng.views.sections.captions.Caption');
goog.require('feng.views.sections.captions.ChangeColorCaption');
goog.require('feng.views.sections.captions.ChangeObjectCaption');
goog.require('feng.views.sections.captions.ChangePictureCaption');
goog.require('feng.views.sections.captions.DropFruitsCaption');
goog.require('feng.views.sections.overlays.TutorialOverlay');
goog.require('feng.views.sections.overlays.CreditsOverlay');
goog.require('feng.views.sections.overlays.OpeningOverlay');
goog.require('feng.views.sections.overlays.EndingOverlay');
goog.require('feng.views.sections.overlays.FinaleOverlay');
goog.require('feng.views.sections.overlays.LoaderOverlay');


/**
 * @constructor
 */
feng.views.View3DHud = function( hudEl, view3dController, tips, episode ){

  goog.base(this);

  this.domElement = hudEl;

  this._view3d = null;
  this._view3dController = view3dController;

  this._episode = episode;

  this._tips = tips;

  this._isInEntryMode = false;

  // create the helpers singleton
  this._helpers = feng.views.helpers.Helpers.getInstance();

  // create a captions collection
  this._captions = {};

  // create overlays
  this._overlaysEl = goog.dom.getElementByClass('overlays', this.domElement);

  var tutorialOverlayEl = goog.dom.getElementByClass('tutorial-overlay', this._overlaysEl);
  this.tutorialOverlay = new feng.views.sections.overlays.TutorialOverlay( tutorialOverlayEl );

  var creditsOverlayEl = goog.dom.getElementByClass('credits-overlay', this._overlaysEl);
  this.creditsOverlay = new feng.views.sections.overlays.CreditsOverlay( creditsOverlayEl );

  var openingOverlayEl = goog.dom.getElementByClass('opening-overlay', this._overlaysEl);
  this.openingOverlay = new feng.views.sections.overlays.OpeningOverlay( openingOverlayEl );

  var endingOverlayEl = goog.dom.getElementByClass('ending-overlay', this._overlaysEl);
  this.endingOverlay = new feng.views.sections.overlays.EndingOverlay( endingOverlayEl );

  var finaleOverlayEl = goog.dom.getElementByClass('finale-overlay', this._overlaysEl);
  this.finaleOverlay = new feng.views.sections.overlays.FinaleOverlay( finaleOverlayEl );

  var loaderOverlayEl = goog.dom.getElementByClass('loader-overlay', this._overlaysEl);
  this.loaderOverlay = new feng.views.sections.overlays.LoaderOverlay( loaderOverlayEl );

  // create controls
  this._controlsEl = goog.dom.getElementByClass('controls', this.domElement);

  var homeButtonEl = goog.dom.getElementByClass('home-button', this._controlsEl);
  this.homeButton = new feng.views.sections.controls.HomeButton( homeButtonEl );
  this.homeButton.setParentEventTarget( this );

  var compassEl = goog.dom.getElementByClass('compass', this._controlsEl);
  this.compass = new feng.views.sections.controls.Compass( compassEl );
  this.compass.setParentEventTarget( this );

  var bookEl = goog.dom.getElementByClass('book', this._controlsEl);
  this.book = new feng.views.sections.controls.Book( bookEl );
  this.book.setParentEventTarget( this );
  
  var reminderEl = goog.dom.getElementByClass('reminder', this._controlsEl);
  this.reminder = new feng.views.sections.controls.Reminder( reminderEl, tips );
  this.reminder.setParentEventTarget( this );

  var progressBarEl = goog.dom.getElementByClass('progressBar', this._controlsEl);
  this.progressBar = new feng.views.sections.controls.ProgressBar( progressBarEl, tips );
  this.progressBar.setParentEventTarget( this );

  var objectSelectorEl = goog.dom.getElementByClass('objectSelector', this._controlsEl);
  this.objectSelector = new feng.views.sections.controls.ObjectSelector( objectSelectorEl );

  var dropButtonEl = goog.dom.getElementByClass('dropButton', this._controlsEl);
  this.dropButton = new feng.views.sections.controls.DropButton( dropButtonEl );

  // captions
  this._captionsEl = goog.dom.getElementByClass('captions', this.domElement);

  // tooltips
  this._tooltipsEl = goog.dom.getElementByClass('tooltips', this.domElement);
  this.tooltips = new feng.views.sections.controls.Tooltips( this._tooltipsEl );
};
goog.inherits(feng.views.View3DHud, goog.events.EventTarget);


feng.views.View3DHud.prototype.init = function() {

  this.reminder.init();
};


feng.views.View3DHud.prototype.setView3D = function( view3d ) {

  if(this._view3d) {
    this._view3d.modeController.unlisten( feng.events.EventType.CHANGE, this.onModeChange, false, this );
  }

  this._view3d = view3d;

  this._view3d.modeController.listen( feng.events.EventType.CHANGE, this.onModeChange, false, this );

  this.compass.setView3D( view3d );
  this.book.setView3D( view3d );
  this.reminder.setView3D( view3d );
  this.progressBar.setView3D( view3d );
  this.objectSelector.setView3D( view3d );
  this.dropButton.setView3D( view3d );
  this.tooltips.setView3D( view3d );
};


feng.views.View3DHud.prototype.pause = function( shouldPause ) {

  goog.dom.classlist.enable( this._captionsEl, 'paused', shouldPause );
  goog.dom.classlist.enable( this._tooltipsEl, 'paused', shouldPause );
  goog.dom.classlist.enable( this._controlsEl, 'paused', shouldPause );

  goog.dom.classlist.enable( this._controlsEl, 'hidden', shouldPause );

  if(!this._helpers.isDisposed()) {
    this._helpers.show( !shouldPause );
  }

  feng.mainOptions.showHelpButton( !shouldPause );
};


feng.views.View3DHud.prototype.activate = function() {

  this._view3dController.listen(feng.events.EventType.SHOW, this.onShowView3D, false, this);
  this._view3dController.listen(feng.events.EventType.ANIMATED_IN, this.onAnimatedInView3D, false, this);

  feng.tutorial.listen(feng.events.EventType.ANIMATE_IN, this.tutorialOverlay.animateIn, false, this.tutorialOverlay);
  feng.tutorial.listen(feng.events.EventType.ANIMATE_OUT, this.tutorialOverlay.animateOut, false, this.tutorialOverlay);

  feng.credits.listen(feng.events.EventType.ANIMATE_IN, this.creditsOverlay.animateIn, false, this.creditsOverlay);
  feng.credits.listen(feng.events.EventType.ANIMATE_OUT, this.creditsOverlay.animateOut, false, this.creditsOverlay);

  this._episode.listen(feng.events.EventType.START, this.loaderOverlay.onLoadStart, false, this.loaderOverlay);
  this._episode.listen(feng.events.EventType.PROGRESS, this.loaderOverlay.onLoadProgress, false, this.loaderOverlay);
  this._episode.listen(feng.events.EventType.COMPLETE, this.loaderOverlay.onLoadComplete, false, this.loaderOverlay);

  this.openingOverlay.listen(feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this);
  this.openingOverlay.listen(feng.events.EventType.ANIMATE_OUT, this.onOverlayAnimateOut, false, this);

  this.endingOverlay.listen(feng.events.EventType.ANIMATE_IN, this.onOverlayAnimateIn, false, this);
  this.endingOverlay.listen(feng.events.EventType.ANIMATE_OUT, this.onOverlayAnimateOut, false, this);

  this.tutorialOverlay.activate();
  this.creditsOverlay.activate();

  this.activateControls();
};


feng.views.View3DHud.prototype.deactivate = function() {

  this._view3d.modeController.removeAllListeners();
  this._view3dController.removeAllListeners();
  feng.tutorial.removeAllListeners();
  feng.credits.removeAllListeners();
  this._episode.removeAllListeners();
  this.openingOverlay.removeAllListeners();

  this.dropButton.deactivate();
  this.tooltips.deactivate();
  this.tutorialOverlay.deactivate();
  this.creditsOverlay.deactivate();

  this.deactivateControls();
};


feng.views.View3DHud.prototype.activateControls = function() {

  this.homeButton.activate();
  this.compass.activate();
  this.book.activate();
  this.reminder.activate();
  this.progressBar.activate();

  if(this._view3d && !this._isInEntryMode) {
    this.tooltips.activate();
  }

  if(!this._helpers.isDisposed()) {

    this._helpers.activate();
    goog.dom.appendChild( this.domElement, this._helpers.domElement );
  }

  feng.mainOptions.showHelpButton( true );
};


feng.views.View3DHud.prototype.deactivateControls = function() {

  this.homeButton.deactivate();
  this.compass.deactivate();
  this.book.deactivate();
  this.reminder.deactivate();
  this.progressBar.deactivate();

  this.tooltips.deactivate();

  if(!this._helpers.isDisposed()) {
    
    this._helpers.deactivate();
  }

  feng.mainOptions.showHelpButton( false );
};


feng.views.View3DHud.prototype.getCaption = function( object, controls ) {

	var key = goog.getUid(object);

	if(this._captions[key]) {
		return this._captions[key];
	}

  var captionClass = feng.views.sections.captions.Caption;

  // get the caption if specified by object
  switch(object.captionClass) {
    case 'changecolor':
    captionClass = feng.views.sections.captions.ChangeColorCaption;
    break;

    case 'changepicture':
    captionClass = feng.views.sections.captions.ChangePictureCaption;
    break;

    case 'changeobject':
    captionClass = feng.views.sections.captions.ChangeObjectCaption;
    break;

    case 'dropfruits':
    captionClass = feng.views.sections.captions.DropFruitsCaption;
    break;

    default:
    break;
  }
  
  var renderController = this._view3d.renderController;
  var viewSize = this._view3d.viewSize;

	var caption = new captionClass( object, renderController, viewSize, controls, this );
	this._captions[ key ] = caption;

	goog.dom.appendChild( this._captionsEl, caption.domElement );

	return caption;
};


feng.views.View3DHud.prototype.showControls = function( shouldShow ) {

  goog.dom.classlist.enable( this._controlsEl, 'hidden', !shouldShow );
  
  this.tooltips.show( shouldShow );

  if(!this._helpers.isDisposed()) {
    this._helpers.show( shouldShow );
  }

  feng.mainOptions.showHelpButton( shouldShow );
};


feng.views.View3DHud.prototype.onModeChange = function( e ) {

  var anyMode = e.nextMode || e.mode;
  var shouldShowControls = true;

  this._isInEntryMode = (e.mode === feng.controllers.view3d.ModeController.Mode.ENTRY);

  switch(anyMode) {

    case feng.controllers.view3d.ModeController.Mode.EXIT:
    case feng.controllers.view3d.ModeController.Mode.CLOSE_UP:
    case null:
    shouldShowControls = false;
    break;
  }

  switch(e.mode) {
    
    case feng.controllers.view3d.ModeController.Mode.BROWSE:
    var numUnlocked = goog.array.count(this._tips, function(tip) {
      return tip.unlocked;
    });
    if(numUnlocked === this._tips.length) {
      this.endingOverlay.updateContent( this._view3d.sectionId );
      this.endingOverlay.animateIn();
    }
    break;
  }

  goog.dom.classlist.enable( this._view3d.containerElement, 'bg-white', (e.mode === feng.controllers.view3d.ModeController.Mode.CLOSE_UP) );

  if(e.gateway) {
    shouldShowControls = false;
  }

  var willShowOpeningOverlay = this.openingOverlay.shouldShow( this._view3d.sectionId, this._view3d.id );

  if(willShowOpeningOverlay) {

    shouldShowControls = false;
  }

  this.showControls( shouldShowControls );
};


feng.views.View3DHud.prototype.onShowView3D = function( e ) {

  var view3d = e.target;

  this.setView3D( view3d );
};


feng.views.View3DHud.prototype.onAnimatedInView3D = function( e ) {

  // pop up opening overlay for only once
  if(this._view3d.modeController.getMode() === feng.controllers.view3d.ModeController.Mode.BROWSE) {

    var view3d = e.target;
    var viewId = view3d.id;
    var sectionId = view3d.sectionId;
   
    this.openingOverlay.updateContent( sectionId, viewId );
    this.openingOverlay.animateIn();
  }
};


feng.views.View3DHud.prototype.onOverlayAnimateIn = function( e ) {
 
  this.deactivateControls();
  this.showControls( false );
};


feng.views.View3DHud.prototype.onOverlayAnimateOut = function( e ) {

  var shouldShowFinaleOverlay;

  // if ending overlay is just closed, detect if any tip is still locked,
  // otherwise show finale overlay
  if(e.currentTarget === this.endingOverlay) {

    var achievements = feng.models.achievements.Achievements.getInstance();
    shouldShowFinaleOverlay = achievements.isAllUnlocked();
  }

  if( shouldShowFinaleOverlay ) {

    this.finaleOverlay.animateIn();

  }else {

    this.activateControls();

    if(!this._isInEntryMode) {
      this.showControls( true );
    }
  }
};goog.provide('feng.controllers.view3d.View3DController');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventHandler');
goog.require('feng.events');

/**
 * @constructor
 */
feng.controllers.view3d.View3DController = function(){

  goog.base(this);

  this.view3d = null;

  this._view3ds = {};
  this._view3dToFadeIn = null;

  this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.controllers.view3d.View3DController, goog.events.EventTarget);


feng.controllers.view3d.View3DController.prototype.activate = function(){

  this._eventHandler.listen(this, feng.events.EventType.SHOW, this.onShowView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.HIDE, this.onHideView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.CHANGE, this.onChangeView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.ANIMATE_IN, this.onAnimateInView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.ANIMATE_OUT, this.onAnimateOutView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.ANIMATED_IN, this.onAnimatedInView3D, false, this);
  this._eventHandler.listen(this, feng.events.EventType.ANIMATED_OUT, this.onAnimatedOutView3D, false, this);
};


feng.controllers.view3d.View3DController.prototype.deactivate = function(){

  this._eventHandler.removeAll();
};


feng.controllers.view3d.View3DController.prototype.registerView3D = function( view3d ){

	this._view3ds[ view3d.sectionId + '.' + view3d.id ] = view3d;
	view3d.setParentEventTarget( this );
};


feng.controllers.view3d.View3DController.prototype.isRegisteredViewID = function( sectionId, viewId ){

	var isRegistered = goog.isDefAndNotNull( this._view3ds[ sectionId + '.' + viewId ] );
	return isRegistered;
};


feng.controllers.view3d.View3DController.prototype.getView3D = function( sectionId, viewId ){

	return this._view3ds[sectionId + '.' + viewId];
};


feng.controllers.view3d.View3DController.prototype.onHideView3D = function(e){

	console.log('Hide View3D: ', e.target.id);

	feng.pubsub.publish( feng.PubSub.Topic.HIDE_VIEW3D, e.target );
};


feng.controllers.view3d.View3DController.prototype.onShowView3D = function(e){

	this.view3d = e.target;

	console.log('Show View3D: ', this.view3d.id);

	this.view3d.createResources();
	this.view3d.activate();

	feng.pubsub.publish( feng.PubSub.Topic.SHOW_VIEW3D, this.view3d );
};


feng.controllers.view3d.View3DController.prototype.onChangeView3D = function(e){

	var from = e.target;
	from.fadeOut();

	this._view3dToFadeIn = this.getView3D( e.sectionId, e.viewId );
	this._view3dToFadeIn.startGateway = this._view3dToFadeIn.view3dObjects[ e.gatewayId ];

	console.log(
		'Change View3D from: ' + e.target.id + 
		' to ' + this._view3dToFadeIn.id + 
		' start gateway: ' + this._view3dToFadeIn.startGateway.gatewayId);
};


feng.controllers.view3d.View3DController.prototype.onAnimateInView3D = function(e){

};


feng.controllers.view3d.View3DController.prototype.onAnimateOutView3D = function(e){

	var view3d = e.target;
	view3d.deactivate();
	view3d.disposeResources();
};


feng.controllers.view3d.View3DController.prototype.onAnimatedInView3D = function(e){

};


feng.controllers.view3d.View3DController.prototype.onAnimatedOutView3D = function(e){

	if(this._view3dToFadeIn) {
		this._view3dToFadeIn.fadeIn( this._startGateway );
	}
};goog.provide('feng.views.sections.Episode');

goog.require('goog.dom');
goog.require('goog.events.EventTarget');
goog.require('feng.controllers.view3d.View3DController');
goog.require('feng.events');
goog.require('feng.views.sections.Section');
goog.require('feng.views.View3D');
goog.require('feng.views.View3DHud');


/**
 * @constructor
 */
feng.views.sections.Episode = function(template, templateData){

	var domFrag = soy.renderAsFragment(template, templateData);

	var mainElement = goog.dom.getElement('main');
  goog.dom.appendChild(mainElement, domFrag);

  var domElement = goog.dom.getElement( templateData.id );

  goog.base(this, domElement);

  this._view3dController = new feng.controllers.view3d.View3DController;

  this._view3dContainerEl = goog.dom.getElementByClass('scene-container', this.domElement);

  var hudEl = goog.dom.getElementByClass('hud', this.domElement);
  var tips = templateData.tips;
  this._hud = new feng.views.View3DHud( hudEl, this._view3dController, tips, this );

  this._viewIds = [];
  this._viewId = null;

  this._view3ds = [];
  this._view3d = null;

  this._hasDoneIntro = false;
};
goog.inherits(feng.views.sections.Episode, feng.views.sections.Section);


feng.views.sections.Episode.prototype.init = function(){

	goog.base(this, 'init');
};


feng.views.sections.Episode.prototype.activate = function(){

	goog.base(this, 'activate');

	this._view3dController.activate();

	this._hud.activate();

	this._view3dController.listen(feng.events.EventType.SHOW, this.onShowView3D, false, this);

	this.activateView();
};


feng.views.sections.Episode.prototype.activateView = function(){

	if(this._view3d) {

		this._view3d.createResources();
		this._view3d.activate();
	}
};


feng.views.sections.Episode.prototype.deactivate = function(){

	goog.base(this, 'deactivate');

	this._view3dController.deactivate();

	this._hud.deactivate();
	
	this._view3dController.unlisten(feng.events.EventType.SHOW, this.onShowView3D, false, this);

	if(this._view3d) {

		this._view3d.deactivate();
		this._view3d.disposeResources();
	}
};


feng.views.sections.Episode.prototype.load = function( viewId ){

	this._viewId = viewId || this._viewId || this._viewIds[0];

	var globalAssetsKey = this.id + '.global';
	var view3dAssetsKey = this.id + '.' + this._viewId;

	this._assetKeys = [globalAssetsKey, view3dAssetsKey];
	
	goog.base(this, 'load');
};


feng.views.sections.Episode.prototype.animateIn = function(){

	var shouldDo = goog.base(this, 'animateIn');

	if(!shouldDo) return false;
	
	this._view3d.fadeIn();

	feng.soundController.playMix( this.id );
};


feng.views.sections.Episode.prototype.animateOut = function(){

	var shouldDo = goog.base(this, 'animateOut');

	if(!shouldDo) return false;

	feng.soundController.stopMix( this.id );
};


feng.views.sections.Episode.prototype.onLoadComplete = function(e){

	goog.base(this, 'onLoadComplete', e);

	if(this._view3ds.length === 0) {

		// create hud
		this._hud.init();
	}

	// register loaded view3d
	var sectionId = this.id;
	var viewId = this._viewId;

	var alreadyRegistered = this._view3dController.isRegisteredViewID( sectionId, this._viewId );

	if(!alreadyRegistered) {

		var view3d = new feng.views.View3D( sectionId, viewId, this._view3dContainerEl, this._hud, this );
		this._view3dController.registerView3D( view3d );
		
		view3d.init();

		this._view3ds.push( view3d );
	}

	this._view3d = this._view3dController.getView3D( sectionId, viewId );
	this.activateView();
};


feng.views.sections.Episode.prototype.onShowView3D = function(e){

	var view3d = e.target;

	// set initial mode
	if(!this._hasDoneIntro) {

		view3d.modeController.setMode({
			mode: feng.controllers.view3d.ModeController.Mode.ENTRY
		});

		this._hasDoneIntro = true;
		
	}else {

		var gatewayObject = view3d.startGateway || view3d.getEntry();
		var position = gatewayObject.origin.position;
		var rotation = gatewayObject.origin.rotation;
	  	
		view3d.modeController.setMode({
			mode: feng.controllers.view3d.ModeController.Mode.BROWSE,
			fromPosition: position,
			fromRotation: rotation,
			fromFov: feng.controllers.controls.Controls.Default.FOV
		});
	}
};goog.provide('feng.views.sections.House');

goog.require('goog.dom');
goog.require('feng.events');
goog.require('feng.views.sections.Episode');


/**
 * @constructor
 */
feng.views.sections.House = function(){

	var viewIds = ['livingroom', 'corridor', 'homeoffice', 'boysroom'];
	var sectionId = 'house';

	var achievements = feng.models.achievements.Achievements.getInstance();
	var tips = achievements.getTipsOfSection( sectionId );

	var tipsOfViews = {};
	goog.object.forEach(viewIds, function(viewId) {
		var tips = achievements.getTipsOfView( viewId, sectionId, false, true );
		tipsOfViews[ viewId ] = tips;
	});

	var template = feng.templates.main.EpisodeSection;
	var templateData = {
		id: sectionId,
		tips: tips,
		tipsOfViews: tipsOfViews,
		token: feng.controllers.NavigationController.Token,
		copy: feng.models.Preload.getInstance().getAsset('global.fengshui-data')
	};

  goog.base(this, template, templateData);

  this._viewIds = viewIds;
  this._viewId = this._viewIds[0];
};
goog.inherits(feng.views.sections.House, feng.views.sections.Episode);goog.provide('feng.views.sections.Studio');

goog.require('goog.dom');
goog.require('feng.events');
goog.require('feng.views.sections.Episode');


/**
 * @constructor
 */
feng.views.sections.Studio = function(){

	var viewIds = ['livingroom', 'bathroom'];
	var sectionId = 'studio';

	var achievements = feng.models.achievements.Achievements.getInstance();
	var tips = achievements.getTipsOfSection( sectionId );

	var tipsOfViews = {};
	goog.object.forEach(viewIds, function(viewId) {
		var tips = achievements.getTipsOfView( viewId, sectionId, false, true );
		tipsOfViews[ viewId ] = tips;
	});

	var template = feng.templates.main.EpisodeSection;
	var templateData = {
		id: sectionId,
		tips: tips,
		tipsOfViews: tipsOfViews,
		token: feng.controllers.NavigationController.Token,
		copy: feng.models.Preload.getInstance().getAsset('global.fengshui-data')
	};

  goog.base(this, template, templateData);

  this._viewIds = viewIds;
  this._viewId = this._viewIds[0];
};
goog.inherits(feng.views.sections.Studio, feng.views.sections.Episode);goog.provide('feng.controllers.SectionController');

goog.require('goog.events.EventTarget');
goog.require('goog.events');
goog.require('feng.views.sections.Home');
goog.require('feng.views.sections.Studio');
goog.require('feng.views.sections.House');


/**
 * @constructor
 */
feng.controllers.SectionController = function(){
  goog.base(this);

  this._sections = {};
  this._section = null;

  var homeSection = this.addSection('home');

  this._eventHandler = new goog.events.EventHandler(this);
};
goog.inherits(feng.controllers.SectionController, goog.events.EventTarget);
goog.addSingletonGetter(feng.controllers.SectionController);


feng.controllers.SectionController.prototype.init = function(){
  
  this.addSection('studio');
  this.addSection('house');

  this._eventHandler.listen(this, feng.events.EventType.ANIMATE_IN, this.onSectionAnimateIn, false, this);
  this._eventHandler.listen(this, feng.events.EventType.ANIMATED_OUT, this.onSectionAnimatedOut, false, this);
};


feng.controllers.SectionController.prototype.hasSection = function(id){
  
  return goog.isDefAndNotNull( this._sections[id] );
};


feng.controllers.SectionController.prototype.getSection = function(id){
  
  return this._sections[id];
};


feng.controllers.SectionController.prototype.addSection = function(id){
  
	var section;

  switch(id) {
  	case 'home':
  	section = new feng.views.sections.Home;
  	break;

    case 'studio':
    section = new feng.views.sections.Studio;
    break;

    case 'house':
    section = new feng.views.sections.House;
    break;
  }

  section.setParentEventTarget(this);
  section.init();

  return section;
};


feng.controllers.SectionController.prototype.onSectionAnimateIn = function(e){
  
	if(this._section) {
		this._section.animateOut();
	}

	this._section = e.target;
};


feng.controllers.SectionController.prototype.onSectionAnimatedOut = function(e){

	if(this._section === e.target) {
		this._section = null;
	}
};goog.provide('feng.apps.Main');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.fx.anim');
goog.require('goog.style');
goog.require('feng.templates.main');
goog.require('feng.controllers.NavigationController');
goog.require('feng.controllers.SectionController');
goog.require('feng.controllers.StorageController');
goog.require('feng.controllers.SoundController');
goog.require('feng.controllers.KeyboardController');
goog.require('feng.controllers.view3d.PathfindingController');
goog.require('feng.views.debug.Debugger');
goog.require('feng.views.MainOptions');
goog.require('feng.views.EpisodeSelection');
goog.require('feng.views.popups.Tutorial');
goog.require('feng.views.popups.Credits');
goog.require('feng.fx.Shaders');
goog.require('feng.PubSub');
goog.require('feng.utils.Utils');


feng.apps.Main = function() {

	goog.base(this);
	
	// redirect to fallback page if WebGL is not supported
	if(!feng.utils.Utils.supportWebGL) {
		window.location.href = '/unsupported.html';
		return;
	}

	goog.fx.anim.setAnimationWindow(window);

	feng.debug = (feng.utils.Utils.getQuery('debug') === 'true') || feng.Config['debug'];
	feng.office = (feng.utils.Utils.getQuery('office') === 'true') || feng.Config['office'];
	feng.quality = feng.utils.Utils.getQuery('quality') || feng.Config['quality'];
	
	if(feng.Config['escapeConsole'] === true) {
		feng.utils.Utils.escapeConsole();
	}

	feng.viewportSize = feng.apps.Main.getViewportSize();

	goog.events.listen(window, goog.events.EventType.RESIZE, function() {
		feng.viewportSize = feng.apps.Main.getViewportSize();
	});

	feng.renderSettings = {
		renderSize: (feng.quality === 'high') ? ((screen.width > 1920) ? 2048 : 1024) : 1024,
		shadowMapSize: (feng.quality === 'high') ? 1024 : 512
	};

	var mainFrag = soy.renderAsFragment(feng.templates.main.Main, {
		debug: feng.debug
	});
	goog.dom.appendChild(document.body, mainFrag);

	feng.pubsub = feng.PubSub.getInstance();

	if(feng.debug) feng.views.debug.Debugger.getInstance();
	if(feng.office) goog.style.setOpacity(document.body, .1);

	feng.storageController = feng.controllers.StorageController.getInstance();

	feng.soundController = feng.controllers.SoundController.getInstance();
	
	feng.mainOptions = new feng.views.MainOptions;

	feng.episodeSelection = feng.views.EpisodeSelection.getInstance();

	feng.tutorial = feng.views.popups.Tutorial.getInstance();
	feng.credits = feng.views.popups.Credits.getInstance();

	feng.controllers.NavigationController.Implementation = feng.controllers.NavigationController.HASH;
	feng.navigationController = feng.controllers.NavigationController.getInstance();

	feng.pathfinder = feng.controllers.view3d.PathfindingController.getInstance();

	feng.shaders = feng.fx.Shaders.getInstance();

	feng.sectionController = feng.controllers.SectionController.getInstance();

	feng.keyboardController = feng.controllers.KeyboardController.getInstance();

	feng.initialToken = feng.navigationController.getTokenArray();
	
	feng.navigationController.init();
	feng.navigationController.replaceToken( feng.controllers.NavigationController.Token.HOME );
};
goog.inherits(feng.apps.Main, goog.events.EventTarget);
goog.addSingletonGetter(feng.apps.Main);


feng.apps.Main.getViewportSize = function() {

	return goog.style.getSize( document.body );
};goog.provide('feng.fx.FloatText');

goog.require('goog.events.EventTarget');
goog.require('goog.string');
goog.require('feng.templates.captions');


/**
 * @constructor
 */
feng.fx.FloatText = function(html, numCharacters, numLines){

	goog.base(this);

	var numCharacters = numCharacters || 30;
	var numLines = numLines || 10;
	var lines = [];
	var paras = html.split('<br>');
	
	for(var i = 0; i < paras.length; i++) {
		var para = paras[i];

		var a = 0, b = Math.floor(para.length / numCharacters);
		var start, end = -1;

		for(a = 0; a < b; a++) {
			start = end + 1;
			end = start + numCharacters;

			if(para.charAt(end+1) === ' ') {
				end = end + 1;
			}else {
				while(para.charAt(end) !== ' ') {
					end --;
				}
			}

			var str = para.substring( start, end );
			lines.push( str );
		}
	}

	var shouldTruncate = (lines.length > numLines);

	lines = lines.slice(0, numLines);

	if(shouldTruncate) {
		lines[lines.length - 1] = goog.string.truncate( lines[lines.length - 1], numCharacters/2 );
	}
	

	this.domElement = soy.renderAsFragment(feng.templates.captions.FloatText, {
		lines: lines
	});

	this._lineEls = goog.dom.getChildren( this.domElement );
	this._numLines = this._lineEls.length;

	this._depths = goog.array.repeat(0, this._numLines);
	this._alphas = goog.array.repeat(0, this._numLines);

	this._lineProps = goog.array.map(this._lineEls, function(lineEl) {
		return {
			el: lineEl,
			x: 0,
			z: 0,
			opacity: 0,
			opacityMultiplier: 0
		};
	});

	this._animateInTweener = new TimelineMax({
		'paused': true
	});

	var tweeners = goog.array.map(this._lineEls, function(el, index) {

		var prop = this._lineProps[index];

		this.onLineUpdate( prop );

		return TweenMax.fromTo(prop, 2, {
			x: -20,
			opacityMultiplier: 0
		}, {
			x: 0,
			opacityMultiplier: 1,
			'ease': Quad.easeOut,
			'onUpdate': this.onLineUpdate,
			'onUpdateParams': [prop],
			'onUpdateScope': this
		});
	}, this);

	this._animateInTweener.add( tweeners, "+=0", "start", .025 );

	this._animateOutTweener = new TimelineMax({
		'paused': true,
		'onComplete': this.onAnimateComplete,
		'onCompleteScope': this
	});

	var tweeners = goog.array.map(this._lineEls, function(el, index) {
		var prop = this._lineProps[index];

		return TweenMax.to(prop, 1, {
			opacityMultiplier: 0,
			'ease': Quad.easeInOut,
			'onUpdate': this.onLineUpdate,
			'onUpdateParams': [prop],
			'onUpdateScope': this
		});
	}, this);

	this._animateOutTweener.add( tweeners, "+=0", "start", .05 );

	document.body.appendChild( this.domElement );
	//console.log(html, lines, this.domElement, this._lineEls);
};
goog.inherits(feng.fx.FloatText, goog.events.EventTarget);


feng.fx.FloatText.prototype.activate = function() {

	goog.fx.anim.registerAnimation( this );
};


feng.fx.FloatText.prototype.deactivate = function() {

	goog.fx.anim.unregisterAnimation( this );
};


feng.fx.FloatText.prototype.animateIn = function() {

	if(this._animateInTweener.isActive()) return;

	goog.style.showElement(this.domElement, true);

	this._animateOutTweener.pause();

	this._animateInTweener.restart();

	this.activate();
};


feng.fx.FloatText.prototype.animateOut = function() {

	if(this._animateOutTweener.isActive()) return;

	this._animateInTweener.pause();

	this._animateOutTweener.restart();
};


feng.fx.FloatText.prototype.onAnimateComplete = function() {

	this.deactivate();

	goog.style.showElement(this.domElement, false);
};


feng.fx.FloatText.prototype.onLineUpdate = function(prop) {

	var el = prop.el;
	var x = prop.x;
	var z = prop.z;
	var opacity = prop.opacity;
	var opacityMultiplier = prop.opacityMultiplier;

	goog.style.setStyle(el, {
		'transform': 'translateX(' + x + 'px) translateZ(' + z + 'px)',
		'opacity': opacity * opacityMultiplier
	});
};


feng.fx.FloatText.prototype.onAnimationFrame = function(now) {

	var counter = 0;
	var step = 1 / this._numLines;
	var increase = Math.PI / this._numLines;

	for ( var i = 0; i < 1; i += step ) {

		var index = Math.round(i * this._numLines);

		var z = Math.sin( counter + now / 1000 ) * 50;
		this._depths[index] = z.toFixed(2);

		var alpha = goog.math.lerp(.5, 1, (Math.sin( counter + now / 1000 ) + 1) * .5);
		this._alphas[index] = alpha;

		counter += increase;
	}

	goog.array.forEach( this._lineEls, function(lineEl, index) {

		this._lineProps[index].z = this._depths[index];
		this._lineProps[index].opacity = this._alphas[index];

		this.onLineUpdate( this._lineProps[index] );

	}, this);
};//   Copyright 2009 The Closure Library Authors. All Rights Reserved.

/**
 * @fileoverview A generator of lorem ipsum text based on the python
 * implementation at http://code.google.com/p/lorem-ipsum-generator/.
 *
 */

goog.provide('goog.text.LoremIpsum');

goog.require('goog.array');
goog.require('goog.math');
goog.require('goog.string');
goog.require('goog.structs.Map');
goog.require('goog.structs.Set');


/**
 * Generates random strings of "lorem ipsum" text, based on the word
 * distribution of a sample text, using the words in a dictionary.
 * @constructor
 */
goog.text.LoremIpsum = function() {
  this.generateChains_(this.sample_);
  this.generateStatistics_(this.sample_);

  this.initializeDictionary_(this.dictionary_);
};


/**
 * Delimiters that end sentences.
 * @type {Array.<string>}
 * @private
 */
goog.text.LoremIpsum.DELIMITERS_SENTENCES_ = ['.', '?', '!'];


/**
 * Regular expression for spliting a text into sentences.
 * @type {RegExp}
 * @private
 */
goog.text.LoremIpsum.SENTENCE_SPLIT_REGEX_ = /[\.\?\!]/;


/**
 * Delimiters that end words.
 * @type {Array.<string>}
 * @private
 */
goog.text.LoremIpsum.DELIMITERS_WORDS_ = [',', '.', '?', '!'];


/**
 * Regular expression for spliting text into words.
 * @type {RegExp}
 * @private
 */
goog.text.LoremIpsum.WORD_SPLIT_REGEX_ = /\s/;


/**
 * Words that can be used in the generated output.
 * Maps a word-length to a list of words of that length.
 * @type {goog.structs.Map}
 * @private
 */
goog.text.LoremIpsum.prototype.words_;


/**
 * Chains of three words that appear in the sample text
 * Maps a pair of word-lengths to a third word-length and an optional
 * piece of trailing punctuation (for example, a period, comma, etc.).
 * @type {goog.structs.Map}
 * @private
 */
goog.text.LoremIpsum.prototype.chains_;


/**
 * Pairs of word-lengths that can appear at the beginning of sentences.
 * @type {Array}
 */
goog.text.LoremIpsum.prototype.starts_;


/**
 * Averange sentence length in words.
 * @type {number}
 * @private
 */
goog.text.LoremIpsum.prototype.sentenceMean_;


/**
 * Sigma (sqrt of variance) for the sentence length in words.
 * @type {number}
 * @private
 */
goog.text.LoremIpsum.prototype.sentenceSigma_;


/**
 * Averange paragraph length in sentences.
 * @type {number}
 * @private
 */
goog.text.LoremIpsum.prototype.paragraphMean_;


/**
 * Sigma (sqrt of variance) for the paragraph length in sentences.
 * @type {number}
 * @private
 */
goog.text.LoremIpsum.prototype.paragraphSigma_;


/**
 * Generates the chains and starts values required for sentence generation.
 * @param {string} sample The same text.
 * @private
 */
goog.text.LoremIpsum.prototype.generateChains_ = function(sample) {
  var words = goog.text.LoremIpsum.splitWords_(sample);
  var wordInfo = goog.array.map(words, goog.text.LoremIpsum.getWordInfo_);

  var previous = [0, 0];
  var previousKey = previous.join('-');
  var chains = new goog.structs.Map();
  var starts = [previousKey];
  var chainKeys = {};

  goog.array.forEach(wordInfo, function(pair) {
    var chain = chains.get(previousKey);
    if (chain) {
      chain.push(pair);
    } else {
      chain = [pair];
      chains.set(previousKey, chain);
    }

    if (goog.array.contains(
        goog.text.LoremIpsum.DELIMITERS_SENTENCES_, pair[1])) {
      starts.push(previousKey);
    }
    chainKeys[previousKey] = previous;
    previous = [previous[1], pair[0]];
    previousKey = previous.join('-');
  });

  if (chains.getCount() > 0) {
    this.chains_ = chains;
    this.starts_ = starts;
    this.chainKeys_ = chainKeys;
  } else {
    throw Error('Could not generate chains from sample text.');
  }
};


/**
 * Calculates the mean and standard deviation of sentence and paragraph lengths.
 * @param {string} sample The same text.
 * @private
 */
goog.text.LoremIpsum.prototype.generateStatistics_ = function(sample) {
  this.generateSentenceStatistics_(sample);
  this.generateParagraphStatistics_(sample);
};


/**
 * Calculates the mean and standard deviation of the lengths of sentences
 * (in words) in a sample text.
 * @param {string} sample The same text.
 * @private
 */
goog.text.LoremIpsum.prototype.generateSentenceStatistics_ = function(sample) {
  var sentences = goog.array.filter(
      goog.text.LoremIpsum.splitSentences_(sample),
      goog.text.LoremIpsum.isNotEmptyOrWhitepace_);

  var sentenceLengths = goog.array.map(
      goog.array.map(sentences, goog.text.LoremIpsum.splitWords_),
      goog.text.LoremIpsum.arrayLength_);
  this.sentenceMean_ = goog.math.average.apply(null, sentenceLengths);
  this.sentenceSigma_ = goog.math.standardDeviation.apply(
      null, sentenceLengths);
};


/**
 * Calculates the mean and standard deviation of the lengths of paragraphs
 * (in sentences) in a sample text.
 * @param {string} sample The same text.
 * @private
 */
goog.text.LoremIpsum.prototype.generateParagraphStatistics_ = function(sample) {
  var paragraphs = goog.array.filter(
      goog.text.LoremIpsum.splitParagraphs_(sample),
      goog.text.LoremIpsum.isNotEmptyOrWhitepace_);

  var paragraphLengths = goog.array.map(
    goog.array.map(paragraphs, goog.text.LoremIpsum.splitSentences_),
    goog.text.LoremIpsum.arrayLength_);

  this.paragraphMean_ = goog.math.average.apply(null, paragraphLengths);
  this.paragraphSigma_ = goog.math.standardDeviation.apply(
      null, paragraphLengths);
};


/**
 * Sets the generator to use a given selection of words for generating
 * sentences with.
 * @param {string} dictionary The dictionary to use.
 */
goog.text.LoremIpsum.prototype.initializeDictionary_ = function(dictionary) {
  var dictionaryWords = goog.text.LoremIpsum.splitWords_(dictionary);

  var words = new goog.structs.Map();
  goog.array.forEach(dictionaryWords, function(word) {
    var set = words.get(word.length);
    if (!set) {
      set = new goog.structs.Set();
      words.set(word.length, set);
    }
    set.add(word);
  });

  this.words_ = words;
};


/**
 * Picks a random starting chain.
 * @return {Array.<string>} The starting key.
 * @private
 */
goog.text.LoremIpsum.prototype.chooseRandomStart_ = function() {
  var key = goog.text.LoremIpsum.randomChoice_(this.starts_);
  return this.chainKeys_[key];
};


/**
 * Generates a single sentence, of random length.
 * @param {boolean} opt_startWithLorem Whether to start the setnence with the
 *     standard "Lorem ipsum..." first sentence.
 * @return {string} The generated sentence.
 */
goog.text.LoremIpsum.prototype.generateSentence = function(opt_startWithLorem) {
  if (this.chains_.getCount() == 0 || this.starts_.length == 0) {
    throw Error('No chains created');
  }

  if (this.words_.getCount() == 0) {
    throw Error('No dictionary');
  }

  // The length of the sentence is a normally distributed random variable.
  var sentenceLength = goog.text.LoremIpsum.randomNormal_(
      this.sentenceMean_, this.sentenceSigma_)
  sentenceLength = Math.max(Math.floor(sentenceLength), 1);

  var wordDelimiter = ''; // Defined here in case while loop doesn't run

  // Start the sentence with "Lorem ipsum...", if desired
  var sentence;
  if (opt_startWithLorem) {
    var lorem = 'lorem ipsum dolor sit amet, consecteteur adipiscing elit';
    sentence = goog.text.LoremIpsum.splitWords_(lorem);
    if (sentence.length > sentenceLength) {
      sentence.length = sentenceLength;
    }
    var lastWord = sentence[sentence.length - 1];
    var lastChar = lastWord.substring(lastWord.length - 1);
    if (goog.array.contains(goog.text.LoremIpsum.DELIMITERS_WORDS_, lastChar)) {
      wordDelimiter = lastChar;
    }
  } else {
    sentence = [];
  }

  var previous = [];
  var previousKey = '';
  // Generate a sentence from the "chains"
  while (sentence.length < sentenceLength) {
    // If the current starting point is invalid, choose another randomly
    if (!this.chains_.containsKey(previousKey)) {
      previous = this.chooseRandomStart_();
      previousKey = previous.join('-');
    }

    // Choose the next "chain" to go to. This determines the next word
    // length we'll use, and whether there is e.g. a comma at the end of
    // the word.
    var chain = /** @type {Array} */ (goog.text.LoremIpsum.randomChoice_(
        /** @type {Array} */ (this.chains_.get(previousKey))));
    var wordLength = chain[0];

    // If the word delimiter contained in the chain is also a sentence
    // delimiter, then we don't include it because we don't want the
    // sentence to end prematurely (we want the length to match the
    // sentence_length value).
    //debugger;
    if (goog.array.contains(goog.text.LoremIpsum.DELIMITERS_SENTENCES_,
        chain[1])) {
      wordDelimiter = '';
    } else {
      wordDelimiter = chain[1];
    }

    // Choose a word randomly that matches (or closely matches) the
    // length we're after.
    var closestLength = goog.text.LoremIpsum.chooseClosest(
            this.words_.getKeys(), wordLength);
    var word = goog.text.LoremIpsum.randomChoice_(
        this.words_.get(closestLength).getValues());

    sentence.push(word + wordDelimiter);
    previous = [previous[1], wordLength];
    previousKey = previous.join('-');
  }

  // Finish the sentence off with capitalisation, a period and
  // form it into a string
  sentence = sentence.join(' ');
  sentence = sentence.slice(0, 1).toUpperCase() + sentence.slice(1);
  if (sentence.substring(sentence.length - 1) == wordDelimiter) {
    sentence = sentence.slice(0, sentence.length - 1);
  }
  return sentence + '.';
};

/**
 * Generates a single lorem ipsum paragraph, of random length.
 * @param {boolean} opt_startWithLorem Whether to start the sentence with the
 *     standard "Lorem ipsum..." first sentence.
 * @return {string} The generated sentence.
 */
goog.text.LoremIpsum.prototype.generateParagraph = function(
    opt_startWithLorem) {
  // The length of the paragraph is a normally distributed random variable.
  var paragraphLength = goog.text.LoremIpsum.randomNormal_(
      this.paragraphMean_, this.paragraphSigma_);
  paragraphLength = Math.max(Math.floor(paragraphLength), 1);

  // Construct a paragraph from a number of sentences.
  var paragraph = []
  var startWithLorem = opt_startWithLorem;
  while (paragraph.length < paragraphLength) {
      var sentence = this.generateSentence(startWithLorem);
      paragraph.push(sentence);
      startWithLorem = false;
  }

  // Form the paragraph into a string.
  paragraph = paragraph.join(' ')
  return paragraph
};


/**
 * Splits a piece of text into paragraphs.
 * @param {string} text The text to split.
 * @return {Array.<string>} An array of paragraphs.
 * @private
 */
goog.text.LoremIpsum.splitParagraphs_ = function(text) {
  return text.split('\n')
};


/**
 * Splits a piece of text into sentences.
 * @param {string} text The text to split.
 * @return {Array.<string>} An array of sentences.
 * @private
 */
goog.text.LoremIpsum.splitSentences_ = function(text) {
  return goog.array.filter(
      text.split(goog.text.LoremIpsum.SENTENCE_SPLIT_REGEX_),
      goog.text.LoremIpsum.isNotEmptyOrWhitepace_);
};


/**
 * Splits a piece of text into words..
 * @param {string} text The text to split.
 * @return {Array.<string>} An array of words.
 * @private
 */
goog.text.LoremIpsum.splitWords_ = function(text) {
  return goog.array.filter(
      text.split(goog.text.LoremIpsum.WORD_SPLIT_REGEX_),
      goog.text.LoremIpsum.isNotEmptyOrWhitepace_);
};


/**
 * Returns the text is not empty or just whitespace.
 * @param {string} text The text to check.
 * @return {boolean} Whether the text is nether empty nor whitespace.
 * @private
 */
goog.text.LoremIpsum.isNotEmptyOrWhitepace_ = function(text) {
  return goog.string.trim(text).length > 0;
};


/**
 * Returns the length of an array. Written as a function so it can be used
 * as a function parameter.
 * @param {Array} array The array to check.
 * @return {number} The length of the array.
 */
goog.text.LoremIpsum.arrayLength_ = function(array) {
  return array.length;
};


/**
 * Find the number in the list of values that is closest to the target.
 * @param {Array.<number>} values The values.
 * @param {number} target The target value.
 * @return {number} The closest value.
 */
goog.text.LoremIpsum.chooseClosest = function(values, target) {
  var closest = values[0];
  goog.array.forEach(values, function(value) {
    if (Math.abs(target - value) < Math.abs(target - closest)) {
      closest = value;
    }
  });

  return closest;
};

/**
 * Gets info about a word used as part of the lorem ipsum algorithm.
 * @param {string} word The word to check.
 * @return {Array} A two element array. The first element is the size of the
 *    word. The second element is the delimter used in the word.
 * @private
 */
goog.text.LoremIpsum.getWordInfo_ = function(word) {
  var ret;
  goog.array.some(goog.text.LoremIpsum.DELIMITERS_WORDS_,
      function (delimiter) {
        if (goog.string.endsWith(word, delimiter)) {
          ret = [word.length - delimiter.length, delimiter];
          return true;
        }
        return false;
      }
  );
  return ret || [word.length, ''];
};


/**
 * Constant used for {@link #randomNormal_}.
 * @type {number}
 * @private
 */
goog.text.LoremIpsum.NV_MAGICCONST_ = 4 * Math.exp(-0.5) / Math.sqrt(2.0);


/**
 * Generates a random number for a normal distribution with the specified
 * mean and sigma.
 * @param {number} mu The mean of the distribution.
 * @param {number} sigma The sigma of the distribution.
 * @private
 */
goog.text.LoremIpsum.randomNormal_ = function(mu, sigma) {
  while (true) {
    var u1 = Math.random();
    var u2 = 1.0 - Math.random();
    var z = goog.text.LoremIpsum.NV_MAGICCONST_ * (u1 - 0.5) / u2;
    var zz = z * z / 4.0;
    if (zz <= -Math.log(u2)) {
      break;
    }
  }
  return mu + z * sigma;
};


/**
 * Picks a random element of the array.
 * @param {Array} array The array to pick from.
 * @return {*} An element from the array.
 */
goog.text.LoremIpsum.randomChoice_ = function(array) {
  return array[goog.math.randomInt(array.length)];
};


/**
 * Dictionary of words for lorem ipsum.
 * @type {string}
 * @private
 */
goog.text.LoremIpsum.DICT_ =
    'a ac accumsan ad adipiscing aenean aliquam aliquet amet ante ' +
    'aptent arcu at auctor augue bibendum blandit class commodo ' +
    'condimentum congue consectetuer consequat conubia convallis cras ' +
    'cubilia cum curabitur curae cursus dapibus diam dictum dictumst ' +
    'dignissim dis dolor donec dui duis egestas eget eleifend elementum ' +
    'elit eni enim erat eros est et etiam eu euismod facilisi facilisis ' +
    'fames faucibus felis fermentum feugiat fringilla fusce gravida ' +
    'habitant habitasse hac hendrerit hymenaeos iaculis id imperdiet ' +
    'in inceptos integer interdum ipsum justo lacinia lacus laoreet ' +
    'lectus leo libero ligula litora lobortis lorem luctus maecenas ' +
    'magna magnis malesuada massa mattis mauris metus mi molestie ' +
    'mollis montes morbi mus nam nascetur natoque nec neque netus ' +
    'nibh nisi nisl non nonummy nostra nulla nullam nunc odio orci ' +
    'ornare parturient pede pellentesque penatibus per pharetra ' +
    'phasellus placerat platea porta porttitor posuere potenti praesent ' +
    'pretium primis proin pulvinar purus quam quis quisque rhoncus ' +
    'ridiculus risus rutrum sagittis sapien scelerisque sed sem semper ' +
    'senectus sit sociis sociosqu sodales sollicitudin suscipit ' +
    'suspendisse taciti tellus tempor tempus tincidunt torquent tortor ' +
    'tristique turpis ullamcorper ultrices ultricies urna ut varius ve ' +
    'vehicula vel velit venenatis vestibulum vitae vivamus viverra ' +
    'volutpat vulputate';


/**
 * A sample to use for generating the distribution of word and sentence lengths
 * in lorem ipsum.
 * @type {string}
 * @private
 */
goog.text.LoremIpsum.SAMPLE_ =
    'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean ' +
    'commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus ' +
    'et magnis dis parturient montes, nascetur ridiculus mus. Donec quam ' +
    'felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla ' +
    'consequat massa quis enim. Donec pede justo, fringilla vel, aliquet ' +
    'nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, ' +
    'venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. ' +
    'Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean ' +
    'vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat ' +
    'vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra ' +
    'quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius ' +
    'laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel ' +
    'augue. Curabitur ullamcorper ultricies nisi. Nam eget dui.\n\n' +

    'Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem ' +
    'quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam ' +
    'nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec ' +
    'odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis ' +
    'faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus ' +
    'tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales ' +
    'sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit ' +
    'cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend ' +
    'sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, ' +
    'metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis ' +
    'hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci ' +
    'luctus et ultrices posuere cubilia Curae; In ac dui quis mi ' +
    'consectetuer lacinia.\n\n' +

    'Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet ' +
    'nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ' +
    'ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent ' +
    'adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy ' +
    'metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros ' +
    'et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, ' +
    'nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit ' +
    'risus. Phasellus nec sem in justo pellentesque facilisis. Etiam ' +
    'imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus ' +
    'non, auctor et, hendrerit quis, nisi.\n\n' +

    'Curabitur ligula sapien, tincidunt non, euismod vitae, posuere ' +
    'imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed ' +
    'cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus ' +
    'accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci ' +
    'luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis ' +
    'porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis ' +
    'orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, ' +
    'bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede ' +
    'sit amet augue. In turpis. Pellentesque posuere. Praesent turpis.\n\n' +

    'Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu ' +
    'sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales ' +
    'nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse ' +
    'pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, ' +
    'nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in ' +
    'faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id ' +
    'purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum ' +
    'mollis diam. Pellentesque ut neque. Pellentesque habitant morbi ' +
    'tristique senectus et netus et malesuada fames ac turpis egestas.\n\n' +

    'In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac ' +
    'felis quis tortor malesuada pretium. Pellentesque auctor neque nec ' +
    'urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean ' +
    'viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et ' +
    'netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis ' +
    'pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna.\n\n' +

    'In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare ' +
    'lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ' +
    'ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. ' +
    'Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, ' +
    'quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at ' +
    'pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo ' +
    'quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam ' +
    'sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce ' +
    'risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis ' +
    'vulputate lorem.\n\n' +

    'Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, ' +
    'dui et placerat feugiat, eros pede varius nisi, condimentum viverra ' +
    'felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, ' +
    'varius ut, felis. In auctor lobortis lacus. Quisque libero metus, ' +
    'condimentum nec, tempor a, commodo mollis, magna. Vestibulum ' +
    'ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia ' +
    'erat. Praesent blandit laoreet nibh.\n\n' +

    'Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, ' +
    'neque sit amet convallis pulvinar, justo nulla eleifend augue, ac ' +
    'auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. ' +
    'Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. ' +
    'Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In ' +
    'hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis ' +
    'mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat ' +
    'nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, ' +
    'lacus.\n\n' +

    'Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, ' +
    'dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi ' +
    'congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin ' +
    'fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit ' +
    'amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam ' +
    'gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac ' +
    'sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus ' +
    'blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in ' +
    'libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In ' +
    'consectetuer turpis ut velit. Nulla sit amet est. Praesent metus ' +
    'tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ' +
    'ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse ' +
    'feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum ' +
    'nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac ' +
    'massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, ' +
    'iaculis quis, molestie non, velit.\n\n' +

    'Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. ' +
    'Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus ' +
    'at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet ' +
    'velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. ' +
    'Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, ' +
    'sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla ' +
    'facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere ' +
    'iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. ' +
    'Curabitur suscipit suscipit tellus.\n\n' +

    'Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id ' +
    'nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu ' +
    'pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante ' +
    'odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque ' +
    'suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ' +
    'ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu ' +
    'quis ligula mattis placerat. Duis lobortis massa imperdiet quam. ' +
    'Suspendisse potenti.\n\n' +

    'Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, ' +
    'lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat ' +
    'volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam ' +
    'eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ' +
    'ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta ' +
    'dolor. Class aptent taciti sociosqu ad litora torquent per conubia ' +
    'nostra, per inceptos hymenaeos.\n\n' +

    'Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. ' +
    'Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. ' +
    'Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, ' +
    'elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum ' +
    'sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus ' +
    'non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. ' +
    'Vestibulum eu odio.\n\n' +

    'Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. ' +
    'Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique ' +
    'sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse ' +
    'faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, ' +
    'vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce ' +
    'fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae ' +
    'odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. ' +
    'Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus ' +
    'consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna ' +
    'cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit ' +
    'quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar ' +
    'varius.\n\n';

/**
 * Sample that the generated text is based on .
 * @type {string}
 */
goog.text.LoremIpsum.prototype.sample_ = goog.text.LoremIpsum.SAMPLE_;


/**
 * Dictionary of words.
 * @type {string}
 */
goog.text.LoremIpsum.prototype.dictionary_ = goog.text.LoremIpsum.DICT_;
goog.provide('feng.apps.Test');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.fx.anim');
goog.require('goog.text.LoremIpsum');
goog.require('feng.fx.FloatText');


feng.apps.Test = function() {

	goog.base(this);
	
	goog.fx.anim.setAnimationWindow(window);

	var lorem = new goog.text.LoremIpsum().generateParagraph();
	var floatText = new feng.fx.FloatText( lorem, 40, 10 );
	floatText.animateIn();

	goog.events.listenOnce(document.body, 'click', function() {
		floatText.animateOut();
	});

};
goog.inherits(feng.apps.Test, goog.events.EventTarget);
goog.addSingletonGetter(feng.apps.Test);goog.provide('feng');

goog.require('goog.Uri');
goog.require('feng.apps.Main');
goog.require('feng.apps.Test');
goog.require('feng.apps.PathEdit');


/**
 * @expose
 */
feng.version = '1.18.15';


feng.Config = {};


feng.init = function( config ) {

	feng.Config = config;
	
	// parse queries
	var uri = new goog.Uri( window.location.href );
	var queryData = uri.getQueryData();

	// apply queries to config
	if(queryData.get('debug') === 'true') {

		feng.Config['debug'] = true;
	}

	if(queryData.get('office') === 'true') {

		feng.Config['office'] = true;
	}

	if(queryData.get('console')) {

		feng.Config['escapeConsole'] = (queryData.get('console') === 'false');

	}else {

		feng.Config['escapeConsole'] = (feng.Config['escapeConsole'] === 'true');
	}

	// execute app
	var app = queryData.get('app') || feng.Config['app'];

	switch(app) {
		case 'main':
		feng.apps.Main.getInstance();
		break;

		case 'pathedit':
		feng.apps.PathEdit.getInstance();
		break;

		case 'test':
		feng.apps.Test.getInstance();
		break;
	};
};


goog.exportProperty(window, 'feng', feng);
goog.exportProperty(feng, 'init', feng.init);